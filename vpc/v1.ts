/**
 * (C) Copyright IBM Corp. 2023.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * IBM OpenAPI SDK Code Generator Version: 3.76.0-ad3e6f96-20230724-172814
 */

/* eslint-disable max-classes-per-file */
/* eslint-disable no-await-in-loop */

import * as extend from 'extend';
import { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http';
import {
  Authenticator,
  BaseService,
  getAuthenticatorFromEnvironment,
  validateParams,
  UserOptions,
} from 'ibm-cloud-sdk-core';
import { getSdkHeaders } from '../lib/common';
import { getQueryParam } from 'ibm-cloud-sdk-core';
import { getNewLogger, SDKLogger } from 'ibm-cloud-sdk-core';

/**
 * The IBM Cloud Virtual Private Cloud (VPC) API can be used to programmatically provision and manage virtual server
 * instances, along with subnets, volumes, load balancers, and more.
 *
 * API Version: today
 */

class VpcV1 extends BaseService {
  static _logger: SDKLogger = getNewLogger('VpcV1');

  static DEFAULT_SERVICE_URL: string = 'https://us-south.iaas.cloud.ibm.com/v1';

  static DEFAULT_SERVICE_NAME: string = 'vpc';

  /*************************
   * Factory method
   ************************/

  /**
   * Constructs an instance of VpcV1 with passed in options and external configuration.
   *
   * @param {UserOptions} [options] - The parameters to send to the service.
   * @param {string} [options.serviceName] - The name of the service to configure
   * @param {Authenticator} [options.authenticator] - The Authenticator object used to authenticate requests to the service
   * @param {string} [options.serviceUrl] - The URL for the service
   * @returns {VpcV1}
   */

  public static newInstance(options: UserOptions): VpcV1 {
    options = options || {};

    if (!options.serviceName) {
      options.serviceName = this.DEFAULT_SERVICE_NAME;
    }
    if (!options.authenticator) {
      options.authenticator = getAuthenticatorFromEnvironment(options.serviceName);
    }
    const service = new VpcV1(options);
    service.configureService(options.serviceName);
    if (options.serviceUrl) {
      service.setServiceUrl(options.serviceUrl);
    }
    return service;
  }

  /** The infrastructure generation. For the API behavior documented here, specify `2`. */
  generation?: number;

  /** The API version, in format `YYYY-MM-DD`. For the API behavior documented here, specify any date between
   *  `2022-09-13` and `2023-08-24`.
   */
  version: string;

  /**
   * Construct a VpcV1 object.
   *
   * @param {Object} options - Options for the service.
   * @param {string} options.version - The API version, in format `YYYY-MM-DD`. For the API behavior documented here,
   * specify any date between `2022-09-13` and `2023-08-24`.
   * @param {string} [options.serviceUrl] - The base url to use when contacting the service. The base url may differ between IBM Cloud regions.
   * @param {OutgoingHttpHeaders} [options.headers] - Default headers that shall be included with every request to the service.
   * @param {Authenticator} options.authenticator - The Authenticator object used to authenticate requests to the service
   * @constructor
   * @returns {VpcV1}
   */
  constructor(options: UserOptions) {
    options = options || {};
    options.generation = 2;
    super(options);
    if (options.serviceUrl) {
      this.setServiceUrl(options.serviceUrl);
    } else {
      this.setServiceUrl(VpcV1.DEFAULT_SERVICE_URL);
    }
    this.generation = options.generation;
    this.version = options.version|| `2023-08-08`;

    const _requiredParams = ['version'];
    const _validationErrors = validateParams(options, _requiredParams, null);
    if (_validationErrors) {
      throw _validationErrors;
    }
  }

  /*************************
   * vPCs
   ************************/

  /**
   * List all VPCs.
   *
   * This request lists all VPCs in the region. A VPC is a virtual network that belongs to an account and provides
   * logical isolation from other networks. A VPC is made up of resources in one or more zones. VPCs are regional, and
   * each VPC can contain resources in multiple zones in a region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {boolean} [params.classicAccess] - Filters the collection to VPCs with a `classic_access` property matching
   * the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPCCollection>>}
   */
  public listVpcs(
    params?: VpcV1.ListVpcsParams
  ): Promise<VpcV1.Response<VpcV1.VPCCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'classicAccess', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'classic_access': _params.classicAccess,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpcs'
    );

    const parameters = {
      options: {
        url: '/vpcs',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a VPC.
   *
   * This request creates a new VPC from a VPC prototype object. The prototype object is structured in the same way as a
   * retrieved VPC, and contains the information necessary to create the new VPC.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.addressPrefixManagement] - Indicates whether a [default address
   * prefix](https://cloud.ibm.com/docs/vpc?topic=vpc-configuring-address-prefixes) will be automatically created for
   * each zone in this VPC. If `manual`, this VPC will be created with no default address prefixes.
   *
   * Since address prefixes are managed identically regardless of whether they were automatically created, the value is
   * not preserved as a VPC property.
   * @param {boolean} [params.classicAccess] - Indicates whether this VPC will be connected to Classic Infrastructure.
   * If true, this VPC's resources will have private network connectivity to the account's Classic Infrastructure
   * resources. Only one VPC, per region, may be connected in this way. This value is set at creation and subsequently
   * immutable.
   * @param {string} [params.name] - The name for this VPC. The name must not be used by another VPC in the region. If
   * unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPC>>}
   */
  public createVpc(
    params?: VpcV1.CreateVpcParams
  ): Promise<VpcV1.Response<VpcV1.VPC>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['addressPrefixManagement', 'classicAccess', 'name', 'resourceGroup', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'address_prefix_management': _params.addressPrefixManagement,
      'classic_access': _params.classicAccess,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createVpc'
    );

    const parameters = {
      options: {
        url: '/vpcs',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPC.
   *
   * This request deletes a VPC. This operation cannot be reversed. For this request to succeed, the VPC must not
   * contain any instances, subnets, public gateways, or endpoint gateways. All security groups and network ACLs
   * associated with the VPC are automatically deleted. All flow log collectors with `auto_delete` set to `true`
   * targeting the VPC or any resource in the VPC are automatically deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpc(
    params: VpcV1.DeleteVpcParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteVpc'
    );

    const parameters = {
      options: {
        url: '/vpcs/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC.
   *
   * This request retrieves a single VPC specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPC>>}
   */
  public getVpc(
    params: VpcV1.GetVpcParams
  ): Promise<VpcV1.Response<VpcV1.VPC>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpc'
    );

    const parameters = {
      options: {
        url: '/vpcs/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPC.
   *
   * This request updates a VPC with the information provided in a VPC patch object. The patch object is structured in
   * the same way as a retrieved VPC and needs to contain only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {string} [params.name] - The name for this VPC. The name must not be used by another VPC in the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPC>>}
   */
  public updateVpc(
    params: VpcV1.UpdateVpcParams
  ): Promise<VpcV1.Response<VpcV1.VPC>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVpc'
    );

    const parameters = {
      options: {
        url: '/vpcs/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC's default network ACL.
   *
   * This request retrieves the default network ACL for the VPC specified by the identifier in the URL. The default
   * network ACL is applied to any new subnets in the VPC which do not specify a network ACL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DefaultNetworkACL>>}
   */
  public getVpcDefaultNetworkAcl(
    params: VpcV1.GetVpcDefaultNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.DefaultNetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpcDefaultNetworkAcl'
    );

    const parameters = {
      options: {
        url: '/vpcs/{id}/default_network_acl',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC's default routing table.
   *
   * This request retrieves the default routing table for the VPC specified by the identifier in the URL. The default
   * routing table is associated with any subnets in the VPC which have not been explicitly associated with another
   * routing table.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DefaultRoutingTable>>}
   */
  public getVpcDefaultRoutingTable(
    params: VpcV1.GetVpcDefaultRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.DefaultRoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpcDefaultRoutingTable'
    );

    const parameters = {
      options: {
        url: '/vpcs/{id}/default_routing_table',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC's default security group.
   *
   * This request retrieves the default security group for the VPC specified by the identifier in the URL. Resources
   * created in this VPC that allow a security group to be optionally specified will use this security group by default.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DefaultSecurityGroup>>}
   */
  public getVpcDefaultSecurityGroup(
    params: VpcV1.GetVpcDefaultSecurityGroupParams
  ): Promise<VpcV1.Response<VpcV1.DefaultSecurityGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpcDefaultSecurityGroup'
    );

    const parameters = {
      options: {
        url: '/vpcs/{id}/default_security_group',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all address prefixes for a VPC.
   *
   * This request lists all address pool prefixes for a VPC.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.AddressPrefixCollection>>}
   */
  public listVpcAddressPrefixes(
    params: VpcV1.ListVpcAddressPrefixesParams
  ): Promise<VpcV1.Response<VpcV1.AddressPrefixCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId'];
    const _validParams = ['vpcId', 'start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpcAddressPrefixes'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/address_prefixes',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an address prefix for a VPC.
   *
   * This request creates a new prefix from a prefix prototype object. The prototype object is structured in the same
   * way as a retrieved prefix, and contains the information necessary to create the new prefix.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.cidr - The IPv4 range of the address prefix, expressed in CIDR format. The range must not
   * overlap with any existing address prefixes in the VPC or any of the following reserved address ranges:
   *
   *   - `127.0.0.0/8` (IPv4 loopback addresses)
   *   - `161.26.0.0/16` (IBM services)
   *   - `166.8.0.0/14` (Cloud Service Endpoints)
   *   - `169.254.0.0/16` (IPv4 link-local addresses)
   *   - `224.0.0.0/4` (IPv4 multicast addresses)
   *
   * The prefix length of the address prefix's CIDR must be between `/9` (8,388,608 addresses) and `/29` (8 addresses).
   * @param {ZoneIdentity} params.zone - The zone this address prefix will reside in.
   * @param {boolean} [params.isDefault] - Indicates whether this will be the default address prefix for this zone in
   * this VPC. If `true`, the VPC must not have a default address prefix for this zone.
   * @param {string} [params.name] - The name for this address prefix. The name must not be used by another address
   * prefix for the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.AddressPrefix>>}
   */
  public createVpcAddressPrefix(
    params: VpcV1.CreateVpcAddressPrefixParams
  ): Promise<VpcV1.Response<VpcV1.AddressPrefix>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'cidr', 'zone'];
    const _validParams = ['vpcId', 'cidr', 'zone', 'isDefault', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'cidr': _params.cidr,
      'zone': _params.zone,
      'is_default': _params.isDefault,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createVpcAddressPrefix'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/address_prefixes',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an address prefix.
   *
   * This request deletes a prefix. This operation cannot be reversed. The request will fail if any subnets use
   * addresses from this prefix.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The prefix identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpcAddressPrefix(
    params: VpcV1.DeleteVpcAddressPrefixParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteVpcAddressPrefix'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/address_prefixes/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an address prefix.
   *
   * This request retrieves a single prefix specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The prefix identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.AddressPrefix>>}
   */
  public getVpcAddressPrefix(
    params: VpcV1.GetVpcAddressPrefixParams
  ): Promise<VpcV1.Response<VpcV1.AddressPrefix>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpcAddressPrefix'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/address_prefixes/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an address prefix.
   *
   * This request updates a prefix with the information in a provided prefix patch. The prefix patch object is
   * structured in the same way as a retrieved prefix and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The prefix identifier.
   * @param {boolean} [params.isDefault] - Indicates whether this is the default prefix for this zone in this VPC.
   * Updating to true makes this prefix the default prefix for this zone in this VPC, provided the VPC currently has no
   * default address prefix for this zone. Updating to false removes the default prefix for this zone in this VPC.
   * @param {string} [params.name] - The name for this address prefix. The name must not be used by another address
   * prefix for the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.AddressPrefix>>}
   */
  public updateVpcAddressPrefix(
    params: VpcV1.UpdateVpcAddressPrefixParams
  ): Promise<VpcV1.Response<VpcV1.AddressPrefix>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'isDefault', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'is_default': _params.isDefault,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVpcAddressPrefix'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/address_prefixes/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all routes in a VPC's default routing table.
   *
   * This request lists all routes in the VPC's default routing table. Each route is zone-specific and directs any
   * packets matching its destination CIDR block to a `next_hop` IP address. The most specific route matching a packet's
   * destination will be used. If multiple equally-specific routes exist, traffic will be distributed across them.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} [params.zoneName] - Filters the collection to resources with a `zone.name` property matching the
   * exact specified name.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RouteCollectionVPCContext>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public listVpcRoutes(
    params: VpcV1.ListVpcRoutesParams
  ): Promise<VpcV1.Response<VpcV1.RouteCollectionVPCContext>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: listVpcRoutes');
    const _params = { ...params };
    const _requiredParams = ['vpcId'];
    const _validParams = ['vpcId', 'zoneName', 'start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'zone.name': _params.zoneName,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpcRoutes'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routes',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a route in a VPC's default routing table.
   *
   * This request creates a new route in the VPC's default routing table. The route prototype object is structured in
   * the same way as a retrieved route, and contains the information necessary to create the new route. The request will
   * fail if the new route will cause a loop.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.destination - The destination CIDR of the route. The host identifier in the CIDR must be
   * zero.
   *
   * At most two routes per `zone` in a table can have the same `destination` and
   * `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
   * @param {ZoneIdentity} params.zone - The zone to apply the route to. (Traffic from subnets in this zone will be
   * subject to this route.).
   * @param {string} [params.action] - The action to perform with a packet matching the route:
   * - `delegate`: delegate to system-provided routes
   * - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
   * - `deliver`: deliver the packet to the specified `next_hop`
   * - `drop`: drop the packet.
   * @param {string} [params.name] - The name for this route. The name must not be used by another route in the routing
   * table. Names starting with `ibm-` are reserved for system-provided routes, and are not allowed. If unspecified, the
   * name will be a hyphenated list of randomly-selected words.
   * @param {RoutePrototypeNextHop} [params.nextHop] - If `action` is `deliver`, the next hop that packets will be
   * delivered to. For other
   * `action` values, it must be omitted or specified as `0.0.0.0`.
   *
   * At most two routes per `zone` in a table can have the same `destination` and `priority`,
   * and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
   * @param {number} [params.priority] - The priority of this route. Smaller values have higher priority.
   *
   * If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
   * priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
   * distributed between them.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public createVpcRoute(
    params: VpcV1.CreateVpcRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: createVpcRoute');
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'destination', 'zone'];
    const _validParams = ['vpcId', 'destination', 'zone', 'action', 'name', 'nextHop', 'priority', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'destination': _params.destination,
      'zone': _params.zone,
      'action': _params.action,
      'name': _params.name,
      'next_hop': _params.nextHop,
      'priority': _params.priority,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createVpcRoute'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routes',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPC route.
   *
   * This request deletes a route. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public deleteVpcRoute(
    params: VpcV1.DeleteVpcRouteParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: deleteVpcRoute');
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteVpcRoute'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routes/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC route.
   *
   * This request retrieves a single route specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public getVpcRoute(
    params: VpcV1.GetVpcRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: getVpcRoute');
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpcRoute'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routes/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPC route.
   *
   * This request updates a route with the information in a provided route patch. The route patch object is structured
   * in the same way as a retrieved route and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The route identifier.
   * @param {string} [params.name] - The name for this route. The name must not be used by another route in the routing
   * table. Names starting with `ibm-` are reserved for system-provided routes, and are not allowed.
   * @param {RouteNextHopPatch} [params.nextHop] - If `action` is `deliver`, the next hop that packets will be delivered
   * to. For other
   * `action` values, specify `0.0.0.0` or remove it by specifying `null`.
   *
   * At most two routes per `zone` in a table can have the same `destination` and `priority`,
   * and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
   * @param {number} [params.priority] - The priority of this route. Smaller values have higher priority.
   *
   * If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
   * priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
   * distributed between them.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public updateVpcRoute(
    params: VpcV1.UpdateVpcRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: updateVpcRoute');
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'name', 'nextHop', 'priority', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'next_hop': _params.nextHop,
      'priority': _params.priority,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVpcRoute'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routes/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all routing tables for a VPC.
   *
   * This request lists all routing tables for a VPC. Each subnet in a VPC is associated with a routing table, which
   * controls delivery of packets sent on that subnet according to the action of the most specific matching route in the
   * table. If multiple equally-specific routes exist, traffic will be distributed across them. If no routes match,
   * delivery will be controlled by the system's built-in routes.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {boolean} [params.isDefault] - Filters the collection to routing tables with an `is_default` property
   * matching the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTableCollection>>}
   */
  public listVpcRoutingTables(
    params: VpcV1.ListVpcRoutingTablesParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTableCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId'];
    const _validParams = ['vpcId', 'start', 'limit', 'isDefault', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'is_default': _params.isDefault,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpcRoutingTables'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a routing table for a VPC.
   *
   * This request creates a routing table from a routing table prototype object. The prototype object is structured in
   * the same way as a retrieved routing table, and contains the information necessary to create the new routing table.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {ResourceFilter[]} [params.acceptRoutesFrom] - The filters specifying the resources that may create routes
   * in this routing table.
   *
   * At present, only the `resource_type` filter is permitted, and only the `vpn_server` value is supported, but filter
   * support is expected to expand in the future.
   * @param {string} [params.name] - The name for this routing table. The name must not be used by another routing table
   * in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {boolean} [params.routeDirectLinkIngress] - If set to `true`, this routing table will be used to route
   * traffic that originates from [Direct Link](https://cloud.ibm.com/docs/dl) to this VPC. The VPC must not already
   * have a routing table with this property set to `true`.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
   * Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN gateway
   * connection, the packet will be dropped.
   *
   * If [Classic Access](https://cloud.ibm.com/docs/vpc?topic=vpc-setting-up-access-to-classic-infrastructure) is
   * enabled for this VPC, and this property is set to `true`, its incoming traffic will also be routed according to
   * this routing table.
   * @param {boolean} [params.routeInternetIngress] - If set to `true`, this routing table will be used to route traffic
   * that originates from the internet. For this to succeed, the VPC must not already have a routing table with this
   * property set to `true`.
   *
   * Incoming traffic will be routed according to the routing table with two exceptions:
   * - Traffic destined for IP addresses associated with public gateways will not be
   *   subject to routes in this routing table.
   * - Routes with an action of deliver are treated as drop unless the `next_hop` is an
   *   IP address in a subnet in the route's `zone`. Therefore, if an incoming packet
   *   matches a route with a `next_hop` of an internet-bound IP address or a VPN gateway
   *   connection, the packet will be dropped.
   * @param {boolean} [params.routeTransitGatewayIngress] - If set to `true`, this routing table will be used to route
   * traffic that originates from [Transit Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC. The VPC
   * must not already have a routing table with this property set to `true`.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
   * Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN gateway
   * connection, the packet will be dropped.
   * @param {boolean} [params.routeVpcZoneIngress] - If set to `true`, this routing table will be used to route traffic
   * that originates from subnets in other zones in this VPC. The VPC must not already have a routing table with this
   * property set to `true`.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
   * Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN gateway
   * connection, the packet will be dropped.
   * @param {RoutePrototype[]} [params.routes] - The prototype objects for routes to create for this routing table. If
   * unspecified, the routing table will be created with no routes.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTable>>}
   */
  public createVpcRoutingTable(
    params: VpcV1.CreateVpcRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId'];
    const _validParams = ['vpcId', 'acceptRoutesFrom', 'name', 'routeDirectLinkIngress', 'routeInternetIngress', 'routeTransitGatewayIngress', 'routeVpcZoneIngress', 'routes', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'accept_routes_from': _params.acceptRoutesFrom,
      'name': _params.name,
      'route_direct_link_ingress': _params.routeDirectLinkIngress,
      'route_internet_ingress': _params.routeInternetIngress,
      'route_transit_gateway_ingress': _params.routeTransitGatewayIngress,
      'route_vpc_zone_ingress': _params.routeVpcZoneIngress,
      'routes': _params.routes,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createVpcRoutingTable'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPC routing table.
   *
   * This request deletes a routing table.  A routing table cannot be deleted if it is associated with any subnets in
   * the VPC. Additionally, a VPC's default routing table cannot be deleted. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The routing table identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpcRoutingTable(
    params: VpcV1.DeleteVpcRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteVpcRoutingTable'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC routing table.
   *
   * This request retrieves a single routing table specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The routing table identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTable>>}
   */
  public getVpcRoutingTable(
    params: VpcV1.GetVpcRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpcRoutingTable'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPC routing table.
   *
   * This request updates a routing table with the information in a provided routing table patch. The patch object is
   * structured in the same way as a retrieved table and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The routing table identifier.
   * @param {ResourceFilter[]} [params.acceptRoutesFrom] - The filters specifying the resources that may create routes
   * in this routing table
   * (replacing any existing filters). All routes created by resources that match a given filter will be removed when an
   * existing filter is removed. Therefore, if an empty array is specified, all filters will be removed, resulting in
   * all routes not directly created by the user being removed.
   *
   * At present, only the `resource_type` filter is permitted, and only the `vpn_server` value is supported, but filter
   * support is expected to expand in the future.
   * @param {string} [params.name] - The name for this routing table. The name must not be used by another routing table
   * in the VPC.
   * @param {boolean} [params.routeDirectLinkIngress] - Indicates whether this routing table is used to route traffic
   * that originates from
   * [Direct Link](https://cloud.ibm.com/docs/dl/) to this VPC. Updating to `true` selects this routing table, provided
   * no other routing table in the VPC already has this property set to `true`, and no subnets are attached to this
   * routing table. Updating to
   * `false` deselects this routing table.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
   * Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN gateway
   * connection, the packet will be dropped.
   * @param {boolean} [params.routeInternetIngress] - Indicates whether this routing table is used to route traffic that
   * originates from the internet.  Updating to `true` selects this routing table, provided no other routing table in
   * the VPC already has this property set to `true`.  Updating to `false` deselects this routing table.
   *
   * Incoming traffic will be routed according to the routing table with two exceptions:
   * -  Traffic destined for IP addresses associated with public gateways will not be subject
   *    to routes in this routing table.
   * -  Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is an
   *    IP address in a subnet in the route's `zone`. Therefore, if an incoming packet matches
   *    a route with a `next_hop` of an internet-bound IP address or a VPN gateway connection,
   *    the packet will be dropped.
   * @param {boolean} [params.routeTransitGatewayIngress] - Indicates whether this routing table is used to route
   * traffic that originates from
   * [Transit Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC. Updating to
   * `true` selects this routing table, provided no other routing table in the VPC already has this property set to
   * `true`, and no subnets are attached to this routing table. Updating to `false` deselects this routing table.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
   * Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN gateway
   * connection, the packet will be dropped.
   *
   * If [Classic Access](https://cloud.ibm.com/docs/vpc?topic=vpc-setting-up-access-to-classic-infrastructure) is
   * enabled for this VPC, and this property is set to `true`, its incoming traffic will also be routed according to
   * this routing table.
   * @param {boolean} [params.routeVpcZoneIngress] - Indicates whether this routing table is used to route traffic that
   * originates from subnets in other zones in this VPC. Updating to `true` selects this routing table, provided no
   * other routing table in the VPC already has this property set to `true`, and no subnets are attached to this routing
   * table. Updating to `false` deselects this routing table.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
   * Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN gateway
   * connection, the packet will be dropped.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTable>>}
   */
  public updateVpcRoutingTable(
    params: VpcV1.UpdateVpcRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'acceptRoutesFrom', 'name', 'routeDirectLinkIngress', 'routeInternetIngress', 'routeTransitGatewayIngress', 'routeVpcZoneIngress', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'accept_routes_from': _params.acceptRoutesFrom,
      'name': _params.name,
      'route_direct_link_ingress': _params.routeDirectLinkIngress,
      'route_internet_ingress': _params.routeInternetIngress,
      'route_transit_gateway_ingress': _params.routeTransitGatewayIngress,
      'route_vpc_zone_ingress': _params.routeVpcZoneIngress,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVpcRoutingTable'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all routes in a VPC routing table.
   *
   * This request lists all routes in a VPC routing table. If subnets are associated with this routing table, delivery
   * of packets sent on a subnet is performed according to the action of the most specific matching route in the table
   * (provided the subnet and route are in the same zone). If multiple equally-specific routes exist, the route with the
   * highest priority will be used. If two matching routes have the same destination and priority, traffic will be
   * distributed between them. If no routes match, delivery will be controlled by the system's built-in routes.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.routingTableId - The routing table identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RouteCollection>>}
   */
  public listVpcRoutingTableRoutes(
    params: VpcV1.ListVpcRoutingTableRoutesParams
  ): Promise<VpcV1.Response<VpcV1.RouteCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'routingTableId'];
    const _validParams = ['vpcId', 'routingTableId', 'start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'routing_table_id': _params.routingTableId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpcRoutingTableRoutes'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a route in a VPC routing table.
   *
   * This request creates a new VPC route from a VPC route prototype object. The prototype object is structured in the
   * same way as a retrieved VPC route and contains the information necessary to create the route.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.routingTableId - The routing table identifier.
   * @param {string} params.destination - The destination CIDR of the route. The host identifier in the CIDR must be
   * zero.
   *
   * At most two routes per `zone` in a table can have the same `destination` and
   * `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
   * @param {ZoneIdentity} params.zone - The zone to apply the route to. (Traffic from subnets in this zone will be
   * subject to this route.).
   * @param {string} [params.action] - The action to perform with a packet matching the route:
   * - `delegate`: delegate to system-provided routes
   * - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
   * - `deliver`: deliver the packet to the specified `next_hop`
   * - `drop`: drop the packet.
   * @param {string} [params.name] - The name for this route. The name must not be used by another route in the routing
   * table. Names starting with `ibm-` are reserved for system-provided routes, and are not allowed. If unspecified, the
   * name will be a hyphenated list of randomly-selected words.
   * @param {RoutePrototypeNextHop} [params.nextHop] - If `action` is `deliver`, the next hop that packets will be
   * delivered to. For other
   * `action` values, it must be omitted or specified as `0.0.0.0`.
   *
   * At most two routes per `zone` in a table can have the same `destination` and `priority`,
   * and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
   * @param {number} [params.priority] - The priority of this route. Smaller values have higher priority.
   *
   * If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
   * priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
   * distributed between them.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   */
  public createVpcRoutingTableRoute(
    params: VpcV1.CreateVpcRoutingTableRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'routingTableId', 'destination', 'zone'];
    const _validParams = ['vpcId', 'routingTableId', 'destination', 'zone', 'action', 'name', 'nextHop', 'priority', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'destination': _params.destination,
      'zone': _params.zone,
      'action': _params.action,
      'name': _params.name,
      'next_hop': _params.nextHop,
      'priority': _params.priority,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'routing_table_id': _params.routingTableId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createVpcRoutingTableRoute'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPC routing table route.
   *
   * This request deletes a VPC route. This operation cannot be reversed. Only VPC routes with an `origin` of `user` are
   * allowed to be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.routingTableId - The routing table identifier.
   * @param {string} params.id - The VPC routing table route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpcRoutingTableRoute(
    params: VpcV1.DeleteVpcRoutingTableRouteParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'routingTableId', 'id'];
    const _validParams = ['vpcId', 'routingTableId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'routing_table_id': _params.routingTableId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteVpcRoutingTableRoute'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC routing table route.
   *
   * This request retrieves a single VPC route specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.routingTableId - The routing table identifier.
   * @param {string} params.id - The VPC routing table route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   */
  public getVpcRoutingTableRoute(
    params: VpcV1.GetVpcRoutingTableRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'routingTableId', 'id'];
    const _validParams = ['vpcId', 'routingTableId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'routing_table_id': _params.routingTableId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpcRoutingTableRoute'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPC routing table route.
   *
   * This request updates a VPC route with the information provided in a route patch object. The patch object is
   * structured in the same way as a retrieved VPC route and needs to contain only the information to be updated. Only
   * VPC routes with an `origin` of `user` are allowed to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.routingTableId - The routing table identifier.
   * @param {string} params.id - The VPC routing table route identifier.
   * @param {string} [params.name] - The name for this route. The name must not be used by another route in the routing
   * table. Names starting with `ibm-` are reserved for system-provided routes, and are not allowed.
   * @param {RouteNextHopPatch} [params.nextHop] - If `action` is `deliver`, the next hop that packets will be delivered
   * to. For other
   * `action` values, specify `0.0.0.0` or remove it by specifying `null`.
   *
   * At most two routes per `zone` in a table can have the same `destination` and `priority`,
   * and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
   * @param {number} [params.priority] - The priority of this route. Smaller values have higher priority.
   *
   * If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
   * priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
   * distributed between them.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   */
  public updateVpcRoutingTableRoute(
    params: VpcV1.UpdateVpcRoutingTableRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'routingTableId', 'id'];
    const _validParams = ['vpcId', 'routingTableId', 'id', 'name', 'nextHop', 'priority', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'next_hop': _params.nextHop,
      'priority': _params.priority,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'routing_table_id': _params.routingTableId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVpcRoutingTableRoute'
    );

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * subnets
   ************************/

  /**
   * List all subnets.
   *
   * This request lists all subnets in the region. Subnets are contiguous ranges of IP addresses specified in CIDR block
   * notation. Each subnet is within a particular zone and cannot span multiple zones or regions.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.routingTableId] - Filters the collection to subnets with a `routing_table.id` property
   * matching the specified identifier.
   * @param {string} [params.routingTableName] - Filters the collection to subnets with a `routing_table.name` property
   * matching the exact specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SubnetCollection>>}
   */
  public listSubnets(
    params?: VpcV1.ListSubnetsParams
  ): Promise<VpcV1.Response<VpcV1.SubnetCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'routingTableId', 'routingTableName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'routing_table.id': _params.routingTableId,
      'routing_table.name': _params.routingTableName,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listSubnets'
    );

    const parameters = {
      options: {
        url: '/subnets',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a subnet.
   *
   * This request creates a new subnet from a subnet prototype object. The prototype object is structured in the same
   * way as a retrieved subnet, and contains the information necessary to create the new subnet. For this request to
   * succeed, the prototype's CIDR block must not overlap with an existing subnet in the VPC.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {SubnetPrototype} params.subnetPrototype - The subnet prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Subnet>>}
   */
  public createSubnet(
    params: VpcV1.CreateSubnetParams
  ): Promise<VpcV1.Response<VpcV1.Subnet>> {
    const _params = { ...params };
    const _requiredParams = ['subnetPrototype'];
    const _validParams = ['subnetPrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.subnetPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createSubnet'
    );

    const parameters = {
      options: {
        url: '/subnets',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a subnet.
   *
   * This request deletes a subnet. This operation cannot be reversed. For this request to succeed, the subnet must not
   * be referenced by any bare metal server network interfaces, instance network interfaces, VPN gateways, or load
   * balancers. A delete operation automatically detaches the subnet from any network ACLs, public gateways, or endpoint
   * gateways. All flow log collectors with `auto_delete` set to `true` targeting the subnet or any resource in the
   * subnet are automatically deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSubnet(
    params: VpcV1.DeleteSubnetParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSubnet'
    );

    const parameters = {
      options: {
        url: '/subnets/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a subnet.
   *
   * This request retrieves a single subnet specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Subnet>>}
   */
  public getSubnet(
    params: VpcV1.GetSubnetParams
  ): Promise<VpcV1.Response<VpcV1.Subnet>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSubnet'
    );

    const parameters = {
      options: {
        url: '/subnets/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a subnet.
   *
   * This request updates a subnet with the information in a provided subnet patch. The subnet patch object is
   * structured in the same way as a retrieved subnet and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {string} [params.name] - The name for this subnet. The name must not be used by another subnet in the VPC.
   * @param {NetworkACLIdentity} [params.networkAcl] - The network ACL to use for this subnet.
   * @param {SubnetPublicGatewayPatch} [params.publicGateway] - The public gateway to use for internet-bound traffic for
   * this subnet.
   * @param {RoutingTableIdentity} [params.routingTable] - The routing table to use for this subnet.  The routing table
   * properties
   * `route_direct_link_ingress`, `route_internet_ingress`,
   * `route_transit_gateway_ingress`, and `route_vpc_zone_ingress` must be `false`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Subnet>>}
   */
  public updateSubnet(
    params: VpcV1.UpdateSubnetParams
  ): Promise<VpcV1.Response<VpcV1.Subnet>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'networkAcl', 'publicGateway', 'routingTable', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'network_acl': _params.networkAcl,
      'public_gateway': _params.publicGateway,
      'routing_table': _params.routingTable,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateSubnet'
    );

    const parameters = {
      options: {
        url: '/subnets/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a subnet's attached network ACL.
   *
   * This request retrieves the network ACL attached to the subnet specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACL>>}
   */
  public getSubnetNetworkAcl(
    params: VpcV1.GetSubnetNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSubnetNetworkAcl'
    );

    const parameters = {
      options: {
        url: '/subnets/{id}/network_acl',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Replace the network ACL for a subnet.
   *
   * This request replaces the existing network ACL for a subnet with the network ACL specified in the request body.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {NetworkACLIdentity} params.networkAclIdentity - The network ACL identity.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACL>>}
   */
  public replaceSubnetNetworkAcl(
    params: VpcV1.ReplaceSubnetNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'networkAclIdentity'];
    const _validParams = ['id', 'networkAclIdentity', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.networkAclIdentity;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'replaceSubnetNetworkAcl'
    );

    const parameters = {
      options: {
        url: '/subnets/{id}/network_acl',
        method: 'PUT',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Detach a public gateway from a subnet.
   *
   * This request detaches the public gateway from the subnet specified by the subnet identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public unsetSubnetPublicGateway(
    params: VpcV1.UnsetSubnetPublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'unsetSubnetPublicGateway'
    );

    const parameters = {
      options: {
        url: '/subnets/{id}/public_gateway',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a subnet's attached public gateway.
   *
   * This request retrieves the public gateway attached to the subnet specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGateway>>}
   */
  public getSubnetPublicGateway(
    params: VpcV1.GetSubnetPublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PublicGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSubnetPublicGateway'
    );

    const parameters = {
      options: {
        url: '/subnets/{id}/public_gateway',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Attach a public gateway to a subnet.
   *
   * This request attaches the public gateway, specified in the request body, to the subnet specified by the subnet
   * identifier in the URL. The public gateway must have the same VPC and zone as the subnet.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {PublicGatewayIdentity} params.publicGatewayIdentity - The public gateway identity.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGateway>>}
   */
  public setSubnetPublicGateway(
    params: VpcV1.SetSubnetPublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PublicGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'publicGatewayIdentity'];
    const _validParams = ['id', 'publicGatewayIdentity', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.publicGatewayIdentity;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'setSubnetPublicGateway'
    );

    const parameters = {
      options: {
        url: '/subnets/{id}/public_gateway',
        method: 'PUT',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a subnet's attached routing table.
   *
   * This request retrieves the routing table attached to the subnet specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTable>>}
   */
  public getSubnetRoutingTable(
    params: VpcV1.GetSubnetRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSubnetRoutingTable'
    );

    const parameters = {
      options: {
        url: '/subnets/{id}/routing_table',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Replace the routing table for a subnet.
   *
   * This request replaces the existing routing table for a subnet with the routing table specified in the request body.
   *
   * For this request to succeed, the routing table `route_direct_link_ingress`,
   * `route_transit_gateway_ingress`, and `route_vpc_zone_ingress` properties must be `false`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {RoutingTableIdentity} params.routingTableIdentity - The routing table identity.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTable>>}
   */
  public replaceSubnetRoutingTable(
    params: VpcV1.ReplaceSubnetRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'routingTableIdentity'];
    const _validParams = ['id', 'routingTableIdentity', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.routingTableIdentity;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'replaceSubnetRoutingTable'
    );

    const parameters = {
      options: {
        url: '/subnets/{id}/routing_table',
        method: 'PUT',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all reserved IPs in a subnet.
   *
   * This request lists all reserved IPs in a subnet. A reserved IP resource will exist for every address in the subnet
   * which is not available for use.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.subnetId - The subnet identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIPCollection>>}
   */
  public listSubnetReservedIps(
    params: VpcV1.ListSubnetReservedIpsParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIPCollection>> {
    const _params = { ...params };
    const _requiredParams = ['subnetId'];
    const _validParams = ['subnetId', 'start', 'limit', 'sort', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const path = {
      'subnet_id': _params.subnetId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listSubnetReservedIps'
    );

    const parameters = {
      options: {
        url: '/subnets/{subnet_id}/reserved_ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Reserve an IP in a subnet.
   *
   * This request reserves an IP address in a subnet. If the provided prototype object includes an `address`, the
   * address must not already be reserved.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.subnetId - The subnet identifier.
   * @param {string} [params.address] - The IP address to reserve, which must not already be reserved on the subnet.
   *
   * If unspecified, an available address on the subnet will automatically be selected.
   * @param {boolean} [params.autoDelete] - Indicates whether this reserved IP member will be automatically deleted when
   * either
   * `target` is deleted, or the reserved IP is unbound. Must be `false` if the reserved IP is unbound.
   * @param {string} [params.name] - The name for this reserved IP. The name must not be used by another reserved IP in
   * the subnet. Names starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If
   * unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ReservedIPTargetPrototype} [params.target] - The target to bind this reserved IP to.  The target must be in
   * the same VPC.
   *
   * At present, only endpoint gateway targets are supported.  The endpoint gateway must
   * not be already bound to a reserved IP in the subnet's zone.
   *
   * If unspecified, the reserved IP will be created unbound.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public createSubnetReservedIp(
    params: VpcV1.CreateSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['subnetId'];
    const _validParams = ['subnetId', 'address', 'autoDelete', 'name', 'target', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'address': _params.address,
      'auto_delete': _params.autoDelete,
      'name': _params.name,
      'target': _params.target,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'subnet_id': _params.subnetId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createSubnetReservedIp'
    );

    const parameters = {
      options: {
        url: '/subnets/{subnet_id}/reserved_ips',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a reserved IP.
   *
   * This request releases a reserved IP. This operation cannot be reversed.
   *
   * For this request to succeed, the reserved IP must not be required by another resource, such as a bare metal server
   * network interface or instance network interface for which it is the primary IP. A provider-owned reserved IP is not
   * allowed to be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.subnetId - The subnet identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSubnetReservedIp(
    params: VpcV1.DeleteSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['subnetId', 'id'];
    const _validParams = ['subnetId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'subnet_id': _params.subnetId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSubnetReservedIp'
    );

    const parameters = {
      options: {
        url: '/subnets/{subnet_id}/reserved_ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a reserved IP.
   *
   * This request retrieves a single reserved IP specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.subnetId - The subnet identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public getSubnetReservedIp(
    params: VpcV1.GetSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['subnetId', 'id'];
    const _validParams = ['subnetId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'subnet_id': _params.subnetId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSubnetReservedIp'
    );

    const parameters = {
      options: {
        url: '/subnets/{subnet_id}/reserved_ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a reserved IP.
   *
   * This request updates a reserved IP with the information in a provided reserved IP patch. The reserved IP patch
   * object is structured in the same way as a retrieved reserved IP and contains only the information to be updated.
   *
   * A provider-owned reserved IP is not allowed to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.subnetId - The subnet identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {boolean} [params.autoDelete] - Indicates whether this reserved IP member will be automatically deleted when
   * either
   * `target` is deleted, or the reserved IP is unbound. Must be `false` if the reserved IP is unbound.
   * @param {string} [params.name] - The name for this reserved IP. The name must not be used by another reserved IP in
   * the subnet. Names starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public updateSubnetReservedIp(
    params: VpcV1.UpdateSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['subnetId', 'id'];
    const _validParams = ['subnetId', 'id', 'autoDelete', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'auto_delete': _params.autoDelete,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'subnet_id': _params.subnetId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateSubnetReservedIp'
    );

    const parameters = {
      options: {
        url: '/subnets/{subnet_id}/reserved_ips/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * images
   ************************/

  /**
   * List all images.
   *
   * This request lists all images available in the region. An image provides source data for a volume. Images are
   * either system-provided, or created from another source, such as importing from Cloud Object Storage.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string[]} [params.status] - Filters the collection to images with a `status` property matching one of the
   * specified comma-separated values.
   * @param {string} [params.visibility] - Filters the collection to images with a `visibility` property matching the
   * specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ImageCollection>>}
   */
  public listImages(
    params?: VpcV1.ListImagesParams
  ): Promise<VpcV1.Response<VpcV1.ImageCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'status', 'visibility', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'status': _params.status,
      'visibility': _params.visibility,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listImages'
    );

    const parameters = {
      options: {
        url: '/images',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an image.
   *
   * This request creates a new image from an image prototype object. The prototype object is structured in the same way
   * as a retrieved image, and contains the information necessary to create the new image. If an image is being
   * imported, a URL to the image file on object storage must be specified. If an image is being created from an
   * existing volume, that volume must be specified.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {ImagePrototype} params.imagePrototype - The image prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Image>>}
   */
  public createImage(
    params: VpcV1.CreateImageParams
  ): Promise<VpcV1.Response<VpcV1.Image>> {
    const _params = { ...params };
    const _requiredParams = ['imagePrototype'];
    const _validParams = ['imagePrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.imagePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createImage'
    );

    const parameters = {
      options: {
        url: '/images',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an image.
   *
   * This request deletes an image. Any active image export jobs will be completed first. This operation cannot be
   * reversed. A system-provided image is not allowed to be deleted. Additionally, an image cannot be deleted if it:
   * - has a `status` of `deleting`
   * - has a `status` of `pending` with a `status_reasons` code of `image_request_in_progress`
   * - has `catalog_offering.managed` set to `true`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The image identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteImage(
    params: VpcV1.DeleteImageParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteImage'
    );

    const parameters = {
      options: {
        url: '/images/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an image.
   *
   * This request retrieves a single image specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The image identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Image>>}
   */
  public getImage(
    params: VpcV1.GetImageParams
  ): Promise<VpcV1.Response<VpcV1.Image>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getImage'
    );

    const parameters = {
      options: {
        url: '/images/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an image.
   *
   * This request updates an image with the information in a provided image patch. The image patch object is structured
   * in the same way as a retrieved image and contains only the information to be updated. A system-provided image is
   * not allowed to be updated. An image with a `status` of `deleting` cannot be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The image identifier.
   * @param {string} [params.deprecationAt] - The deprecation date and time to set for this image.
   *
   * This cannot be set if the image has a `status` of `failed` or `deleting`, or if
   * `catalog_offering.managed` is `true`.
   *
   * The date and time must not be in the past, and must be earlier than `obsolescence_at`
   * (if `obsolescence_at` is set). Additionally, if the image status is currently
   * `deprecated`, the value cannot be changed (but may be removed).
   *
   * Specify `null` to remove an existing deprecation date and time. If the image status is currently `deprecated`, it
   * will become `available`.
   *
   * If the deprecation date and time is reached while the image has a status of `pending`, the image's status will
   * transition to `deprecated` upon its successful creation (or
   * `obsolete` if the obsolescence date and time was also reached).
   * @param {string} [params.name] - The name for this image. The name must not be used by another image in the region.
   * Names starting with `ibm-` are reserved for system-provided images, and are not allowed.
   * @param {string} [params.obsolescenceAt] - The obsolescence date and time to set for this image.
   *
   * This cannot be set if the image has a `status` of `failed` or `deleting`, or if
   * `catalog_offering.managed` is `true`.
   *
   * The date and time must not be in the past, and must be later than `deprecation_at` (if
   * `deprecation_at` is set). Additionally, if the image status is currently `obsolete`, the value cannot be changed
   * (but may be removed).
   *
   * Specify `null` to remove an existing obsolescence date and time. If the image status is currently `obsolete`, it
   * will become `deprecated` if `deprecation_at` is in the past. Otherwise, it will become `available`.
   *
   * If the obsolescence date and time is reached while the image has a status of `pending`, the image's status will
   * transition to `obsolete` upon its successful creation.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Image>>}
   */
  public updateImage(
    params: VpcV1.UpdateImageParams
  ): Promise<VpcV1.Response<VpcV1.Image>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'deprecationAt', 'name', 'obsolescenceAt', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'deprecation_at': _params.deprecationAt,
      'name': _params.name,
      'obsolescence_at': _params.obsolescenceAt,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateImage'
    );

    const parameters = {
      options: {
        url: '/images/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Deprecate an image.
   *
   * This request deprecates an image, resulting in its `status` becoming `deprecated` and
   * `deprecation_at` being set to the current date and time.
   *
   * The image must:
   * - have a `status` of `available`
   * - have `catalog_offering.managed` set to `false`
   * - not have `deprecation_at` set
   *
   * The image must not have `deprecation_at` set, must have `catalog_offering.managed` set to
   * `false`, and must have a `status` of `available`.
   *
   * A system-provided image is not allowed to be deprecated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The image identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deprecateImage(
    params: VpcV1.DeprecateImageParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deprecateImage'
    );

    const parameters = {
      options: {
        url: '/images/{id}/deprecate',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Obsolete an image.
   *
   * This request obsoletes an image, resulting in its `status` becoming `obsolete` and
   * `obsolescence_at` being set to the current date and time.
   *
   * The image must:
   * - have a `status` of `available` or `deprecated`
   * - have `catalog_offering.managed` set to `false`
   * - not have `deprecation_at` set in the future
   * - not have `obsolescence_at` set
   *
   * A system-provided image is not allowed to be obsoleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The image identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public obsoleteImage(
    params: VpcV1.ObsoleteImageParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'obsoleteImage'
    );

    const parameters = {
      options: {
        url: '/images/{id}/obsolete',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all image export jobs.
   *
   * This request lists all export jobs for an image. Each job tracks the exporting of the image to another location,
   * such as a bucket within cloud object storage.
   *
   * The jobs will be sorted by their `created_at` property values, with newest jobs first. Jobs with identical
   * `created_at` property values will in turn be sorted by ascending
   * `name` property values.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.imageId - The image identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ImageExportJobUnpaginatedCollection>>}
   */
  public listImageExportJobs(
    params: VpcV1.ListImageExportJobsParams
  ): Promise<VpcV1.Response<VpcV1.ImageExportJobUnpaginatedCollection>> {
    const _params = { ...params };
    const _requiredParams = ['imageId'];
    const _validParams = ['imageId', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'name': _params.name,
    };

    const path = {
      'image_id': _params.imageId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listImageExportJobs'
    );

    const parameters = {
      options: {
        url: '/images/{image_id}/export_jobs',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an image export job.
   *
   * This request creates and queues a new export job for the image specified in the URL using the image export job
   * prototype object. The image must be owned by the account and be in the `available`, `deprecated`, `obsolete`, or
   * `unusable` state. The prototype object is structured in the same way as a retrieved image export job, and contains
   * the information necessary to create and queue the new image export job.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.imageId - The image identifier.
   * @param {CloudObjectStorageBucketIdentity} params.storageBucket - The Cloud Object Storage bucket to export the
   * image to. The bucket must exist and an IAM
   * service authorization must grant `Image Service for VPC` of
   * `VPC Infrastructure Services` writer access to the bucket.
   * @param {string} [params.format] - The format to use for the exported image. If the image is encrypted, only `qcow2`
   * is supported.
   * @param {string} [params.name] - The name for this image export job. The name must not be used by another export job
   * for the image. If unspecified, the name will be a hyphenated list of randomly-selected words prefixed with the
   * first 16 characters of the parent image name.
   *
   * The exported image object name in Cloud Object Storage (`storage_object.name` in the response) will be based on
   * this name. The object name will be unique within the bucket.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ImageExportJob>>}
   */
  public createImageExportJob(
    params: VpcV1.CreateImageExportJobParams
  ): Promise<VpcV1.Response<VpcV1.ImageExportJob>> {
    const _params = { ...params };
    const _requiredParams = ['imageId', 'storageBucket'];
    const _validParams = ['imageId', 'storageBucket', 'format', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'storage_bucket': _params.storageBucket,
      'format': _params.format,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'image_id': _params.imageId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createImageExportJob'
    );

    const parameters = {
      options: {
        url: '/images/{image_id}/export_jobs',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an image export job.
   *
   * This request deletes an image export job. This operation cannot be reversed. If the job has not completed, the job
   * will be canceled, and the incomplete exported image object deleted. If the job has completed, the exported image
   * object will not be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.imageId - The image identifier.
   * @param {string} params.id - The image export job identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteImageExportJob(
    params: VpcV1.DeleteImageExportJobParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['imageId', 'id'];
    const _validParams = ['imageId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'image_id': _params.imageId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteImageExportJob'
    );

    const parameters = {
      options: {
        url: '/images/{image_id}/export_jobs/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an image export job.
   *
   * This request retrieves a single image export job specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.imageId - The image identifier.
   * @param {string} params.id - The image export job identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ImageExportJob>>}
   */
  public getImageExportJob(
    params: VpcV1.GetImageExportJobParams
  ): Promise<VpcV1.Response<VpcV1.ImageExportJob>> {
    const _params = { ...params };
    const _requiredParams = ['imageId', 'id'];
    const _validParams = ['imageId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'image_id': _params.imageId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getImageExportJob'
    );

    const parameters = {
      options: {
        url: '/images/{image_id}/export_jobs/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an image export job.
   *
   * This request updates an image export job with the information in a provided image export job patch. The image
   * export job patch object is structured in the same way as a retrieved image export job and contains only the
   * information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.imageId - The image identifier.
   * @param {string} params.id - The image export job identifier.
   * @param {string} [params.name] - The name for this image export job. The name must not be used by another export job
   * for the image. Changing the name will not affect the exported image name,
   * `storage_object.name`, or `storage_href` values.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ImageExportJob>>}
   */
  public updateImageExportJob(
    params: VpcV1.UpdateImageExportJobParams
  ): Promise<VpcV1.Response<VpcV1.ImageExportJob>> {
    const _params = { ...params };
    const _requiredParams = ['imageId', 'id'];
    const _validParams = ['imageId', 'id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'image_id': _params.imageId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateImageExportJob'
    );

    const parameters = {
      options: {
        url: '/images/{image_id}/export_jobs/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all operating systems.
   *
   * This request lists all operating systems in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.OperatingSystemCollection>>}
   */
  public listOperatingSystems(
    params?: VpcV1.ListOperatingSystemsParams
  ): Promise<VpcV1.Response<VpcV1.OperatingSystemCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listOperatingSystems'
    );

    const parameters = {
      options: {
        url: '/operating_systems',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an operating system.
   *
   * This request retrieves a single operating system specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The operating system name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.OperatingSystem>>}
   */
  public getOperatingSystem(
    params: VpcV1.GetOperatingSystemParams
  ): Promise<VpcV1.Response<VpcV1.OperatingSystem>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getOperatingSystem'
    );

    const parameters = {
      options: {
        url: '/operating_systems/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * keys
   ************************/

  /**
   * List all keys.
   *
   * This request lists all keys in the region. A key contains a public SSH key which may be installed on instances when
   * they are created. Private keys are not stored.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.KeyCollection>>}
   */
  public listKeys(
    params?: VpcV1.ListKeysParams
  ): Promise<VpcV1.Response<VpcV1.KeyCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listKeys'
    );

    const parameters = {
      options: {
        url: '/keys',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a key.
   *
   * This request creates a new SSH key from an key prototype object. The prototype object is structured in the same way
   * as a retrieved key, and contains the information necessary to create the new key. The public key value must be
   * provided.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.publicKey - A unique public SSH key to import, in OpenSSH format (consisting of three
   * space-separated fields: the algorithm name, base64-encoded key, and a comment). The algorithm and comment fields
   * may be omitted, as only the key field is imported.
   *
   * Keys of type `rsa` may be 2048 or 4096 bits in length, however 4096 is recommended. Keys of type `ed25519` are 256
   * bits in length.
   * @param {string} [params.name] - The name for this key. The name must not be used by another key in the region. If
   * unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {string} [params.type] - The crypto-system used by this key.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Key>>}
   */
  public createKey(
    params: VpcV1.CreateKeyParams
  ): Promise<VpcV1.Response<VpcV1.Key>> {
    const _params = { ...params };
    const _requiredParams = ['publicKey'];
    const _validParams = ['publicKey', 'name', 'resourceGroup', 'type', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'public_key': _params.publicKey,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
      'type': _params.type,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createKey'
    );

    const parameters = {
      options: {
        url: '/keys',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a key.
   *
   * This request deletes a key. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The key identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteKey(
    params: VpcV1.DeleteKeyParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteKey'
    );

    const parameters = {
      options: {
        url: '/keys/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a key.
   *
   * This request retrieves a single key specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The key identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Key>>}
   */
  public getKey(
    params: VpcV1.GetKeyParams
  ): Promise<VpcV1.Response<VpcV1.Key>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getKey'
    );

    const parameters = {
      options: {
        url: '/keys/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a key.
   *
   * This request updates a key's name.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The key identifier.
   * @param {string} [params.name] - The name for this key. The name must not be used by another key in the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Key>>}
   */
  public updateKey(
    params: VpcV1.UpdateKeyParams
  ): Promise<VpcV1.Response<VpcV1.Key>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateKey'
    );

    const parameters = {
      options: {
        url: '/keys/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * instances
   ************************/

  /**
   * List all instance profiles.
   *
   * This request lists provisionable [instance profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) in the
   * region. An instance profile specifies the performance characteristics and pricing model for an instance.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceProfileCollection>>}
   */
  public listInstanceProfiles(
    params?: VpcV1.ListInstanceProfilesParams
  ): Promise<VpcV1.Response<VpcV1.InstanceProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceProfiles'
    );

    const parameters = {
      options: {
        url: '/instance/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance profile.
   *
   * This request retrieves a single instance profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The instance profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceProfile>>}
   */
  public getInstanceProfile(
    params: VpcV1.GetInstanceProfileParams
  ): Promise<VpcV1.Response<VpcV1.InstanceProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceProfile'
    );

    const parameters = {
      options: {
        url: '/instance/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all instance templates.
   *
   * This request lists all instance templates in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceTemplateCollection>>}
   */
  public listInstanceTemplates(
    params?: VpcV1.ListInstanceTemplatesParams
  ): Promise<VpcV1.Response<VpcV1.InstanceTemplateCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceTemplates'
    );

    const parameters = {
      options: {
        url: '/instance/templates',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an instance template.
   *
   * This request creates a new instance template. The prototype object is structured in the same way as a retrieved
   * instance template, and contains the information necessary to provision a new instance from the template.
   *
   * If a `source_template` is specified in the prototype object, its contents are copied into the new template prior to
   * copying any other properties provided in the prototype object.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {InstanceTemplatePrototype} params.instanceTemplatePrototype - The instance template prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceTemplate>>}
   */
  public createInstanceTemplate(
    params: VpcV1.CreateInstanceTemplateParams
  ): Promise<VpcV1.Response<VpcV1.InstanceTemplate>> {
    const _params = { ...params };
    const _requiredParams = ['instanceTemplatePrototype'];
    const _validParams = ['instanceTemplatePrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.instanceTemplatePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createInstanceTemplate'
    );

    const parameters = {
      options: {
        url: '/instance/templates',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance template.
   *
   * This request deletes the instance template. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance template identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceTemplate(
    params: VpcV1.DeleteInstanceTemplateParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteInstanceTemplate'
    );

    const parameters = {
      options: {
        url: '/instance/templates/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance template.
   *
   * This request retrieves a single instance template specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance template identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceTemplate>>}
   */
  public getInstanceTemplate(
    params: VpcV1.GetInstanceTemplateParams
  ): Promise<VpcV1.Response<VpcV1.InstanceTemplate>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceTemplate'
    );

    const parameters = {
      options: {
        url: '/instance/templates/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance template.
   *
   * This request updates an instance template with the information provided in the instance template patch. The
   * instance template patch object is structured in the same way as a retrieved instance template and contains only the
   * information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance template identifier.
   * @param {string} [params.name] - The name for this instance template. The name must not be used by another instance
   * template in the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceTemplate>>}
   */
  public updateInstanceTemplate(
    params: VpcV1.UpdateInstanceTemplateParams
  ): Promise<VpcV1.Response<VpcV1.InstanceTemplate>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateInstanceTemplate'
    );

    const parameters = {
      options: {
        url: '/instance/templates/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all instances.
   *
   * This request lists all instances in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.vpcId] - Filters the collection to resources with a `vpc.id` property matching the
   * specified identifier.
   * @param {string} [params.vpcCrn] - Filters the collection to resources with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to resources with a `vpc.name` property matching the
   * exact specified name.
   * @param {string} [params.dedicatedHostId] - Filters the collection to instances with a `dedicated_host.id` property
   * matching the specified identifier.
   * @param {string} [params.dedicatedHostCrn] - Filters the collection to instances with a `dedicated_host.crn`
   * property matching the specified CRN.
   * @param {string} [params.dedicatedHostName] - Filters the collection to instances with a `dedicated_host.name`
   * property matching the exact specified name.
   * @param {string} [params.placementGroupId] - Filters the collection to instances with a `placement_target.id`
   * property matching the specified placement group identifier.
   * @param {string} [params.placementGroupCrn] - Filters the collection to instances with a `placement_target.crn`
   * property matching the specified placement group CRN.
   * @param {string} [params.placementGroupName] - Filters the collection to instances with a `placement_target.name`
   * property matching the exact specified placement group name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceCollection>>}
   */
  public listInstances(
    params?: VpcV1.ListInstancesParams
  ): Promise<VpcV1.Response<VpcV1.InstanceCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'vpcId', 'vpcCrn', 'vpcName', 'dedicatedHostId', 'dedicatedHostCrn', 'dedicatedHostName', 'placementGroupId', 'placementGroupCrn', 'placementGroupName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'vpc.id': _params.vpcId,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
      'dedicated_host.id': _params.dedicatedHostId,
      'dedicated_host.crn': _params.dedicatedHostCrn,
      'dedicated_host.name': _params.dedicatedHostName,
      'placement_group.id': _params.placementGroupId,
      'placement_group.crn': _params.placementGroupCrn,
      'placement_group.name': _params.placementGroupName,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstances'
    );

    const parameters = {
      options: {
        url: '/instances',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an instance.
   *
   * This request provisions a new instance from an instance prototype object. The prototype object is structured in the
   * same way as a retrieved instance, and contains the information necessary to provision the new instance. The
   * instance is automatically started.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {InstancePrototype} params.instancePrototype - The instance prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Instance>>}
   */
  public createInstance(
    params: VpcV1.CreateInstanceParams
  ): Promise<VpcV1.Response<VpcV1.Instance>> {
    const _params = { ...params };
    const _requiredParams = ['instancePrototype'];
    const _validParams = ['instancePrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.instancePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createInstance'
    );

    const parameters = {
      options: {
        url: '/instances',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance.
   *
   * This request deletes an instance. This operation cannot be reversed. Any floating IPs associated with instance
   * network interfaces are implicitly disassociated. All flow log collectors with `auto_delete` set to `true` targeting
   * the instance and/or the instance network interfaces are automatically deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The virtual server instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstance(
    params: VpcV1.DeleteInstanceParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteInstance'
    );

    const parameters = {
      options: {
        url: '/instances/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance.
   *
   * This request retrieves a single instance specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The virtual server instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Instance>>}
   */
  public getInstance(
    params: VpcV1.GetInstanceParams
  ): Promise<VpcV1.Response<VpcV1.Instance>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstance'
    );

    const parameters = {
      options: {
        url: '/instances/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance.
   *
   * This request updates an instance with the information in a provided instance patch. The instance patch object is
   * structured in the same way as a retrieved instance and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The virtual server instance identifier.
   * @param {InstanceAvailabilityPolicyPatch} [params.availabilityPolicy] - The availability policy for this virtual
   * server instance.
   * @param {InstanceMetadataServicePatch} [params.metadataService] - The metadata service configuration.
   * @param {string} [params.name] - The name for this virtual server instance. The name must not be used by another
   * virtual server instance in the region. Changing the name will not affect the system hostname.
   * @param {InstancePlacementTargetPatch} [params.placementTarget] - The placement restrictions to use for the virtual
   * server instance. For the placement
   * restrictions to be changed, the instance `status` must be `stopping` or `stopped`.
   * @param {InstancePatchProfile} [params.profile] - The profile to use for this virtual server instance. For the
   * profile to be changed,
   * the instance `status` must be `stopping` or `stopped`. In addition, the requested
   * profile must:
   * - Have matching instance disk support. Any disks associated with the current profile
   *   will be deleted, and any disks associated with the requested profile will be
   *   created.
   * - Be compatible with any `placement_target` constraints. For example, if the
   *   instance is placed on a dedicated host, the requested profile `family` must be
   *   the same as the dedicated host `family`.
   * - Have the same `vcpu.architecture`.
   * - Support the number of network interfaces the instance currently has.
   * @param {number} [params.totalVolumeBandwidth] - The amount of bandwidth (in megabits per second) allocated
   * exclusively to instance storage volumes. An increase in this value will result in a corresponding decrease to
   * `total_network_bandwidth`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Instance>>}
   */
  public updateInstance(
    params: VpcV1.UpdateInstanceParams
  ): Promise<VpcV1.Response<VpcV1.Instance>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'availabilityPolicy', 'metadataService', 'name', 'placementTarget', 'profile', 'totalVolumeBandwidth', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'availability_policy': _params.availabilityPolicy,
      'metadata_service': _params.metadataService,
      'name': _params.name,
      'placement_target': _params.placementTarget,
      'profile': _params.profile,
      'total_volume_bandwidth': _params.totalVolumeBandwidth,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateInstance'
    );

    const parameters = {
      options: {
        url: '/instances/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve initialization configuration for an instance.
   *
   * This request retrieves configuration used to initialize the instance, such as SSH keys and the Windows
   * administrator password. These can subsequently be changed on the instance and therefore may not be current.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceInitialization>>}
   */
  public getInstanceInitialization(
    params: VpcV1.GetInstanceInitializationParams
  ): Promise<VpcV1.Response<VpcV1.InstanceInitialization>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceInitialization'
    );

    const parameters = {
      options: {
        url: '/instances/{id}/initialization',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an instance action.
   *
   * This request creates a new action which will be queued up to run as soon as any pending or running actions have
   * completed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.type - The type of action.
   * @param {boolean} [params.force] - If set to true, the action will be forced immediately, and all queued actions
   * deleted. Ignored for the start action.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceAction>>}
   */
  public createInstanceAction(
    params: VpcV1.CreateInstanceActionParams
  ): Promise<VpcV1.Response<VpcV1.InstanceAction>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'type'];
    const _validParams = ['instanceId', 'type', 'force', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'type': _params.type,
      'force': _params.force,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createInstanceAction'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/actions',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a console access token for an instance.
   *
   * This request creates a new single-use console access token for an instance. All console configuration is provided
   * at token create time, and the token is subsequently used in the `access_token` query parameter for the WebSocket
   * request.  The access token is only valid for a short period of time, and a maximum of one token is valid for a
   * given instance at a time.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.consoleType - The instance console type for which this token may be used.
   * @param {boolean} [params.force] - Indicates whether to disconnect an existing serial console session as the serial
   * console cannot be shared.  This has no effect on VNC consoles.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceConsoleAccessToken>>}
   */
  public createInstanceConsoleAccessToken(
    params: VpcV1.CreateInstanceConsoleAccessTokenParams
  ): Promise<VpcV1.Response<VpcV1.InstanceConsoleAccessToken>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'consoleType'];
    const _validParams = ['instanceId', 'consoleType', 'force', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'console_type': _params.consoleType,
      'force': _params.force,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createInstanceConsoleAccessToken'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/console_access_token',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all disks on an instance.
   *
   * This request lists all disks on an instance.  A disk is a block device that is locally attached to the instance's
   * physical host and is also referred to as instance storage. By default, the listed disks are sorted by their
   * `created_at` property values, with the newest disk first.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceDiskCollection>>}
   */
  public listInstanceDisks(
    params: VpcV1.ListInstanceDisksParams
  ): Promise<VpcV1.Response<VpcV1.InstanceDiskCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceDisks'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/disks',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance disk.
   *
   * This request retrieves a single instance disk specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance disk identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceDisk>>}
   */
  public getInstanceDisk(
    params: VpcV1.GetInstanceDiskParams
  ): Promise<VpcV1.Response<VpcV1.InstanceDisk>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceDisk'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/disks/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance disk.
   *
   * This request updates the instance disk with the information in a provided patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance disk identifier.
   * @param {string} [params.name] - The name for this instance disk. The name must not be used by another disk on the
   * instance.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceDisk>>}
   */
  public updateInstanceDisk(
    params: VpcV1.UpdateInstanceDiskParams
  ): Promise<VpcV1.Response<VpcV1.InstanceDisk>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateInstanceDisk'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/disks/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all network interfaces on an instance.
   *
   * This request lists all network interfaces on an instance. An instance network interface is an abstract
   * representation of a network device and attaches an instance to a single subnet. Each network interface on an
   * instance can attach to any subnet in the zone, including subnets that are already attached to the instance.
   * Multiple network interfaces on the instance may also attach to the same subnet.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkInterfaceUnpaginatedCollection>>}
   */
  public listInstanceNetworkInterfaces(
    params: VpcV1.ListInstanceNetworkInterfacesParams
  ): Promise<VpcV1.Response<VpcV1.NetworkInterfaceUnpaginatedCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceNetworkInterfaces'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a network interface on an instance.
   *
   * This request creates a new instance network interface from an instance network interface prototype object. The
   * prototype object is structured in the same way as a retrieved instance network interface, and contains the
   * information necessary to create the new instance network interface. Any subnet in the instance's VPC may be
   * specified. Addresses on the instance network interface must be within the specified subnet's CIDR blocks.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {SubnetIdentity} params.subnet - The associated subnet.
   * @param {boolean} [params.allowIpSpoofing] - Indicates whether source IP spoofing is allowed on this instance
   * interface.
   * @param {string} [params.name] - The name for the instance network interface. The name must not be used by another
   * network interface on the virtual server instance. If unspecified, the name will be a hyphenated list of
   * randomly-selected words.
   * @param {NetworkInterfaceIPPrototype} [params.primaryIp] - The primary IP address to bind to the instance network
   * interface. This can be
   * specified using an existing reserved IP, or a prototype object for a new reserved IP.
   *
   * If an existing reserved IP or a prototype object with an address is specified, it must
   * be available on the instance network interface's subnet. Otherwise, an
   * available address on the subnet will be automatically selected and reserved.
   * @param {SecurityGroupIdentity[]} [params.securityGroups] - The security groups to use for this instance network
   * interface. If unspecified, the VPC's default security group is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkInterface>>}
   */
  public createInstanceNetworkInterface(
    params: VpcV1.CreateInstanceNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.NetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'subnet'];
    const _validParams = ['instanceId', 'subnet', 'allowIpSpoofing', 'name', 'primaryIp', 'securityGroups', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'subnet': _params.subnet,
      'allow_ip_spoofing': _params.allowIpSpoofing,
      'name': _params.name,
      'primary_ip': _params.primaryIp,
      'security_groups': _params.securityGroups,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createInstanceNetworkInterface'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance network interface.
   *
   * This request deletes an instance network interface. This operation cannot be reversed. Any floating IPs associated
   * with the instance network interface are implicitly disassociated. All flow log collectors with `auto_delete` set to
   * `true` targeting the instance network interface are automatically deleted. The primary instance network interface
   * is not allowed to be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceNetworkInterface(
    params: VpcV1.DeleteInstanceNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteInstanceNetworkInterface'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance network interface.
   *
   * This request retrieves a single instance network interface specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkInterface>>}
   */
  public getInstanceNetworkInterface(
    params: VpcV1.GetInstanceNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.NetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceNetworkInterface'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance network interface.
   *
   * This request updates an instance network interface with the information provided in an instance network interface
   * patch object. The instance network interface patch object is structured in the same way as a retrieved instance
   * network interface and needs to contain only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance network interface identifier.
   * @param {boolean} [params.allowIpSpoofing] - Indicates whether source IP spoofing is allowed on this instance
   * interface.
   * @param {string} [params.name] - The name for the instance network interface. The name must not be used by another
   * network interface on the virtual server instance.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkInterface>>}
   */
  public updateInstanceNetworkInterface(
    params: VpcV1.UpdateInstanceNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.NetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'allowIpSpoofing', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'allow_ip_spoofing': _params.allowIpSpoofing,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateInstanceNetworkInterface'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all floating IPs associated with an instance network interface.
   *
   * This request lists all floating IPs associated with an instance network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIPUnpaginatedCollection>>}
   */
  public listInstanceNetworkInterfaceFloatingIps(
    params: VpcV1.ListInstanceNetworkInterfaceFloatingIpsParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIPUnpaginatedCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceNetworkInterfaceFloatingIps'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Disassociate a floating IP from an instance network interface.
   *
   * This request disassociates the specified floating IP from the specified instance network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeInstanceNetworkInterfaceFloatingIp(
    params: VpcV1.RemoveInstanceNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId', 'id'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'removeInstanceNetworkInterfaceFloatingIp'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve associated floating IP.
   *
   * This request retrieves a specified floating IP address if it is associated with the instance network interface and
   * instance specified in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public getInstanceNetworkInterfaceFloatingIp(
    params: VpcV1.GetInstanceNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId', 'id'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceNetworkInterfaceFloatingIp'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Associate a floating IP with an instance network interface.
   *
   * This request associates the specified floating IP with the specified instance network interface, replacing any
   * existing association. For this request to succeed, the existing floating IP must not be required by another
   * resource, such as a public gateway. A request body is not required, and if provided, is ignored.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public addInstanceNetworkInterfaceFloatingIp(
    params: VpcV1.AddInstanceNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId', 'id'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'addInstanceNetworkInterfaceFloatingIp'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all reserved IPs bound to an instance network interface.
   *
   * This request lists all reserved IPs bound to an instance network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIPCollectionInstanceNetworkInterfaceContext>>}
   */
  public listInstanceNetworkInterfaceIps(
    params: VpcV1.ListInstanceNetworkInterfaceIpsParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIPCollectionInstanceNetworkInterfaceContext>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceNetworkInterfaceIps'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve bound reserved IP.
   *
   * This request retrieves the specified reserved IP address if it is bound to the network interface and instance
   * specified in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public getInstanceNetworkInterfaceIp(
    params: VpcV1.GetInstanceNetworkInterfaceIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId', 'id'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceNetworkInterfaceIp'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all volumes attachments on an instance.
   *
   * This request lists all volume attachments on an instance. A volume attachment connects a volume to an instance.
   * Each instance may have many volume attachments but each volume attachment connects exactly one instance to exactly
   * one volume.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeAttachmentCollection>>}
   */
  public listInstanceVolumeAttachments(
    params: VpcV1.ListInstanceVolumeAttachmentsParams
  ): Promise<VpcV1.Response<VpcV1.VolumeAttachmentCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceVolumeAttachments'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/volume_attachments',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a volume attachment on an instance.
   *
   * This request creates a new volume attachment from a volume attachment prototype object, connecting a volume to an
   * instance. For this request to succeed, the specified volume must not be busy. The prototype object is structured in
   * the same way as a retrieved volume attachment, and contains the information necessary to create the new volume
   * attachment.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {VolumeAttachmentPrototypeVolume} params.volume - An existing volume to attach to the instance, or a
   * prototype object for a new volume.
   * @param {boolean} [params.deleteVolumeOnInstanceDelete] - Indicates whether deleting the instance will also delete
   * the attached volume.
   * @param {string} [params.name] - The name for this volume attachment. The name must not be used by another volume
   * attachment on the instance. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeAttachment>>}
   */
  public createInstanceVolumeAttachment(
    params: VpcV1.CreateInstanceVolumeAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.VolumeAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'volume'];
    const _validParams = ['instanceId', 'volume', 'deleteVolumeOnInstanceDelete', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'volume': _params.volume,
      'delete_volume_on_instance_delete': _params.deleteVolumeOnInstanceDelete,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createInstanceVolumeAttachment'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/volume_attachments',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a volume attachment.
   *
   * This request deletes a volume attachment. This operation cannot be reversed, but a new volume attachment may
   * subsequently be created for the volume.  For this request to succeed, the volume must not be busy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The volume attachment identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceVolumeAttachment(
    params: VpcV1.DeleteInstanceVolumeAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteInstanceVolumeAttachment'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/volume_attachments/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a volume attachment.
   *
   * This request retrieves a single volume attachment specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The volume attachment identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeAttachment>>}
   */
  public getInstanceVolumeAttachment(
    params: VpcV1.GetInstanceVolumeAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.VolumeAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceVolumeAttachment'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/volume_attachments/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a volume attachment.
   *
   * This request updates a volume attachment with the information provided in a volume attachment patch object. The
   * volume attachment patch object is structured in the same way as a retrieved volume attachment and needs to contain
   * only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The volume attachment identifier.
   * @param {boolean} [params.deleteVolumeOnInstanceDelete] - Indicates whether deleting the instance will also delete
   * the attached volume.
   * @param {string} [params.name] - The name for this volume attachment. The name must not be used by another volume
   * attachment on the instance.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeAttachment>>}
   */
  public updateInstanceVolumeAttachment(
    params: VpcV1.UpdateInstanceVolumeAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.VolumeAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'deleteVolumeOnInstanceDelete', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'delete_volume_on_instance_delete': _params.deleteVolumeOnInstanceDelete,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateInstanceVolumeAttachment'
    );

    const parameters = {
      options: {
        url: '/instances/{instance_id}/volume_attachments/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * instanceGroups
   ************************/

  /**
   * List all instance groups.
   *
   * This request lists all instance groups in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupCollection>>}
   */
  public listInstanceGroups(
    params?: VpcV1.ListInstanceGroupsParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceGroups'
    );

    const parameters = {
      options: {
        url: '/instance_groups',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an instance group.
   *
   * This request creates a new instance group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {InstanceTemplateIdentity} params.instanceTemplate - Instance template to use when creating new instances.
   *
   * Instance groups are not compatible with instance templates that specify `true` for
   * `default_trusted_profile.auto_link`.
   * @param {SubnetIdentity[]} params.subnets - The subnets to use when creating new instances.
   * @param {number} [params.applicationPort] - The port to use for new load balancer pool members created by this
   * instance group. The load balancer pool member will receive load balancer traffic on this port, unless the load
   * balancer listener is using a port range. (Traffic received on a listener using a port range will be sent to members
   * using the same port the listener received it on.)
   *
   * This port will also be used for health checks unless the port property of
   * `health_monitor` property is specified.
   *
   * This property must be specified if and only if `load_balancer_pool` has been specified.
   * @param {LoadBalancerIdentity} [params.loadBalancer] - The load balancer associated with the specified load balancer
   * pool.
   * Required if `load_balancer_pool` is specified. The load balancer must have
   * `instance_groups_supported` set to `true`.
   * @param {LoadBalancerPoolIdentity} [params.loadBalancerPool] - If specified, this instance group will manage the
   * load balancer pool. A pool member
   * will be created for each instance created by this group.  The specified load
   * balancer pool must not be used by another instance group in the VPC.
   *
   * If specified, `load_balancer` and `application_port` must also be specified.
   * @param {number} [params.membershipCount] - The number of instances in the instance group.
   * @param {string} [params.name] - The name for this instance group. The name must not be used by another instance
   * group in the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroup>>}
   */
  public createInstanceGroup(
    params: VpcV1.CreateInstanceGroupParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroup>> {
    const _params = { ...params };
    const _requiredParams = ['instanceTemplate', 'subnets'];
    const _validParams = ['instanceTemplate', 'subnets', 'applicationPort', 'loadBalancer', 'loadBalancerPool', 'membershipCount', 'name', 'resourceGroup', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'instance_template': _params.instanceTemplate,
      'subnets': _params.subnets,
      'application_port': _params.applicationPort,
      'load_balancer': _params.loadBalancer,
      'load_balancer_pool': _params.loadBalancerPool,
      'membership_count': _params.membershipCount,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createInstanceGroup'
    );

    const parameters = {
      options: {
        url: '/instance_groups',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance group.
   *
   * This request deletes an instance group. This operation cannot be reversed. Any instances associated with the group
   * will be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroup(
    params: VpcV1.DeleteInstanceGroupParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteInstanceGroup'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance group.
   *
   * This request retrieves a single instance group specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroup>>}
   */
  public getInstanceGroup(
    params: VpcV1.GetInstanceGroupParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceGroup'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance group.
   *
   * This request updates an instance group with the information provided instance group patch. The instance group patch
   * object is structured in the same way as a retrieved instance group and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance group identifier.
   * @param {number} [params.applicationPort] - The port to use for new load balancer pool members created by this
   * instance group.
   *
   * This property must be set if and only if `load_balancer_pool` has been set.
   * @param {InstanceTemplateIdentity} [params.instanceTemplate] - Instance template to use when creating new instances.
   *
   * Instance groups are not compatible with instance templates that specify `true` for
   * `default_trusted_profile.auto_link`.
   * @param {LoadBalancerIdentity} [params.loadBalancer] - The load balancer associated with `load_balancer_pool`.
   * The load balancer must have `instance_groups_supported` set to `true`.
   *
   * This property must be set if and only if `load_balancer_pool` has been set.
   * @param {LoadBalancerPoolIdentity} [params.loadBalancerPool] - If specified, this instance group will manage the
   * load balancer pool. A pool member
   * will be created for each instance created by this group.  The specified load
   * balancer pool must not be used by another instance group in the VPC.
   *
   * If set, `load_balancer` and `application_port` must also be set.
   * @param {number} [params.membershipCount] - The number of instances in the instance group.
   * @param {string} [params.name] - The name for this instance group. The name must not be used by another instance
   * group in the region.
   * @param {SubnetIdentity[]} [params.subnets] - The subnets to use when creating new instances.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroup>>}
   */
  public updateInstanceGroup(
    params: VpcV1.UpdateInstanceGroupParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'applicationPort', 'instanceTemplate', 'loadBalancer', 'loadBalancerPool', 'membershipCount', 'name', 'subnets', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'application_port': _params.applicationPort,
      'instance_template': _params.instanceTemplate,
      'load_balancer': _params.loadBalancer,
      'load_balancer_pool': _params.loadBalancerPool,
      'membership_count': _params.membershipCount,
      'name': _params.name,
      'subnets': _params.subnets,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateInstanceGroup'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance group load balancer.
   *
   * This request unbinds the instance group from the load balancer pool, and deletes the load balancer pool members.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupLoadBalancer(
    params: VpcV1.DeleteInstanceGroupLoadBalancerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId'];
    const _validParams = ['instanceGroupId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteInstanceGroupLoadBalancer'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/load_balancer',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all managers for an instance group.
   *
   * This request lists all managers for an instance group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerCollection>>}
   */
  public listInstanceGroupManagers(
    params: VpcV1.ListInstanceGroupManagersParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId'];
    const _validParams = ['instanceGroupId', 'start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceGroupManagers'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a manager for an instance group.
   *
   * This request creates a new instance group manager.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {InstanceGroupManagerPrototype} params.instanceGroupManagerPrototype - The instance group manager prototype
   * object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManager>>}
   */
  public createInstanceGroupManager(
    params: VpcV1.CreateInstanceGroupManagerParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManager>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerPrototype'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerPrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.instanceGroupManagerPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createInstanceGroupManager'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance group manager.
   *
   * This request deletes an instance group manager. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group manager identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupManager(
    params: VpcV1.DeleteInstanceGroupManagerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteInstanceGroupManager'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance group manager.
   *
   * This request retrieves a single instance group manager specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group manager identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManager>>}
   */
  public getInstanceGroupManager(
    params: VpcV1.GetInstanceGroupManagerParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManager>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceGroupManager'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance group manager.
   *
   * This request updates an instance group manager with the information provided instance group manager patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group manager identifier.
   * @param {number} [params.aggregationWindow] - The time window in seconds to aggregate metrics prior to evaluation.
   * @param {number} [params.cooldown] - The duration of time in seconds to pause further scale actions after scaling
   * has taken place.
   * @param {boolean} [params.managementEnabled] - Indicates whether this manager will control the instance group.
   * @param {number} [params.maxMembershipCount] - The maximum number of members in a managed instance group.
   * @param {number} [params.minMembershipCount] - The minimum number of members in a managed instance group.
   * @param {string} [params.name] - The name for this instance group manager. The name must not be used by another
   * manager for the instance group.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManager>>}
   */
  public updateInstanceGroupManager(
    params: VpcV1.UpdateInstanceGroupManagerParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManager>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'aggregationWindow', 'cooldown', 'managementEnabled', 'maxMembershipCount', 'minMembershipCount', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'aggregation_window': _params.aggregationWindow,
      'cooldown': _params.cooldown,
      'management_enabled': _params.managementEnabled,
      'max_membership_count': _params.maxMembershipCount,
      'min_membership_count': _params.minMembershipCount,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateInstanceGroupManager'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all actions for an instance group manager.
   *
   * This request lists all instance group actions for an instance group manager.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerActionsCollection>>}
   */
  public listInstanceGroupManagerActions(
    params: VpcV1.ListInstanceGroupManagerActionsParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerActionsCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceGroupManagerActions'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an instance group manager action.
   *
   * This request creates a new instance group manager action.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {InstanceGroupManagerActionPrototype} params.instanceGroupManagerActionPrototype - The instance group
   * manager action prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>>}
   */
  public createInstanceGroupManagerAction(
    params: VpcV1.CreateInstanceGroupManagerActionParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'instanceGroupManagerActionPrototype'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'instanceGroupManagerActionPrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.instanceGroupManagerActionPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createInstanceGroupManagerAction'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete specified instance group manager action.
   *
   * This request deletes an instance group manager action. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager action identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupManagerAction(
    params: VpcV1.DeleteInstanceGroupManagerActionParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteInstanceGroupManagerAction'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve specified instance group manager action.
   *
   * This request retrieves a single instance group manager action specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager action identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>>}
   */
  public getInstanceGroupManagerAction(
    params: VpcV1.GetInstanceGroupManagerActionParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceGroupManagerAction'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update specified instance group manager action.
   *
   * This request updates an instance group manager action.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager action identifier.
   * @param {string} [params.cronSpec] - The cron specification for a recurring scheduled action. Actions can be applied
   * a maximum of one time within a 5 min period.
   * @param {InstanceGroupManagerActionGroupPatch} [params.group] -
   * @param {InstanceGroupManagerActionManagerPatch} [params.manager] -
   * @param {string} [params.name] - The name for this instance group manager action. The name must not be used by
   * another action for the instance group manager.
   * @param {string} [params.runAt] - The date and time the scheduled action will run.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>>}
   */
  public updateInstanceGroupManagerAction(
    params: VpcV1.UpdateInstanceGroupManagerActionParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'cronSpec', 'group', 'manager', 'name', 'runAt', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'cron_spec': _params.cronSpec,
      'group': _params.group,
      'manager': _params.manager,
      'name': _params.name,
      'run_at': _params.runAt,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateInstanceGroupManagerAction'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all policies for an instance group manager.
   *
   * This request lists all policies for an instance group manager.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicyCollection>>}
   */
  public listInstanceGroupManagerPolicies(
    params: VpcV1.ListInstanceGroupManagerPoliciesParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicyCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceGroupManagerPolicies'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a policy for an instance group manager.
   *
   * This request creates a new instance group manager policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {InstanceGroupManagerPolicyPrototype} params.instanceGroupManagerPolicyPrototype - The instance group
   * manager policy prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>>}
   */
  public createInstanceGroupManagerPolicy(
    params: VpcV1.CreateInstanceGroupManagerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'instanceGroupManagerPolicyPrototype'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'instanceGroupManagerPolicyPrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.instanceGroupManagerPolicyPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createInstanceGroupManagerPolicy'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance group manager policy.
   *
   * This request deletes an instance group manager policy. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupManagerPolicy(
    params: VpcV1.DeleteInstanceGroupManagerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteInstanceGroupManagerPolicy'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance group manager policy.
   *
   * This request retrieves a single instance group manager policy specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>>}
   */
  public getInstanceGroupManagerPolicy(
    params: VpcV1.GetInstanceGroupManagerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceGroupManagerPolicy'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance group manager policy.
   *
   * This request updates an instance group manager policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager policy identifier.
   * @param {string} [params.metricType] - The type of metric to be evaluated.
   * @param {number} [params.metricValue] - The metric value to be evaluated.
   * @param {string} [params.name] - The name for this instance group manager policy. The name must not be used by
   * another policy for the instance group manager.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>>}
   */
  public updateInstanceGroupManagerPolicy(
    params: VpcV1.UpdateInstanceGroupManagerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'metricType', 'metricValue', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'metric_type': _params.metricType,
      'metric_value': _params.metricValue,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateInstanceGroupManagerPolicy'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete all memberships from an instance group.
   *
   * This request deletes all memberships of an instance group. This operation cannot be reversed. reversed. Any
   * memberships that have `delete_instance_on_membership_delete` set to `true` will also have their instances deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupMemberships(
    params: VpcV1.DeleteInstanceGroupMembershipsParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId'];
    const _validParams = ['instanceGroupId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteInstanceGroupMemberships'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/memberships',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all memberships for an instance group.
   *
   * This request lists all instance group memberships for an instance group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupMembershipCollection>>}
   */
  public listInstanceGroupMemberships(
    params: VpcV1.ListInstanceGroupMembershipsParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupMembershipCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId'];
    const _validParams = ['instanceGroupId', 'start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listInstanceGroupMemberships'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/memberships',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance group membership.
   *
   * This request deletes a memberships of an instance group. This operation cannot be reversed. reversed. If the
   * membership has `delete_instance_on_membership_delete` set to `true`, the instance will also be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group membership identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupMembership(
    params: VpcV1.DeleteInstanceGroupMembershipParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteInstanceGroupMembership'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/memberships/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance group membership.
   *
   * This request retrieves a single instance group membership specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group membership identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupMembership>>}
   */
  public getInstanceGroupMembership(
    params: VpcV1.GetInstanceGroupMembershipParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupMembership>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getInstanceGroupMembership'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/memberships/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance group membership.
   *
   * This request updates an instance group membership with the information provided instance group membership patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group membership identifier.
   * @param {string} [params.name] - The name for this instance group membership. The name must not be used by another
   * membership for the instance group manager.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupMembership>>}
   */
  public updateInstanceGroupMembership(
    params: VpcV1.UpdateInstanceGroupMembershipParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupMembership>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateInstanceGroupMembership'
    );

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/memberships/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * dedicatedHosts
   ************************/

  /**
   * List all dedicated host groups.
   *
   * This request lists all dedicated host groups in the region. Host groups are a collection of dedicated hosts for
   * placement of instances. Each dedicated host must belong to one and only one group. Host groups do not span zones.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.zoneName] - Filters the collection to resources with a `zone.name` property matching the
   * exact specified name.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostGroupCollection>>}
   */
  public listDedicatedHostGroups(
    params?: VpcV1.ListDedicatedHostGroupsParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostGroupCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'zoneName', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'zone.name': _params.zoneName,
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listDedicatedHostGroups'
    );

    const parameters = {
      options: {
        url: '/dedicated_host/groups',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a dedicated host group.
   *
   * This request creates a new dedicated host group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params._class - The dedicated host profile class for hosts in this group.
   * @param {string} params.family - The dedicated host profile family for hosts in this group.
   * @param {ZoneIdentity} params.zone - The zone this dedicated host group will reside in.
   * @param {string} [params.name] - The name for this dedicated host group. The name must not be used by another
   * dedicated host group in the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>>}
   */
  public createDedicatedHostGroup(
    params: VpcV1.CreateDedicatedHostGroupParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>> {
    const _params = { ...params };
    const _requiredParams = ['_class', 'family', 'zone'];
    const _validParams = ['_class', 'family', 'zone', 'name', 'resourceGroup', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'class': _params._class,
      'family': _params.family,
      'zone': _params.zone,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createDedicatedHostGroup'
    );

    const parameters = {
      options: {
        url: '/dedicated_host/groups',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a dedicated host group.
   *
   * This request deletes a dedicated host group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteDedicatedHostGroup(
    params: VpcV1.DeleteDedicatedHostGroupParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteDedicatedHostGroup'
    );

    const parameters = {
      options: {
        url: '/dedicated_host/groups/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a dedicated host group.
   *
   * This request retrieves a single dedicated host group specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>>}
   */
  public getDedicatedHostGroup(
    params: VpcV1.GetDedicatedHostGroupParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getDedicatedHostGroup'
    );

    const parameters = {
      options: {
        url: '/dedicated_host/groups/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a dedicated host group.
   *
   * This request updates a dedicated host group with the information in a provided dedicated host group patch. The
   * dedicated host group patch object is structured in the same way as a retrieved dedicated host group and contains
   * only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host group identifier.
   * @param {string} [params.name] - The name for this dedicated host group. The name must not be used by another
   * dedicated host group in the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>>}
   */
  public updateDedicatedHostGroup(
    params: VpcV1.UpdateDedicatedHostGroupParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateDedicatedHostGroup'
    );

    const parameters = {
      options: {
        url: '/dedicated_host/groups/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all dedicated host profiles.
   *
   * This request lists provisionable [dedicated host profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles) in
   * the region. A dedicated host profile specifies the hardware characteristics for a dedicated host.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostProfileCollection>>}
   */
  public listDedicatedHostProfiles(
    params?: VpcV1.ListDedicatedHostProfilesParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listDedicatedHostProfiles'
    );

    const parameters = {
      options: {
        url: '/dedicated_host/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a dedicated host profile.
   *
   * This request retrieves a single dedicated host profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The dedicated host profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostProfile>>}
   */
  public getDedicatedHostProfile(
    params: VpcV1.GetDedicatedHostProfileParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getDedicatedHostProfile'
    );

    const parameters = {
      options: {
        url: '/dedicated_host/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all dedicated hosts.
   *
   * This request lists all dedicated hosts in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.dedicatedHostGroupId] - Filters the collection to dedicated hosts with a `group.id`
   * property matching the specified identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.zoneName] - Filters the collection to resources with a `zone.name` property matching the
   * exact specified name.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostCollection>>}
   */
  public listDedicatedHosts(
    params?: VpcV1.ListDedicatedHostsParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['dedicatedHostGroupId', 'start', 'limit', 'resourceGroupId', 'zoneName', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'dedicated_host_group.id': _params.dedicatedHostGroupId,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'zone.name': _params.zoneName,
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listDedicatedHosts'
    );

    const parameters = {
      options: {
        url: '/dedicated_hosts',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a dedicated host.
   *
   * This request creates a new dedicated host.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {DedicatedHostPrototype} params.dedicatedHostPrototype - The dedicated host prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHost>>}
   */
  public createDedicatedHost(
    params: VpcV1.CreateDedicatedHostParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHost>> {
    const _params = { ...params };
    const _requiredParams = ['dedicatedHostPrototype'];
    const _validParams = ['dedicatedHostPrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.dedicatedHostPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createDedicatedHost'
    );

    const parameters = {
      options: {
        url: '/dedicated_hosts',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all disks on a dedicated host.
   *
   * This request lists all disks on a dedicated host.  A disk is a physical device that is locally attached to the
   * compute node. By default, the listed disks are sorted by their
   * `created_at` property values, with the newest disk first.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.dedicatedHostId - The dedicated host identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostDiskCollection>>}
   */
  public listDedicatedHostDisks(
    params: VpcV1.ListDedicatedHostDisksParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostDiskCollection>> {
    const _params = { ...params };
    const _requiredParams = ['dedicatedHostId'];
    const _validParams = ['dedicatedHostId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'dedicated_host_id': _params.dedicatedHostId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listDedicatedHostDisks'
    );

    const parameters = {
      options: {
        url: '/dedicated_hosts/{dedicated_host_id}/disks',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a dedicated host disk.
   *
   * This request retrieves a single dedicated host disk specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.dedicatedHostId - The dedicated host identifier.
   * @param {string} params.id - The dedicated host disk identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostDisk>>}
   */
  public getDedicatedHostDisk(
    params: VpcV1.GetDedicatedHostDiskParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostDisk>> {
    const _params = { ...params };
    const _requiredParams = ['dedicatedHostId', 'id'];
    const _validParams = ['dedicatedHostId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'dedicated_host_id': _params.dedicatedHostId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getDedicatedHostDisk'
    );

    const parameters = {
      options: {
        url: '/dedicated_hosts/{dedicated_host_id}/disks/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a dedicated host disk.
   *
   * This request updates the dedicated host disk with the information in a provided patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.dedicatedHostId - The dedicated host identifier.
   * @param {string} params.id - The dedicated host disk identifier.
   * @param {string} [params.name] - The name for this dedicated host disk. The name must not be used by another disk on
   * the dedicated host.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostDisk>>}
   */
  public updateDedicatedHostDisk(
    params: VpcV1.UpdateDedicatedHostDiskParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostDisk>> {
    const _params = { ...params };
    const _requiredParams = ['dedicatedHostId', 'id'];
    const _validParams = ['dedicatedHostId', 'id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'dedicated_host_id': _params.dedicatedHostId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateDedicatedHostDisk'
    );

    const parameters = {
      options: {
        url: '/dedicated_hosts/{dedicated_host_id}/disks/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a dedicated host.
   *
   * This request deletes a dedicated host.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteDedicatedHost(
    params: VpcV1.DeleteDedicatedHostParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteDedicatedHost'
    );

    const parameters = {
      options: {
        url: '/dedicated_hosts/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a dedicated host.
   *
   * This request retrieves a single dedicated host specified by the identifiers in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHost>>}
   */
  public getDedicatedHost(
    params: VpcV1.GetDedicatedHostParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHost>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getDedicatedHost'
    );

    const parameters = {
      options: {
        url: '/dedicated_hosts/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a dedicated host.
   *
   * This request updates a dedicated host with the information in a provided dedicated host patch. The dedicated host
   * patch object is structured in the same way as a retrieved dedicated host and contains only the information to be
   * updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host identifier.
   * @param {boolean} [params.instancePlacementEnabled] - If set to true, instances can be placed on this dedicated
   * host.
   * @param {string} [params.name] - The name for this dedicated host. The name must not be used by another dedicated
   * host in the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHost>>}
   */
  public updateDedicatedHost(
    params: VpcV1.UpdateDedicatedHostParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHost>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'instancePlacementEnabled', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'instance_placement_enabled': _params.instancePlacementEnabled,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateDedicatedHost'
    );

    const parameters = {
      options: {
        url: '/dedicated_hosts/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * backupPolicies
   ************************/

  /**
   * List all backup policies.
   *
   * This request lists all backup policies in the region. Backup policies control which sources are selected for backup
   * and include a set of backup policy plans that provide the backup schedules and deletion triggers.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.tag] - Filters the collection to resources with an item in the `tags` property matching the
   * exact specified tag.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyCollection>>}
   */
  public listBackupPolicies(
    params?: VpcV1.ListBackupPoliciesParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'tag', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'tag': _params.tag,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listBackupPolicies'
    );

    const parameters = {
      options: {
        url: '/backup_policies',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a backup policy.
   *
   * This request creates a new backup policy from a backup policy prototype object. The prototype object is structured
   * in the same way as a retrieved backup policy, and contains the information necessary to create the new backup
   * policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string[]} params.matchUserTags - The user tags this backup policy will apply to. Resources that have both a
   * matching user tag and a matching type will be subject to the backup policy.
   * @param {string[]} [params.matchResourceTypes] - The resource types this backup policy will apply to. Resources that
   * have both a matching type and a matching user tag will be subject to the backup policy.
   * @param {string} [params.name] - The name for this backup policy. The name must not be used by another backup policy
   * in the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {BackupPolicyPlanPrototype[]} [params.plans] - The prototype objects for backup plans to be created for this
   * backup policy.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicy>>}
   */
  public createBackupPolicy(
    params: VpcV1.CreateBackupPolicyParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['matchUserTags'];
    const _validParams = ['matchUserTags', 'matchResourceTypes', 'name', 'plans', 'resourceGroup', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'match_user_tags': _params.matchUserTags,
      'match_resource_types': _params.matchResourceTypes,
      'name': _params.name,
      'plans': _params.plans,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createBackupPolicy'
    );

    const parameters = {
      options: {
        url: '/backup_policies',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all jobs for a backup policy.
   *
   * This request retrieves all jobs for a backup policy. A backup job represents the execution of a backup policy plan
   * for a resource matching the policy's criteria.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} [params.status] - Filters the collection to backup policy jobs with a `status` property matching
   * the specified value.
   * @param {string} [params.backupPolicyPlanId] - Filters the collection to backup policy jobs with a
   * `backup_policy_plan.id` property matching the specified identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.sourceId] - Filters the collection to backup policy jobs with a `source.id` property
   * matching the specified identifier.
   * @param {string} [params.targetSnapshotsId] - Filters the collection to backup policy jobs with an item in the
   * `target_snapshots` property with an `id` property matching the specified identifier.
   * @param {string} [params.targetSnapshotsCrn] - Filters the collection to backup policy jobs with an item in the
   * `target_snapshots` property with a `crn` property matching the specified CRN.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyJobCollection>>}
   */
  public listBackupPolicyJobs(
    params: VpcV1.ListBackupPolicyJobsParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyJobCollection>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId'];
    const _validParams = ['backupPolicyId', 'status', 'backupPolicyPlanId', 'start', 'limit', 'sort', 'sourceId', 'targetSnapshotsId', 'targetSnapshotsCrn', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'status': _params.status,
      'backup_policy_plan.id': _params.backupPolicyPlanId,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
      'source.id': _params.sourceId,
      'target_snapshots[].id': _params.targetSnapshotsId,
      'target_snapshots[].crn': _params.targetSnapshotsCrn,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listBackupPolicyJobs'
    );

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/jobs',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a backup policy job.
   *
   * This request retrieves a single backup policy job specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} params.id - The backup policy job identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyJob>>}
   */
  public getBackupPolicyJob(
    params: VpcV1.GetBackupPolicyJobParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyJob>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId', 'id'];
    const _validParams = ['backupPolicyId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getBackupPolicyJob'
    );

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/jobs/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all plans for a backup policy.
   *
   * This request retrieves all plans for a backup policy. Backup plans provide the backup schedule and deletion
   * triggers.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyPlanCollection>>}
   */
  public listBackupPolicyPlans(
    params: VpcV1.ListBackupPolicyPlansParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyPlanCollection>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId'];
    const _validParams = ['backupPolicyId', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'name': _params.name,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listBackupPolicyPlans'
    );

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/plans',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a plan for a backup policy.
   *
   * This request creates a new backup policy plan from a backup policy plan prototype object. The prototype object is
   * structured in the same way as a retrieved backup policy plan, and contains the information necessary to create the
   * new backup policy plan.
   *
   * Backups created by this plan will use the resource group of the source being backed up.
   *
   * Backups created by this plan will use the plan's name truncated to 46 characters, followed by a unique 16-character
   * suffix.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} params.cronSpec - The cron specification for the backup schedule. The backup policy jobs
   * (which create and delete backups for this plan) will not start until this time, and may start for up to 90 minutes
   * after this time.
   *
   * All backup schedules for plans in the same policy must be at least an hour apart.
   * @param {boolean} [params.active] - Indicates whether the plan is active.
   * @param {string[]} [params.attachUserTags] - User tags to attach to each backup (snapshot) created by this plan. If
   * unspecified, no user tags will be attached.
   * @param {BackupPolicyPlanClonePolicyPrototype} [params.clonePolicy] -
   * @param {boolean} [params.copyUserTags] - Indicates whether to copy the source's user tags to the created backups
   * (snapshots).
   * @param {BackupPolicyPlanDeletionTriggerPrototype} [params.deletionTrigger] -
   * @param {string} [params.name] - The name for this backup policy plan. The name must not be used by another plan for
   * the backup policy. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {BackupPolicyPlanRemoteRegionPolicyPrototype[]} [params.remoteRegionPolicies] - The policies for additional
   * backups in remote regions.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>>}
   */
  public createBackupPolicyPlan(
    params: VpcV1.CreateBackupPolicyPlanParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId', 'cronSpec'];
    const _validParams = ['backupPolicyId', 'cronSpec', 'active', 'attachUserTags', 'clonePolicy', 'copyUserTags', 'deletionTrigger', 'name', 'remoteRegionPolicies', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'cron_spec': _params.cronSpec,
      'active': _params.active,
      'attach_user_tags': _params.attachUserTags,
      'clone_policy': _params.clonePolicy,
      'copy_user_tags': _params.copyUserTags,
      'deletion_trigger': _params.deletionTrigger,
      'name': _params.name,
      'remote_region_policies': _params.remoteRegionPolicies,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createBackupPolicyPlan'
    );

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/plans',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a backup policy plan.
   *
   * This request deletes a backup policy plan. This operation cannot be reversed. Any backups that have been created by
   * the plan will remain but will no longer be subject to the plan's deletion trigger. Any running jobs associated with
   * the plan will run to completion before the plan is deleted.
   *
   * If the request is accepted, the backup policy plan `status` will be set to `deleting`. Once deletion processing
   * completes, the backup policy plan will no longer be retrievable.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} params.id - The backup policy plan identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>>}
   */
  public deleteBackupPolicyPlan(
    params: VpcV1.DeleteBackupPolicyPlanParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId', 'id'];
    const _validParams = ['backupPolicyId', 'id', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteBackupPolicyPlan'
    );

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/plans/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a backup policy plan.
   *
   * This request retrieves a single backup policy plan specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} params.id - The backup policy plan identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>>}
   */
  public getBackupPolicyPlan(
    params: VpcV1.GetBackupPolicyPlanParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId', 'id'];
    const _validParams = ['backupPolicyId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getBackupPolicyPlan'
    );

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/plans/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a backup policy plan.
   *
   * This request updates a backup policy plan with the information in a provided plan patch. The plan patch object is
   * structured in the same way as a retrieved backup policy plan and can contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} params.id - The backup policy plan identifier.
   * @param {boolean} [params.active] - Indicates whether the plan is active.
   * @param {string[]} [params.attachUserTags] - The user tags to attach to backups (snapshots) created by this plan.
   * Updating this value does not change the user tags for backups that have already been created by this plan.
   * @param {BackupPolicyPlanClonePolicyPatch} [params.clonePolicy] -
   * @param {boolean} [params.copyUserTags] - Indicates whether to copy the source's user tags to the created backups
   * (snapshots).
   * @param {string} [params.cronSpec] - The cron specification for the backup schedule. The backup policy jobs
   * (which create and delete backups for this plan) will not start until this time, and may start for up to 90 minutes
   * after this time.
   *
   * All backup schedules for plans in the same policy must be at least an hour apart.
   * @param {BackupPolicyPlanDeletionTriggerPatch} [params.deletionTrigger] -
   * @param {string} [params.name] - The name for this backup policy plan. The name must not be used by another plan for
   * the backup policy.
   * @param {BackupPolicyPlanRemoteRegionPolicyPrototype[]} [params.remoteRegionPolicies] - The policies for additional
   * backups in remote regions (replacing any existing policies).
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>>}
   */
  public updateBackupPolicyPlan(
    params: VpcV1.UpdateBackupPolicyPlanParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId', 'id'];
    const _validParams = ['backupPolicyId', 'id', 'active', 'attachUserTags', 'clonePolicy', 'copyUserTags', 'cronSpec', 'deletionTrigger', 'name', 'remoteRegionPolicies', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'active': _params.active,
      'attach_user_tags': _params.attachUserTags,
      'clone_policy': _params.clonePolicy,
      'copy_user_tags': _params.copyUserTags,
      'cron_spec': _params.cronSpec,
      'deletion_trigger': _params.deletionTrigger,
      'name': _params.name,
      'remote_region_policies': _params.remoteRegionPolicies,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateBackupPolicyPlan'
    );

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/plans/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a backup policy.
   *
   * This request deletes a backup policy. This operation cannot be reversed.
   *
   * If the request is accepted, the backup policy `status` will be set to `deleting`. Once deletion processing
   * completes, the backup policy will no longer be retrievable.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The backup policy identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicy>>}
   */
  public deleteBackupPolicy(
    params: VpcV1.DeleteBackupPolicyParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteBackupPolicy'
    );

    const parameters = {
      options: {
        url: '/backup_policies/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a backup policy.
   *
   * This request retrieves a single backup policy specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The backup policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicy>>}
   */
  public getBackupPolicy(
    params: VpcV1.GetBackupPolicyParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getBackupPolicy'
    );

    const parameters = {
      options: {
        url: '/backup_policies/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a backup policy.
   *
   * This request updates a backup policy with the information in a provided backup policy patch. The backup policy
   * patch object is structured in the same way as a retrieved backup policy and contains only the information to be
   * updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The backup policy identifier.
   * @param {string[]} [params.matchUserTags] - The user tags this backup policy will apply to (replacing any existing
   * tags). Resources that have both a matching user tag and a matching type will be subject to the backup policy.
   * @param {string} [params.name] - The name for this backup policy. The name must not be used by another backup policy
   * in the region.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicy>>}
   */
  public updateBackupPolicy(
    params: VpcV1.UpdateBackupPolicyParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'matchUserTags', 'name', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'match_user_tags': _params.matchUserTags,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateBackupPolicy'
    );

    const parameters = {
      options: {
        url: '/backup_policies/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * placementGroups
   ************************/

  /**
   * List all placement groups.
   *
   * This request lists all placement groups in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PlacementGroupCollection>>}
   */
  public listPlacementGroups(
    params?: VpcV1.ListPlacementGroupsParams
  ): Promise<VpcV1.Response<VpcV1.PlacementGroupCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listPlacementGroups'
    );

    const parameters = {
      options: {
        url: '/placement_groups',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a placement group.
   *
   * This request creates a new placement group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.strategy - The strategy for this placement group
   * - `host_spread`: place on different compute hosts
   * - `power_spread`: place on compute hosts that use different power sources
   *
   * The enumerated values for this property may expand in the future. When processing this property, check for and log
   * unknown values. Optionally halt processing and surface the error, or bypass the placement group on which the
   * unexpected strategy was encountered.
   * @param {string} [params.name] - The name for this placement group. The name must not be used by another placement
   * group in the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PlacementGroup>>}
   */
  public createPlacementGroup(
    params: VpcV1.CreatePlacementGroupParams
  ): Promise<VpcV1.Response<VpcV1.PlacementGroup>> {
    const _params = { ...params };
    const _requiredParams = ['strategy'];
    const _validParams = ['strategy', 'name', 'resourceGroup', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'strategy': _params.strategy,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createPlacementGroup'
    );

    const parameters = {
      options: {
        url: '/placement_groups',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a placement group.
   *
   * This request deletes a placement group. This operation cannot be reversed. For this request to succeed, the
   * placement group must not be associated with an instance.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The placement group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deletePlacementGroup(
    params: VpcV1.DeletePlacementGroupParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deletePlacementGroup'
    );

    const parameters = {
      options: {
        url: '/placement_groups/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a placement group.
   *
   * This request retrieves a single placement group specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The placement group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PlacementGroup>>}
   */
  public getPlacementGroup(
    params: VpcV1.GetPlacementGroupParams
  ): Promise<VpcV1.Response<VpcV1.PlacementGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getPlacementGroup'
    );

    const parameters = {
      options: {
        url: '/placement_groups/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a placement group.
   *
   * This request updates a placement group with the information provided placement group patch. The placement group
   * patch object is structured in the same way as a retrieved placement group and contains only the information to be
   * updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The placement group identifier.
   * @param {string} [params.name] - The name for this placement group. The name must not be used by another placement
   * group in the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PlacementGroup>>}
   */
  public updatePlacementGroup(
    params: VpcV1.UpdatePlacementGroupParams
  ): Promise<VpcV1.Response<VpcV1.PlacementGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updatePlacementGroup'
    );

    const parameters = {
      options: {
        url: '/placement_groups/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * bareMetalServers
   ************************/

  /**
   * List all bare metal server profiles.
   *
   * This request lists all [bare metal server
   * profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile) available in the region. A bare
   * metal server profile specifies the performance characteristics and pricing model for a bare metal server.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerProfileCollection>>}
   */
  public listBareMetalServerProfiles(
    params?: VpcV1.ListBareMetalServerProfilesParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listBareMetalServerProfiles'
    );

    const parameters = {
      options: {
        url: '/bare_metal_server/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a bare metal server profile.
   *
   * This request retrieves a single bare metal server profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The bare metal server profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerProfile>>}
   */
  public getBareMetalServerProfile(
    params: VpcV1.GetBareMetalServerProfileParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getBareMetalServerProfile'
    );

    const parameters = {
      options: {
        url: '/bare_metal_server/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all bare metal servers.
   *
   * This request lists all bare metal servers in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.vpcId] - Filters the collection to resources with a `vpc.id` property matching the
   * specified identifier.
   * @param {string} [params.vpcCrn] - Filters the collection to resources with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to resources with a `vpc.name` property matching the
   * exact specified name.
   * @param {string} [params.networkInterfacesSubnetId] - Filters the collection to bare metal servers with an item in
   * the `network_interfaces` property with a `subnet.id` property matching the specified identifier.
   * @param {string} [params.networkInterfacesSubnetCrn] - Filters the collection to bare metal servers with an item in
   * the `network_interfaces` property with a `subnet.crn` property matching the specified CRN.
   * @param {string} [params.networkInterfacesSubnetName] - Filters the collection to bare metal servers with an item in
   * the `network_interfaces` property with a `subnet.name` property matching the exact specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerCollection>>}
   */
  public listBareMetalServers(
    params?: VpcV1.ListBareMetalServersParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'vpcId', 'vpcCrn', 'vpcName', 'networkInterfacesSubnetId', 'networkInterfacesSubnetCrn', 'networkInterfacesSubnetName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'vpc.id': _params.vpcId,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
      'network_interfaces.subnet.id': _params.networkInterfacesSubnetId,
      'network_interfaces.subnet.crn': _params.networkInterfacesSubnetCrn,
      'network_interfaces.subnet.name': _params.networkInterfacesSubnetName,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listBareMetalServers'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a bare metal server.
   *
   * This request provisions a new bare metal server from a prototype object. The prototype object is structured in the
   * same way as a retrieved bare metal server, and contains the information necessary to provision the new bare metal
   * server. The bare metal server is automatically started.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {BareMetalServerInitializationPrototype} params.initialization -
   * @param {BareMetalServerPrimaryNetworkInterfacePrototype} params.primaryNetworkInterface - The primary bare metal
   * server network interface to create.
   * @param {BareMetalServerProfileIdentity} params.profile - The
   * [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
   * to use for this bare metal server.
   * @param {ZoneIdentity} params.zone - The zone this bare metal server will reside in.
   * @param {boolean} [params.enableSecureBoot] - Indicates whether secure boot is enabled. If enabled, the image must
   * support secure boot or the server will fail to boot.
   * @param {string} [params.name] - The name for this bare metal server. The name must not be used by another bare
   * metal server in the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   *
   * The system hostname will be based on this name.
   * @param {BareMetalServerNetworkInterfacePrototype[]} [params.networkInterfaces] - The additional bare metal server
   * network interfaces to create.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {BareMetalServerTrustedPlatformModulePrototype} [params.trustedPlatformModule] -
   * @param {VPCIdentity} [params.vpc] - The VPC this bare metal server will reside in.
   *
   * If specified, it must match the VPC for the subnets that the network interfaces of
   * the bare metal server are attached to.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServer>>}
   */
  public createBareMetalServer(
    params: VpcV1.CreateBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServer>> {
    const _params = { ...params };
    const _requiredParams = ['initialization', 'primaryNetworkInterface', 'profile', 'zone'];
    const _validParams = ['initialization', 'primaryNetworkInterface', 'profile', 'zone', 'enableSecureBoot', 'name', 'networkInterfaces', 'resourceGroup', 'trustedPlatformModule', 'vpc', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'initialization': _params.initialization,
      'primary_network_interface': _params.primaryNetworkInterface,
      'profile': _params.profile,
      'zone': _params.zone,
      'enable_secure_boot': _params.enableSecureBoot,
      'name': _params.name,
      'network_interfaces': _params.networkInterfaces,
      'resource_group': _params.resourceGroup,
      'trusted_platform_module': _params.trustedPlatformModule,
      'vpc': _params.vpc,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createBareMetalServer'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a console access token for a bare metal server.
   *
   * This request creates a new single-use console access token for a bare metal server. All console configuration is
   * provided at token create time, and the token is subsequently used in the `access_token` query parameter for the
   * WebSocket request.  The access token is only valid for a short period of time, and a maximum of one token is valid
   * for a given bare metal server at a time.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.consoleType - The bare metal server console type for which this token may be used
   *
   * Must be `serial` for bare metal servers with a `cpu.architecture` of `s390x`.
   * @param {boolean} [params.force] - Indicates whether to disconnect an existing serial console session as the serial
   * console cannot be shared.  This has no effect on VNC consoles.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerConsoleAccessToken>>}
   */
  public createBareMetalServerConsoleAccessToken(
    params: VpcV1.CreateBareMetalServerConsoleAccessTokenParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerConsoleAccessToken>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'consoleType'];
    const _validParams = ['bareMetalServerId', 'consoleType', 'force', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'console_type': _params.consoleType,
      'force': _params.force,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createBareMetalServerConsoleAccessToken'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/console_access_token',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all disks on a bare metal server.
   *
   * This request lists all disks on a bare metal server.  A disk is a block device that is locally attached to the
   * physical server.  By default, the listed disks are sorted by their `created_at` property values, with the newest
   * disk first.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerDiskCollection>>}
   */
  public listBareMetalServerDisks(
    params: VpcV1.ListBareMetalServerDisksParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerDiskCollection>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId'];
    const _validParams = ['bareMetalServerId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listBareMetalServerDisks'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/disks',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a bare metal server disk.
   *
   * This request retrieves a single disk specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server disk identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerDisk>>}
   */
  public getBareMetalServerDisk(
    params: VpcV1.GetBareMetalServerDiskParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerDisk>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getBareMetalServerDisk'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/disks/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a bare metal server disk.
   *
   * This request updates the bare metal server disk with the information in a provided patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server disk identifier.
   * @param {string} [params.name] - The name for this bare metal server disk. The name must not be used by another disk
   * on the bare metal server.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerDisk>>}
   */
  public updateBareMetalServerDisk(
    params: VpcV1.UpdateBareMetalServerDiskParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerDisk>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateBareMetalServerDisk'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/disks/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all network interfaces on a bare metal server.
   *
   * This request lists all network interfaces on a bare metal server. A bare metal server network interface is an
   * abstract representation of a network device and attaches a bare metal server to a single subnet. Each network
   * interface on a bare metal server can attach to any subnet in the zone, including subnets that are already attached
   * to the bare metal server.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterfaceCollection>>}
   */
  public listBareMetalServerNetworkInterfaces(
    params: VpcV1.ListBareMetalServerNetworkInterfacesParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterfaceCollection>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId'];
    const _validParams = ['bareMetalServerId', 'start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listBareMetalServerNetworkInterfaces'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a network interface on a bare metal server.
   *
   * This request creates a new bare metal server network interface from a bare metal server network interface prototype
   * object. The prototype object is structured in the same way as a retrieved bare metal server network interface, and
   * contains the information necessary to create the new bare metal server network interface. Any subnet in the bare
   * metal server's VPC may be specified, even if it is already attached to another bare metal server network interface.
   * Addresses on the bare metal server network interface must be within the specified subnet's CIDR blocks.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {BareMetalServerNetworkInterfacePrototype} params.bareMetalServerNetworkInterfacePrototype - The bare metal
   * server network interface prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>>}
   */
  public createBareMetalServerNetworkInterface(
    params: VpcV1.CreateBareMetalServerNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'bareMetalServerNetworkInterfacePrototype'];
    const _validParams = ['bareMetalServerId', 'bareMetalServerNetworkInterfacePrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.bareMetalServerNetworkInterfacePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createBareMetalServerNetworkInterface'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a bare metal server network interface.
   *
   * This request deletes a bare metal server network interface. This operation cannot be reversed. Any floating IPs
   * associated with the bare metal server network interface are implicitly disassociated.  The primary bare metal
   * server network interface is not allowed to be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteBareMetalServerNetworkInterface(
    params: VpcV1.DeleteBareMetalServerNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteBareMetalServerNetworkInterface'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a bare metal server network interface.
   *
   * This request retrieves a single bare metal server network interface specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>>}
   */
  public getBareMetalServerNetworkInterface(
    params: VpcV1.GetBareMetalServerNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getBareMetalServerNetworkInterface'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a bare metal server network interface.
   *
   * This request updates a bare metal server network interface with the information provided in a bare metal server
   * network interface patch object. The bare metal server network interface patch object is structured in the same way
   * as a retrieved bare metal server network interface and needs to contain only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server network interface identifier.
   * @param {boolean} [params.allowIpSpoofing] - Indicates whether source IP spoofing is allowed on this bare metal
   * server network interface.
   * @param {number[]} [params.allowedVlans] - Indicates what VLAN IDs (for VLAN type only) can use this physical (PCI
   * type) interface.
   * @param {boolean} [params.enableInfrastructureNat] - If `true`:
   * - The VPC infrastructure performs any needed NAT operations.
   * - `floating_ips` must not have more than one floating IP.
   *
   * If `false`:
   * - Packets are passed unchanged to/from the bare metal server network interface,
   *   allowing the workload to perform any needed NAT operations.
   * - `allow_ip_spoofing` must be `false`.
   * - `interface_type` must not be `hipersocket`.
   * @param {string} [params.name] - The name for this bare metal server network interface. The name must not be used by
   * another network interface on the bare metal server.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>>}
   */
  public updateBareMetalServerNetworkInterface(
    params: VpcV1.UpdateBareMetalServerNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'allowIpSpoofing', 'allowedVlans', 'enableInfrastructureNat', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'allow_ip_spoofing': _params.allowIpSpoofing,
      'allowed_vlans': _params.allowedVlans,
      'enable_infrastructure_nat': _params.enableInfrastructureNat,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateBareMetalServerNetworkInterface'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all floating IPs associated with a bare metal server network interface.
   *
   * This request lists all floating IPs associated with a bare metal server network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIPUnpaginatedCollection>>}
   */
  public listBareMetalServerNetworkInterfaceFloatingIps(
    params: VpcV1.ListBareMetalServerNetworkInterfaceFloatingIpsParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIPUnpaginatedCollection>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listBareMetalServerNetworkInterfaceFloatingIps'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Disassociate a floating IP from a bare metal server network interface.
   *
   * This request disassociates the specified floating IP from the specified bare metal server network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeBareMetalServerNetworkInterfaceFloatingIp(
    params: VpcV1.RemoveBareMetalServerNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId', 'id'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'removeBareMetalServerNetworkInterfaceFloatingIp'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve associated floating IP.
   *
   * This request retrieves a specified floating IP if it is associated with the bare metal server network interface
   * specified in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public getBareMetalServerNetworkInterfaceFloatingIp(
    params: VpcV1.GetBareMetalServerNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId', 'id'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getBareMetalServerNetworkInterfaceFloatingIp'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Associate a floating IP with a bare metal server network interface.
   *
   * This request associates the specified floating IP with the specified bare metal server network interface. If
   * `enable_infrastructure_nat` is `false`, this adds the IP to any existing associations. If
   * `enable_infrastructure_nat` is `true`, this replaces any existing association.  For this request to succeed, the
   * existing floating IP must not be required by another resource, such as a public gateway. A request body is not
   * required, and if provided, is ignored.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public addBareMetalServerNetworkInterfaceFloatingIp(
    params: VpcV1.AddBareMetalServerNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId', 'id'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'addBareMetalServerNetworkInterfaceFloatingIp'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all reserved IPs bound to a bare metal server network interface.
   *
   * This request lists all reserved IPs bound to a bare metal server network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIPCollectionBareMetalServerNetworkInterfaceContext>>}
   */
  public listBareMetalServerNetworkInterfaceIps(
    params: VpcV1.ListBareMetalServerNetworkInterfaceIpsParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIPCollectionBareMetalServerNetworkInterfaceContext>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listBareMetalServerNetworkInterfaceIps'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve bound reserved IP.
   *
   * This request retrieves the specified reserved IP address if it is bound to the network interface for the bare metal
   * server specified in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public getBareMetalServerNetworkInterfaceIp(
    params: VpcV1.GetBareMetalServerNetworkInterfaceIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId', 'id'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getBareMetalServerNetworkInterfaceIp'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a bare metal server.
   *
   * This request deletes a bare metal server. This operation cannot be reversed. Any floating IPs associated with the
   * bare metal server network interfaces are implicitly disassociated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteBareMetalServer(
    params: VpcV1.DeleteBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteBareMetalServer'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a bare metal server.
   *
   * This request retrieves a single bare metal server specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServer>>}
   */
  public getBareMetalServer(
    params: VpcV1.GetBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getBareMetalServer'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a bare metal server.
   *
   * This request updates a bare metal server with the information in a provided patch. The bare metal server patch
   * object is structured in the same way as a retrieved bare metal server and contains only the information to be
   * updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {boolean} [params.enableSecureBoot] - Indicates whether secure boot is enabled. If enabled, the image must
   * support secure boot or the bare metal server will fail to boot.
   *
   * For `enable_secure_boot` to be changed, the bare metal server `status` must be
   * `stopped`.
   * @param {string} [params.name] - The name for this bare metal server. The name must not be used by another bare
   * metal server in the region. Changing the name will not affect the system hostname.
   * @param {BareMetalServerTrustedPlatformModulePatch} [params.trustedPlatformModule] -
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServer>>}
   */
  public updateBareMetalServer(
    params: VpcV1.UpdateBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'enableSecureBoot', 'name', 'trustedPlatformModule', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'enable_secure_boot': _params.enableSecureBoot,
      'name': _params.name,
      'trusted_platform_module': _params.trustedPlatformModule,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateBareMetalServer'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve initialization configuration for a bare metal server.
   *
   * This request retrieves configuration used to initialize the bare metal server, such as the image used, SSH keys,
   * and any configured usernames and passwords. These can subsequently be changed on the server and therefore may not
   * be current.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerInitialization>>}
   */
  public getBareMetalServerInitialization(
    params: VpcV1.GetBareMetalServerInitializationParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerInitialization>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getBareMetalServerInitialization'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}/initialization',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Restart a bare metal server.
   *
   * This request restarts a bare metal server.  It will run immediately regardless of the state of the server.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public restartBareMetalServer(
    params: VpcV1.RestartBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'restartBareMetalServer'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}/restart',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Start a bare metal server.
   *
   * This request starts a bare metal server.  It will run immediately provided the server is stopped.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public startBareMetalServer(
    params: VpcV1.StartBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'startBareMetalServer'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}/start',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Stop a bare metal server.
   *
   * This request stops a bare metal server. It will run immediately provided the server is running. Note: A soft stop
   * may not complete as it relies on the operating system to perform the operation.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {string} params.type - The type of stop operation:
   * - `soft`: signal running operating system to quiesce and shutdown cleanly
   * - `hard`: immediately stop the server.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public stopBareMetalServer(
    params: VpcV1.StopBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'type'];
    const _validParams = ['id', 'type', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'type': _params.type,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'stopBareMetalServer'
    );

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}/stop',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * volumes
   ************************/

  /**
   * List all volume profiles.
   *
   * This request lists all [volume profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) available
   * in the region. A volume profile specifies the performance characteristics and pricing model for a volume.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeProfileCollection>>}
   */
  public listVolumeProfiles(
    params?: VpcV1.ListVolumeProfilesParams
  ): Promise<VpcV1.Response<VpcV1.VolumeProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVolumeProfiles'
    );

    const parameters = {
      options: {
        url: '/volume/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a volume profile.
   *
   * This request retrieves a single volume profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The volume profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeProfile>>}
   */
  public getVolumeProfile(
    params: VpcV1.GetVolumeProfileParams
  ): Promise<VpcV1.Response<VpcV1.VolumeProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVolumeProfile'
    );

    const parameters = {
      options: {
        url: '/volume/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all volumes.
   *
   * This request lists all volumes in the region. Volumes are network-connected block storage devices that may be
   * attached to one or more instances in the same region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.attachmentState] - Filters the collection to volumes with an `attachment_state` property
   * matching the specified value.
   * @param {string} [params.encryption] - Filters the collection to resources with an `encryption` property matching
   * the specified value.
   * @param {string} [params.operatingSystemFamily] - Filters the collection to resources with an
   * `operating_system.family` property matching the specified operating system family.
   *
   * This parameter also supports the values `null` and `not:null` which filter the collection to resources which have
   * no operating system or any operating system, respectively.
   * @param {string} [params.operatingSystemArchitecture] - Filters the collection to resources with an
   * `operating_system.architecture` property matching the specified operating system architecture.
   *
   * This parameter also supports the values `null` and `not:null` which filter the collection to resources which have
   * no operating system or any operating system, respectively.
   * @param {string} [params.zoneName] - Filters the collection to resources with a `zone.name` property matching the
   * exact specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeCollection>>}
   */
  public listVolumes(
    params?: VpcV1.ListVolumesParams
  ): Promise<VpcV1.Response<VpcV1.VolumeCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'name', 'attachmentState', 'encryption', 'operatingSystemFamily', 'operatingSystemArchitecture', 'zoneName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'name': _params.name,
      'attachment_state': _params.attachmentState,
      'encryption': _params.encryption,
      'operating_system.family': _params.operatingSystemFamily,
      'operating_system.architecture': _params.operatingSystemArchitecture,
      'zone.name': _params.zoneName,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVolumes'
    );

    const parameters = {
      options: {
        url: '/volumes',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a volume.
   *
   * This request creates a new volume from a volume prototype object. The prototype object is structured in the same
   * way as a retrieved volume, and contains the information necessary to create the new volume.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {VolumePrototype} params.volumePrototype - The volume prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Volume>>}
   */
  public createVolume(
    params: VpcV1.CreateVolumeParams
  ): Promise<VpcV1.Response<VpcV1.Volume>> {
    const _params = { ...params };
    const _requiredParams = ['volumePrototype'];
    const _validParams = ['volumePrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.volumePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createVolume'
    );

    const parameters = {
      options: {
        url: '/volumes',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a volume.
   *
   * This request deletes a volume. This operation cannot be reversed. For this request to succeed, the volume must not
   * be attached to any instances.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The volume identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVolume(
    params: VpcV1.DeleteVolumeParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteVolume'
    );

    const parameters = {
      options: {
        url: '/volumes/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a volume.
   *
   * This request retrieves a single volume specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The volume identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Volume>>}
   */
  public getVolume(
    params: VpcV1.GetVolumeParams
  ): Promise<VpcV1.Response<VpcV1.Volume>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVolume'
    );

    const parameters = {
      options: {
        url: '/volumes/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a volume.
   *
   * This request updates a volume with the information in a provided volume patch. The volume patch object is
   * structured in the same way as a retrieved volume and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The volume identifier.
   * @param {number} [params.capacity] - The capacity to use for the volume (in gigabytes). The volume must be attached
   * to a running virtual server instance, and the specified value must not be less than the current capacity.
   * Additionally, if the volume is attached as a boot volume, the maximum value is 250 gigabytes.
   *
   * The minimum and maximum capacity limits for creating or updating volumes may expand in the future.
   * @param {number} [params.iops] - The maximum I/O operations per second (IOPS) to use for this volume. Applicable
   * only to volumes using a profile `family` of `custom`. The volume must be attached as a data volume to a running
   * virtual server instance.
   * @param {string} [params.name] - The name for this volume. The name must not be used by another volume in the
   * region.
   * @param {VolumeProfileIdentity} [params.profile] - The profile to use for this volume. The requested profile must be
   * in the same
   * `family` as the current profile. The volume must be attached as a data volume to
   * a running virtual server instance, and must have a `capacity` within the range
   * supported by the specified profile.
   * @param {string[]} [params.userTags] - The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags)
   * associated with this volume.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Volume>>}
   */
  public updateVolume(
    params: VpcV1.UpdateVolumeParams
  ): Promise<VpcV1.Response<VpcV1.Volume>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'capacity', 'iops', 'name', 'profile', 'userTags', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'capacity': _params.capacity,
      'iops': _params.iops,
      'name': _params.name,
      'profile': _params.profile,
      'user_tags': _params.userTags,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVolume'
    );

    const parameters = {
      options: {
        url: '/volumes/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * snapshots
   ************************/

  /**
   * Delete a filtered collection of snapshots.
   *
   * This request deletes all snapshots created from a specific source volume.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.sourceVolumeId - Filters the collection to resources with a `source_volume.id` property
   * matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSnapshots(
    params: VpcV1.DeleteSnapshotsParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['sourceVolumeId'];
    const _validParams = ['sourceVolumeId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'source_volume.id': _params.sourceVolumeId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSnapshots'
    );

    const parameters = {
      options: {
        url: '/snapshots',
        method: 'DELETE',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all snapshots.
   *
   * This request lists all snapshots in the region. A snapshot preserves the data of a volume at the time the snapshot
   * is created.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.tag] - Filters the collection to resources with an item in the `tags` property matching the
   * exact specified tag.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.sourceVolumeId] - Filters the collection to resources with a `source_volume.id` property
   * matching the specified identifier.
   * @param {string} [params.sourceVolumeCrn] - Filters the collection to resources with a `source_volume.crn` property
   * matching the specified CRN.
   * @param {string} [params.sourceImageId] - Filters the collection to resources with a `source_image.id` property
   * matching the specified identifier.
   *
   * This parameter also supports the values `null` and `not:null` which filter the collection to resources which have
   * no source image or any existent source image, respectively.
   * @param {string} [params.sourceImageCrn] - Filters the collection to resources with a `source_image.crn` property
   * matching the specified CRN.
   *
   * This parameter also supports the values `null` and `not:null` which filter the collection to resources which have
   * no source image or any existent source image, respectively.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.backupPolicyPlanId] - Filters the collection to backup policy jobs with a
   * `backup_policy_plan.id` property matching the specified identifier.
   * @param {string} [params.copiesId] - Filters the collection to snapshots with an item in the `copies` property with
   * an `id` property matching the specified identifier.
   * @param {string} [params.copiesName] - Filters the collection to snapshots with an item in the `copies` property
   * with a `name` property matching the exact specified name.
   * @param {string} [params.copiesCrn] - Filters the collection to snapshots with an item in the `copies` property with
   * an `id` property matching the specified CRN.
   * @param {string} [params.copiesRemoteRegionName] - Filters the collection to snapshots with an item in the `copies`
   * property with a
   * `remote.region.name` property matching the exact specified name.
   * @param {string} [params.sourceSnapshotId] - Filters the collection to resources with a `source_snapshot.id`
   * property matching the specified identifier.
   * @param {string} [params.sourceSnapshotRemoteRegionName] - Filters the collection to resources with a
   * `source_snapshot.remote.region.name` property matching the exact specified name.
   * @param {string} [params.sourceVolumeRemoteRegionName] - Filters the collection to resources with a
   * `source_volume.remote.region.name` property matching the exact specified name.
   * @param {string} [params.sourceImageRemoteRegionName] - Filters the collection to resources with a
   * `source_image.remote.region.name` property matching the exact specified name.
   * @param {string} [params.clonesZoneName] - Filters the collection to snapshots with an item in the `clones` property
   * with a `zone.name` property matching the exact specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotCollection>>}
   */
  public listSnapshots(
    params?: VpcV1.ListSnapshotsParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'tag', 'resourceGroupId', 'name', 'sourceVolumeId', 'sourceVolumeCrn', 'sourceImageId', 'sourceImageCrn', 'sort', 'backupPolicyPlanId', 'copiesId', 'copiesName', 'copiesCrn', 'copiesRemoteRegionName', 'sourceSnapshotId', 'sourceSnapshotRemoteRegionName', 'sourceVolumeRemoteRegionName', 'sourceImageRemoteRegionName', 'clonesZoneName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'tag': _params.tag,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'source_volume.id': _params.sourceVolumeId,
      'source_volume.crn': _params.sourceVolumeCrn,
      'source_image.id': _params.sourceImageId,
      'source_image.crn': _params.sourceImageCrn,
      'sort': _params.sort,
      'backup_policy_plan.id': _params.backupPolicyPlanId,
      'copies[].id': _params.copiesId,
      'copies[].name': _params.copiesName,
      'copies[].crn': _params.copiesCrn,
      'copies[].remote.region.name': _params.copiesRemoteRegionName,
      'source_snapshot.id': _params.sourceSnapshotId,
      'source_snapshot.remote.region.name': _params.sourceSnapshotRemoteRegionName,
      'source_volume.remote.region.name': _params.sourceVolumeRemoteRegionName,
      'source_image.remote.region.name': _params.sourceImageRemoteRegionName,
      'clones[].zone.name': _params.clonesZoneName,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listSnapshots'
    );

    const parameters = {
      options: {
        url: '/snapshots',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a snapshot.
   *
   * This request creates a new snapshot from a snapshot prototype object.  The prototype object is structured in the
   * same way as a retrieved snapshot, and contains the information necessary to provision the new snapshot.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {SnapshotPrototype} params.snapshotPrototype - The snapshot prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Snapshot>>}
   */
  public createSnapshot(
    params: VpcV1.CreateSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.Snapshot>> {
    const _params = { ...params };
    const _requiredParams = ['snapshotPrototype'];
    const _validParams = ['snapshotPrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.snapshotPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createSnapshot'
    );

    const parameters = {
      options: {
        url: '/snapshots',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a snapshot.
   *
   * This request deletes a snapshot. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSnapshot(
    params: VpcV1.DeleteSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSnapshot'
    );

    const parameters = {
      options: {
        url: '/snapshots/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a snapshot.
   *
   * This request retrieves a single snapshot specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Snapshot>>}
   */
  public getSnapshot(
    params: VpcV1.GetSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.Snapshot>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSnapshot'
    );

    const parameters = {
      options: {
        url: '/snapshots/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a snapshot.
   *
   * This request updates a snapshot with the information in a provided snapshot patch. The snapshot consistency group
   * patch object is structured in the same way as a retrieved snapshot and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {string} [params.name] - The name for this snapshot. The name must not be used by another snapshot in the
   * region.
   * @param {string[]} [params.userTags] - The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags)
   * associated with this snapshot.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Snapshot>>}
   */
  public updateSnapshot(
    params: VpcV1.UpdateSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.Snapshot>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'userTags', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'user_tags': _params.userTags,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateSnapshot'
    );

    const parameters = {
      options: {
        url: '/snapshots/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all clones for a snapshot.
   *
   * This request lists all clones for a snapshot. Use a clone to quickly restore a snapshot within the clone's zone.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotCloneCollection>>}
   */
  public listSnapshotClones(
    params: VpcV1.ListSnapshotClonesParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotCloneCollection>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listSnapshotClones'
    );

    const parameters = {
      options: {
        url: '/snapshots/{id}/clones',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a snapshot clone.
   *
   * This request deletes a snapshot clone. This operation cannot be reversed, but an equivalent clone may be recreated
   * from the snapshot.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {string} params.zoneName - The zone name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSnapshotClone(
    params: VpcV1.DeleteSnapshotCloneParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'zoneName'];
    const _validParams = ['id', 'zoneName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
      'zone_name': _params.zoneName,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSnapshotClone'
    );

    const parameters = {
      options: {
        url: '/snapshots/{id}/clones/{zone_name}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a snapshot clone.
   *
   * This request retrieves a single clone specified by the snapshot identifier and zone name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {string} params.zoneName - The zone name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotClone>>}
   */
  public getSnapshotClone(
    params: VpcV1.GetSnapshotCloneParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotClone>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'zoneName'];
    const _validParams = ['id', 'zoneName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
      'zone_name': _params.zoneName,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSnapshotClone'
    );

    const parameters = {
      options: {
        url: '/snapshots/{id}/clones/{zone_name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a clone for a snapshot.
   *
   * This request creates a new clone for a snapshot in the specified zone. A request body is not required, and if
   * provided, is ignored. If the snapshot already has a clone in the zone, it is returned.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {string} params.zoneName - The zone name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotClone>>}
   */
  public createSnapshotClone(
    params: VpcV1.CreateSnapshotCloneParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotClone>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'zoneName'];
    const _validParams = ['id', 'zoneName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
      'zone_name': _params.zoneName,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createSnapshotClone'
    );

    const parameters = {
      options: {
        url: '/snapshots/{id}/clones/{zone_name}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * shares
   ************************/

  /**
   * List all file share profiles.
   *
   * This request lists all [file share profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles)
   * available in the region. A file share profile specifies the performance characteristics and pricing model for a
   * file share.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareProfileCollection>>}
   */
  public listShareProfiles(
    params?: VpcV1.ListShareProfilesParams
  ): Promise<VpcV1.Response<VpcV1.ShareProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'sort', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listShareProfiles'
    );

    const parameters = {
      options: {
        url: '/share/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a file share profile.
   *
   * This request retrieves a single file share profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The file share profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareProfile>>}
   */
  public getShareProfile(
    params: VpcV1.GetShareProfileParams
  ): Promise<VpcV1.Response<VpcV1.ShareProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getShareProfile'
    );

    const parameters = {
      options: {
        url: '/share/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all file shares.
   *
   * This request lists all file shares in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.replicationRole] - Filters the collection to file shares with a `replication_role` property
   * matching the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareCollection>>}
   */
  public listShares(
    params?: VpcV1.ListSharesParams
  ): Promise<VpcV1.Response<VpcV1.ShareCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'sort', 'replicationRole', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'sort': _params.sort,
      'replication_role': _params.replicationRole,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listShares'
    );

    const parameters = {
      options: {
        url: '/shares',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a file share.
   *
   * This request provisions new file shares from a share prototype object. The new file shares can be a standalone
   * share, a replica share, or both a source and replica share.
   *
   * The prototype object is structured in the same way as a retrieved share, and contains the information necessary to
   * provision the new file shares.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {SharePrototype} params.sharePrototype - The file share prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Share>>}
   */
  public createShare(
    params: VpcV1.CreateShareParams
  ): Promise<VpcV1.Response<VpcV1.Share>> {
    const _params = { ...params };
    const _requiredParams = ['sharePrototype'];
    const _validParams = ['sharePrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.sharePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createShare'
    );

    const parameters = {
      options: {
        url: '/shares',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a file share.
   *
   * This request deletes a share. This operation cannot be reversed. A share cannot be deleted if it:
   * - has share mount targets
   * - has a `lifecycle_state` of `updating`
   * - has a replication operation in progress
   *
   * If the request is accepted, the share `lifecycle_state` will be set to `deleting`. Once deletion processing
   * completes, it will no longer be retrievable.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The file share identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Share>>}
   */
  public deleteShare(
    params: VpcV1.DeleteShareParams
  ): Promise<VpcV1.Response<VpcV1.Share>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteShare'
    );

    const parameters = {
      options: {
        url: '/shares/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a file share.
   *
   * This request retrieves a single file share specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The file share identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Share>>}
   */
  public getShare(
    params: VpcV1.GetShareParams
  ): Promise<VpcV1.Response<VpcV1.Share>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getShare'
    );

    const parameters = {
      options: {
        url: '/shares/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a file share.
   *
   * This request updates a share with the information in a provided share patch. The share patch object is structured
   * in the same way as a retrieved share and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The file share identifier.
   * @param {string} [params.accessControlMode] - The access control mode for the share:
   *
   * - `security_group`: The security groups on the virtual network interface for a
   *   mount target control access to the mount target.
   * - `vpc`: All clients in the VPC for a mount target have access to the mount target.
   *
   * For this property to be changed, the share must have no mount targets and
   * `replication_role` must be `none`.
   * @param {number} [params.iops] - The maximum input/output operations per second (IOPS) for the file share. The value
   * must be in the range supported by the share's size.
   *
   * For this property to be changed, the share `lifecycle_state` must be `stable`.
   * @param {string} [params.name] - The name for this share. The name must not be used by another share in the region.
   * @param {ShareProfileIdentity} [params.profile] - The profile to use for this file share.
   *
   * The requested profile must be in the same `family`.
   * @param {string} [params.replicationCronSpec] - The cron specification for the file share replication schedule.
   *
   * Replication of a share can be scheduled to occur at most once per hour.
   *
   * For this property to be changed, the share `replication_role` must be `replica`.
   * @param {number} [params.size] - The size of the file share rounded up to the next gigabyte. The value must not be
   * less than the share's current size, and must not exceed the maximum supported by the share's profile and IOPS.
   *
   * For this property to be changed, the share `lifecycle_state` must be `stable`.
   * @param {string[]} [params.userTags] - Tags for this resource.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Share>>}
   */
  public updateShare(
    params: VpcV1.UpdateShareParams
  ): Promise<VpcV1.Response<VpcV1.Share>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'accessControlMode', 'iops', 'name', 'profile', 'replicationCronSpec', 'size', 'userTags', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'access_control_mode': _params.accessControlMode,
      'iops': _params.iops,
      'name': _params.name,
      'profile': _params.profile,
      'replication_cron_spec': _params.replicationCronSpec,
      'size': _params.size,
      'user_tags': _params.userTags,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateShare'
    );

    const parameters = {
      options: {
        url: '/shares/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Failover to replica file share.
   *
   * This request triggers a failover to the replica file share specified by the identifier in the URL. The failover
   * cannot be started if a source share or the replica share has a `lifecycle_state` of `updating`, or has a
   * replication operation in progress.
   *
   * If `fallback_policy` is specified as `split`, and the request is accepted but the failover operation cannot be
   * performed, a split will be triggered.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} [params.fallbackPolicy] - The action to take if the failover request is accepted but cannot be
   * performed or times out:
   * - `fail`: Fail the operation, resulting in the replication relationship being unchanged.
   * - `split`: Split the replica from its source, resulting in two individual read-write
   *     file shares. Because the final sync was not completed, the replica may be
   *     out-of-date. This is useful in disaster recovery scenarios where the source is known
   *     to be unreachable.
   * @param {number} [params.timeout] - The failover timeout in seconds.
   *
   * If the timeout is reached, the `fallback_policy` will be triggered.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public failoverShare(
    params: VpcV1.FailoverShareParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['shareId'];
    const _validParams = ['shareId', 'fallbackPolicy', 'timeout', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'fallback_policy': _params.fallbackPolicy,
      'timeout': _params.timeout,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'failoverShare'
    );

    const parameters = {
      options: {
        url: '/shares/{share_id}/failover',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all mount targets for a file share.
   *
   * This request retrieves all share mount targets for a file share. A share mount target is a network endpoint at
   * which a file share may be mounted. The file share can be mounted by clients in the same VPC and zone after creating
   * share mount targets.
   *
   * The share mount targets will be sorted by their `created_at` property values, with newest targets first.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareMountTargetCollection>>}
   */
  public listShareMountTargets(
    params: VpcV1.ListShareMountTargetsParams
  ): Promise<VpcV1.Response<VpcV1.ShareMountTargetCollection>> {
    const _params = { ...params };
    const _requiredParams = ['shareId'];
    const _validParams = ['shareId', 'name', 'start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'name': _params.name,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listShareMountTargets'
    );

    const parameters = {
      options: {
        url: '/shares/{share_id}/mount_targets',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a mount target for a file share.
   *
   * This request creates a new share mount target from a share mount target prototype object.
   *
   * The prototype object is structured in the same way as a retrieved share mount target, and contains the information
   * necessary to provision the new file share mount target.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {ShareMountTargetPrototype} params.shareMountTargetPrototype - The share mount target prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareMountTarget>>}
   */
  public createShareMountTarget(
    params: VpcV1.CreateShareMountTargetParams
  ): Promise<VpcV1.Response<VpcV1.ShareMountTarget>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'shareMountTargetPrototype'];
    const _validParams = ['shareId', 'shareMountTargetPrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.shareMountTargetPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createShareMountTarget'
    );

    const parameters = {
      options: {
        url: '/shares/{share_id}/mount_targets',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a share mount target.
   *
   * This request deletes a share mount target. This operation cannot be reversed.
   *
   * If the request is accepted, the share mount target `lifecycle_state` will be set to
   * `deleting`. Once deletion processing completes, it will no longer be retrievable.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} params.id - The share mount target identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareMountTarget>>}
   */
  public deleteShareMountTarget(
    params: VpcV1.DeleteShareMountTargetParams
  ): Promise<VpcV1.Response<VpcV1.ShareMountTarget>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'id'];
    const _validParams = ['shareId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteShareMountTarget'
    );

    const parameters = {
      options: {
        url: '/shares/{share_id}/mount_targets/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a share mount target.
   *
   * This request retrieves a single share mount target specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} params.id - The share mount target identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareMountTarget>>}
   */
  public getShareMountTarget(
    params: VpcV1.GetShareMountTargetParams
  ): Promise<VpcV1.Response<VpcV1.ShareMountTarget>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'id'];
    const _validParams = ['shareId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getShareMountTarget'
    );

    const parameters = {
      options: {
        url: '/shares/{share_id}/mount_targets/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a share mount target.
   *
   * This request updates a share mount target with the information provided in a share mount target patch object. The
   * share mount target patch object is structured in the same way as a retrieved share mount target and needs to
   * contain only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} params.id - The share mount target identifier.
   * @param {string} [params.name] - The name for this share mount target. The name must not be used by another mount
   * target for the file share.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareMountTarget>>}
   */
  public updateShareMountTarget(
    params: VpcV1.UpdateShareMountTargetParams
  ): Promise<VpcV1.Response<VpcV1.ShareMountTarget>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'id'];
    const _validParams = ['shareId', 'id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateShareMountTarget'
    );

    const parameters = {
      options: {
        url: '/shares/{share_id}/mount_targets/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Split the source file share from a replica share.
   *
   * This request removes the replication relationship between a source share and the replica share specified by the
   * identifier in the URL. The replication relationship cannot be removed if a source share or the replica share has a
   * `lifecycle_state` of `updating`, or has a replication operation in progress.
   *
   * This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteShareSource(
    params: VpcV1.DeleteShareSourceParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['shareId'];
    const _validParams = ['shareId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteShareSource'
    );

    const parameters = {
      options: {
        url: '/shares/{share_id}/source',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve the source file share for a replica file share.
   *
   * This request retrieves the source file share associated with the replica file share specified by the identifier in
   * the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Share>>}
   */
  public getShareSource(
    params: VpcV1.GetShareSourceParams
  ): Promise<VpcV1.Response<VpcV1.Share>> {
    const _params = { ...params };
    const _requiredParams = ['shareId'];
    const _validParams = ['shareId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getShareSource'
    );

    const parameters = {
      options: {
        url: '/shares/{share_id}/source',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * geography
   ************************/

  /**
   * List all regions.
   *
   * This request lists all regions. Each region is a separate geographic area that contains multiple isolated zones.
   * Resources can be provisioned into one or more zones in a region. Each zone is isolated, but connected to other
   * zones in the same region with low-latency and high-bandwidth links. Regions represent the top-level of fault
   * isolation available. Resources deployed within a single region also benefit from the low latency afforded by
   * geographic proximity.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RegionCollection>>}
   */
  public listRegions(
    params?: VpcV1.ListRegionsParams
  ): Promise<VpcV1.Response<VpcV1.RegionCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listRegions'
    );

    const parameters = {
      options: {
        url: '/regions',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a region.
   *
   * This request retrieves a single region specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The region name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Region>>}
   */
  public getRegion(
    params: VpcV1.GetRegionParams
  ): Promise<VpcV1.Response<VpcV1.Region>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getRegion'
    );

    const parameters = {
      options: {
        url: '/regions/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all zones in a region.
   *
   * This request lists all zones in a region. Zones represent logically-isolated data centers with high-bandwidth and
   * low-latency interconnects to other zones in the same region. Faults in a zone do not affect other zones.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.regionName - The region name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ZoneCollection>>}
   */
  public listRegionZones(
    params: VpcV1.ListRegionZonesParams
  ): Promise<VpcV1.Response<VpcV1.ZoneCollection>> {
    const _params = { ...params };
    const _requiredParams = ['regionName'];
    const _validParams = ['regionName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'region_name': _params.regionName,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listRegionZones'
    );

    const parameters = {
      options: {
        url: '/regions/{region_name}/zones',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a zone.
   *
   * This request retrieves a single zone specified by the region and zone names in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.regionName - The region name.
   * @param {string} params.name - The zone name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Zone>>}
   */
  public getRegionZone(
    params: VpcV1.GetRegionZoneParams
  ): Promise<VpcV1.Response<VpcV1.Zone>> {
    const _params = { ...params };
    const _requiredParams = ['regionName', 'name'];
    const _validParams = ['regionName', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'region_name': _params.regionName,
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getRegionZone'
    );

    const parameters = {
      options: {
        url: '/regions/{region_name}/zones/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * virtualNetworkInterfaces
   ************************/

  /**
   * List all virtual network interfaces.
   *
   * This request lists all virtual network interfaces in the region. A virtual network interface is a logical
   * abstraction of a virtual network interface in a subnet, and may be attached to a target resource.
   *
   * The virtual network interfaces will be sorted by their `created_at` property values, with newest virtual network
   * interfaces first. Virtual network interfaces with identical
   * `created_at` property values will in turn be sorted by ascending `name` property values.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VirtualNetworkInterfaceCollection>>}
   */
  public listVirtualNetworkInterfaces(
    params?: VpcV1.ListVirtualNetworkInterfacesParams
  ): Promise<VpcV1.Response<VpcV1.VirtualNetworkInterfaceCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVirtualNetworkInterfaces'
    );

    const parameters = {
      options: {
        url: '/virtual_network_interfaces',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a virtual network interface.
   *
   * This request retrieves a single virtual network interface specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The virtual network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>>}
   */
  public getVirtualNetworkInterface(
    params: VpcV1.GetVirtualNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVirtualNetworkInterface'
    );

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a virtual network interface.
   *
   * This request updates a virtual network interface with the information in a provided virtual network interface
   * patch. The virtual network interface patch object is structured in the same way as a retrieved virtual network
   * interface and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The virtual network interface identifier.
   * @param {string} [params.name] - The name for this virtual network interface. The name is unique across all virtual
   * network interfaces in the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>>}
   */
  public updateVirtualNetworkInterface(
    params: VpcV1.UpdateVirtualNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVirtualNetworkInterface'
    );

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * publicGateways
   ************************/

  /**
   * List all public gateways.
   *
   * This request lists all public gateways in the region. A public gateway is a virtual network device associated with
   * a VPC, which allows access to the Internet. A public gateway resides in a zone and can be connected to subnets in
   * the same zone only.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGatewayCollection>>}
   */
  public listPublicGateways(
    params?: VpcV1.ListPublicGatewaysParams
  ): Promise<VpcV1.Response<VpcV1.PublicGatewayCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listPublicGateways'
    );

    const parameters = {
      options: {
        url: '/public_gateways',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a public gateway.
   *
   * This request creates a new public gateway from a public gateway prototype object. For this to succeed, the VPC must
   * not already have a public gateway in the specified zone.
   *
   * If a floating IP is provided, it must be unbound. If a floating IP is not provided, one will be created and bound
   * to the public gateway. Once a public gateway has been created, its floating IP cannot be unbound. A public gateway
   * must be explicitly attached to each subnet it will provide connectivity for.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {VPCIdentity} params.vpc - The VPC this public gateway will reside in.
   * @param {ZoneIdentity} params.zone - The zone this public gateway will reside in.
   * @param {PublicGatewayFloatingIPPrototype} [params.floatingIp] -
   * @param {string} [params.name] - The name for this public gateway. The name must not be used by another public
   * gateway in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGateway>>}
   */
  public createPublicGateway(
    params: VpcV1.CreatePublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PublicGateway>> {
    const _params = { ...params };
    const _requiredParams = ['vpc', 'zone'];
    const _validParams = ['vpc', 'zone', 'floatingIp', 'name', 'resourceGroup', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'vpc': _params.vpc,
      'zone': _params.zone,
      'floating_ip': _params.floatingIp,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createPublicGateway'
    );

    const parameters = {
      options: {
        url: '/public_gateways',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a public gateway.
   *
   * This request deletes a public gateway. This operation cannot be reversed. For this request to succeed, the public
   * gateway must not be attached to any subnets. The public gateway's floating IP will be automatically unbound. If the
   * floating IP was created when the public gateway was created, it will be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The public gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deletePublicGateway(
    params: VpcV1.DeletePublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deletePublicGateway'
    );

    const parameters = {
      options: {
        url: '/public_gateways/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a public gateway.
   *
   * This request retrieves a single public gateway specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The public gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGateway>>}
   */
  public getPublicGateway(
    params: VpcV1.GetPublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PublicGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getPublicGateway'
    );

    const parameters = {
      options: {
        url: '/public_gateways/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a public gateway.
   *
   * This request updates a public gateway's name.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The public gateway identifier.
   * @param {string} [params.name] - The name for this public gateway. The name must not be used by another public
   * gateway in the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGateway>>}
   */
  public updatePublicGateway(
    params: VpcV1.UpdatePublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PublicGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updatePublicGateway'
    );

    const parameters = {
      options: {
        url: '/public_gateways/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * floatingIPs
   ************************/

  /**
   * List all floating IPs.
   *
   * This request lists all floating IPs in the region. Floating IPs allow inbound and outbound traffic from the
   * Internet to an instance.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIPCollection>>}
   */
  public listFloatingIps(
    params?: VpcV1.ListFloatingIpsParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIPCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'sort', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'sort': _params.sort,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listFloatingIps'
    );

    const parameters = {
      options: {
        url: '/floating_ips',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Reserve a floating IP.
   *
   * This request reserves a new floating IP.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {FloatingIPPrototype} params.floatingIpPrototype - The floating IP prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public createFloatingIp(
    params: VpcV1.CreateFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['floatingIpPrototype'];
    const _validParams = ['floatingIpPrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.floatingIpPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createFloatingIp'
    );

    const parameters = {
      options: {
        url: '/floating_ips',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a floating IP.
   *
   * This request disassociates (if associated) and releases a floating IP. This operation cannot be reversed. For this
   * request to succeed, the floating IP must not be required by another resource, such as a public gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteFloatingIp(
    params: VpcV1.DeleteFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteFloatingIp'
    );

    const parameters = {
      options: {
        url: '/floating_ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a floating IP.
   *
   * This request retrieves a single floating IP specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public getFloatingIp(
    params: VpcV1.GetFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getFloatingIp'
    );

    const parameters = {
      options: {
        url: '/floating_ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a floating IP.
   *
   * This request updates a floating IP's name and/or target.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The floating IP identifier.
   * @param {string} [params.name] - The name for this floating IP. The name must not be used by another floating IP in
   * the region.
   * @param {FloatingIPTargetPatch} [params.target] - The target resource to bind this floating IP to, replacing any
   * existing binding.
   * The floating IP must not be required by another resource, such as a public gateway.
   *
   * The target resource must not already have a floating IP bound to it if the target
   * resource is:
   *
   * - an instance network interface
   * - a bare metal server network interface with `enable_infrastructure_nat` set to `true`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public updateFloatingIp(
    params: VpcV1.UpdateFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'target', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'target': _params.target,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateFloatingIp'
    );

    const parameters = {
      options: {
        url: '/floating_ips/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * networkACLs
   ************************/

  /**
   * List all network ACLs.
   *
   * This request lists all network ACLs in the region. A network ACL defines a set of packet filtering (5-tuple) rules
   * for all traffic in and out of a subnet. Both allow and deny rules can be defined, and rules are stateless such that
   * reverse traffic in response to allowed traffic is not automatically permitted.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACLCollection>>}
   */
  public listNetworkAcls(
    params?: VpcV1.ListNetworkAclsParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACLCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listNetworkAcls'
    );

    const parameters = {
      options: {
        url: '/network_acls',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a network ACL.
   *
   * This request creates a new stateless network ACL from a network ACL prototype object. The prototype object is
   * structured in the same way as a retrieved network ACL, and contains the information necessary to create the new
   * network ACL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {NetworkACLPrototype} params.networkAclPrototype - The network ACL prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACL>>}
   */
  public createNetworkAcl(
    params: VpcV1.CreateNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclPrototype'];
    const _validParams = ['networkAclPrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.networkAclPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createNetworkAcl'
    );

    const parameters = {
      options: {
        url: '/network_acls',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a network ACL.
   *
   * This request deletes a network ACL. This operation cannot be reversed. For this request to succeed, the network ACL
   * must not be the default network ACL for any VPCs, and the network ACL must not be attached to any subnets.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The network ACL identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteNetworkAcl(
    params: VpcV1.DeleteNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteNetworkAcl'
    );

    const parameters = {
      options: {
        url: '/network_acls/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a network ACL.
   *
   * This request retrieves a single network ACL specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The network ACL identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACL>>}
   */
  public getNetworkAcl(
    params: VpcV1.GetNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getNetworkAcl'
    );

    const parameters = {
      options: {
        url: '/network_acls/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a network ACL.
   *
   * This request updates a network ACL's name.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The network ACL identifier.
   * @param {string} [params.name] - The name for this network ACL. The name must not be used by another network ACL for
   * the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACL>>}
   */
  public updateNetworkAcl(
    params: VpcV1.UpdateNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateNetworkAcl'
    );

    const parameters = {
      options: {
        url: '/network_acls/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all rules for a network ACL.
   *
   * This request lists all rules for a network ACL. These rules can allow or deny traffic between a source CIDR block
   * and a destination CIDR block over a particular protocol and port range.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.networkAclId - The network ACL identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.direction] - Filters the collection to rules with a `direction` property matching the
   * specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACLRuleCollection>>}
   */
  public listNetworkAclRules(
    params: VpcV1.ListNetworkAclRulesParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACLRuleCollection>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclId'];
    const _validParams = ['networkAclId', 'start', 'limit', 'direction', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'direction': _params.direction,
    };

    const path = {
      'network_acl_id': _params.networkAclId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listNetworkAclRules'
    );

    const parameters = {
      options: {
        url: '/network_acls/{network_acl_id}/rules',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a rule for a network ACL.
   *
   * This request creates a new rule from a network ACL rule prototype object. The prototype object is structured in the
   * same way as a retrieved rule, and contains the information necessary to create the new rule.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.networkAclId - The network ACL identifier.
   * @param {NetworkACLRulePrototype} params.networkAclRulePrototype - The network ACL rule prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACLRule>>}
   */
  public createNetworkAclRule(
    params: VpcV1.CreateNetworkAclRuleParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACLRule>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclId', 'networkAclRulePrototype'];
    const _validParams = ['networkAclId', 'networkAclRulePrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.networkAclRulePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'network_acl_id': _params.networkAclId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createNetworkAclRule'
    );

    const parameters = {
      options: {
        url: '/network_acls/{network_acl_id}/rules',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a network ACL rule.
   *
   * This request deletes a rule. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.networkAclId - The network ACL identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteNetworkAclRule(
    params: VpcV1.DeleteNetworkAclRuleParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclId', 'id'];
    const _validParams = ['networkAclId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'network_acl_id': _params.networkAclId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteNetworkAclRule'
    );

    const parameters = {
      options: {
        url: '/network_acls/{network_acl_id}/rules/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a network ACL rule.
   *
   * This request retrieves a single rule specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.networkAclId - The network ACL identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACLRule>>}
   */
  public getNetworkAclRule(
    params: VpcV1.GetNetworkAclRuleParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACLRule>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclId', 'id'];
    const _validParams = ['networkAclId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'network_acl_id': _params.networkAclId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getNetworkAclRule'
    );

    const parameters = {
      options: {
        url: '/network_acls/{network_acl_id}/rules/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a network ACL rule.
   *
   * This request updates a rule with the information in a provided rule patch. The rule patch object contains only the
   * information to be updated. The request will fail if the information is not applicable to the rule's protocol.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.networkAclId - The network ACL identifier.
   * @param {string} params.id - The rule identifier.
   * @param {string} [params.action] - The action to perform for a packet matching the rule.
   * @param {NetworkACLRuleBeforePatch} [params.before] - The rule to move this rule immediately before.
   *
   * Specify `null` to move this rule after all existing rules.
   * @param {number} [params.code] - The ICMP traffic code to match. If set, `type` must also be set.
   *
   * Specify `null` to remove an existing ICMP traffic code.
   * @param {string} [params.destination] - The destination IP address or CIDR block to match. The CIDR block
   * `0.0.0.0/0` matches all destination addresses.
   * @param {number} [params.destinationPortMax] - The inclusive upper bound of TCP/UDP destination port range.
   * @param {number} [params.destinationPortMin] - The inclusive lower bound of TCP/UDP destination port range.
   * @param {string} [params.direction] - The direction of traffic to match.
   * @param {string} [params.name] - The name for this network ACL rule. The name must not be used by another rule for
   * the network ACL.
   * @param {string} [params.protocol] - The protocol to enforce.
   * @param {string} [params.source] - The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches
   * all source addresses.
   * @param {number} [params.sourcePortMax] - The inclusive upper bound of TCP/UDP source port range.
   * @param {number} [params.sourcePortMin] - The inclusive lower bound of TCP/UDP source port range.
   * @param {number} [params.type] - The ICMP traffic type to match.
   *
   * Specify `null` to remove an existing ICMP traffic type value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACLRule>>}
   */
  public updateNetworkAclRule(
    params: VpcV1.UpdateNetworkAclRuleParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACLRule>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclId', 'id'];
    const _validParams = ['networkAclId', 'id', 'action', 'before', 'code', 'destination', 'destinationPortMax', 'destinationPortMin', 'direction', 'name', 'protocol', 'source', 'sourcePortMax', 'sourcePortMin', 'type', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'action': _params.action,
      'before': _params.before,
      'code': _params.code,
      'destination': _params.destination,
      'destination_port_max': _params.destinationPortMax,
      'destination_port_min': _params.destinationPortMin,
      'direction': _params.direction,
      'name': _params.name,
      'protocol': _params.protocol,
      'source': _params.source,
      'source_port_max': _params.sourcePortMax,
      'source_port_min': _params.sourcePortMin,
      'type': _params.type,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'network_acl_id': _params.networkAclId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateNetworkAclRule'
    );

    const parameters = {
      options: {
        url: '/network_acls/{network_acl_id}/rules/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * securityGroups
   ************************/

  /**
   * List all security groups.
   *
   * This request lists all security groups in the region. Security groups provide a way to apply IP filtering rules to
   * instances in the associated VPC. With security groups, all traffic is denied by default, and rules added to
   * security groups define which traffic the security group permits. Security group rules are stateful such that
   * reverse traffic in response to allowed traffic is automatically permitted.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.vpcId] - Filters the collection to resources with a `vpc.id` property matching the
   * specified identifier.
   * @param {string} [params.vpcCrn] - Filters the collection to resources with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to resources with a `vpc.name` property matching the
   * exact specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupCollection>>}
   */
  public listSecurityGroups(
    params?: VpcV1.ListSecurityGroupsParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'vpcId', 'vpcCrn', 'vpcName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'vpc.id': _params.vpcId,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listSecurityGroups'
    );

    const parameters = {
      options: {
        url: '/security_groups',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a security group.
   *
   * This request creates a new security group from a security group prototype object. The prototype object is
   * structured in the same way as a retrieved security group, and contains the information necessary to create the new
   * security group. If security group rules are included in the prototype object, those rules will be added to the
   * security group. Each security group is scoped to one VPC. Only resources in that VPC can be added to the security
   * group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {VPCIdentity} params.vpc - The VPC this security group will reside in.
   * @param {string} [params.name] - The name for this security group. The name must not be used by another security
   * group for the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {SecurityGroupRulePrototype[]} [params.rules] - The prototype objects for rules to be created for this
   * security group. If unspecified, no rules will be created, resulting in all traffic being denied.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroup>>}
   */
  public createSecurityGroup(
    params: VpcV1.CreateSecurityGroupParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroup>> {
    const _params = { ...params };
    const _requiredParams = ['vpc'];
    const _validParams = ['vpc', 'name', 'resourceGroup', 'rules', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'vpc': _params.vpc,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
      'rules': _params.rules,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createSecurityGroup'
    );

    const parameters = {
      options: {
        url: '/security_groups',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a security group.
   *
   * This request deletes a security group. A security group cannot be deleted if it is referenced by any security group
   * targets or rules. Additionally, a VPC's default security group cannot be deleted. This operation cannot be
   * reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The security group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSecurityGroup(
    params: VpcV1.DeleteSecurityGroupParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSecurityGroup'
    );

    const parameters = {
      options: {
        url: '/security_groups/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a security group.
   *
   * This request retrieves a single security group specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The security group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroup>>}
   */
  public getSecurityGroup(
    params: VpcV1.GetSecurityGroupParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSecurityGroup'
    );

    const parameters = {
      options: {
        url: '/security_groups/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a security group.
   *
   * This request updates a security group with the information provided in a security group patch object. The security
   * group patch object is structured in the same way as a retrieved security group and contains only the information to
   * be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The security group identifier.
   * @param {string} [params.name] - The name for this security group. The name must not be used by another security
   * group for the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroup>>}
   */
  public updateSecurityGroup(
    params: VpcV1.UpdateSecurityGroupParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateSecurityGroup'
    );

    const parameters = {
      options: {
        url: '/security_groups/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all rules in a security group.
   *
   * This request lists all rules in a security group. These rules define what traffic the security group permits.
   * Security group rules are stateful, such that reverse traffic in response to allowed traffic is automatically
   * permitted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupRuleCollection>>}
   */
  public listSecurityGroupRules(
    params: VpcV1.ListSecurityGroupRulesParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupRuleCollection>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId'];
    const _validParams = ['securityGroupId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listSecurityGroupRules'
    );

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/rules',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a rule for a security group.
   *
   * This request creates a new security group rule from a security group rule prototype object. The prototype object is
   * structured in the same way as a retrieved security group rule and contains the information necessary to create the
   * rule. As part of creating a new rule in a security group, the rule is applied to all the networking interfaces in
   * the security group. Rules specify which IP traffic a security group will allow. Security group rules are stateful,
   * such that reverse traffic in response to allowed traffic is automatically permitted. A rule allowing inbound TCP
   * traffic on port 80 also allows outbound TCP traffic on port 80 without the need for an additional rule.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {SecurityGroupRulePrototype} params.securityGroupRulePrototype - The properties of the security group rule
   * to be created.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupRule>>}
   */
  public createSecurityGroupRule(
    params: VpcV1.CreateSecurityGroupRuleParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupRule>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'securityGroupRulePrototype'];
    const _validParams = ['securityGroupId', 'securityGroupRulePrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.securityGroupRulePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createSecurityGroupRule'
    );

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/rules',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a security group rule.
   *
   * This request deletes a security group rule. This operation cannot be reversed. Removing a security group rule will
   * not end existing connections allowed by that rule.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSecurityGroupRule(
    params: VpcV1.DeleteSecurityGroupRuleParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSecurityGroupRule'
    );

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/rules/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a security group rule.
   *
   * This request retrieves a single security group rule specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupRule>>}
   */
  public getSecurityGroupRule(
    params: VpcV1.GetSecurityGroupRuleParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupRule>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSecurityGroupRule'
    );

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/rules/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a security group rule.
   *
   * This request updates a security group rule with the information in a provided rule patch object. The rule patch
   * object contains only the information to be updated. The request will fail if the information is not applicable to
   * the rule's protocol.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The rule identifier.
   * @param {number} [params.code] - The ICMP traffic code to allow. If set, `type` must also be set.
   *
   * Specify `null` to remove an existing ICMP traffic code.
   * @param {string} [params.direction] - The direction of traffic to enforce.
   * @param {string} [params.ipVersion] - The IP version to enforce. The format of `remote.address` or
   * `remote.cidr_block` must match this property, if they are used. Alternatively, if `remote` references a security
   * group, then this rule only applies to IP addresses (network interfaces) in that group matching this IP version.
   * @param {number} [params.portMax] - The inclusive upper bound of the protocol destination port range. If set,
   * `port_min` must also be set, and must not be larger.
   *
   * Specify `null` to remove an existing upper bound.
   * @param {number} [params.portMin] - The inclusive lower bound of the protocol destination port range. If set,
   * `port_max` must also be set, and must not be smaller.
   *
   * Specify `null` to remove an existing lower bound.
   * @param {SecurityGroupRuleRemotePatch} [params.remote] - The remote IP addresses or security groups from which this
   * rule will allow traffic (or to
   * which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
   * security group. A CIDR block of `0.0.0.0/0` will allow traffic from any source (or to
   * any destination, for outbound rules).
   * @param {number} [params.type] - The ICMP traffic type to allow.
   *
   * Specify `null` to remove an existing ICMP traffic type value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupRule>>}
   */
  public updateSecurityGroupRule(
    params: VpcV1.UpdateSecurityGroupRuleParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupRule>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'code', 'direction', 'ipVersion', 'portMax', 'portMin', 'remote', 'type', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'code': _params.code,
      'direction': _params.direction,
      'ip_version': _params.ipVersion,
      'port_max': _params.portMax,
      'port_min': _params.portMin,
      'remote': _params.remote,
      'type': _params.type,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateSecurityGroupRule'
    );

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/rules/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all targets associated with a security group.
   *
   * This request lists all targets associated with a security group, to which the rules in the security group are
   * applied.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupTargetCollection>>}
   */
  public listSecurityGroupTargets(
    params: VpcV1.ListSecurityGroupTargetsParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupTargetCollection>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId'];
    const _validParams = ['securityGroupId', 'start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listSecurityGroupTargets'
    );

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/targets',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Remove a target from a security group.
   *
   * This request removes a target from a security group. For this request to succeed, the target must be attached to at
   * least one other security group.  The specified target identifier can be:
   *
   * - A bare metal server network interface identifier
   * - A virtual network interface identifier
   * - A VPN server identifier
   * - An application load balancer identifier
   * - An endpoint gateway identifier
   * - An instance network interface identifier
   *
   * Security groups are stateful, so any changes to a target's security groups are applied to new connections. Existing
   * connections are not affected.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The security group target identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSecurityGroupTargetBinding(
    params: VpcV1.DeleteSecurityGroupTargetBindingParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSecurityGroupTargetBinding'
    );

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/targets/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a security group target.
   *
   * This request retrieves a single target specified by the identifier in the URL path. The target must be an existing
   * target of the security group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The security group target identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupTargetReference>>}
   */
  public getSecurityGroupTarget(
    params: VpcV1.GetSecurityGroupTargetParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupTargetReference>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSecurityGroupTarget'
    );

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/targets/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Add a target to a security group.
   *
   * This request adds a resource to an existing security group. The specified target identifier can be:
   *
   * - A bare metal server network interface identifier
   * - A virtual network interface identifier
   * - A VPN server identifier
   * - An application load balancer identifier
   * - An endpoint gateway identifier
   * - An instance network interface identifier
   *
   * When a target is added to a security group, the security group rules are applied to the target. A request body is
   * not required, and if provided, is ignored.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The security group target identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupTargetReference>>}
   */
  public createSecurityGroupTargetBinding(
    params: VpcV1.CreateSecurityGroupTargetBindingParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupTargetReference>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createSecurityGroupTargetBinding'
    );

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/targets/{id}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * vPNGateways
   ************************/

  /**
   * List all IKE policies.
   *
   * This request lists all IKE policies in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IKEPolicyCollection>>}
   */
  public listIkePolicies(
    params?: VpcV1.ListIkePoliciesParams
  ): Promise<VpcV1.Response<VpcV1.IKEPolicyCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listIkePolicies'
    );

    const parameters = {
      options: {
        url: '/ike_policies',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an IKE policy.
   *
   * This request creates a new IKE policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.authenticationAlgorithm - The authentication algorithm.
   * @param {number} params.dhGroup - The Diffie-Hellman group.
   * @param {string} params.encryptionAlgorithm - The encryption algorithm.
   * @param {number} params.ikeVersion - The IKE protocol version.
   * @param {number} [params.keyLifetime] - The key lifetime in seconds.
   * @param {string} [params.name] - The name for this IKE policy. The name must not be used by another IKE policies in
   * the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IKEPolicy>>}
   */
  public createIkePolicy(
    params: VpcV1.CreateIkePolicyParams
  ): Promise<VpcV1.Response<VpcV1.IKEPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['authenticationAlgorithm', 'dhGroup', 'encryptionAlgorithm', 'ikeVersion'];
    const _validParams = ['authenticationAlgorithm', 'dhGroup', 'encryptionAlgorithm', 'ikeVersion', 'keyLifetime', 'name', 'resourceGroup', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'authentication_algorithm': _params.authenticationAlgorithm,
      'dh_group': _params.dhGroup,
      'encryption_algorithm': _params.encryptionAlgorithm,
      'ike_version': _params.ikeVersion,
      'key_lifetime': _params.keyLifetime,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createIkePolicy'
    );

    const parameters = {
      options: {
        url: '/ike_policies',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an IKE policy.
   *
   * This request deletes an IKE policy. This operation cannot be reversed. For this request to succeed, there must not
   * be any VPN gateway connections using this policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IKE policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteIkePolicy(
    params: VpcV1.DeleteIkePolicyParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteIkePolicy'
    );

    const parameters = {
      options: {
        url: '/ike_policies/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an IKE policy.
   *
   * This request retrieves a single IKE policy specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IKE policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IKEPolicy>>}
   */
  public getIkePolicy(
    params: VpcV1.GetIkePolicyParams
  ): Promise<VpcV1.Response<VpcV1.IKEPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getIkePolicy'
    );

    const parameters = {
      options: {
        url: '/ike_policies/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an IKE policy.
   *
   * This request updates the properties of an existing IKE policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IKE policy identifier.
   * @param {string} [params.authenticationAlgorithm] - The authentication algorithm.
   * @param {number} [params.dhGroup] - The Diffie-Hellman group.
   * @param {string} [params.encryptionAlgorithm] - The encryption algorithm.
   * @param {number} [params.ikeVersion] - The IKE protocol version.
   * @param {number} [params.keyLifetime] - The key lifetime in seconds.
   * @param {string} [params.name] - The name for this IKE policy. The name must not be used by another IKE policy in
   * the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IKEPolicy>>}
   */
  public updateIkePolicy(
    params: VpcV1.UpdateIkePolicyParams
  ): Promise<VpcV1.Response<VpcV1.IKEPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'authenticationAlgorithm', 'dhGroup', 'encryptionAlgorithm', 'ikeVersion', 'keyLifetime', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'authentication_algorithm': _params.authenticationAlgorithm,
      'dh_group': _params.dhGroup,
      'encryption_algorithm': _params.encryptionAlgorithm,
      'ike_version': _params.ikeVersion,
      'key_lifetime': _params.keyLifetime,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateIkePolicy'
    );

    const parameters = {
      options: {
        url: '/ike_policies/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all VPN gateway connections that use a specified IKE policy.
   *
   * This request lists all VPN gateway connections that use a policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IKE policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCollection>>}
   */
  public listIkePolicyConnections(
    params: VpcV1.ListIkePolicyConnectionsParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCollection>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listIkePolicyConnections'
    );

    const parameters = {
      options: {
        url: '/ike_policies/{id}/connections',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all IPsec policies.
   *
   * This request lists all IPsec policies in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IPsecPolicyCollection>>}
   */
  public listIpsecPolicies(
    params?: VpcV1.ListIpsecPoliciesParams
  ): Promise<VpcV1.Response<VpcV1.IPsecPolicyCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listIpsecPolicies'
    );

    const parameters = {
      options: {
        url: '/ipsec_policies',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an IPsec policy.
   *
   * This request creates a new IPsec policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.authenticationAlgorithm - The authentication algorithm
   *
   * Must be `disabled` if and only if the `encryption_algorithm` is
   * `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`.
   * @param {string} params.encryptionAlgorithm - The encryption algorithm
   *
   * The `authentication_algorithm` must be `disabled` if and only if
   * `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or
   * `aes256gcm16`.
   * @param {string} params.pfs - Perfect Forward Secrecy.
   * @param {number} [params.keyLifetime] - The key lifetime in seconds.
   * @param {string} [params.name] - The name for this IPsec policy. The name must not be used by another IPsec policies
   * in the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IPsecPolicy>>}
   */
  public createIpsecPolicy(
    params: VpcV1.CreateIpsecPolicyParams
  ): Promise<VpcV1.Response<VpcV1.IPsecPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['authenticationAlgorithm', 'encryptionAlgorithm', 'pfs'];
    const _validParams = ['authenticationAlgorithm', 'encryptionAlgorithm', 'pfs', 'keyLifetime', 'name', 'resourceGroup', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'authentication_algorithm': _params.authenticationAlgorithm,
      'encryption_algorithm': _params.encryptionAlgorithm,
      'pfs': _params.pfs,
      'key_lifetime': _params.keyLifetime,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createIpsecPolicy'
    );

    const parameters = {
      options: {
        url: '/ipsec_policies',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an IPsec policy.
   *
   * This request deletes an IPsec policy. This operation cannot be reversed. For this request to succeed, there must
   * not be any VPN gateway connections using this policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IPsec policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteIpsecPolicy(
    params: VpcV1.DeleteIpsecPolicyParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteIpsecPolicy'
    );

    const parameters = {
      options: {
        url: '/ipsec_policies/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an IPsec policy.
   *
   * This request retrieves a single IPsec policy specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IPsec policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IPsecPolicy>>}
   */
  public getIpsecPolicy(
    params: VpcV1.GetIpsecPolicyParams
  ): Promise<VpcV1.Response<VpcV1.IPsecPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getIpsecPolicy'
    );

    const parameters = {
      options: {
        url: '/ipsec_policies/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an IPsec policy.
   *
   * This request updates the properties of an existing IPsec policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IPsec policy identifier.
   * @param {string} [params.authenticationAlgorithm] - The authentication algorithm
   *
   * Must be `disabled` if and only if the `encryption_algorithm` is
   * `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`.
   * @param {string} [params.encryptionAlgorithm] - The encryption algorithm
   *
   * The `authentication_algorithm` must be `disabled` if and only if
   * `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or
   * `aes256gcm16`.
   * @param {number} [params.keyLifetime] - The key lifetime in seconds.
   * @param {string} [params.name] - The name for this IPsec policy. The name must not be used by another IPsec policy
   * in the region.
   * @param {string} [params.pfs] - Perfect Forward Secrecy.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IPsecPolicy>>}
   */
  public updateIpsecPolicy(
    params: VpcV1.UpdateIpsecPolicyParams
  ): Promise<VpcV1.Response<VpcV1.IPsecPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'authenticationAlgorithm', 'encryptionAlgorithm', 'keyLifetime', 'name', 'pfs', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'authentication_algorithm': _params.authenticationAlgorithm,
      'encryption_algorithm': _params.encryptionAlgorithm,
      'key_lifetime': _params.keyLifetime,
      'name': _params.name,
      'pfs': _params.pfs,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateIpsecPolicy'
    );

    const parameters = {
      options: {
        url: '/ipsec_policies/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all VPN gateway connections that use a specified IPsec policy.
   *
   * This request lists all VPN gateway connections that use a policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IPsec policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCollection>>}
   */
  public listIpsecPolicyConnections(
    params: VpcV1.ListIpsecPolicyConnectionsParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCollection>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listIpsecPolicyConnections'
    );

    const parameters = {
      options: {
        url: '/ipsec_policies/{id}/connections',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all VPN gateways.
   *
   * This request lists all VPN gateways in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.mode] - Filters the collection to VPN gateways with a `mode` property matching the
   * specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayCollection>>}
   */
  public listVpnGateways(
    params?: VpcV1.ListVpnGatewaysParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'sort', 'mode', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'sort': _params.sort,
      'mode': _params.mode,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpnGateways'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a VPN gateway.
   *
   * This request creates a new VPN gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {VPNGatewayPrototype} params.vpnGatewayPrototype - The VPN gateway prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGateway>>}
   */
  public createVpnGateway(
    params: VpcV1.CreateVpnGatewayParams
  ): Promise<VpcV1.Response<VpcV1.VPNGateway>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayPrototype'];
    const _validParams = ['vpnGatewayPrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.vpnGatewayPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createVpnGateway'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPN gateway.
   *
   * This request deletes a VPN gateway. This operation cannot be reversed. For this request to succeed, the VPN gateway
   * must not have a `status` of `pending`, and there must not be any VPC routes using the VPN gateway's connections as
   * a next hop.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpnGateway(
    params: VpcV1.DeleteVpnGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteVpnGateway'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPN gateway.
   *
   * This request retrieves a single VPN gateway specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGateway>>}
   */
  public getVpnGateway(
    params: VpcV1.GetVpnGatewayParams
  ): Promise<VpcV1.Response<VpcV1.VPNGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpnGateway'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPN gateway.
   *
   * This request updates the properties of an existing VPN gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN gateway identifier.
   * @param {string} [params.name] - The name for this VPN gateway. The name must not be used by another VPN gateway in
   * the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGateway>>}
   */
  public updateVpnGateway(
    params: VpcV1.UpdateVpnGatewayParams
  ): Promise<VpcV1.Response<VpcV1.VPNGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVpnGateway'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all connections of a VPN gateway.
   *
   * This request lists all connections of a VPN gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} [params.status] - Filters the collection to VPN gateway connections with a `status` property
   * matching the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCollection>>}
   */
  public listVpnGatewayConnections(
    params: VpcV1.ListVpnGatewayConnectionsParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId'];
    const _validParams = ['vpnGatewayId', 'status', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'status': _params.status,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpnGatewayConnections'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a connection for a VPN gateway.
   *
   * This request creates a new VPN gateway connection.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {VPNGatewayConnectionPrototype} params.vpnGatewayConnectionPrototype - The VPN gateway connection prototype
   * object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>>}
   */
  public createVpnGatewayConnection(
    params: VpcV1.CreateVpnGatewayConnectionParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'vpnGatewayConnectionPrototype'];
    const _validParams = ['vpnGatewayId', 'vpnGatewayConnectionPrototype', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.vpnGatewayConnectionPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createVpnGatewayConnection'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPN gateway connection.
   *
   * This request deletes a VPN gateway connection. This operation cannot be reversed. For this request to succeed,
   * there must not be VPC routes using this VPN connection as a next hop.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpnGatewayConnection(
    params: VpcV1.DeleteVpnGatewayConnectionParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id'];
    const _validParams = ['vpnGatewayId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteVpnGatewayConnection'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPN gateway connection.
   *
   * This request retrieves a single VPN gateway connection specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>>}
   */
  public getVpnGatewayConnection(
    params: VpcV1.GetVpnGatewayConnectionParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id'];
    const _validParams = ['vpnGatewayId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpnGatewayConnection'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPN gateway connection.
   *
   * This request updates the properties of an existing VPN gateway connection.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {VPNGatewayConnectionPatch} params.vpnGatewayConnectionPatch - The VPN gateway connection patch.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>>}
   */
  public updateVpnGatewayConnection(
    params: VpcV1.UpdateVpnGatewayConnectionParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'vpnGatewayConnectionPatch'];
    const _validParams = ['vpnGatewayId', 'id', 'vpnGatewayConnectionPatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.vpnGatewayConnectionPatch;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVpnGatewayConnection'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all local CIDRs for a VPN gateway connection.
   *
   * This request lists all local CIDRs for a VPN gateway connection.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionLocalCIDRs>>}
   */
  public listVpnGatewayConnectionLocalCidrs(
    params: VpcV1.ListVpnGatewayConnectionLocalCidrsParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionLocalCIDRs>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id'];
    const _validParams = ['vpnGatewayId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpnGatewayConnectionLocalCidrs'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/local_cidrs',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Remove a local CIDR from a VPN gateway connection.
   *
   * This request removes a CIDR from a VPN gateway connection.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidrPrefix - The address prefix part of the CIDR.
   * @param {string} params.prefixLength - The prefix length part of the CIDR.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeVpnGatewayConnectionLocalCidr(
    params: VpcV1.RemoveVpnGatewayConnectionLocalCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength'];
    const _validParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr_prefix': _params.cidrPrefix,
      'prefix_length': _params.prefixLength,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'removeVpnGatewayConnectionLocalCidr'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/local_cidrs/{cidr_prefix}/{prefix_length}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Check if the specified local CIDR exists on a VPN gateway connection.
   *
   * This request succeeds if a CIDR exists on the specified VPN gateway connection, and fails otherwise.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidrPrefix - The address prefix part of the CIDR.
   * @param {string} params.prefixLength - The prefix length part of the CIDR.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public checkVpnGatewayConnectionLocalCidr(
    params: VpcV1.CheckVpnGatewayConnectionLocalCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength'];
    const _validParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr_prefix': _params.cidrPrefix,
      'prefix_length': _params.prefixLength,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'checkVpnGatewayConnectionLocalCidr'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/local_cidrs/{cidr_prefix}/{prefix_length}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Set a local CIDR on a VPN gateway connection.
   *
   * This request adds the specified CIDR to the specified VPN gateway connection. This request succeeds if the
   * specified CIDR already exists. A request body is not required, and if provided, is ignored.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidrPrefix - The address prefix part of the CIDR.
   * @param {string} params.prefixLength - The prefix length part of the CIDR.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public addVpnGatewayConnectionLocalCidr(
    params: VpcV1.AddVpnGatewayConnectionLocalCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength'];
    const _validParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr_prefix': _params.cidrPrefix,
      'prefix_length': _params.prefixLength,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'addVpnGatewayConnectionLocalCidr'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/local_cidrs/{cidr_prefix}/{prefix_length}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all peer CIDRs for a VPN gateway connection.
   *
   * This request lists all peer CIDRs for a VPN gateway connection.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionPeerCIDRs>>}
   */
  public listVpnGatewayConnectionPeerCidrs(
    params: VpcV1.ListVpnGatewayConnectionPeerCidrsParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionPeerCIDRs>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id'];
    const _validParams = ['vpnGatewayId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpnGatewayConnectionPeerCidrs'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer_cidrs',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Remove a peer CIDR from a VPN gateway connection.
   *
   * This request removes a CIDR from a VPN gateway connection.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidrPrefix - The address prefix part of the CIDR.
   * @param {string} params.prefixLength - The prefix length part of the CIDR.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeVpnGatewayConnectionPeerCidr(
    params: VpcV1.RemoveVpnGatewayConnectionPeerCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength'];
    const _validParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr_prefix': _params.cidrPrefix,
      'prefix_length': _params.prefixLength,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'removeVpnGatewayConnectionPeerCidr'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer_cidrs/{cidr_prefix}/{prefix_length}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Check if the specified peer CIDR exists on a VPN gateway connection.
   *
   * This request succeeds if a CIDR exists on the specified VPN gateway connection, and fails otherwise.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidrPrefix - The address prefix part of the CIDR.
   * @param {string} params.prefixLength - The prefix length part of the CIDR.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public checkVpnGatewayConnectionPeerCidr(
    params: VpcV1.CheckVpnGatewayConnectionPeerCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength'];
    const _validParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr_prefix': _params.cidrPrefix,
      'prefix_length': _params.prefixLength,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'checkVpnGatewayConnectionPeerCidr'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer_cidrs/{cidr_prefix}/{prefix_length}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Set a peer CIDR on a VPN gateway connection.
   *
   * This request adds the specified CIDR to the specified VPN gateway connection. This request succeeds if the
   * specified CIDR already exists. A request body is not required, and if provided, is ignored.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidrPrefix - The address prefix part of the CIDR.
   * @param {string} params.prefixLength - The prefix length part of the CIDR.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public addVpnGatewayConnectionPeerCidr(
    params: VpcV1.AddVpnGatewayConnectionPeerCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength'];
    const _validParams = ['vpnGatewayId', 'id', 'cidrPrefix', 'prefixLength', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr_prefix': _params.cidrPrefix,
      'prefix_length': _params.prefixLength,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'addVpnGatewayConnectionPeerCidr'
    );

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer_cidrs/{cidr_prefix}/{prefix_length}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * vPNServers
   ************************/

  /**
   * List all VPN servers.
   *
   * This request lists all VPN servers.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerCollection>>}
   */
  public listVpnServers(
    params?: VpcV1.ListVpnServersParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['name', 'start', 'limit', 'resourceGroupId', 'sort', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'name': _params.name,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'sort': _params.sort,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpnServers'
    );

    const parameters = {
      options: {
        url: '/vpn_servers',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a VPN server.
   *
   * This request creates a new VPN server.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {CertificateInstanceIdentity} params.certificate - The certificate instance for this VPN server.
   * @param {VPNServerAuthenticationPrototype[]} params.clientAuthentication - The methods used to authenticate VPN
   * clients to this VPN server. VPN clients must authenticate against all specified methods.
   * @param {string} params.clientIpPool - The VPN client IPv4 address pool, expressed in CIDR format. The request must
   * not overlap with any existing address prefixes in the VPC or any of the following reserved address ranges:
   *   - `127.0.0.0/8` (IPv4 loopback addresses)
   *   - `161.26.0.0/16` (IBM services)
   *   - `166.8.0.0/14` (Cloud Service Endpoints)
   *   - `169.254.0.0/16` (IPv4 link-local addresses)
   *   - `224.0.0.0/4` (IPv4 multicast addresses)
   *
   * The prefix length of the client IP address pool's CIDR must be between
   * `/9` (8,388,608 addresses) and `/22` (1024 addresses). A CIDR block that contains twice the number of IP addresses
   * that are required to enable the maximum number of concurrent connections is recommended.
   * @param {SubnetIdentity[]} params.subnets - The subnets to provision this VPN server in.  Use subnets in different
   * zones for high availability.
   * @param {IP[]} [params.clientDnsServerIps] - The DNS server addresses that will be provided to VPN clients connected
   * to this VPN server.
   * @param {number} [params.clientIdleTimeout] - The seconds a VPN client can be idle before this VPN server will
   * disconnect it.   Specify `0` to prevent the server from disconnecting idle clients.
   * @param {boolean} [params.enableSplitTunneling] - Indicates whether the split tunneling is enabled on this VPN
   * server.
   * @param {string} [params.name] - The name for this VPN server. The name must not be used by another VPN server in
   * the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {number} [params.port] - The port number to use for this VPN server.
   * @param {string} [params.protocol] - The transport protocol to use for this VPN server.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {SecurityGroupIdentity[]} [params.securityGroups] - The security groups to use for this VPN server. If
   * unspecified, the VPC's default security group is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServer>>}
   */
  public createVpnServer(
    params: VpcV1.CreateVpnServerParams
  ): Promise<VpcV1.Response<VpcV1.VPNServer>> {
    const _params = { ...params };
    const _requiredParams = ['certificate', 'clientAuthentication', 'clientIpPool', 'subnets'];
    const _validParams = ['certificate', 'clientAuthentication', 'clientIpPool', 'subnets', 'clientDnsServerIps', 'clientIdleTimeout', 'enableSplitTunneling', 'name', 'port', 'protocol', 'resourceGroup', 'securityGroups', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'certificate': _params.certificate,
      'client_authentication': _params.clientAuthentication,
      'client_ip_pool': _params.clientIpPool,
      'subnets': _params.subnets,
      'client_dns_server_ips': _params.clientDnsServerIps,
      'client_idle_timeout': _params.clientIdleTimeout,
      'enable_split_tunneling': _params.enableSplitTunneling,
      'name': _params.name,
      'port': _params.port,
      'protocol': _params.protocol,
      'resource_group': _params.resourceGroup,
      'security_groups': _params.securityGroups,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createVpnServer'
    );

    const parameters = {
      options: {
        url: '/vpn_servers',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPN server.
   *
   * This request deletes a VPN server. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN server identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpnServer(
    params: VpcV1.DeleteVpnServerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteVpnServer'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPN server.
   *
   * This request retrieves a single VPN server specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServer>>}
   */
  public getVpnServer(
    params: VpcV1.GetVpnServerParams
  ): Promise<VpcV1.Response<VpcV1.VPNServer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpnServer'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPN server.
   *
   * This request updates the properties of an existing VPN server. Any property changes will cause all connected VPN
   * clients are disconnected from this VPN server except for the name change.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN server identifier.
   * @param {CertificateInstanceIdentity} [params.certificate] - The certificate instance for this VPN server.
   * @param {VPNServerAuthenticationPrototype[]} [params.clientAuthentication] - The authentication methods to use to
   * authenticate VPN client on this VPN server
   * (replacing any existing methods).
   * @param {IP[]} [params.clientDnsServerIps] - The DNS server addresses that will be provided to VPN clients connected
   * to this VPN server (replacing any existing addresses).
   * @param {number} [params.clientIdleTimeout] - The seconds a VPN client can be idle before this VPN server will
   * disconnect it.  If `0`, the server will not disconnect idle clients.
   * @param {string} [params.clientIpPool] - The VPN client IPv4 address pool, expressed in CIDR format. The request
   * must not overlap with any existing address prefixes in the VPC or any of the following reserved address ranges:
   *   - `127.0.0.0/8` (IPv4 loopback addresses)
   *   - `161.26.0.0/16` (IBM services)
   *   - `166.8.0.0/14` (Cloud Service Endpoints)
   *   - `169.254.0.0/16` (IPv4 link-local addresses)
   *   - `224.0.0.0/4` (IPv4 multicast addresses)
   *
   * The prefix length of the client IP address pool's CIDR must be between
   * `/9` (8,388,608 addresses) and `/22` (1024 addresses). A CIDR block that contains twice the number of IP addresses
   * that are required to enable the maximum number of concurrent connections is recommended.
   * @param {boolean} [params.enableSplitTunneling] - Indicates whether the split tunneling is enabled on this VPN
   * server.
   * @param {string} [params.name] - The name for this VPN server. The name must not be used by another VPN server in
   * the VPC.
   * @param {number} [params.port] - The port number used by this VPN server.
   * @param {string} [params.protocol] - The transport protocol used by this VPN server.
   * @param {SubnetIdentity[]} [params.subnets] - The subnets to provision this VPN server in (replacing the existing
   * subnets).
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServer>>}
   */
  public updateVpnServer(
    params: VpcV1.UpdateVpnServerParams
  ): Promise<VpcV1.Response<VpcV1.VPNServer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'certificate', 'clientAuthentication', 'clientDnsServerIps', 'clientIdleTimeout', 'clientIpPool', 'enableSplitTunneling', 'name', 'port', 'protocol', 'subnets', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'certificate': _params.certificate,
      'client_authentication': _params.clientAuthentication,
      'client_dns_server_ips': _params.clientDnsServerIps,
      'client_idle_timeout': _params.clientIdleTimeout,
      'client_ip_pool': _params.clientIpPool,
      'enable_split_tunneling': _params.enableSplitTunneling,
      'name': _params.name,
      'port': _params.port,
      'protocol': _params.protocol,
      'subnets': _params.subnets,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVpnServer'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve client configuration.
   *
   * This request retrieves OpenVPN client configuration on a single VPN server specified by the identifier in the URL.
   * This configuration includes directives compatible with OpenVPN releases 2.4 and 2.5.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<string>>}
   */
  public getVpnServerClientConfiguration(
    params: VpcV1.GetVpnServerClientConfigurationParams
  ): Promise<VpcV1.Response<string>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpnServerClientConfiguration'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{id}/client_configuration',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'text/plain',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all VPN clients for a VPN server.
   *
   * This request retrieves all connected VPN clients, and any disconnected VPN clients that the VPN server has not yet
   * deleted based on its auto-deletion policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerClientCollection>>}
   */
  public listVpnServerClients(
    params: VpcV1.ListVpnServerClientsParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerClientCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId'];
    const _validParams = ['vpnServerId', 'start', 'limit', 'sort', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpnServerClients'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/clients',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPN client.
   *
   * This request disconnects and deletes the VPN client from the VPN server. The VPN client may reconnect unless its
   * authentication permissions for the configured authentication methods (such as its client certificate) have been
   * revoked.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN client identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpnServerClient(
    params: VpcV1.DeleteVpnServerClientParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteVpnServerClient'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/clients/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPN client.
   *
   * This request retrieves a single VPN client specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN client identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerClient>>}
   */
  public getVpnServerClient(
    params: VpcV1.GetVpnServerClientParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerClient>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpnServerClient'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/clients/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Disconnect a VPN client.
   *
   * This request disconnects the specified VPN client, and deletes the client according to the VPN server's
   * auto-deletion policy. The VPN client may reconnect unless its authentication permissions for the configured
   * authentication methods (such as its client certificate) have been revoked.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN client identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public disconnectVpnClient(
    params: VpcV1.DisconnectVpnClientParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'disconnectVpnClient'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/clients/{id}/disconnect',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all VPN routes for a VPN server.
   *
   * This request lists all VPN routes in a VPN server. All VPN routes are provided to the VPN client when the
   * connection is established.  Packets received from the VPN client will be dropped by the VPN server if there is no
   * VPN route matching their specified destinations. All VPN routes must be unique within the VPN server.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerRouteCollection>>}
   */
  public listVpnServerRoutes(
    params: VpcV1.ListVpnServerRoutesParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerRouteCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId'];
    const _validParams = ['vpnServerId', 'start', 'limit', 'sort', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listVpnServerRoutes'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/routes',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a VPN route for a VPN server.
   *
   * This request creates a new VPN route in the VPN server. All VPN routes are provided to the VPN client when the
   * connection is established. Packets received from the VPN client will be dropped by the VPN server if there is no
   * VPN route matching their specified destinations. All VPN routes must be unique within the VPN server. destination
   * of the packet.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.destination - The destination to use for this VPN route in the VPN server. Must be unique
   * within the VPN server. If an incoming packet does not match any destination, it will be dropped.
   * @param {string} [params.action] - The action to perform with a packet matching the VPN route:
   * - `translate`: translate the source IP address to one of the private IP addresses of the VPN server, then deliver
   * the packet to target.
   * - `deliver`: deliver the packet to the target.
   * - `drop`: drop the packet
   *
   * The enumerated values for this property are expected to expand in the future. When processing this property, check
   * for and log unknown values. Optionally halt processing and surface the error, or bypass the VPN route on which the
   * unexpected property value was encountered.
   * @param {string} [params.name] - The name for this VPN server route. The name must not be used by another route for
   * the VPN server. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerRoute>>}
   */
  public createVpnServerRoute(
    params: VpcV1.CreateVpnServerRouteParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerRoute>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'destination'];
    const _validParams = ['vpnServerId', 'destination', 'action', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'destination': _params.destination,
      'action': _params.action,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createVpnServerRoute'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/routes',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPN route.
   *
   * This request deletes a VPN route. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpnServerRoute(
    params: VpcV1.DeleteVpnServerRouteParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteVpnServerRoute'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/routes/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPN route.
   *
   * This request retrieves a single VPN route specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerRoute>>}
   */
  public getVpnServerRoute(
    params: VpcV1.GetVpnServerRouteParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerRoute>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getVpnServerRoute'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/routes/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPN route.
   *
   * This request updates a VPN route with the information in a provided VPN route patch. The VPN route patch object is
   * structured in the same way as a retrieved VPN route and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN route identifier.
   * @param {string} [params.name] - The name for this VPN server route. The name must not be used by another route for
   * the VPN server.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerRoute>>}
   */
  public updateVpnServerRoute(
    params: VpcV1.UpdateVpnServerRouteParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerRoute>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVpnServerRoute'
    );

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/routes/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * loadBalancers
   ************************/

  /**
   * List all load balancer profiles.
   *
   * This request lists all load balancer profiles available in the region. A load balancer profile specifies the
   * performance characteristics and pricing model for a load balancer.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerProfileCollection>>}
   */
  public listLoadBalancerProfiles(
    params?: VpcV1.ListLoadBalancerProfilesParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listLoadBalancerProfiles'
    );

    const parameters = {
      options: {
        url: '/load_balancer/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer profile.
   *
   * This request retrieves a load balancer profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The load balancer profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerProfile>>}
   */
  public getLoadBalancerProfile(
    params: VpcV1.GetLoadBalancerProfileParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getLoadBalancerProfile'
    );

    const parameters = {
      options: {
        url: '/load_balancer/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all load balancers.
   *
   * This request lists all load balancers in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerCollection>>}
   */
  public listLoadBalancers(
    params?: VpcV1.ListLoadBalancersParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listLoadBalancers'
    );

    const parameters = {
      options: {
        url: '/load_balancers',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a load balancer.
   *
   * This request creates and provisions a new load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {boolean} params.isPublic - Indicates whether this load balancer is public.
   *
   * At present, if route mode is enabled, the load balancer must not be public.
   * @param {SubnetIdentity[]} params.subnets - The subnets to provision this load balancer in. The subnets must be in
   * the same VPC. The load balancer's availability will depend on the availability of the zones that the subnets reside
   * in.
   *
   * Load balancers in the `network` family allow only one subnet to be specified.
   * @param {LoadBalancerLoggingDatapathPrototype} [params.datapath] - The datapath logging configuration for this load
   * balancer.
   * @param {LoadBalancerDNSPrototype} [params.dns] - The DNS configuration for this load balancer.
   *
   * If unspecified, DNS `A` records for this load balancer's `hostname` property will be added
   * to the public DNS zone `lb.appdomain.cloud`. Otherwise, those DNS `A` records will be
   * added to the specified `zone`.
   * @param {LoadBalancerListenerPrototypeLoadBalancerContext[]} [params.listeners] - The listeners of this load
   * balancer.
   * @param {LoadBalancerLoggingPrototype} [params.logging] - The logging configuration to use for this load balancer.
   * See [VPC Datapath
   * Logging](https://cloud.ibm.com/docs/vpc?topic=vpc-datapath-logging) on the logging
   * format, fields and permitted values.
   *
   * To activate logging, the load balancer profile must support the specified logging type.
   * @param {string} [params.name] - The name for this load balancer. The name must not be used by another load balancer
   * in the VPC.  If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {LoadBalancerPoolPrototype[]} [params.pools] - The pools of this load balancer.
   * @param {LoadBalancerProfileIdentity} [params.profile] - The profile to use for this load balancer.
   *
   * If unspecified, `application` will be used.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {boolean} [params.routeMode] - Indicates whether route mode is enabled for this load balancer.
   *
   * At present, public load balancers are not supported with route mode enabled.
   * @param {SecurityGroupIdentity[]} [params.securityGroups] - The security groups to use for this load balancer. If
   * unspecified, the VPC's default security group is used.
   *
   * The load balancer profile must support security groups.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancer>>}
   */
  public createLoadBalancer(
    params: VpcV1.CreateLoadBalancerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancer>> {
    const _params = { ...params };
    const _requiredParams = ['isPublic', 'subnets'];
    const _validParams = ['isPublic', 'subnets', 'datapath', 'dns', 'listeners', 'logging', 'name', 'pools', 'profile', 'resourceGroup', 'routeMode', 'securityGroups', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'is_public': _params.isPublic,
      'subnets': _params.subnets,
      'datapath': _params.datapath,
      'dns': _params.dns,
      'listeners': _params.listeners,
      'logging': _params.logging,
      'name': _params.name,
      'pools': _params.pools,
      'profile': _params.profile,
      'resource_group': _params.resourceGroup,
      'route_mode': _params.routeMode,
      'security_groups': _params.securityGroups,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createLoadBalancer'
    );

    const parameters = {
      options: {
        url: '/load_balancers',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer.
   *
   * This request deletes a load balancer. This operation cannot be reversed. A load balancer cannot be deleted if its
   * `provisioning_status` is `delete_pending`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The load balancer identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancer(
    params: VpcV1.DeleteLoadBalancerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteLoadBalancer'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer.
   *
   * This request retrieves a single load balancer specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The load balancer identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancer>>}
   */
  public getLoadBalancer(
    params: VpcV1.GetLoadBalancerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getLoadBalancer'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer.
   *
   * This request updates a load balancer with the information in a provided load balancer patch. The load balancer
   * patch object is structured in the same way as a retrieved load balancer and contains only the information to be
   * updated. A load balancer can only be updated if its `provisioning_status` is `active`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The load balancer identifier.
   * @param {LoadBalancerDNSPatch} [params.dns] - The DNS configuration for this load balancer.
   *
   * Specify `null` to remove the existing DNS configuration, which will remove all DNS `A`
   * records for this load balancer that had been added to `zone`, and add equivalent `A`
   * records to the public DNS zone `lb.appdomain.cloud`.
   * @param {LoadBalancerLoggingPatch} [params.logging] - The logging configuration to use for this load balancer.
   *
   * To activate logging, the load balancer profile must support the specified logging type.
   * @param {string} [params.name] - The name for this load balancer. The name must not be used by another load balancer
   * in the VPC.
   * @param {SubnetIdentity[]} [params.subnets] - The subnets to provision this load balancer in. The load balancer's
   * availability will depend on the availability of the zones that the subnets reside in.
   *
   * The specified subnets must be in the same VPC as the existing subnets, and will completely replace the existing
   * subnets.
   *
   * The load balancer must be in the `application` family.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancer>>}
   */
  public updateLoadBalancer(
    params: VpcV1.UpdateLoadBalancerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'dns', 'logging', 'name', 'subnets', 'ifMatch', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'dns': _params.dns,
      'logging': _params.logging,
      'name': _params.name,
      'subnets': _params.subnets,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateLoadBalancer'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all statistics of a load balancer.
   *
   * This request lists statistics of a load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The load balancer identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerStatistics>>}
   */
  public getLoadBalancerStatistics(
    params: VpcV1.GetLoadBalancerStatisticsParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerStatistics>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getLoadBalancerStatistics'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{id}/statistics',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all listeners for a load balancer.
   *
   * This request lists all listeners for a load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerCollection>>}
   */
  public listLoadBalancerListeners(
    params: VpcV1.ListLoadBalancerListenersParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId'];
    const _validParams = ['loadBalancerId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listLoadBalancerListeners'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a listener for a load balancer.
   *
   * This request creates a new listener for a load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.protocol - The listener protocol. Each listener in the load balancer must have a unique
   * `port` and `protocol` combination.
   *
   * Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
   * the `application` family support `tcp`, `http` and
   * `https`.
   *
   * Additional restrictions:
   * - If `default_pool` is set, the pool's protocol must match, or be compatible with
   *   the listener's protocol. At present, the compatible protocols are `http` and
   *   `https`.
   * - If `https_redirect` is set, the protocol must be `http`.
   * @param {boolean} [params.acceptProxyProtocol] - If set to `true`, this listener will accept and forward PROXY
   * protocol information. Supported by load balancers in the `application` family (otherwise always `false`).
   * Additional restrictions:
   * - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
   *   match the `accept_proxy_protocol` value of the `https_redirect` listener.
   * - If this listener is the target of another listener's `https_redirect`, its
   *   `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
   * @param {CertificateInstanceIdentity} [params.certificateInstance] - The certificate instance to use for SSL
   * termination. The listener must have a
   * `protocol` of `https`.
   * @param {number} [params.connectionLimit] - The connection limit of the listener.
   * @param {LoadBalancerPoolIdentity} [params.defaultPool] - The default pool for this listener. If specified, the pool
   * must:
   * - Belong to this load balancer.
   * - Have the same `protocol` as this listener, or have a compatible protocol.
   *   At present, the compatible protocols are `http` and `https`.
   * - Not already be the `default_pool` for another listener.
   *
   * If unspecified, this listener will be created with no default pool, but one may be
   * subsequently set.
   * @param {LoadBalancerListenerHTTPSRedirectPrototype} [params.httpsRedirect] - The target listener that requests will
   * be redirected to. This listener must have a
   * `protocol` of `http`, and the target listener must have a `protocol` of `https`.
   * @param {number} [params.idleConnectionTimeout] - The idle connection timeout of the listener in seconds. Supported
   * for load balancers in the `application` family.
   * @param {LoadBalancerListenerPolicyPrototype[]} [params.policies] - The policy prototype objects for this listener.
   * The load balancer must be in the
   * `application` family.
   * @param {number} [params.port] - The listener port number, or the inclusive lower bound of the port range. Each
   * listener in the load balancer must have a unique `port` and `protocol` combination.
   *
   * Not supported for load balancers operating with route mode enabled.
   * @param {number} [params.portMax] - The inclusive upper bound of the range of ports used by this listener. Must not
   * be less than `port_min`.
   *
   * At present, only load balancers operating with route mode enabled, and public load balancers in the `network`
   * family support different values for `port_min` and
   * `port_max`. When route mode is enabled, the value `65535` must be specified.
   *
   * The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
   * same protocol.
   * @param {number} [params.portMin] - The inclusive lower bound of the range of ports used by this listener. Must not
   * be greater than `port_max`.
   *
   * At present, only load balancers operating with route mode enabled, and public load balancers in the `network`
   * family support different values for `port_min` and
   * `port_max`. When route mode is enabled, the value `1` must be specified.
   *
   * The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
   * same protocol.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListener>>}
   */
  public createLoadBalancerListener(
    params: VpcV1.CreateLoadBalancerListenerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListener>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'protocol'];
    const _validParams = ['loadBalancerId', 'protocol', 'acceptProxyProtocol', 'certificateInstance', 'connectionLimit', 'defaultPool', 'httpsRedirect', 'idleConnectionTimeout', 'policies', 'port', 'portMax', 'portMin', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'protocol': _params.protocol,
      'accept_proxy_protocol': _params.acceptProxyProtocol,
      'certificate_instance': _params.certificateInstance,
      'connection_limit': _params.connectionLimit,
      'default_pool': _params.defaultPool,
      'https_redirect': _params.httpsRedirect,
      'idle_connection_timeout': _params.idleConnectionTimeout,
      'policies': _params.policies,
      'port': _params.port,
      'port_max': _params.portMax,
      'port_min': _params.portMin,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createLoadBalancerListener'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer listener.
   *
   * This request deletes a load balancer listener. This operation cannot be reversed. For this operation to succeed,
   * the listener must not be the target of another load balancer listener.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The listener identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancerListener(
    params: VpcV1.DeleteLoadBalancerListenerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteLoadBalancerListener'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer listener.
   *
   * This request retrieves a single listener specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The listener identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListener>>}
   */
  public getLoadBalancerListener(
    params: VpcV1.GetLoadBalancerListenerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListener>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getLoadBalancerListener'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer listener.
   *
   * This request updates a load balancer listener from a listener patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The listener identifier.
   * @param {boolean} [params.acceptProxyProtocol] - If set to `true`, this listener will accept and forward PROXY
   * protocol information. Supported by load balancers in the `application` family (otherwise always `false`).
   * Additional restrictions:
   * - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
   *   match the `accept_proxy_protocol` value of the `https_redirect` listener.
   * - If this listener is the target of another listener's `https_redirect`, its
   *   `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
   * @param {CertificateInstanceIdentity} [params.certificateInstance] - The certificate instance to use for SSL
   * termination. The listener must have a
   * `protocol` of `https`.
   * @param {number} [params.connectionLimit] - The connection limit of the listener.
   * @param {LoadBalancerPoolIdentity} [params.defaultPool] - The default pool for this listener. The specified pool
   * must:
   *
   * - Belong to this load balancer
   * - Have the same `protocol` as this listener, or have a compatible protocol.
   *   At present, the compatible protocols are `http` and `https`.
   * - Not already be the `default_pool` for another listener
   *
   * Specify `null` to remove an existing default pool.
   * @param {LoadBalancerListenerHTTPSRedirectPatch} [params.httpsRedirect] - The target listener that requests will be
   * redirected to. This listener must have a
   * `protocol` of `http`, and the target listener must have a `protocol` of `https`.
   *
   * Specify `null` to remove any existing https redirect.
   * @param {number} [params.idleConnectionTimeout] - The idle connection timeout of the listener in seconds. Supported
   * for load balancers in the `application` family.
   * @param {number} [params.port] - The listener port number, or the inclusive lower bound of the port range. Each
   * listener in the load balancer must have a unique `port` and `protocol` combination.
   *
   * Not supported for load balancers operating with route mode enabled.
   * @param {number} [params.portMax] - The inclusive upper bound of the range of ports used by this listener. Must not
   * be less than `port_min`.
   *
   * At present, only load balancers operating with route mode enabled, and public load balancers in the `network`
   * family support different values for `port_min` and
   * `port_max`. When route mode is enabled, the value `65535` must be specified.
   *
   * The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
   * same protocol.
   * @param {number} [params.portMin] - The inclusive lower bound of the range of ports used by this listener. Must not
   * be greater than `port_max`.
   *
   * At present, only load balancers operating with route mode enabled, and public load balancers in the `network`
   * family support different values for `port_min` and
   * `port_max`. When route mode is enabled, the value `1` must be specified.
   *
   * The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
   * same protocol.
   * @param {string} [params.protocol] - The listener protocol. Each listener in the load balancer must have a unique
   * `port` and `protocol` combination.
   *
   * Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
   * the `application` family support `tcp`, `http` and
   * `https`.
   *
   * Additional restrictions:
   * - If `default_pool` is set, the protocol cannot be changed.
   * - If `https_redirect` is set, the protocol must be `http`.
   * - If another listener's `https_redirect` targets this listener, the protocol must be
   * `https`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListener>>}
   */
  public updateLoadBalancerListener(
    params: VpcV1.UpdateLoadBalancerListenerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListener>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'acceptProxyProtocol', 'certificateInstance', 'connectionLimit', 'defaultPool', 'httpsRedirect', 'idleConnectionTimeout', 'port', 'portMax', 'portMin', 'protocol', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'accept_proxy_protocol': _params.acceptProxyProtocol,
      'certificate_instance': _params.certificateInstance,
      'connection_limit': _params.connectionLimit,
      'default_pool': _params.defaultPool,
      'https_redirect': _params.httpsRedirect,
      'idle_connection_timeout': _params.idleConnectionTimeout,
      'port': _params.port,
      'port_max': _params.portMax,
      'port_min': _params.portMin,
      'protocol': _params.protocol,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateLoadBalancerListener'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all policies for a load balancer listener.
   *
   * This request lists all policies for a load balancer listener.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyCollection>>}
   */
  public listLoadBalancerListenerPolicies(
    params: VpcV1.ListLoadBalancerListenerPoliciesParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId'];
    const _validParams = ['loadBalancerId', 'listenerId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listLoadBalancerListenerPolicies'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a policy for a load balancer listener.
   *
   * Creates a new policy for a load balancer listener.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.action - The policy action.
   *
   * The enumerated values for this property are expected to expand in the future. When processing this property, check
   * for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on which the
   * unexpected property value was encountered.
   * @param {number} params.priority - Priority of the policy. Lower value indicates higher priority.
   * @param {string} [params.name] - The name for this policy. The name must not be used by another policy for the load
   * balancer listener. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {LoadBalancerListenerPolicyRulePrototype[]} [params.rules] - The rule prototype objects for this policy.
   * @param {LoadBalancerListenerPolicyTargetPrototype} [params.target] - - If `action` is `forward`, specify a
   * `LoadBalancerPoolIdentity`.
   * - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPrototype`.
   * - If `action` is `https_redirect`, specify a
   *   `LoadBalancerListenerPolicyHTTPSRedirectPrototype`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>>}
   */
  public createLoadBalancerListenerPolicy(
    params: VpcV1.CreateLoadBalancerListenerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'action', 'priority'];
    const _validParams = ['loadBalancerId', 'listenerId', 'action', 'priority', 'name', 'rules', 'target', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'action': _params.action,
      'priority': _params.priority,
      'name': _params.name,
      'rules': _params.rules,
      'target': _params.target,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createLoadBalancerListenerPolicy'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer listener policy.
   *
   * Deletes a policy of the load balancer listener. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.id - The policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancerListenerPolicy(
    params: VpcV1.DeleteLoadBalancerListenerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteLoadBalancerListenerPolicy'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer listener policy.
   *
   * Retrieve a single policy specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.id - The policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>>}
   */
  public getLoadBalancerListenerPolicy(
    params: VpcV1.GetLoadBalancerListenerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getLoadBalancerListenerPolicy'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer listener policy.
   *
   * Updates a policy from a policy patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.id - The policy identifier.
   * @param {string} [params.name] - The name for this policy. The name must not be used by another policy for the load
   * balancer listener.
   * @param {number} [params.priority] - Priority of the policy. Lower value indicates higher priority.
   * @param {LoadBalancerListenerPolicyTargetPatch} [params.target] - - If `action` is `forward`, specify a
   * `LoadBalancerPoolIdentity`.
   * - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPatch`.
   * - If `action` is `https_redirect`, specify a
   *   `LoadBalancerListenerPolicyHTTPSRedirectPatch`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>>}
   */
  public updateLoadBalancerListenerPolicy(
    params: VpcV1.UpdateLoadBalancerListenerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'id', 'name', 'priority', 'target', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'priority': _params.priority,
      'target': _params.target,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateLoadBalancerListenerPolicy'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all rules of a load balancer listener policy.
   *
   * This request lists all rules of a load balancer listener policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.policyId - The policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRuleCollection>>}
   */
  public listLoadBalancerListenerPolicyRules(
    params: VpcV1.ListLoadBalancerListenerPolicyRulesParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRuleCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'policyId'];
    const _validParams = ['loadBalancerId', 'listenerId', 'policyId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'policy_id': _params.policyId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listLoadBalancerListenerPolicyRules'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a rule for a load balancer listener policy.
   *
   * Creates a new rule for the load balancer listener policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.policyId - The policy identifier.
   * @param {string} params.condition - The condition of the rule.
   * @param {string} params.type - The type of the rule.
   *
   * Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
   * @param {string} params.value - Value to be matched for rule condition.
   *
   * If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
   * @param {string} [params.field] - The field. This is applicable to `header`, `query`, and `body` rule types.
   *
   * If the rule type is `header`, this property is required.
   *
   * If the rule type is `query`, this is optional. If specified and the rule condition is not
   * `matches_regex`, the value must be percent-encoded.
   *
   * If the rule type is `body`, this is optional.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>>}
   */
  public createLoadBalancerListenerPolicyRule(
    params: VpcV1.CreateLoadBalancerListenerPolicyRuleParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'policyId', 'condition', 'type', 'value'];
    const _validParams = ['loadBalancerId', 'listenerId', 'policyId', 'condition', 'type', 'value', 'field', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'condition': _params.condition,
      'type': _params.type,
      'value': _params.value,
      'field': _params.field,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'policy_id': _params.policyId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createLoadBalancerListenerPolicyRule'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer listener policy rule.
   *
   * Deletes a rule from the load balancer listener policy. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.policyId - The policy identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancerListenerPolicyRule(
    params: VpcV1.DeleteLoadBalancerListenerPolicyRuleParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'policyId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'policyId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'policy_id': _params.policyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteLoadBalancerListenerPolicyRule'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer listener policy rule.
   *
   * Retrieves a single rule specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.policyId - The policy identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>>}
   */
  public getLoadBalancerListenerPolicyRule(
    params: VpcV1.GetLoadBalancerListenerPolicyRuleParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'policyId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'policyId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'policy_id': _params.policyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getLoadBalancerListenerPolicyRule'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer listener policy rule.
   *
   * Updates a rule of the load balancer listener policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.policyId - The policy identifier.
   * @param {string} params.id - The rule identifier.
   * @param {string} [params.condition] - The condition of the rule.
   * @param {string} [params.field] - The field. This is applicable to `header`, `query`, and `body` rule types.
   *
   * If the rule type is `header`, this property is required.
   *
   * If the rule type is `query`, this is optional. If specified and the rule condition is not
   * `matches_regex`, the value must be percent-encoded.
   *
   * If the rule type is `body`, this is optional.
   * @param {string} [params.type] - The type of the rule.
   *
   * Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
   * @param {string} [params.value] - Value to be matched for rule condition.
   *
   * If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>>}
   */
  public updateLoadBalancerListenerPolicyRule(
    params: VpcV1.UpdateLoadBalancerListenerPolicyRuleParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'policyId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'policyId', 'id', 'condition', 'field', 'type', 'value', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'condition': _params.condition,
      'field': _params.field,
      'type': _params.type,
      'value': _params.value,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'policy_id': _params.policyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateLoadBalancerListenerPolicyRule'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all pools of a load balancer.
   *
   * This request lists all pools of a load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolCollection>>}
   */
  public listLoadBalancerPools(
    params: VpcV1.ListLoadBalancerPoolsParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId'];
    const _validParams = ['loadBalancerId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listLoadBalancerPools'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a load balancer pool.
   *
   * This request creates a new pool from a pool prototype object.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.algorithm - The load balancing algorithm.
   * @param {LoadBalancerPoolHealthMonitorPrototype} params.healthMonitor - The health monitor of this pool.
   * @param {string} params.protocol - The protocol used for this load balancer pool. Load balancers in the `network`
   * family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the
   * `application` family support `tcp`, `http`, and `https`.
   * @param {LoadBalancerPoolMemberPrototype[]} [params.members] - The members for this load balancer pool. For load
   * balancers in the `network` family, the same `port` and `target` tuple cannot be shared by a pool member of any
   * other load balancer in the same VPC.
   * @param {string} [params.name] - The name for this load balancer pool. The name must not be used by another pool for
   * the load balancer. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {string} [params.proxyProtocol] - The PROXY protocol setting for this pool:
   * - `v1`: Enabled with version 1 (human-readable header format)
   * - `v2`: Enabled with version 2 (binary header format)
   * - `disabled`: Disabled
   *
   * Supported by load balancers in the `application` family (otherwise always `disabled`).
   * @param {LoadBalancerPoolSessionPersistencePrototype} [params.sessionPersistence] - The session persistence of this
   * pool.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPool>>}
   */
  public createLoadBalancerPool(
    params: VpcV1.CreateLoadBalancerPoolParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPool>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'algorithm', 'healthMonitor', 'protocol'];
    const _validParams = ['loadBalancerId', 'algorithm', 'healthMonitor', 'protocol', 'members', 'name', 'proxyProtocol', 'sessionPersistence', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'algorithm': _params.algorithm,
      'health_monitor': _params.healthMonitor,
      'protocol': _params.protocol,
      'members': _params.members,
      'name': _params.name,
      'proxy_protocol': _params.proxyProtocol,
      'session_persistence': _params.sessionPersistence,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createLoadBalancerPool'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer pool.
   *
   * This request deletes a load balancer pool. This operation cannot be reversed. The pool must not currently be the
   * default pool for any listener in the load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The pool identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancerPool(
    params: VpcV1.DeleteLoadBalancerPoolParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteLoadBalancerPool'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer pool.
   *
   * This request retrieves a single pool specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The pool identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPool>>}
   */
  public getLoadBalancerPool(
    params: VpcV1.GetLoadBalancerPoolParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPool>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getLoadBalancerPool'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer pool.
   *
   * This request updates a load balancer pool from a pool patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The pool identifier.
   * @param {string} [params.algorithm] - The load balancing algorithm.
   * @param {LoadBalancerPoolHealthMonitorPatch} [params.healthMonitor] - The health monitor of this pool.
   * @param {string} [params.name] - The name for this load balancer pool. The name must not be used by another pool for
   * the load balancer.
   * @param {string} [params.protocol] - The protocol for this load balancer pool.
   *
   * Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
   * the `application` family support `tcp`, `http` and
   * `https`.
   *
   * If this pool is associated with a load balancer listener, the specified protocol must match, or be compatible with
   * the listener's protocol. At present, the compatible protocols are `http` and `https`.
   * @param {string} [params.proxyProtocol] - The PROXY protocol setting for this pool:
   * - `v1`: Enabled with version 1 (human-readable header format)
   * - `v2`: Enabled with version 2 (binary header format)
   * - `disabled`: Disabled
   *
   * Supported by load balancers in the `application` family (otherwise always `disabled`).
   * @param {LoadBalancerPoolSessionPersistencePatch} [params.sessionPersistence] - The session persistence of this
   * pool.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPool>>}
   */
  public updateLoadBalancerPool(
    params: VpcV1.UpdateLoadBalancerPoolParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPool>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'algorithm', 'healthMonitor', 'name', 'protocol', 'proxyProtocol', 'sessionPersistence', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'algorithm': _params.algorithm,
      'health_monitor': _params.healthMonitor,
      'name': _params.name,
      'protocol': _params.protocol,
      'proxy_protocol': _params.proxyProtocol,
      'session_persistence': _params.sessionPersistence,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateLoadBalancerPool'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all members of a load balancer pool.
   *
   * This request lists all members of a load balancer pool.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMemberCollection>>}
   */
  public listLoadBalancerPoolMembers(
    params: VpcV1.ListLoadBalancerPoolMembersParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMemberCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId'];
    const _validParams = ['loadBalancerId', 'poolId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listLoadBalancerPoolMembers'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a member in a load balancer pool.
   *
   * This request creates a new member and adds the member to the pool.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {number} params.port - The port the member will receive load balancer traffic on. Applies only to load
   * balancer traffic received on a listener with a single port. (If the traffic is received on a listener with a port
   * range, the member will receive the traffic on the same port the listener received it on.)
   *
   * This port will also be used for health checks unless the `port` property of
   * `health_monitor` property is specified.
   *
   * The port must be unique across all members for all pools associated with this pool's listener.
   * @param {LoadBalancerPoolMemberTargetPrototype} params.target - The pool member target. Load balancers in the
   * `network` family support virtual server
   * instances. Load balancers in the `application` family support IP addresses. If the load
   * balancer has route mode enabled, the member must be in a zone the load balancer has a
   * subnet in.
   * @param {number} [params.weight] - Weight of the server member. Applicable only if the pool algorithm is
   * `weighted_round_robin`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>>}
   */
  public createLoadBalancerPoolMember(
    params: VpcV1.CreateLoadBalancerPoolMemberParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId', 'port', 'target'];
    const _validParams = ['loadBalancerId', 'poolId', 'port', 'target', 'weight', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'port': _params.port,
      'target': _params.target,
      'weight': _params.weight,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createLoadBalancerPoolMember'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Replace load balancer pool members.
   *
   * This request replaces the existing members of the load balancer pool with new members created from the collection
   * of member prototype objects.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {LoadBalancerPoolMemberPrototype[]} params.members - The member prototype objects for this pool.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMemberCollection>>}
   */
  public replaceLoadBalancerPoolMembers(
    params: VpcV1.ReplaceLoadBalancerPoolMembersParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMemberCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId', 'members'];
    const _validParams = ['loadBalancerId', 'poolId', 'members', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'members': _params.members,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'replaceLoadBalancerPoolMembers'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members',
        method: 'PUT',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer pool member.
   *
   * This request deletes a member from the pool. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {string} params.id - The member identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancerPoolMember(
    params: VpcV1.DeleteLoadBalancerPoolMemberParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId', 'id'];
    const _validParams = ['loadBalancerId', 'poolId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteLoadBalancerPoolMember'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer pool member.
   *
   * This request retrieves a single member specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {string} params.id - The member identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>>}
   */
  public getLoadBalancerPoolMember(
    params: VpcV1.GetLoadBalancerPoolMemberParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId', 'id'];
    const _validParams = ['loadBalancerId', 'poolId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getLoadBalancerPoolMember'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer pool member.
   *
   * This request updates an existing member from a member patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {string} params.id - The member identifier.
   * @param {number} [params.port] - The port the member will receive load balancer traffic on. Applies only to load
   * balancer traffic received on a listener with a single port. (If the traffic is received on a listener with a port
   * range, the member will receive the traffic on the same port the listener received it on.)
   *
   * This port will also be used for health checks unless the `port` property of
   * `health_monitor` property is specified.
   *
   * The port must be unique across all members for all pools associated with this pool's listener.
   * @param {LoadBalancerPoolMemberTargetPrototype} [params.target] - The pool member target. Load balancers in the
   * `network` family support virtual server
   * instances. Load balancers in the `application` family support IP addresses. If the load
   * balancer has route mode enabled, the member must be in a zone the load balancer has a
   * subnet in.
   * @param {number} [params.weight] - Weight of the server member. Applicable only if the pool algorithm is
   * `weighted_round_robin`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>>}
   */
  public updateLoadBalancerPoolMember(
    params: VpcV1.UpdateLoadBalancerPoolMemberParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId', 'id'];
    const _validParams = ['loadBalancerId', 'poolId', 'id', 'port', 'target', 'weight', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'port': _params.port,
      'target': _params.target,
      'weight': _params.weight,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateLoadBalancerPoolMember'
    );

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * endpointGateways
   ************************/

  /**
   * List all endpoint gateways.
   *
   * This request lists all endpoint gateways in the region. An endpoint gateway maps one or more reserved IPs in a VPC
   * to a target outside the VPC.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EndpointGatewayCollection>>}
   */
  public listEndpointGateways(
    params?: VpcV1.ListEndpointGatewaysParams
  ): Promise<VpcV1.Response<VpcV1.EndpointGatewayCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['name', 'start', 'limit', 'resourceGroupId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'name': _params.name,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listEndpointGateways'
    );

    const parameters = {
      options: {
        url: '/endpoint_gateways',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an endpoint gateway.
   *
   * This request creates a new endpoint gateway. An endpoint gateway maps one or more reserved IPs in a VPC to a target
   * outside the VPC.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {EndpointGatewayTargetPrototype} params.target - The target to use for this endpoint gateway. Must not
   * already be the target of another
   * endpoint gateway in the VPC.
   * @param {VPCIdentity} params.vpc - The VPC this endpoint gateway will reside in.
   * @param {EndpointGatewayReservedIP[]} [params.ips] - The reserved IPs to bind to this endpoint gateway. At most one
   * reserved IP per zone is allowed.
   * @param {string} [params.name] - The name for this endpoint gateway. The name must not be used by another endpoint
   * gateway in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {SecurityGroupIdentity[]} [params.securityGroups] - The security groups to use for this endpoint gateway. If
   * unspecified, the VPC's default security group is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EndpointGateway>>}
   */
  public createEndpointGateway(
    params: VpcV1.CreateEndpointGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EndpointGateway>> {
    const _params = { ...params };
    const _requiredParams = ['target', 'vpc'];
    const _validParams = ['target', 'vpc', 'ips', 'name', 'resourceGroup', 'securityGroups', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'target': _params.target,
      'vpc': _params.vpc,
      'ips': _params.ips,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
      'security_groups': _params.securityGroups,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createEndpointGateway'
    );

    const parameters = {
      options: {
        url: '/endpoint_gateways',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all reserved IPs bound to an endpoint gateway.
   *
   * This request lists all reserved IPs bound to an endpoint gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.endpointGatewayId - The endpoint gateway identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIPCollectionEndpointGatewayContext>>}
   */
  public listEndpointGatewayIps(
    params: VpcV1.ListEndpointGatewayIpsParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIPCollectionEndpointGatewayContext>> {
    const _params = { ...params };
    const _requiredParams = ['endpointGatewayId'];
    const _validParams = ['endpointGatewayId', 'start', 'limit', 'sort', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const path = {
      'endpoint_gateway_id': _params.endpointGatewayId,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listEndpointGatewayIps'
    );

    const parameters = {
      options: {
        url: '/endpoint_gateways/{endpoint_gateway_id}/ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Unbind a reserved IP from an endpoint gateway.
   *
   * This request unbinds the specified reserved IP from the specified endpoint gateway. If the reserved IP has
   * `auto_delete` set to `true`, the reserved IP will be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.endpointGatewayId - The endpoint gateway identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeEndpointGatewayIp(
    params: VpcV1.RemoveEndpointGatewayIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['endpointGatewayId', 'id'];
    const _validParams = ['endpointGatewayId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'endpoint_gateway_id': _params.endpointGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'removeEndpointGatewayIp'
    );

    const parameters = {
      options: {
        url: '/endpoint_gateways/{endpoint_gateway_id}/ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a reserved IP bound to an endpoint gateway.
   *
   * This request retrieves the specified reserved IP address if it is bound to the endpoint gateway specified in the
   * URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.endpointGatewayId - The endpoint gateway identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public getEndpointGatewayIp(
    params: VpcV1.GetEndpointGatewayIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['endpointGatewayId', 'id'];
    const _validParams = ['endpointGatewayId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'endpoint_gateway_id': _params.endpointGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getEndpointGatewayIp'
    );

    const parameters = {
      options: {
        url: '/endpoint_gateways/{endpoint_gateway_id}/ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Bind a reserved IP to an endpoint gateway.
   *
   * This request binds the specified reserved IP to the specified endpoint gateway. The reserved IP:
   *
   * - must currently be unbound
   * - must not be in the same zone as any other reserved IP bound to the endpoint gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.endpointGatewayId - The endpoint gateway identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public addEndpointGatewayIp(
    params: VpcV1.AddEndpointGatewayIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['endpointGatewayId', 'id'];
    const _validParams = ['endpointGatewayId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'endpoint_gateway_id': _params.endpointGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'addEndpointGatewayIp'
    );

    const parameters = {
      options: {
        url: '/endpoint_gateways/{endpoint_gateway_id}/ips/{id}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an endpoint gateway.
   *
   * This request deletes an endpoint gateway. This operation cannot be reversed.
   *
   * Reserved IPs that were bound to the endpoint gateway will be released if their
   * `auto_delete` property is set to true.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The endpoint gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteEndpointGateway(
    params: VpcV1.DeleteEndpointGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteEndpointGateway'
    );

    const parameters = {
      options: {
        url: '/endpoint_gateways/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an endpoint gateway.
   *
   * This request retrieves a single endpoint gateway specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The endpoint gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EndpointGateway>>}
   */
  public getEndpointGateway(
    params: VpcV1.GetEndpointGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EndpointGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getEndpointGateway'
    );

    const parameters = {
      options: {
        url: '/endpoint_gateways/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an endpoint gateway.
   *
   * This request updates an endpoint gateway's name.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The endpoint gateway identifier.
   * @param {string} [params.name] - The name for this endpoint gateway. The name must not be used by another endpoint
   * gateway in the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EndpointGateway>>}
   */
  public updateEndpointGateway(
    params: VpcV1.UpdateEndpointGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EndpointGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateEndpointGateway'
    );

    const parameters = {
      options: {
        url: '/endpoint_gateways/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * flowLogCollectors
   ************************/

  /**
   * List all flow log collectors.
   *
   * This request lists all flow log collectors in the region. A flow log collector summarizes data sent over the
   * instance network interfaces contained within its target.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.vpcId] - Filters the collection to resources with a `vpc.id` property matching the
   * specified identifier.
   * @param {string} [params.vpcCrn] - Filters the collection to resources with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to resources with a `vpc.name` property matching the
   * exact specified name.
   * @param {string} [params.targetId] - Filters the collection to resources with a `target.id` property matching the
   * specified identifier.
   * @param {string} [params.targetResourceType] - Filters the collection to resources with a `target.resource_type`
   * property matching the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FlowLogCollectorCollection>>}
   */
  public listFlowLogCollectors(
    params?: VpcV1.ListFlowLogCollectorsParams
  ): Promise<VpcV1.Response<VpcV1.FlowLogCollectorCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'vpcId', 'vpcCrn', 'vpcName', 'targetId', 'targetResourceType', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'vpc.id': _params.vpcId,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
      'target.id': _params.targetId,
      'target.resource_type': _params.targetResourceType,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listFlowLogCollectors'
    );

    const parameters = {
      options: {
        url: '/flow_log_collectors',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a flow log collector.
   *
   * This request creates and starts a new flow log collector from a flow log collector prototype object. The prototype
   * object is structured in the same way as a retrieved flow log collector, and contains the information necessary to
   * create and start the new flow log collector.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {LegacyCloudObjectStorageBucketIdentity} params.storageBucket - The Cloud Object Storage bucket where the
   * collected flows will be logged.
   * The bucket must exist and an IAM service authorization must grant
   * `IBM Cloud Flow Logs` resources of `VPC Infrastructure Services` writer
   * access to the bucket.
   * @param {FlowLogCollectorTargetPrototype} params.target - The target this collector will collect flow logs for. If
   * the target is an instance,
   * subnet, or VPC, flow logs will not be collected for any instance network interfaces within
   * the target that are themselves the target of a more specific flow log collector.
   * @param {boolean} [params.active] - Indicates whether this collector will be active upon creation.
   * @param {string} [params.name] - The name for this flow log collector. The name must not be used by another flow log
   * collector in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FlowLogCollector>>}
   */
  public createFlowLogCollector(
    params: VpcV1.CreateFlowLogCollectorParams
  ): Promise<VpcV1.Response<VpcV1.FlowLogCollector>> {
    const _params = { ...params };
    const _requiredParams = ['storageBucket', 'target'];
    const _validParams = ['storageBucket', 'target', 'active', 'name', 'resourceGroup', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'storage_bucket': _params.storageBucket,
      'target': _params.target,
      'active': _params.active,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createFlowLogCollector'
    );

    const parameters = {
      options: {
        url: '/flow_log_collectors',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a flow log collector.
   *
   * This request stops and deletes a flow log collector. This operation cannot be reversed.
   *
   * Collected flow logs remain available within the flow log collector's Cloud Object Storage bucket.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The flow log collector identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteFlowLogCollector(
    params: VpcV1.DeleteFlowLogCollectorParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteFlowLogCollector'
    );

    const parameters = {
      options: {
        url: '/flow_log_collectors/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a flow log collector.
   *
   * This request retrieves a single flow log collector specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The flow log collector identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FlowLogCollector>>}
   */
  public getFlowLogCollector(
    params: VpcV1.GetFlowLogCollectorParams
  ): Promise<VpcV1.Response<VpcV1.FlowLogCollector>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getFlowLogCollector'
    );

    const parameters = {
      options: {
        url: '/flow_log_collectors/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a flow log collector.
   *
   * This request updates a flow log collector with the information in a provided flow log collector patch. The flow log
   * collector patch object is structured in the same way as a retrieved flow log collector and contains only the
   * information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The flow log collector identifier.
   * @param {boolean} [params.active] - Indicates whether this collector is active. Updating to false deactivates the
   * collector and updating to true activates the collector.
   * @param {string} [params.name] - The name for this flow log collector. The name must not be used by another flow log
   * collector in the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FlowLogCollector>>}
   */
  public updateFlowLogCollector(
    params: VpcV1.UpdateFlowLogCollectorParams
  ): Promise<VpcV1.Response<VpcV1.FlowLogCollector>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'active', 'name', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'active': _params.active,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      VpcV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateFlowLogCollector'
    );

    const parameters = {
      options: {
        url: '/flow_log_collectors/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
}

/*************************
 * interfaces
 ************************/

namespace VpcV1 {
  /** Options for the `VpcV1` constructor. */
  export interface Options extends UserOptions {
    /** The infrastructure generation. For the API behavior documented here, specify `2`. */
    generation?: number;
    /** The API version, in format `YYYY-MM-DD`. For the API behavior documented here, specify any date between
     *  `2022-09-13` and `2023-08-24`.
     */
    version: string;
  }

  /** An operation response. */
  export interface Response<T = any> {
    result: T;
    status: number;
    statusText: string;
    headers: IncomingHttpHeaders;
  }

  /** The callback for a service request. */
  export type Callback<T> = (error: any, response?: Response<T>) => void;

  /** The body of a service request that returns no response data. */
  export interface EmptyObject {}

  /** A standard JS object, defined to avoid the limitations of `Object` and `object` */
  export interface JsonObject {
    [key: string]: any;
  }

  /*************************
   * request interfaces
   ************************/

  /** Parameters for the `listVpcs` operation. */
  export interface ListVpcsParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to VPCs with a `classic_access` property matching the specified value. */
    classicAccess?: boolean;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createVpc` operation. */
  export interface CreateVpcParams {
    /** Indicates whether a [default address
     *  prefix](https://cloud.ibm.com/docs/vpc?topic=vpc-configuring-address-prefixes) will be automatically created for
     *  each zone in this VPC. If `manual`, this VPC will be created with no default address prefixes.
     *
     *  Since address prefixes are managed identically regardless of whether they were automatically created, the value
     *  is not preserved as a VPC property.
     */
    addressPrefixManagement?: CreateVpcConstants.AddressPrefixManagement | string;
    /** Indicates whether this VPC will be connected to Classic Infrastructure. If true, this VPC's resources will
     *  have private network connectivity to the account's Classic Infrastructure resources. Only one VPC, per region,
     *  may be connected in this way. This value is set at creation and subsequently immutable.
     */
    classicAccess?: boolean;
    /** The name for this VPC. The name must not be used by another VPC in the region. If unspecified, the name will
     *  be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createVpc` operation. */
  export namespace CreateVpcConstants {
    /** Indicates whether a [default address prefix](https://cloud.ibm.com/docs/vpc?topic=vpc-configuring-address-prefixes) will be automatically created for each zone in this VPC. If `manual`, this VPC will be created with no default address prefixes. Since address prefixes are managed identically regardless of whether they were automatically created, the value is not preserved as a VPC property. */
    export enum AddressPrefixManagement {
      AUTO = 'auto',
      MANUAL = 'manual',
    }
  }

  /** Parameters for the `deleteVpc` operation. */
  export interface DeleteVpcParams {
    /** The VPC identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpc` operation. */
  export interface GetVpcParams {
    /** The VPC identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVpc` operation. */
  export interface UpdateVpcParams {
    /** The VPC identifier. */
    id: string;
    /** The name for this VPC. The name must not be used by another VPC in the region. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpcDefaultNetworkAcl` operation. */
  export interface GetVpcDefaultNetworkAclParams {
    /** The VPC identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpcDefaultRoutingTable` operation. */
  export interface GetVpcDefaultRoutingTableParams {
    /** The VPC identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpcDefaultSecurityGroup` operation. */
  export interface GetVpcDefaultSecurityGroupParams {
    /** The VPC identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVpcAddressPrefixes` operation. */
  export interface ListVpcAddressPrefixesParams {
    /** The VPC identifier. */
    vpcId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createVpcAddressPrefix` operation. */
  export interface CreateVpcAddressPrefixParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The IPv4 range of the address prefix, expressed in CIDR format. The range must not overlap with any existing
     *  address prefixes in the VPC or any of the following reserved address ranges:
     *
     *    - `127.0.0.0/8` (IPv4 loopback addresses)
     *    - `161.26.0.0/16` (IBM services)
     *    - `166.8.0.0/14` (Cloud Service Endpoints)
     *    - `169.254.0.0/16` (IPv4 link-local addresses)
     *    - `224.0.0.0/4` (IPv4 multicast addresses)
     *
     *  The prefix length of the address prefix's CIDR must be between `/9` (8,388,608 addresses) and `/29` (8
     *  addresses).
     */
    cidr: string;
    /** The zone this address prefix will reside in. */
    zone: ZoneIdentity;
    /** Indicates whether this will be the default address prefix for this zone in this VPC. If `true`, the VPC must
     *  not have a default address prefix for this zone.
     */
    isDefault?: boolean;
    /** The name for this address prefix. The name must not be used by another address prefix for the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteVpcAddressPrefix` operation. */
  export interface DeleteVpcAddressPrefixParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The prefix identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpcAddressPrefix` operation. */
  export interface GetVpcAddressPrefixParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The prefix identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVpcAddressPrefix` operation. */
  export interface UpdateVpcAddressPrefixParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The prefix identifier. */
    id: string;
    /** Indicates whether this is the default prefix for this zone in this VPC. Updating to true makes this prefix
     *  the default prefix for this zone in this VPC, provided the VPC currently has no default address prefix for this
     *  zone. Updating to false removes the default prefix for this zone in this VPC.
     */
    isDefault?: boolean;
    /** The name for this address prefix. The name must not be used by another address prefix for the VPC. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVpcRoutes` operation. */
  export interface ListVpcRoutesParams {
    /** The VPC identifier. */
    vpcId: string;
    /** Filters the collection to resources with a `zone.name` property matching the exact specified name. */
    zoneName?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createVpcRoute` operation. */
  export interface CreateVpcRouteParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The destination CIDR of the route. The host identifier in the CIDR must be zero.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and
     *  `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
     */
    destination: string;
    /** The zone to apply the route to. (Traffic from subnets in this zone will be subject to this route.). */
    zone: ZoneIdentity;
    /** The action to perform with a packet matching the route:
     *  - `delegate`: delegate to system-provided routes
     *  - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
     *  - `deliver`: deliver the packet to the specified `next_hop`
     *  - `drop`: drop the packet.
     */
    action?: CreateVpcRouteConstants.Action | string;
    /** The name for this route. The name must not be used by another route in the routing table. Names starting
     *  with `ibm-` are reserved for system-provided routes, and are not allowed. If unspecified, the name will be a
     *  hyphenated list of randomly-selected words.
     */
    name?: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to. For other
     *  `action` values, it must be omitted or specified as `0.0.0.0`.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and `priority`,
     *  and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
     */
    nextHop?: RoutePrototypeNextHop;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createVpcRoute` operation. */
  export namespace CreateVpcRouteConstants {
    /** The action to perform with a packet matching the route: - `delegate`: delegate to system-provided routes - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes - `deliver`: deliver the packet to the specified `next_hop` - `drop`: drop the packet. */
    export enum Action {
      DELEGATE = 'delegate',
      DELEGATE_VPC = 'delegate_vpc',
      DELIVER = 'deliver',
      DROP = 'drop',
    }
  }

  /** Parameters for the `deleteVpcRoute` operation. */
  export interface DeleteVpcRouteParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The route identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpcRoute` operation. */
  export interface GetVpcRouteParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The route identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVpcRoute` operation. */
  export interface UpdateVpcRouteParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The route identifier. */
    id: string;
    /** The name for this route. The name must not be used by another route in the routing table. Names starting
     *  with `ibm-` are reserved for system-provided routes, and are not allowed.
     */
    name?: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to. For other
     *  `action` values, specify `0.0.0.0` or remove it by specifying `null`.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and `priority`,
     *  and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
     */
    nextHop?: RouteNextHopPatch;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVpcRoutingTables` operation. */
  export interface ListVpcRoutingTablesParams {
    /** The VPC identifier. */
    vpcId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to routing tables with an `is_default` property matching the specified value. */
    isDefault?: boolean;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createVpcRoutingTable` operation. */
  export interface CreateVpcRoutingTableParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The filters specifying the resources that may create routes in this routing table.
     *
     *  At present, only the `resource_type` filter is permitted, and only the `vpn_server` value is supported, but
     *  filter support is expected to expand in the future.
     */
    acceptRoutesFrom?: ResourceFilter[];
    /** The name for this routing table. The name must not be used by another routing table in the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** If set to `true`, this routing table will be used to route traffic that originates from [Direct
     *  Link](https://cloud.ibm.com/docs/dl) to this VPC. The VPC must not already have a routing table with this
     *  property set to `true`.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     *
     *  If [Classic Access](https://cloud.ibm.com/docs/vpc?topic=vpc-setting-up-access-to-classic-infrastructure) is
     *  enabled for this VPC, and this property is set to `true`, its incoming traffic will also be routed according to
     *  this routing table.
     */
    routeDirectLinkIngress?: boolean;
    /** If set to `true`, this routing table will be used to route traffic that originates from the internet. For
     *  this to succeed, the VPC must not already have a routing table with this property set to `true`.
     *
     *  Incoming traffic will be routed according to the routing table with two exceptions:
     *  - Traffic destined for IP addresses associated with public gateways will not be
     *    subject to routes in this routing table.
     *  - Routes with an action of deliver are treated as drop unless the `next_hop` is an
     *    IP address in a subnet in the route's `zone`. Therefore, if an incoming packet
     *    matches a route with a `next_hop` of an internet-bound IP address or a VPN gateway
     *    connection, the packet will be dropped.
     */
    routeInternetIngress?: boolean;
    /** If set to `true`, this routing table will be used to route traffic that originates from [Transit
     *  Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC. The VPC must not already have a routing table
     *  with this property set to `true`.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     */
    routeTransitGatewayIngress?: boolean;
    /** If set to `true`, this routing table will be used to route traffic that originates from subnets in other
     *  zones in this VPC. The VPC must not already have a routing table with this property set to `true`.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     */
    routeVpcZoneIngress?: boolean;
    /** The prototype objects for routes to create for this routing table. If unspecified, the routing table will be
     *  created with no routes.
     */
    routes?: RoutePrototype[];
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteVpcRoutingTable` operation. */
  export interface DeleteVpcRoutingTableParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpcRoutingTable` operation. */
  export interface GetVpcRoutingTableParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVpcRoutingTable` operation. */
  export interface UpdateVpcRoutingTableParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    id: string;
    /** The filters specifying the resources that may create routes in this routing table
     *  (replacing any existing filters). All routes created by resources that match a given filter will be removed when
     *  an existing filter is removed. Therefore, if an empty array is specified, all filters will be removed, resulting
     *  in all routes not directly created by the user being removed.
     *
     *  At present, only the `resource_type` filter is permitted, and only the `vpn_server` value is supported, but
     *  filter support is expected to expand in the future.
     */
    acceptRoutesFrom?: ResourceFilter[];
    /** The name for this routing table. The name must not be used by another routing table in the VPC. */
    name?: string;
    /** Indicates whether this routing table is used to route traffic that originates from
     *  [Direct Link](https://cloud.ibm.com/docs/dl/) to this VPC. Updating to `true` selects this routing table,
     *  provided no other routing table in the VPC already has this property set to `true`, and no subnets are attached
     *  to this routing table. Updating to
     *  `false` deselects this routing table.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     */
    routeDirectLinkIngress?: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from the internet.  Updating
     *  to `true` selects this routing table, provided no other routing table in the VPC already has this property set
     *  to `true`.  Updating to `false` deselects this routing table.
     *
     *  Incoming traffic will be routed according to the routing table with two exceptions:
     *  -  Traffic destined for IP addresses associated with public gateways will not be subject
     *     to routes in this routing table.
     *  -  Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is an
     *     IP address in a subnet in the route's `zone`. Therefore, if an incoming packet matches
     *     a route with a `next_hop` of an internet-bound IP address or a VPN gateway connection,
     *     the packet will be dropped.
     */
    routeInternetIngress?: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from
     *  [Transit Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC. Updating to
     *  `true` selects this routing table, provided no other routing table in the VPC already has this property set to
     *  `true`, and no subnets are attached to this routing table. Updating to `false` deselects this routing table.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     *
     *  If [Classic Access](https://cloud.ibm.com/docs/vpc?topic=vpc-setting-up-access-to-classic-infrastructure) is
     *  enabled for this VPC, and this property is set to `true`, its incoming traffic will also be routed according to
     *  this routing table.
     */
    routeTransitGatewayIngress?: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from subnets in other zones in
     *  this VPC. Updating to `true` selects this routing table, provided no other routing table in the VPC already has
     *  this property set to `true`, and no subnets are attached to this routing table. Updating to `false` deselects
     *  this routing table.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     */
    routeVpcZoneIngress?: boolean;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVpcRoutingTableRoutes` operation. */
  export interface ListVpcRoutingTableRoutesParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    routingTableId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createVpcRoutingTableRoute` operation. */
  export interface CreateVpcRoutingTableRouteParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    routingTableId: string;
    /** The destination CIDR of the route. The host identifier in the CIDR must be zero.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and
     *  `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
     */
    destination: string;
    /** The zone to apply the route to. (Traffic from subnets in this zone will be subject to this route.). */
    zone: ZoneIdentity;
    /** The action to perform with a packet matching the route:
     *  - `delegate`: delegate to system-provided routes
     *  - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
     *  - `deliver`: deliver the packet to the specified `next_hop`
     *  - `drop`: drop the packet.
     */
    action?: CreateVpcRoutingTableRouteConstants.Action | string;
    /** The name for this route. The name must not be used by another route in the routing table. Names starting
     *  with `ibm-` are reserved for system-provided routes, and are not allowed. If unspecified, the name will be a
     *  hyphenated list of randomly-selected words.
     */
    name?: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to. For other
     *  `action` values, it must be omitted or specified as `0.0.0.0`.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and `priority`,
     *  and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
     */
    nextHop?: RoutePrototypeNextHop;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createVpcRoutingTableRoute` operation. */
  export namespace CreateVpcRoutingTableRouteConstants {
    /** The action to perform with a packet matching the route: - `delegate`: delegate to system-provided routes - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes - `deliver`: deliver the packet to the specified `next_hop` - `drop`: drop the packet. */
    export enum Action {
      DELEGATE = 'delegate',
      DELEGATE_VPC = 'delegate_vpc',
      DELIVER = 'deliver',
      DROP = 'drop',
    }
  }

  /** Parameters for the `deleteVpcRoutingTableRoute` operation. */
  export interface DeleteVpcRoutingTableRouteParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    routingTableId: string;
    /** The VPC routing table route identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpcRoutingTableRoute` operation. */
  export interface GetVpcRoutingTableRouteParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    routingTableId: string;
    /** The VPC routing table route identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVpcRoutingTableRoute` operation. */
  export interface UpdateVpcRoutingTableRouteParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    routingTableId: string;
    /** The VPC routing table route identifier. */
    id: string;
    /** The name for this route. The name must not be used by another route in the routing table. Names starting
     *  with `ibm-` are reserved for system-provided routes, and are not allowed.
     */
    name?: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to. For other
     *  `action` values, specify `0.0.0.0` or remove it by specifying `null`.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and `priority`,
     *  and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
     */
    nextHop?: RouteNextHopPatch;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listSubnets` operation. */
  export interface ListSubnetsParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to subnets with a `routing_table.id` property matching the specified identifier. */
    routingTableId?: string;
    /** Filters the collection to subnets with a `routing_table.name` property matching the exact specified name. */
    routingTableName?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createSubnet` operation. */
  export interface CreateSubnetParams {
    /** The subnet prototype object. */
    subnetPrototype: SubnetPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSubnet` operation. */
  export interface DeleteSubnetParams {
    /** The subnet identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSubnet` operation. */
  export interface GetSubnetParams {
    /** The subnet identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateSubnet` operation. */
  export interface UpdateSubnetParams {
    /** The subnet identifier. */
    id: string;
    /** The name for this subnet. The name must not be used by another subnet in the VPC. */
    name?: string;
    /** The network ACL to use for this subnet. */
    networkAcl?: NetworkACLIdentity;
    /** The public gateway to use for internet-bound traffic for this subnet. */
    publicGateway?: SubnetPublicGatewayPatch;
    /** The routing table to use for this subnet.  The routing table properties
     *  `route_direct_link_ingress`, `route_internet_ingress`,
     *  `route_transit_gateway_ingress`, and `route_vpc_zone_ingress` must be `false`.
     */
    routingTable?: RoutingTableIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSubnetNetworkAcl` operation. */
  export interface GetSubnetNetworkAclParams {
    /** The subnet identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `replaceSubnetNetworkAcl` operation. */
  export interface ReplaceSubnetNetworkAclParams {
    /** The subnet identifier. */
    id: string;
    /** The network ACL identity. */
    networkAclIdentity: NetworkACLIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `unsetSubnetPublicGateway` operation. */
  export interface UnsetSubnetPublicGatewayParams {
    /** The subnet identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSubnetPublicGateway` operation. */
  export interface GetSubnetPublicGatewayParams {
    /** The subnet identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `setSubnetPublicGateway` operation. */
  export interface SetSubnetPublicGatewayParams {
    /** The subnet identifier. */
    id: string;
    /** The public gateway identity. */
    publicGatewayIdentity: PublicGatewayIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSubnetRoutingTable` operation. */
  export interface GetSubnetRoutingTableParams {
    /** The subnet identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `replaceSubnetRoutingTable` operation. */
  export interface ReplaceSubnetRoutingTableParams {
    /** The subnet identifier. */
    id: string;
    /** The routing table identity. */
    routingTableIdentity: RoutingTableIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listSubnetReservedIps` operation. */
  export interface ListSubnetReservedIpsParams {
    /** The subnet identifier. */
    subnetId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListSubnetReservedIpsConstants.Sort | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listSubnetReservedIps` operation. */
  export namespace ListSubnetReservedIpsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      ADDRESS = 'address',
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createSubnetReservedIp` operation. */
  export interface CreateSubnetReservedIpParams {
    /** The subnet identifier. */
    subnetId: string;
    /** The IP address to reserve, which must not already be reserved on the subnet.
     *
     *  If unspecified, an available address on the subnet will automatically be selected.
     */
    address?: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound. Must be `false` if the reserved IP is unbound.
     */
    autoDelete?: boolean;
    /** The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The target to bind this reserved IP to.  The target must be in the same VPC.
     *
     *  At present, only endpoint gateway targets are supported.  The endpoint gateway must
     *  not be already bound to a reserved IP in the subnet's zone.
     *
     *  If unspecified, the reserved IP will be created unbound.
     */
    target?: ReservedIPTargetPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSubnetReservedIp` operation. */
  export interface DeleteSubnetReservedIpParams {
    /** The subnet identifier. */
    subnetId: string;
    /** The reserved IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSubnetReservedIp` operation. */
  export interface GetSubnetReservedIpParams {
    /** The subnet identifier. */
    subnetId: string;
    /** The reserved IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateSubnetReservedIp` operation. */
  export interface UpdateSubnetReservedIpParams {
    /** The subnet identifier. */
    subnetId: string;
    /** The reserved IP identifier. */
    id: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound. Must be `false` if the reserved IP is unbound.
     */
    autoDelete?: boolean;
    /** The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listImages` operation. */
  export interface ListImagesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to images with a `status` property matching one of the specified comma-separated
     *  values.
     */
    status?: ListImagesConstants.Status[] | string[];
    /** Filters the collection to images with a `visibility` property matching the specified value. */
    visibility?: ListImagesConstants.Visibility | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listImages` operation. */
  export namespace ListImagesConstants {
    /** Filters the collection to images with a `status` property matching one of the specified comma-separated values. */
    export enum Status {
      AVAILABLE = 'available',
      DELETING = 'deleting',
      DEPRECATED = 'deprecated',
      FAILED = 'failed',
      OBSOLETE = 'obsolete',
      PENDING = 'pending',
      UNUSABLE = 'unusable',
    }
    /** Filters the collection to images with a `visibility` property matching the specified value. */
    export enum Visibility {
      PRIVATE = 'private',
      PUBLIC = 'public',
    }
  }

  /** Parameters for the `createImage` operation. */
  export interface CreateImageParams {
    /** The image prototype object. */
    imagePrototype: ImagePrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteImage` operation. */
  export interface DeleteImageParams {
    /** The image identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getImage` operation. */
  export interface GetImageParams {
    /** The image identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateImage` operation. */
  export interface UpdateImageParams {
    /** The image identifier. */
    id: string;
    /** The deprecation date and time to set for this image.
     *
     *  This cannot be set if the image has a `status` of `failed` or `deleting`, or if
     *  `catalog_offering.managed` is `true`.
     *
     *  The date and time must not be in the past, and must be earlier than `obsolescence_at`
     *  (if `obsolescence_at` is set). Additionally, if the image status is currently
     *  `deprecated`, the value cannot be changed (but may be removed).
     *
     *  Specify `null` to remove an existing deprecation date and time. If the image status is currently `deprecated`,
     *  it will become `available`.
     *
     *  If the deprecation date and time is reached while the image has a status of `pending`, the image's status will
     *  transition to `deprecated` upon its successful creation (or
     *  `obsolete` if the obsolescence date and time was also reached).
     */
    deprecationAt?: string;
    /** The name for this image. The name must not be used by another image in the region. Names starting with
     *  `ibm-` are reserved for system-provided images, and are not allowed.
     */
    name?: string;
    /** The obsolescence date and time to set for this image.
     *
     *  This cannot be set if the image has a `status` of `failed` or `deleting`, or if
     *  `catalog_offering.managed` is `true`.
     *
     *  The date and time must not be in the past, and must be later than `deprecation_at` (if
     *  `deprecation_at` is set). Additionally, if the image status is currently `obsolete`, the value cannot be changed
     *  (but may be removed).
     *
     *  Specify `null` to remove an existing obsolescence date and time. If the image status is currently `obsolete`, it
     *  will become `deprecated` if `deprecation_at` is in the past. Otherwise, it will become `available`.
     *
     *  If the obsolescence date and time is reached while the image has a status of `pending`, the image's status will
     *  transition to `obsolete` upon its successful creation.
     */
    obsolescenceAt?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deprecateImage` operation. */
  export interface DeprecateImageParams {
    /** The image identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `obsoleteImage` operation. */
  export interface ObsoleteImageParams {
    /** The image identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listImageExportJobs` operation. */
  export interface ListImageExportJobsParams {
    /** The image identifier. */
    imageId: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createImageExportJob` operation. */
  export interface CreateImageExportJobParams {
    /** The image identifier. */
    imageId: string;
    /** The Cloud Object Storage bucket to export the image to. The bucket must exist and an IAM
     *  service authorization must grant `Image Service for VPC` of
     *  `VPC Infrastructure Services` writer access to the bucket.
     */
    storageBucket: CloudObjectStorageBucketIdentity;
    /** The format to use for the exported image. If the image is encrypted, only `qcow2` is supported. */
    format?: CreateImageExportJobConstants.Format | string;
    /** The name for this image export job. The name must not be used by another export job for the image. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words prefixed with the first 16 characters
     *  of the parent image name.
     *
     *  The exported image object name in Cloud Object Storage (`storage_object.name` in the response) will be based on
     *  this name. The object name will be unique within the bucket.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createImageExportJob` operation. */
  export namespace CreateImageExportJobConstants {
    /** The format to use for the exported image. If the image is encrypted, only `qcow2` is supported. */
    export enum Format {
      QCOW2 = 'qcow2',
      VHD = 'vhd',
    }
  }

  /** Parameters for the `deleteImageExportJob` operation. */
  export interface DeleteImageExportJobParams {
    /** The image identifier. */
    imageId: string;
    /** The image export job identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getImageExportJob` operation. */
  export interface GetImageExportJobParams {
    /** The image identifier. */
    imageId: string;
    /** The image export job identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateImageExportJob` operation. */
  export interface UpdateImageExportJobParams {
    /** The image identifier. */
    imageId: string;
    /** The image export job identifier. */
    id: string;
    /** The name for this image export job. The name must not be used by another export job for the image. Changing
     *  the name will not affect the exported image name,
     *  `storage_object.name`, or `storage_href` values.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listOperatingSystems` operation. */
  export interface ListOperatingSystemsParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getOperatingSystem` operation. */
  export interface GetOperatingSystemParams {
    /** The operating system name. */
    name: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listKeys` operation. */
  export interface ListKeysParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createKey` operation. */
  export interface CreateKeyParams {
    /** A unique public SSH key to import, in OpenSSH format (consisting of three space-separated fields: the
     *  algorithm name, base64-encoded key, and a comment). The algorithm and comment fields may be omitted, as only the
     *  key field is imported.
     *
     *  Keys of type `rsa` may be 2048 or 4096 bits in length, however 4096 is recommended. Keys of type `ed25519` are
     *  256 bits in length.
     */
    publicKey: string;
    /** The name for this key. The name must not be used by another key in the region. If unspecified, the name will
     *  be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** The crypto-system used by this key. */
    type?: CreateKeyConstants.Type | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createKey` operation. */
  export namespace CreateKeyConstants {
    /** The crypto-system used by this key. */
    export enum Type {
      ED25519 = 'ed25519',
      RSA = 'rsa',
    }
  }

  /** Parameters for the `deleteKey` operation. */
  export interface DeleteKeyParams {
    /** The key identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getKey` operation. */
  export interface GetKeyParams {
    /** The key identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateKey` operation. */
  export interface UpdateKeyParams {
    /** The key identifier. */
    id: string;
    /** The name for this key. The name must not be used by another key in the region. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstanceProfiles` operation. */
  export interface ListInstanceProfilesParams {
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceProfile` operation. */
  export interface GetInstanceProfileParams {
    /** The instance profile name. */
    name: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstanceTemplates` operation. */
  export interface ListInstanceTemplatesParams {
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createInstanceTemplate` operation. */
  export interface CreateInstanceTemplateParams {
    /** The instance template prototype object. */
    instanceTemplatePrototype: InstanceTemplatePrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteInstanceTemplate` operation. */
  export interface DeleteInstanceTemplateParams {
    /** The instance template identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceTemplate` operation. */
  export interface GetInstanceTemplateParams {
    /** The instance template identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateInstanceTemplate` operation. */
  export interface UpdateInstanceTemplateParams {
    /** The instance template identifier. */
    id: string;
    /** The name for this instance template. The name must not be used by another instance template in the region. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstances` operation. */
  export interface ListInstancesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to resources with a `vpc.id` property matching the specified identifier. */
    vpcId?: string;
    /** Filters the collection to resources with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to resources with a `vpc.name` property matching the exact specified name. */
    vpcName?: string;
    /** Filters the collection to instances with a `dedicated_host.id` property matching the specified identifier. */
    dedicatedHostId?: string;
    /** Filters the collection to instances with a `dedicated_host.crn` property matching the specified CRN. */
    dedicatedHostCrn?: string;
    /** Filters the collection to instances with a `dedicated_host.name` property matching the exact specified name. */
    dedicatedHostName?: string;
    /** Filters the collection to instances with a `placement_target.id` property matching the specified placement
     *  group identifier.
     */
    placementGroupId?: string;
    /** Filters the collection to instances with a `placement_target.crn` property matching the specified placement
     *  group CRN.
     */
    placementGroupCrn?: string;
    /** Filters the collection to instances with a `placement_target.name` property matching the exact specified
     *  placement group name.
     */
    placementGroupName?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createInstance` operation. */
  export interface CreateInstanceParams {
    /** The instance prototype object. */
    instancePrototype: InstancePrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteInstance` operation. */
  export interface DeleteInstanceParams {
    /** The virtual server instance identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstance` operation. */
  export interface GetInstanceParams {
    /** The virtual server instance identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateInstance` operation. */
  export interface UpdateInstanceParams {
    /** The virtual server instance identifier. */
    id: string;
    /** The availability policy for this virtual server instance. */
    availabilityPolicy?: InstanceAvailabilityPolicyPatch;
    /** The metadata service configuration. */
    metadataService?: InstanceMetadataServicePatch;
    /** The name for this virtual server instance. The name must not be used by another virtual server instance in
     *  the region. Changing the name will not affect the system hostname.
     */
    name?: string;
    /** The placement restrictions to use for the virtual server instance. For the placement
     *  restrictions to be changed, the instance `status` must be `stopping` or `stopped`.
     */
    placementTarget?: InstancePlacementTargetPatch;
    /** The profile to use for this virtual server instance. For the profile to be changed,
     *  the instance `status` must be `stopping` or `stopped`. In addition, the requested
     *  profile must:
     *  - Have matching instance disk support. Any disks associated with the current profile
     *    will be deleted, and any disks associated with the requested profile will be
     *    created.
     *  - Be compatible with any `placement_target` constraints. For example, if the
     *    instance is placed on a dedicated host, the requested profile `family` must be
     *    the same as the dedicated host `family`.
     *  - Have the same `vcpu.architecture`.
     *  - Support the number of network interfaces the instance currently has.
     */
    profile?: InstancePatchProfile;
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An
     *  increase in this value will result in a corresponding decrease to
     *  `total_network_bandwidth`.
     */
    totalVolumeBandwidth?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceInitialization` operation. */
  export interface GetInstanceInitializationParams {
    /** The instance identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createInstanceAction` operation. */
  export interface CreateInstanceActionParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The type of action. */
    type: CreateInstanceActionConstants.Type | string;
    /** If set to true, the action will be forced immediately, and all queued actions deleted. Ignored for the start
     *  action.
     */
    force?: boolean;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createInstanceAction` operation. */
  export namespace CreateInstanceActionConstants {
    /** The type of action. */
    export enum Type {
      REBOOT = 'reboot',
      START = 'start',
      STOP = 'stop',
    }
  }

  /** Parameters for the `createInstanceConsoleAccessToken` operation. */
  export interface CreateInstanceConsoleAccessTokenParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance console type for which this token may be used. */
    consoleType: CreateInstanceConsoleAccessTokenConstants.ConsoleType | string;
    /** Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.
     *  This has no effect on VNC consoles.
     */
    force?: boolean;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createInstanceConsoleAccessToken` operation. */
  export namespace CreateInstanceConsoleAccessTokenConstants {
    /** The instance console type for which this token may be used. */
    export enum ConsoleType {
      SERIAL = 'serial',
      VNC = 'vnc',
    }
  }

  /** Parameters for the `listInstanceDisks` operation. */
  export interface ListInstanceDisksParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceDisk` operation. */
  export interface GetInstanceDiskParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance disk identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateInstanceDisk` operation. */
  export interface UpdateInstanceDiskParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance disk identifier. */
    id: string;
    /** The name for this instance disk. The name must not be used by another disk on the instance. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstanceNetworkInterfaces` operation. */
  export interface ListInstanceNetworkInterfacesParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createInstanceNetworkInterface` operation. */
  export interface CreateInstanceNetworkInterfaceParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The associated subnet. */
    subnet: SubnetIdentity;
    /** Indicates whether source IP spoofing is allowed on this instance interface. */
    allowIpSpoofing?: boolean;
    /** The name for the instance network interface. The name must not be used by another network interface on the
     *  virtual server instance. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The primary IP address to bind to the instance network interface. This can be
     *  specified using an existing reserved IP, or a prototype object for a new reserved IP.
     *
     *  If an existing reserved IP or a prototype object with an address is specified, it must
     *  be available on the instance network interface's subnet. Otherwise, an
     *  available address on the subnet will be automatically selected and reserved.
     */
    primaryIp?: NetworkInterfaceIPPrototype;
    /** The security groups to use for this instance network interface. If unspecified, the VPC's default security
     *  group is used.
     */
    securityGroups?: SecurityGroupIdentity[];
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteInstanceNetworkInterface` operation. */
  export interface DeleteInstanceNetworkInterfaceParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceNetworkInterface` operation. */
  export interface GetInstanceNetworkInterfaceParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateInstanceNetworkInterface` operation. */
  export interface UpdateInstanceNetworkInterfaceParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    id: string;
    /** Indicates whether source IP spoofing is allowed on this instance interface. */
    allowIpSpoofing?: boolean;
    /** The name for the instance network interface. The name must not be used by another network interface on the
     *  virtual server instance.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstanceNetworkInterfaceFloatingIps` operation. */
  export interface ListInstanceNetworkInterfaceFloatingIpsParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `removeInstanceNetworkInterfaceFloatingIp` operation. */
  export interface RemoveInstanceNetworkInterfaceFloatingIpParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceNetworkInterfaceFloatingIp` operation. */
  export interface GetInstanceNetworkInterfaceFloatingIpParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `addInstanceNetworkInterfaceFloatingIp` operation. */
  export interface AddInstanceNetworkInterfaceFloatingIpParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstanceNetworkInterfaceIps` operation. */
  export interface ListInstanceNetworkInterfaceIpsParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceNetworkInterfaceIp` operation. */
  export interface GetInstanceNetworkInterfaceIpParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
    /** The reserved IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstanceVolumeAttachments` operation. */
  export interface ListInstanceVolumeAttachmentsParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createInstanceVolumeAttachment` operation. */
  export interface CreateInstanceVolumeAttachmentParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** An existing volume to attach to the instance, or a prototype object for a new volume. */
    volume: VolumeAttachmentPrototypeVolume;
    /** Indicates whether deleting the instance will also delete the attached volume. */
    deleteVolumeOnInstanceDelete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteInstanceVolumeAttachment` operation. */
  export interface DeleteInstanceVolumeAttachmentParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The volume attachment identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceVolumeAttachment` operation. */
  export interface GetInstanceVolumeAttachmentParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The volume attachment identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateInstanceVolumeAttachment` operation. */
  export interface UpdateInstanceVolumeAttachmentParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The volume attachment identifier. */
    id: string;
    /** Indicates whether deleting the instance will also delete the attached volume. */
    deleteVolumeOnInstanceDelete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstanceGroups` operation. */
  export interface ListInstanceGroupsParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createInstanceGroup` operation. */
  export interface CreateInstanceGroupParams {
    /** Instance template to use when creating new instances.
     *
     *  Instance groups are not compatible with instance templates that specify `true` for
     *  `default_trusted_profile.auto_link`.
     */
    instanceTemplate: InstanceTemplateIdentity;
    /** The subnets to use when creating new instances. */
    subnets: SubnetIdentity[];
    /** The port to use for new load balancer pool members created by this instance group. The load balancer pool
     *  member will receive load balancer traffic on this port, unless the load balancer listener is using a port range.
     *  (Traffic received on a listener using a port range will be sent to members using the same port the listener
     *  received it on.)
     *
     *  This port will also be used for health checks unless the port property of
     *  `health_monitor` property is specified.
     *
     *  This property must be specified if and only if `load_balancer_pool` has been specified.
     */
    applicationPort?: number;
    /** The load balancer associated with the specified load balancer pool.
     *  Required if `load_balancer_pool` is specified. The load balancer must have
     *  `instance_groups_supported` set to `true`.
     */
    loadBalancer?: LoadBalancerIdentity;
    /** If specified, this instance group will manage the load balancer pool. A pool member
     *  will be created for each instance created by this group.  The specified load
     *  balancer pool must not be used by another instance group in the VPC.
     *
     *  If specified, `load_balancer` and `application_port` must also be specified.
     */
    loadBalancerPool?: LoadBalancerPoolIdentity;
    /** The number of instances in the instance group. */
    membershipCount?: number;
    /** The name for this instance group. The name must not be used by another instance group in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteInstanceGroup` operation. */
  export interface DeleteInstanceGroupParams {
    /** The instance group identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceGroup` operation. */
  export interface GetInstanceGroupParams {
    /** The instance group identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateInstanceGroup` operation. */
  export interface UpdateInstanceGroupParams {
    /** The instance group identifier. */
    id: string;
    /** The port to use for new load balancer pool members created by this instance group.
     *
     *  This property must be set if and only if `load_balancer_pool` has been set.
     */
    applicationPort?: number;
    /** Instance template to use when creating new instances.
     *
     *  Instance groups are not compatible with instance templates that specify `true` for
     *  `default_trusted_profile.auto_link`.
     */
    instanceTemplate?: InstanceTemplateIdentity;
    /** The load balancer associated with `load_balancer_pool`.
     *  The load balancer must have `instance_groups_supported` set to `true`.
     *
     *  This property must be set if and only if `load_balancer_pool` has been set.
     */
    loadBalancer?: LoadBalancerIdentity;
    /** If specified, this instance group will manage the load balancer pool. A pool member
     *  will be created for each instance created by this group.  The specified load
     *  balancer pool must not be used by another instance group in the VPC.
     *
     *  If set, `load_balancer` and `application_port` must also be set.
     */
    loadBalancerPool?: LoadBalancerPoolIdentity;
    /** The number of instances in the instance group. */
    membershipCount?: number;
    /** The name for this instance group. The name must not be used by another instance group in the region. */
    name?: string;
    /** The subnets to use when creating new instances. */
    subnets?: SubnetIdentity[];
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteInstanceGroupLoadBalancer` operation. */
  export interface DeleteInstanceGroupLoadBalancerParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstanceGroupManagers` operation. */
  export interface ListInstanceGroupManagersParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createInstanceGroupManager` operation. */
  export interface CreateInstanceGroupManagerParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager prototype object. */
    instanceGroupManagerPrototype: InstanceGroupManagerPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteInstanceGroupManager` operation. */
  export interface DeleteInstanceGroupManagerParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceGroupManager` operation. */
  export interface GetInstanceGroupManagerParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateInstanceGroupManager` operation. */
  export interface UpdateInstanceGroupManagerParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    id: string;
    /** The time window in seconds to aggregate metrics prior to evaluation. */
    aggregationWindow?: number;
    /** The duration of time in seconds to pause further scale actions after scaling has taken place. */
    cooldown?: number;
    /** Indicates whether this manager will control the instance group. */
    managementEnabled?: boolean;
    /** The maximum number of members in a managed instance group. */
    maxMembershipCount?: number;
    /** The minimum number of members in a managed instance group. */
    minMembershipCount?: number;
    /** The name for this instance group manager. The name must not be used by another manager for the instance
     *  group.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstanceGroupManagerActions` operation. */
  export interface ListInstanceGroupManagerActionsParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createInstanceGroupManagerAction` operation. */
  export interface CreateInstanceGroupManagerActionParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager action prototype object. */
    instanceGroupManagerActionPrototype: InstanceGroupManagerActionPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteInstanceGroupManagerAction` operation. */
  export interface DeleteInstanceGroupManagerActionParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager action identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceGroupManagerAction` operation. */
  export interface GetInstanceGroupManagerActionParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager action identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateInstanceGroupManagerAction` operation. */
  export interface UpdateInstanceGroupManagerActionParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager action identifier. */
    id: string;
    /** The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within
     *  a 5 min period.
     */
    cronSpec?: string;
    group?: InstanceGroupManagerActionGroupPatch;
    manager?: InstanceGroupManagerActionManagerPatch;
    /** The name for this instance group manager action. The name must not be used by another action for the
     *  instance group manager.
     */
    name?: string;
    /** The date and time the scheduled action will run. */
    runAt?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstanceGroupManagerPolicies` operation. */
  export interface ListInstanceGroupManagerPoliciesParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createInstanceGroupManagerPolicy` operation. */
  export interface CreateInstanceGroupManagerPolicyParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager policy prototype object. */
    instanceGroupManagerPolicyPrototype: InstanceGroupManagerPolicyPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteInstanceGroupManagerPolicy` operation. */
  export interface DeleteInstanceGroupManagerPolicyParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager policy identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceGroupManagerPolicy` operation. */
  export interface GetInstanceGroupManagerPolicyParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager policy identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateInstanceGroupManagerPolicy` operation. */
  export interface UpdateInstanceGroupManagerPolicyParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager policy identifier. */
    id: string;
    /** The type of metric to be evaluated. */
    metricType?: UpdateInstanceGroupManagerPolicyConstants.MetricType | string;
    /** The metric value to be evaluated. */
    metricValue?: number;
    /** The name for this instance group manager policy. The name must not be used by another policy for the
     *  instance group manager.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `updateInstanceGroupManagerPolicy` operation. */
  export namespace UpdateInstanceGroupManagerPolicyConstants {
    /** The type of metric to be evaluated. */
    export enum MetricType {
      CPU = 'cpu',
      MEMORY = 'memory',
      NETWORK_IN = 'network_in',
      NETWORK_OUT = 'network_out',
    }
  }

  /** Parameters for the `deleteInstanceGroupMemberships` operation. */
  export interface DeleteInstanceGroupMembershipsParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listInstanceGroupMemberships` operation. */
  export interface ListInstanceGroupMembershipsParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteInstanceGroupMembership` operation. */
  export interface DeleteInstanceGroupMembershipParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group membership identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getInstanceGroupMembership` operation. */
  export interface GetInstanceGroupMembershipParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group membership identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateInstanceGroupMembership` operation. */
  export interface UpdateInstanceGroupMembershipParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group membership identifier. */
    id: string;
    /** The name for this instance group membership. The name must not be used by another membership for the
     *  instance group manager.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listDedicatedHostGroups` operation. */
  export interface ListDedicatedHostGroupsParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `zone.name` property matching the exact specified name. */
    zoneName?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createDedicatedHostGroup` operation. */
  export interface CreateDedicatedHostGroupParams {
    /** The dedicated host profile class for hosts in this group. */
    _class: string;
    /** The dedicated host profile family for hosts in this group. */
    family: CreateDedicatedHostGroupConstants.Family | string;
    /** The zone this dedicated host group will reside in. */
    zone: ZoneIdentity;
    /** The name for this dedicated host group. The name must not be used by another dedicated host group in the
     *  region. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createDedicatedHostGroup` operation. */
  export namespace CreateDedicatedHostGroupConstants {
    /** The dedicated host profile family for hosts in this group. */
    export enum Family {
      BALANCED = 'balanced',
      COMPUTE = 'compute',
      MEMORY = 'memory',
    }
  }

  /** Parameters for the `deleteDedicatedHostGroup` operation. */
  export interface DeleteDedicatedHostGroupParams {
    /** The dedicated host group identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getDedicatedHostGroup` operation. */
  export interface GetDedicatedHostGroupParams {
    /** The dedicated host group identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateDedicatedHostGroup` operation. */
  export interface UpdateDedicatedHostGroupParams {
    /** The dedicated host group identifier. */
    id: string;
    /** The name for this dedicated host group. The name must not be used by another dedicated host group in the
     *  region.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listDedicatedHostProfiles` operation. */
  export interface ListDedicatedHostProfilesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getDedicatedHostProfile` operation. */
  export interface GetDedicatedHostProfileParams {
    /** The dedicated host profile name. */
    name: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listDedicatedHosts` operation. */
  export interface ListDedicatedHostsParams {
    /** Filters the collection to dedicated hosts with a `group.id` property matching the specified identifier. */
    dedicatedHostGroupId?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `zone.name` property matching the exact specified name. */
    zoneName?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createDedicatedHost` operation. */
  export interface CreateDedicatedHostParams {
    /** The dedicated host prototype object. */
    dedicatedHostPrototype: DedicatedHostPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listDedicatedHostDisks` operation. */
  export interface ListDedicatedHostDisksParams {
    /** The dedicated host identifier. */
    dedicatedHostId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getDedicatedHostDisk` operation. */
  export interface GetDedicatedHostDiskParams {
    /** The dedicated host identifier. */
    dedicatedHostId: string;
    /** The dedicated host disk identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateDedicatedHostDisk` operation. */
  export interface UpdateDedicatedHostDiskParams {
    /** The dedicated host identifier. */
    dedicatedHostId: string;
    /** The dedicated host disk identifier. */
    id: string;
    /** The name for this dedicated host disk. The name must not be used by another disk on the dedicated host. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteDedicatedHost` operation. */
  export interface DeleteDedicatedHostParams {
    /** The dedicated host identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getDedicatedHost` operation. */
  export interface GetDedicatedHostParams {
    /** The dedicated host identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateDedicatedHost` operation. */
  export interface UpdateDedicatedHostParams {
    /** The dedicated host identifier. */
    id: string;
    /** If set to true, instances can be placed on this dedicated host. */
    instancePlacementEnabled?: boolean;
    /** The name for this dedicated host. The name must not be used by another dedicated host in the region. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listBackupPolicies` operation. */
  export interface ListBackupPoliciesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to resources with an item in the `tags` property matching the exact specified tag. */
    tag?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createBackupPolicy` operation. */
  export interface CreateBackupPolicyParams {
    /** The user tags this backup policy will apply to. Resources that have both a matching user tag and a matching
     *  type will be subject to the backup policy.
     */
    matchUserTags: string[];
    /** The resource types this backup policy will apply to. Resources that have both a matching type and a matching
     *  user tag will be subject to the backup policy.
     */
    matchResourceTypes?: CreateBackupPolicyConstants.MatchResourceTypes | string[];
    /** The name for this backup policy. The name must not be used by another backup policy in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The prototype objects for backup plans to be created for this backup policy. */
    plans?: BackupPolicyPlanPrototype[];
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createBackupPolicy` operation. */
  export namespace CreateBackupPolicyConstants {
    /** The resource type. */
    export enum MatchResourceTypes {
      VOLUME = 'volume',
    }
  }

  /** Parameters for the `listBackupPolicyJobs` operation. */
  export interface ListBackupPolicyJobsParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** Filters the collection to backup policy jobs with a `status` property matching the specified value. */
    status?: ListBackupPolicyJobsConstants.Status | string;
    /** Filters the collection to backup policy jobs with a `backup_policy_plan.id` property matching the specified
     *  identifier.
     */
    backupPolicyPlanId?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListBackupPolicyJobsConstants.Sort | string;
    /** Filters the collection to backup policy jobs with a `source.id` property matching the specified identifier. */
    sourceId?: string;
    /** Filters the collection to backup policy jobs with an item in the `target_snapshots` property with an `id`
     *  property matching the specified identifier.
     */
    targetSnapshotsId?: string;
    /** Filters the collection to backup policy jobs with an item in the `target_snapshots` property with a `crn`
     *  property matching the specified CRN.
     */
    targetSnapshotsCrn?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listBackupPolicyJobs` operation. */
  export namespace ListBackupPolicyJobsConstants {
    /** Filters the collection to backup policy jobs with a `status` property matching the specified value. */
    export enum Status {
      FAILED = 'failed',
      RUNNING = 'running',
      SUCCEEDED = 'succeeded',
    }
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `getBackupPolicyJob` operation. */
  export interface GetBackupPolicyJobParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** The backup policy job identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listBackupPolicyPlans` operation. */
  export interface ListBackupPolicyPlansParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createBackupPolicyPlan` operation. */
  export interface CreateBackupPolicyPlanParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** The cron specification for the backup schedule. The backup policy jobs
     *  (which create and delete backups for this plan) will not start until this time, and may start for up to 90
     *  minutes after this time.
     *
     *  All backup schedules for plans in the same policy must be at least an hour apart.
     */
    cronSpec: string;
    /** Indicates whether the plan is active. */
    active?: boolean;
    /** User tags to attach to each backup (snapshot) created by this plan. If unspecified, no user tags will be
     *  attached.
     */
    attachUserTags?: string[];
    clonePolicy?: BackupPolicyPlanClonePolicyPrototype;
    /** Indicates whether to copy the source's user tags to the created backups (snapshots). */
    copyUserTags?: boolean;
    deletionTrigger?: BackupPolicyPlanDeletionTriggerPrototype;
    /** The name for this backup policy plan. The name must not be used by another plan for the backup policy. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The policies for additional backups in remote regions. */
    remoteRegionPolicies?: BackupPolicyPlanRemoteRegionPolicyPrototype[];
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteBackupPolicyPlan` operation. */
  export interface DeleteBackupPolicyPlanParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** The backup policy plan identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getBackupPolicyPlan` operation. */
  export interface GetBackupPolicyPlanParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** The backup policy plan identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateBackupPolicyPlan` operation. */
  export interface UpdateBackupPolicyPlanParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** The backup policy plan identifier. */
    id: string;
    /** Indicates whether the plan is active. */
    active?: boolean;
    /** The user tags to attach to backups (snapshots) created by this plan. Updating this value does not change the
     *  user tags for backups that have already been created by this plan.
     */
    attachUserTags?: string[];
    clonePolicy?: BackupPolicyPlanClonePolicyPatch;
    /** Indicates whether to copy the source's user tags to the created backups (snapshots). */
    copyUserTags?: boolean;
    /** The cron specification for the backup schedule. The backup policy jobs
     *  (which create and delete backups for this plan) will not start until this time, and may start for up to 90
     *  minutes after this time.
     *
     *  All backup schedules for plans in the same policy must be at least an hour apart.
     */
    cronSpec?: string;
    deletionTrigger?: BackupPolicyPlanDeletionTriggerPatch;
    /** The name for this backup policy plan. The name must not be used by another plan for the backup policy. */
    name?: string;
    /** The policies for additional backups in remote regions (replacing any existing policies). */
    remoteRegionPolicies?: BackupPolicyPlanRemoteRegionPolicyPrototype[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteBackupPolicy` operation. */
  export interface DeleteBackupPolicyParams {
    /** The backup policy identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getBackupPolicy` operation. */
  export interface GetBackupPolicyParams {
    /** The backup policy identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateBackupPolicy` operation. */
  export interface UpdateBackupPolicyParams {
    /** The backup policy identifier. */
    id: string;
    /** The user tags this backup policy will apply to (replacing any existing tags). Resources that have both a
     *  matching user tag and a matching type will be subject to the backup policy.
     */
    matchUserTags?: string[];
    /** The name for this backup policy. The name must not be used by another backup policy in the region. */
    name?: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listPlacementGroups` operation. */
  export interface ListPlacementGroupsParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createPlacementGroup` operation. */
  export interface CreatePlacementGroupParams {
    /** The strategy for this placement group
     *  - `host_spread`: place on different compute hosts
     *  - `power_spread`: place on compute hosts that use different power sources
     *
     *  The enumerated values for this property may expand in the future. When processing this property, check for and
     *  log unknown values. Optionally halt processing and surface the error, or bypass the placement group on which the
     *  unexpected strategy was encountered.
     */
    strategy: CreatePlacementGroupConstants.Strategy | string;
    /** The name for this placement group. The name must not be used by another placement group in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createPlacementGroup` operation. */
  export namespace CreatePlacementGroupConstants {
    /** The strategy for this placement group - `host_spread`: place on different compute hosts - `power_spread`: place on compute hosts that use different power sources The enumerated values for this property may expand in the future. When processing this property, check for and log unknown values. Optionally halt processing and surface the error, or bypass the placement group on which the unexpected strategy was encountered. */
    export enum Strategy {
      HOST_SPREAD = 'host_spread',
      POWER_SPREAD = 'power_spread',
    }
  }

  /** Parameters for the `deletePlacementGroup` operation. */
  export interface DeletePlacementGroupParams {
    /** The placement group identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getPlacementGroup` operation. */
  export interface GetPlacementGroupParams {
    /** The placement group identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updatePlacementGroup` operation. */
  export interface UpdatePlacementGroupParams {
    /** The placement group identifier. */
    id: string;
    /** The name for this placement group. The name must not be used by another placement group in the region. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listBareMetalServerProfiles` operation. */
  export interface ListBareMetalServerProfilesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getBareMetalServerProfile` operation. */
  export interface GetBareMetalServerProfileParams {
    /** The bare metal server profile name. */
    name: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listBareMetalServers` operation. */
  export interface ListBareMetalServersParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to resources with a `vpc.id` property matching the specified identifier. */
    vpcId?: string;
    /** Filters the collection to resources with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to resources with a `vpc.name` property matching the exact specified name. */
    vpcName?: string;
    /** Filters the collection to bare metal servers with an item in the `network_interfaces` property with a
     *  `subnet.id` property matching the specified identifier.
     */
    networkInterfacesSubnetId?: string;
    /** Filters the collection to bare metal servers with an item in the `network_interfaces` property with a
     *  `subnet.crn` property matching the specified CRN.
     */
    networkInterfacesSubnetCrn?: string;
    /** Filters the collection to bare metal servers with an item in the `network_interfaces` property with a
     *  `subnet.name` property matching the exact specified name.
     */
    networkInterfacesSubnetName?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createBareMetalServer` operation. */
  export interface CreateBareMetalServerParams {
    initialization: BareMetalServerInitializationPrototype;
    /** The primary bare metal server network interface to create. */
    primaryNetworkInterface: BareMetalServerPrimaryNetworkInterfacePrototype;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
     *  to use for this bare metal server.
     */
    profile: BareMetalServerProfileIdentity;
    /** The zone this bare metal server will reside in. */
    zone: ZoneIdentity;
    /** Indicates whether secure boot is enabled. If enabled, the image must support secure boot or the server will
     *  fail to boot.
     */
    enableSecureBoot?: boolean;
    /** The name for this bare metal server. The name must not be used by another bare metal server in the region.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     *
     *  The system hostname will be based on this name.
     */
    name?: string;
    /** The additional bare metal server network interfaces to create. */
    networkInterfaces?: BareMetalServerNetworkInterfacePrototype[];
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    trustedPlatformModule?: BareMetalServerTrustedPlatformModulePrototype;
    /** The VPC this bare metal server will reside in.
     *
     *  If specified, it must match the VPC for the subnets that the network interfaces of
     *  the bare metal server are attached to.
     */
    vpc?: VPCIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createBareMetalServerConsoleAccessToken` operation. */
  export interface CreateBareMetalServerConsoleAccessTokenParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server console type for which this token may be used
     *
     *  Must be `serial` for bare metal servers with a `cpu.architecture` of `s390x`.
     */
    consoleType: CreateBareMetalServerConsoleAccessTokenConstants.ConsoleType | string;
    /** Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.
     *  This has no effect on VNC consoles.
     */
    force?: boolean;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createBareMetalServerConsoleAccessToken` operation. */
  export namespace CreateBareMetalServerConsoleAccessTokenConstants {
    /** The bare metal server console type for which this token may be used Must be `serial` for bare metal servers with a `cpu.architecture` of `s390x`. */
    export enum ConsoleType {
      SERIAL = 'serial',
      VNC = 'vnc',
    }
  }

  /** Parameters for the `listBareMetalServerDisks` operation. */
  export interface ListBareMetalServerDisksParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getBareMetalServerDisk` operation. */
  export interface GetBareMetalServerDiskParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server disk identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateBareMetalServerDisk` operation. */
  export interface UpdateBareMetalServerDiskParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server disk identifier. */
    id: string;
    /** The name for this bare metal server disk. The name must not be used by another disk on the bare metal
     *  server.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listBareMetalServerNetworkInterfaces` operation. */
  export interface ListBareMetalServerNetworkInterfacesParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createBareMetalServerNetworkInterface` operation. */
  export interface CreateBareMetalServerNetworkInterfaceParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface prototype object. */
    bareMetalServerNetworkInterfacePrototype: BareMetalServerNetworkInterfacePrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteBareMetalServerNetworkInterface` operation. */
  export interface DeleteBareMetalServerNetworkInterfaceParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getBareMetalServerNetworkInterface` operation. */
  export interface GetBareMetalServerNetworkInterfaceParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateBareMetalServerNetworkInterface` operation. */
  export interface UpdateBareMetalServerNetworkInterfaceParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    id: string;
    /** Indicates whether source IP spoofing is allowed on this bare metal server network interface. */
    allowIpSpoofing?: boolean;
    /** Indicates what VLAN IDs (for VLAN type only) can use this physical (PCI type) interface. */
    allowedVlans?: number[];
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the bare metal server network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - `interface_type` must not be `hipersocket`.
     */
    enableInfrastructureNat?: boolean;
    /** The name for this bare metal server network interface. The name must not be used by another network
     *  interface on the bare metal server.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listBareMetalServerNetworkInterfaceFloatingIps` operation. */
  export interface ListBareMetalServerNetworkInterfaceFloatingIpsParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `removeBareMetalServerNetworkInterfaceFloatingIp` operation. */
  export interface RemoveBareMetalServerNetworkInterfaceFloatingIpParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getBareMetalServerNetworkInterfaceFloatingIp` operation. */
  export interface GetBareMetalServerNetworkInterfaceFloatingIpParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `addBareMetalServerNetworkInterfaceFloatingIp` operation. */
  export interface AddBareMetalServerNetworkInterfaceFloatingIpParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listBareMetalServerNetworkInterfaceIps` operation. */
  export interface ListBareMetalServerNetworkInterfaceIpsParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getBareMetalServerNetworkInterfaceIp` operation. */
  export interface GetBareMetalServerNetworkInterfaceIpParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
    /** The reserved IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteBareMetalServer` operation. */
  export interface DeleteBareMetalServerParams {
    /** The bare metal server identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getBareMetalServer` operation. */
  export interface GetBareMetalServerParams {
    /** The bare metal server identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateBareMetalServer` operation. */
  export interface UpdateBareMetalServerParams {
    /** The bare metal server identifier. */
    id: string;
    /** Indicates whether secure boot is enabled. If enabled, the image must support secure boot or the bare metal
     *  server will fail to boot.
     *
     *  For `enable_secure_boot` to be changed, the bare metal server `status` must be
     *  `stopped`.
     */
    enableSecureBoot?: boolean;
    /** The name for this bare metal server. The name must not be used by another bare metal server in the region.
     *  Changing the name will not affect the system hostname.
     */
    name?: string;
    trustedPlatformModule?: BareMetalServerTrustedPlatformModulePatch;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getBareMetalServerInitialization` operation. */
  export interface GetBareMetalServerInitializationParams {
    /** The bare metal server identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `restartBareMetalServer` operation. */
  export interface RestartBareMetalServerParams {
    /** The bare metal server identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `startBareMetalServer` operation. */
  export interface StartBareMetalServerParams {
    /** The bare metal server identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `stopBareMetalServer` operation. */
  export interface StopBareMetalServerParams {
    /** The bare metal server identifier. */
    id: string;
    /** The type of stop operation:
     *  - `soft`: signal running operating system to quiesce and shutdown cleanly
     *  - `hard`: immediately stop the server.
     */
    type: StopBareMetalServerConstants.Type | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `stopBareMetalServer` operation. */
  export namespace StopBareMetalServerConstants {
    /** The type of stop operation: - `soft`: signal running operating system to quiesce and shutdown cleanly - `hard`: immediately stop the server. */
    export enum Type {
      HARD = 'hard',
      SOFT = 'soft',
    }
  }

  /** Parameters for the `listVolumeProfiles` operation. */
  export interface ListVolumeProfilesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVolumeProfile` operation. */
  export interface GetVolumeProfileParams {
    /** The volume profile name. */
    name: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVolumes` operation. */
  export interface ListVolumesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to volumes with an `attachment_state` property matching the specified value. */
    attachmentState?: ListVolumesConstants.AttachmentState | string;
    /** Filters the collection to resources with an `encryption` property matching the specified value. */
    encryption?: ListVolumesConstants.Encryption | string;
    /** Filters the collection to resources with an `operating_system.family` property matching the specified
     *  operating system family.
     *
     *  This parameter also supports the values `null` and `not:null` which filter the collection to resources which
     *  have no operating system or any operating system, respectively.
     */
    operatingSystemFamily?: string;
    /** Filters the collection to resources with an `operating_system.architecture` property matching the specified
     *  operating system architecture.
     *
     *  This parameter also supports the values `null` and `not:null` which filter the collection to resources which
     *  have no operating system or any operating system, respectively.
     */
    operatingSystemArchitecture?: string;
    /** Filters the collection to resources with a `zone.name` property matching the exact specified name. */
    zoneName?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listVolumes` operation. */
  export namespace ListVolumesConstants {
    /** Filters the collection to volumes with an `attachment_state` property matching the specified value. */
    export enum AttachmentState {
      ATTACHED = 'attached',
      UNATTACHED = 'unattached',
      UNUSABLE = 'unusable',
    }
    /** Filters the collection to resources with an `encryption` property matching the specified value. */
    export enum Encryption {
      PROVIDER_MANAGED = 'provider_managed',
      USER_MANAGED = 'user_managed',
    }
  }

  /** Parameters for the `createVolume` operation. */
  export interface CreateVolumeParams {
    /** The volume prototype object. */
    volumePrototype: VolumePrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteVolume` operation. */
  export interface DeleteVolumeParams {
    /** The volume identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVolume` operation. */
  export interface GetVolumeParams {
    /** The volume identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVolume` operation. */
  export interface UpdateVolumeParams {
    /** The volume identifier. */
    id: string;
    /** The capacity to use for the volume (in gigabytes). The volume must be attached to a running virtual server
     *  instance, and the specified value must not be less than the current capacity. Additionally, if the volume is
     *  attached as a boot volume, the maximum value is 250 gigabytes.
     *
     *  The minimum and maximum capacity limits for creating or updating volumes may expand in the future.
     */
    capacity?: number;
    /** The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a
     *  profile `family` of `custom`. The volume must be attached as a data volume to a running virtual server instance.
     */
    iops?: number;
    /** The name for this volume. The name must not be used by another volume in the region. */
    name?: string;
    /** The profile to use for this volume. The requested profile must be in the same
     *  `family` as the current profile. The volume must be attached as a data volume to
     *  a running virtual server instance, and must have a `capacity` within the range
     *  supported by the specified profile.
     */
    profile?: VolumeProfileIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume. */
    userTags?: string[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSnapshots` operation. */
  export interface DeleteSnapshotsParams {
    /** Filters the collection to resources with a `source_volume.id` property matching the specified identifier. */
    sourceVolumeId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listSnapshots` operation. */
  export interface ListSnapshotsParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with an item in the `tags` property matching the exact specified tag. */
    tag?: string;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to resources with a `source_volume.id` property matching the specified identifier. */
    sourceVolumeId?: string;
    /** Filters the collection to resources with a `source_volume.crn` property matching the specified CRN. */
    sourceVolumeCrn?: string;
    /** Filters the collection to resources with a `source_image.id` property matching the specified identifier.
     *
     *  This parameter also supports the values `null` and `not:null` which filter the collection to resources which
     *  have no source image or any existent source image, respectively.
     */
    sourceImageId?: string;
    /** Filters the collection to resources with a `source_image.crn` property matching the specified CRN.
     *
     *  This parameter also supports the values `null` and `not:null` which filter the collection to resources which
     *  have no source image or any existent source image, respectively.
     */
    sourceImageCrn?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListSnapshotsConstants.Sort | string;
    /** Filters the collection to backup policy jobs with a `backup_policy_plan.id` property matching the specified
     *  identifier.
     */
    backupPolicyPlanId?: string;
    /** Filters the collection to snapshots with an item in the `copies` property with an `id` property matching the
     *  specified identifier.
     */
    copiesId?: string;
    /** Filters the collection to snapshots with an item in the `copies` property with a `name` property matching
     *  the exact specified name.
     */
    copiesName?: string;
    /** Filters the collection to snapshots with an item in the `copies` property with an `id` property matching the
     *  specified CRN.
     */
    copiesCrn?: string;
    /** Filters the collection to snapshots with an item in the `copies` property with a
     *  `remote.region.name` property matching the exact specified name.
     */
    copiesRemoteRegionName?: string;
    /** Filters the collection to resources with a `source_snapshot.id` property matching the specified identifier. */
    sourceSnapshotId?: string;
    /** Filters the collection to resources with a `source_snapshot.remote.region.name` property matching the exact
     *  specified name.
     */
    sourceSnapshotRemoteRegionName?: string;
    /** Filters the collection to resources with a `source_volume.remote.region.name` property matching the exact
     *  specified name.
     */
    sourceVolumeRemoteRegionName?: string;
    /** Filters the collection to resources with a `source_image.remote.region.name` property matching the exact
     *  specified name.
     */
    sourceImageRemoteRegionName?: string;
    /** Filters the collection to snapshots with an item in the `clones` property with a `zone.name` property
     *  matching the exact specified name.
     */
    clonesZoneName?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listSnapshots` operation. */
  export namespace ListSnapshotsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createSnapshot` operation. */
  export interface CreateSnapshotParams {
    /** The snapshot prototype object. */
    snapshotPrototype: SnapshotPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSnapshot` operation. */
  export interface DeleteSnapshotParams {
    /** The snapshot identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSnapshot` operation. */
  export interface GetSnapshotParams {
    /** The snapshot identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateSnapshot` operation. */
  export interface UpdateSnapshotParams {
    /** The snapshot identifier. */
    id: string;
    /** The name for this snapshot. The name must not be used by another snapshot in the region. */
    name?: string;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot. */
    userTags?: string[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listSnapshotClones` operation. */
  export interface ListSnapshotClonesParams {
    /** The snapshot identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSnapshotClone` operation. */
  export interface DeleteSnapshotCloneParams {
    /** The snapshot identifier. */
    id: string;
    /** The zone name. */
    zoneName: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSnapshotClone` operation. */
  export interface GetSnapshotCloneParams {
    /** The snapshot identifier. */
    id: string;
    /** The zone name. */
    zoneName: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createSnapshotClone` operation. */
  export interface CreateSnapshotCloneParams {
    /** The snapshot identifier. */
    id: string;
    /** The zone name. */
    zoneName: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listShareProfiles` operation. */
  export interface ListShareProfilesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListShareProfilesConstants.Sort | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listShareProfiles` operation. */
  export namespace ListShareProfilesConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `getShareProfile` operation. */
  export interface GetShareProfileParams {
    /** The file share profile name. */
    name: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listShares` operation. */
  export interface ListSharesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListSharesConstants.Sort | string;
    /** Filters the collection to file shares with a `replication_role` property matching the specified value. */
    replicationRole?: ListSharesConstants.ReplicationRole | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listShares` operation. */
  export namespace ListSharesConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
    /** Filters the collection to file shares with a `replication_role` property matching the specified value. */
    export enum ReplicationRole {
      NONE = 'none',
      REPLICA = 'replica',
      SOURCE = 'source',
    }
  }

  /** Parameters for the `createShare` operation. */
  export interface CreateShareParams {
    /** The file share prototype object. */
    sharePrototype: SharePrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteShare` operation. */
  export interface DeleteShareParams {
    /** The file share identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getShare` operation. */
  export interface GetShareParams {
    /** The file share identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateShare` operation. */
  export interface UpdateShareParams {
    /** The file share identifier. */
    id: string;
    /** The access control mode for the share:
     *
     *  - `security_group`: The security groups on the virtual network interface for a
     *    mount target control access to the mount target.
     *  - `vpc`: All clients in the VPC for a mount target have access to the mount target.
     *
     *  For this property to be changed, the share must have no mount targets and
     *  `replication_role` must be `none`.
     */
    accessControlMode?: UpdateShareConstants.AccessControlMode | string;
    /** The maximum input/output operations per second (IOPS) for the file share. The value must be in the range
     *  supported by the share's size.
     *
     *  For this property to be changed, the share `lifecycle_state` must be `stable`.
     */
    iops?: number;
    /** The name for this share. The name must not be used by another share in the region. */
    name?: string;
    /** The profile to use for this file share.
     *
     *  The requested profile must be in the same `family`.
     */
    profile?: ShareProfileIdentity;
    /** The cron specification for the file share replication schedule.
     *
     *  Replication of a share can be scheduled to occur at most once per hour.
     *
     *  For this property to be changed, the share `replication_role` must be `replica`.
     */
    replicationCronSpec?: string;
    /** The size of the file share rounded up to the next gigabyte. The value must not be less than the share's
     *  current size, and must not exceed the maximum supported by the share's profile and IOPS.
     *
     *  For this property to be changed, the share `lifecycle_state` must be `stable`.
     */
    size?: number;
    /** Tags for this resource. */
    userTags?: string[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `updateShare` operation. */
  export namespace UpdateShareConstants {
    /** The access control mode for the share: - `security_group`: The security groups on the virtual network interface for a mount target control access to the mount target. - `vpc`: All clients in the VPC for a mount target have access to the mount target. For this property to be changed, the share must have no mount targets and `replication_role` must be `none`. */
    export enum AccessControlMode {
      SECURITY_GROUP = 'security_group',
      VPC = 'vpc',
    }
  }

  /** Parameters for the `failoverShare` operation. */
  export interface FailoverShareParams {
    /** The file share identifier. */
    shareId: string;
    /** The action to take if the failover request is accepted but cannot be performed or times out:
     *  - `fail`: Fail the operation, resulting in the replication relationship being unchanged.
     *  - `split`: Split the replica from its source, resulting in two individual read-write
     *      file shares. Because the final sync was not completed, the replica may be
     *      out-of-date. This is useful in disaster recovery scenarios where the source is known
     *      to be unreachable.
     */
    fallbackPolicy?: FailoverShareConstants.FallbackPolicy | string;
    /** The failover timeout in seconds.
     *
     *  If the timeout is reached, the `fallback_policy` will be triggered.
     */
    timeout?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `failoverShare` operation. */
  export namespace FailoverShareConstants {
    /** The action to take if the failover request is accepted but cannot be performed or times out: - `fail`: Fail the operation, resulting in the replication relationship being unchanged. - `split`: Split the replica from its source, resulting in two individual read-write file shares. Because the final sync was not completed, the replica may be out-of-date. This is useful in disaster recovery scenarios where the source is known to be unreachable. */
    export enum FallbackPolicy {
      FAIL = 'fail',
      SPLIT = 'split',
    }
  }

  /** Parameters for the `listShareMountTargets` operation. */
  export interface ListShareMountTargetsParams {
    /** The file share identifier. */
    shareId: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createShareMountTarget` operation. */
  export interface CreateShareMountTargetParams {
    /** The file share identifier. */
    shareId: string;
    /** The share mount target prototype object. */
    shareMountTargetPrototype: ShareMountTargetPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteShareMountTarget` operation. */
  export interface DeleteShareMountTargetParams {
    /** The file share identifier. */
    shareId: string;
    /** The share mount target identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getShareMountTarget` operation. */
  export interface GetShareMountTargetParams {
    /** The file share identifier. */
    shareId: string;
    /** The share mount target identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateShareMountTarget` operation. */
  export interface UpdateShareMountTargetParams {
    /** The file share identifier. */
    shareId: string;
    /** The share mount target identifier. */
    id: string;
    /** The name for this share mount target. The name must not be used by another mount target for the file share. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteShareSource` operation. */
  export interface DeleteShareSourceParams {
    /** The file share identifier. */
    shareId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getShareSource` operation. */
  export interface GetShareSourceParams {
    /** The file share identifier. */
    shareId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listRegions` operation. */
  export interface ListRegionsParams {
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getRegion` operation. */
  export interface GetRegionParams {
    /** The region name. */
    name: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listRegionZones` operation. */
  export interface ListRegionZonesParams {
    /** The region name. */
    regionName: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getRegionZone` operation. */
  export interface GetRegionZoneParams {
    /** The region name. */
    regionName: string;
    /** The zone name. */
    name: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVirtualNetworkInterfaces` operation. */
  export interface ListVirtualNetworkInterfacesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVirtualNetworkInterface` operation. */
  export interface GetVirtualNetworkInterfaceParams {
    /** The virtual network interface identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVirtualNetworkInterface` operation. */
  export interface UpdateVirtualNetworkInterfaceParams {
    /** The virtual network interface identifier. */
    id: string;
    /** The name for this virtual network interface. The name is unique across all virtual network interfaces in the
     *  VPC.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listPublicGateways` operation. */
  export interface ListPublicGatewaysParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createPublicGateway` operation. */
  export interface CreatePublicGatewayParams {
    /** The VPC this public gateway will reside in. */
    vpc: VPCIdentity;
    /** The zone this public gateway will reside in. */
    zone: ZoneIdentity;
    floatingIp?: PublicGatewayFloatingIPPrototype;
    /** The name for this public gateway. The name must not be used by another public gateway in the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deletePublicGateway` operation. */
  export interface DeletePublicGatewayParams {
    /** The public gateway identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getPublicGateway` operation. */
  export interface GetPublicGatewayParams {
    /** The public gateway identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updatePublicGateway` operation. */
  export interface UpdatePublicGatewayParams {
    /** The public gateway identifier. */
    id: string;
    /** The name for this public gateway. The name must not be used by another public gateway in the VPC. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listFloatingIps` operation. */
  export interface ListFloatingIpsParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListFloatingIpsConstants.Sort | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listFloatingIps` operation. */
  export namespace ListFloatingIpsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createFloatingIp` operation. */
  export interface CreateFloatingIpParams {
    /** The floating IP prototype object. */
    floatingIpPrototype: FloatingIPPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteFloatingIp` operation. */
  export interface DeleteFloatingIpParams {
    /** The floating IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getFloatingIp` operation. */
  export interface GetFloatingIpParams {
    /** The floating IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateFloatingIp` operation. */
  export interface UpdateFloatingIpParams {
    /** The floating IP identifier. */
    id: string;
    /** The name for this floating IP. The name must not be used by another floating IP in the region. */
    name?: string;
    /** The target resource to bind this floating IP to, replacing any existing binding.
     *  The floating IP must not be required by another resource, such as a public gateway.
     *
     *  The target resource must not already have a floating IP bound to it if the target
     *  resource is:
     *
     *  - an instance network interface
     *  - a bare metal server network interface with `enable_infrastructure_nat` set to `true`.
     */
    target?: FloatingIPTargetPatch;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listNetworkAcls` operation. */
  export interface ListNetworkAclsParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createNetworkAcl` operation. */
  export interface CreateNetworkAclParams {
    /** The network ACL prototype object. */
    networkAclPrototype: NetworkACLPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteNetworkAcl` operation. */
  export interface DeleteNetworkAclParams {
    /** The network ACL identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getNetworkAcl` operation. */
  export interface GetNetworkAclParams {
    /** The network ACL identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateNetworkAcl` operation. */
  export interface UpdateNetworkAclParams {
    /** The network ACL identifier. */
    id: string;
    /** The name for this network ACL. The name must not be used by another network ACL for the VPC. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listNetworkAclRules` operation. */
  export interface ListNetworkAclRulesParams {
    /** The network ACL identifier. */
    networkAclId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to rules with a `direction` property matching the specified value. */
    direction?: ListNetworkAclRulesConstants.Direction | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listNetworkAclRules` operation. */
  export namespace ListNetworkAclRulesConstants {
    /** Filters the collection to rules with a `direction` property matching the specified value. */
    export enum Direction {
      INBOUND = 'inbound',
      OUTBOUND = 'outbound',
    }
  }

  /** Parameters for the `createNetworkAclRule` operation. */
  export interface CreateNetworkAclRuleParams {
    /** The network ACL identifier. */
    networkAclId: string;
    /** The network ACL rule prototype object. */
    networkAclRulePrototype: NetworkACLRulePrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteNetworkAclRule` operation. */
  export interface DeleteNetworkAclRuleParams {
    /** The network ACL identifier. */
    networkAclId: string;
    /** The rule identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getNetworkAclRule` operation. */
  export interface GetNetworkAclRuleParams {
    /** The network ACL identifier. */
    networkAclId: string;
    /** The rule identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateNetworkAclRule` operation. */
  export interface UpdateNetworkAclRuleParams {
    /** The network ACL identifier. */
    networkAclId: string;
    /** The rule identifier. */
    id: string;
    /** The action to perform for a packet matching the rule. */
    action?: UpdateNetworkAclRuleConstants.Action | string;
    /** The rule to move this rule immediately before.
     *
     *  Specify `null` to move this rule after all existing rules.
     */
    before?: NetworkACLRuleBeforePatch;
    /** The ICMP traffic code to match. If set, `type` must also be set.
     *
     *  Specify `null` to remove an existing ICMP traffic code.
     */
    code?: number;
    /** The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination
     *  addresses.
     */
    destination?: string;
    /** The inclusive upper bound of TCP/UDP destination port range. */
    destinationPortMax?: number;
    /** The inclusive lower bound of TCP/UDP destination port range. */
    destinationPortMin?: number;
    /** The direction of traffic to match. */
    direction?: UpdateNetworkAclRuleConstants.Direction | string;
    /** The name for this network ACL rule. The name must not be used by another rule for the network ACL. */
    name?: string;
    /** The protocol to enforce. */
    protocol?: UpdateNetworkAclRuleConstants.Protocol | string;
    /** The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses. */
    source?: string;
    /** The inclusive upper bound of TCP/UDP source port range. */
    sourcePortMax?: number;
    /** The inclusive lower bound of TCP/UDP source port range. */
    sourcePortMin?: number;
    /** The ICMP traffic type to match.
     *
     *  Specify `null` to remove an existing ICMP traffic type value.
     */
    type?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `updateNetworkAclRule` operation. */
  export namespace UpdateNetworkAclRuleConstants {
    /** The action to perform for a packet matching the rule. */
    export enum Action {
      ALLOW = 'allow',
      DENY = 'deny',
    }
    /** The direction of traffic to match. */
    export enum Direction {
      INBOUND = 'inbound',
      OUTBOUND = 'outbound',
    }
    /** The protocol to enforce. */
    export enum Protocol {
      ALL = 'all',
      ICMP = 'icmp',
      TCP = 'tcp',
      UDP = 'udp',
    }
  }

  /** Parameters for the `listSecurityGroups` operation. */
  export interface ListSecurityGroupsParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `vpc.id` property matching the specified identifier. */
    vpcId?: string;
    /** Filters the collection to resources with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to resources with a `vpc.name` property matching the exact specified name. */
    vpcName?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createSecurityGroup` operation. */
  export interface CreateSecurityGroupParams {
    /** The VPC this security group will reside in. */
    vpc: VPCIdentity;
    /** The name for this security group. The name must not be used by another security group for the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** The prototype objects for rules to be created for this security group. If unspecified, no rules will be
     *  created, resulting in all traffic being denied.
     */
    rules?: SecurityGroupRulePrototype[];
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSecurityGroup` operation. */
  export interface DeleteSecurityGroupParams {
    /** The security group identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSecurityGroup` operation. */
  export interface GetSecurityGroupParams {
    /** The security group identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateSecurityGroup` operation. */
  export interface UpdateSecurityGroupParams {
    /** The security group identifier. */
    id: string;
    /** The name for this security group. The name must not be used by another security group for the VPC. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listSecurityGroupRules` operation. */
  export interface ListSecurityGroupRulesParams {
    /** The security group identifier. */
    securityGroupId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createSecurityGroupRule` operation. */
  export interface CreateSecurityGroupRuleParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The properties of the security group rule to be created. */
    securityGroupRulePrototype: SecurityGroupRulePrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSecurityGroupRule` operation. */
  export interface DeleteSecurityGroupRuleParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The rule identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSecurityGroupRule` operation. */
  export interface GetSecurityGroupRuleParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The rule identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateSecurityGroupRule` operation. */
  export interface UpdateSecurityGroupRuleParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The rule identifier. */
    id: string;
    /** The ICMP traffic code to allow. If set, `type` must also be set.
     *
     *  Specify `null` to remove an existing ICMP traffic code.
     */
    code?: number;
    /** The direction of traffic to enforce. */
    direction?: UpdateSecurityGroupRuleConstants.Direction | string;
    /** The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property,
     *  if they are used. Alternatively, if `remote` references a security group, then this rule only applies to IP
     *  addresses (network interfaces) in that group matching this IP version.
     */
    ipVersion?: UpdateSecurityGroupRuleConstants.IpVersion | string;
    /** The inclusive upper bound of the protocol destination port range. If set, `port_min` must also be set, and
     *  must not be larger.
     *
     *  Specify `null` to remove an existing upper bound.
     */
    portMax?: number;
    /** The inclusive lower bound of the protocol destination port range. If set, `port_max` must also be set, and
     *  must not be smaller.
     *
     *  Specify `null` to remove an existing lower bound.
     */
    portMin?: number;
    /** The remote IP addresses or security groups from which this rule will allow traffic (or to
     *  which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
     *  security group. A CIDR block of `0.0.0.0/0` will allow traffic from any source (or to
     *  any destination, for outbound rules).
     */
    remote?: SecurityGroupRuleRemotePatch;
    /** The ICMP traffic type to allow.
     *
     *  Specify `null` to remove an existing ICMP traffic type value.
     */
    type?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `updateSecurityGroupRule` operation. */
  export namespace UpdateSecurityGroupRuleConstants {
    /** The direction of traffic to enforce. */
    export enum Direction {
      INBOUND = 'inbound',
      OUTBOUND = 'outbound',
    }
    /** The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network interfaces) in that group matching this IP version. */
    export enum IpVersion {
      IPV4 = 'ipv4',
    }
  }

  /** Parameters for the `listSecurityGroupTargets` operation. */
  export interface ListSecurityGroupTargetsParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSecurityGroupTargetBinding` operation. */
  export interface DeleteSecurityGroupTargetBindingParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The security group target identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSecurityGroupTarget` operation. */
  export interface GetSecurityGroupTargetParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The security group target identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createSecurityGroupTargetBinding` operation. */
  export interface CreateSecurityGroupTargetBindingParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The security group target identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listIkePolicies` operation. */
  export interface ListIkePoliciesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createIkePolicy` operation. */
  export interface CreateIkePolicyParams {
    /** The authentication algorithm. */
    authenticationAlgorithm: CreateIkePolicyConstants.AuthenticationAlgorithm | string;
    /** The Diffie-Hellman group. */
    dhGroup: number;
    /** The encryption algorithm. */
    encryptionAlgorithm: CreateIkePolicyConstants.EncryptionAlgorithm | string;
    /** The IKE protocol version. */
    ikeVersion: number;
    /** The key lifetime in seconds. */
    keyLifetime?: number;
    /** The name for this IKE policy. The name must not be used by another IKE policies in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createIkePolicy` operation. */
  export namespace CreateIkePolicyConstants {
    /** The authentication algorithm. */
    export enum AuthenticationAlgorithm {
      SHA256 = 'sha256',
      SHA384 = 'sha384',
      SHA512 = 'sha512',
    }
    /** The encryption algorithm. */
    export enum EncryptionAlgorithm {
      AES128 = 'aes128',
      AES192 = 'aes192',
      AES256 = 'aes256',
    }
  }

  /** Parameters for the `deleteIkePolicy` operation. */
  export interface DeleteIkePolicyParams {
    /** The IKE policy identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getIkePolicy` operation. */
  export interface GetIkePolicyParams {
    /** The IKE policy identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateIkePolicy` operation. */
  export interface UpdateIkePolicyParams {
    /** The IKE policy identifier. */
    id: string;
    /** The authentication algorithm. */
    authenticationAlgorithm?: UpdateIkePolicyConstants.AuthenticationAlgorithm | string;
    /** The Diffie-Hellman group. */
    dhGroup?: number;
    /** The encryption algorithm. */
    encryptionAlgorithm?: UpdateIkePolicyConstants.EncryptionAlgorithm | string;
    /** The IKE protocol version. */
    ikeVersion?: number;
    /** The key lifetime in seconds. */
    keyLifetime?: number;
    /** The name for this IKE policy. The name must not be used by another IKE policy in the region. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `updateIkePolicy` operation. */
  export namespace UpdateIkePolicyConstants {
    /** The authentication algorithm. */
    export enum AuthenticationAlgorithm {
      SHA256 = 'sha256',
      SHA384 = 'sha384',
      SHA512 = 'sha512',
    }
    /** The encryption algorithm. */
    export enum EncryptionAlgorithm {
      AES128 = 'aes128',
      AES192 = 'aes192',
      AES256 = 'aes256',
    }
  }

  /** Parameters for the `listIkePolicyConnections` operation. */
  export interface ListIkePolicyConnectionsParams {
    /** The IKE policy identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listIpsecPolicies` operation. */
  export interface ListIpsecPoliciesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createIpsecPolicy` operation. */
  export interface CreateIpsecPolicyParams {
    /** The authentication algorithm
     *
     *  Must be `disabled` if and only if the `encryption_algorithm` is
     *  `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`.
     */
    authenticationAlgorithm: CreateIpsecPolicyConstants.AuthenticationAlgorithm | string;
    /** The encryption algorithm
     *
     *  The `authentication_algorithm` must be `disabled` if and only if
     *  `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or
     *  `aes256gcm16`.
     */
    encryptionAlgorithm: CreateIpsecPolicyConstants.EncryptionAlgorithm | string;
    /** Perfect Forward Secrecy. */
    pfs: CreateIpsecPolicyConstants.Pfs | string;
    /** The key lifetime in seconds. */
    keyLifetime?: number;
    /** The name for this IPsec policy. The name must not be used by another IPsec policies in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createIpsecPolicy` operation. */
  export namespace CreateIpsecPolicyConstants {
    /** The authentication algorithm Must be `disabled` if and only if the `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`. */
    export enum AuthenticationAlgorithm {
      DISABLED = 'disabled',
      SHA256 = 'sha256',
      SHA384 = 'sha384',
      SHA512 = 'sha512',
    }
    /** The encryption algorithm The `authentication_algorithm` must be `disabled` if and only if `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`. */
    export enum EncryptionAlgorithm {
      AES128 = 'aes128',
      AES128GCM16 = 'aes128gcm16',
      AES192 = 'aes192',
      AES192GCM16 = 'aes192gcm16',
      AES256 = 'aes256',
      AES256GCM16 = 'aes256gcm16',
    }
    /** Perfect Forward Secrecy. */
    export enum Pfs {
      DISABLED = 'disabled',
      GROUP_14 = 'group_14',
      GROUP_15 = 'group_15',
      GROUP_16 = 'group_16',
      GROUP_17 = 'group_17',
      GROUP_18 = 'group_18',
      GROUP_19 = 'group_19',
      GROUP_20 = 'group_20',
      GROUP_21 = 'group_21',
      GROUP_22 = 'group_22',
      GROUP_23 = 'group_23',
      GROUP_24 = 'group_24',
      GROUP_31 = 'group_31',
    }
  }

  /** Parameters for the `deleteIpsecPolicy` operation. */
  export interface DeleteIpsecPolicyParams {
    /** The IPsec policy identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getIpsecPolicy` operation. */
  export interface GetIpsecPolicyParams {
    /** The IPsec policy identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateIpsecPolicy` operation. */
  export interface UpdateIpsecPolicyParams {
    /** The IPsec policy identifier. */
    id: string;
    /** The authentication algorithm
     *
     *  Must be `disabled` if and only if the `encryption_algorithm` is
     *  `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`.
     */
    authenticationAlgorithm?: UpdateIpsecPolicyConstants.AuthenticationAlgorithm | string;
    /** The encryption algorithm
     *
     *  The `authentication_algorithm` must be `disabled` if and only if
     *  `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or
     *  `aes256gcm16`.
     */
    encryptionAlgorithm?: UpdateIpsecPolicyConstants.EncryptionAlgorithm | string;
    /** The key lifetime in seconds. */
    keyLifetime?: number;
    /** The name for this IPsec policy. The name must not be used by another IPsec policy in the region. */
    name?: string;
    /** Perfect Forward Secrecy. */
    pfs?: UpdateIpsecPolicyConstants.Pfs | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `updateIpsecPolicy` operation. */
  export namespace UpdateIpsecPolicyConstants {
    /** The authentication algorithm Must be `disabled` if and only if the `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`. */
    export enum AuthenticationAlgorithm {
      DISABLED = 'disabled',
      SHA256 = 'sha256',
      SHA384 = 'sha384',
      SHA512 = 'sha512',
    }
    /** The encryption algorithm The `authentication_algorithm` must be `disabled` if and only if `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`. */
    export enum EncryptionAlgorithm {
      AES128 = 'aes128',
      AES128GCM16 = 'aes128gcm16',
      AES192 = 'aes192',
      AES192GCM16 = 'aes192gcm16',
      AES256 = 'aes256',
      AES256GCM16 = 'aes256gcm16',
    }
    /** Perfect Forward Secrecy. */
    export enum Pfs {
      DISABLED = 'disabled',
      GROUP_14 = 'group_14',
      GROUP_15 = 'group_15',
      GROUP_16 = 'group_16',
      GROUP_17 = 'group_17',
      GROUP_18 = 'group_18',
      GROUP_19 = 'group_19',
      GROUP_20 = 'group_20',
      GROUP_21 = 'group_21',
      GROUP_22 = 'group_22',
      GROUP_23 = 'group_23',
      GROUP_24 = 'group_24',
      GROUP_31 = 'group_31',
    }
  }

  /** Parameters for the `listIpsecPolicyConnections` operation. */
  export interface ListIpsecPolicyConnectionsParams {
    /** The IPsec policy identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVpnGateways` operation. */
  export interface ListVpnGatewaysParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListVpnGatewaysConstants.Sort | string;
    /** Filters the collection to VPN gateways with a `mode` property matching the specified value. */
    mode?: ListVpnGatewaysConstants.Mode | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listVpnGateways` operation. */
  export namespace ListVpnGatewaysConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
    /** Filters the collection to VPN gateways with a `mode` property matching the specified value. */
    export enum Mode {
      POLICY = 'policy',
      ROUTE = 'route',
    }
  }

  /** Parameters for the `createVpnGateway` operation. */
  export interface CreateVpnGatewayParams {
    /** The VPN gateway prototype object. */
    vpnGatewayPrototype: VPNGatewayPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteVpnGateway` operation. */
  export interface DeleteVpnGatewayParams {
    /** The VPN gateway identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpnGateway` operation. */
  export interface GetVpnGatewayParams {
    /** The VPN gateway identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVpnGateway` operation. */
  export interface UpdateVpnGatewayParams {
    /** The VPN gateway identifier. */
    id: string;
    /** The name for this VPN gateway. The name must not be used by another VPN gateway in the VPC. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVpnGatewayConnections` operation. */
  export interface ListVpnGatewayConnectionsParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** Filters the collection to VPN gateway connections with a `status` property matching the specified value. */
    status?: ListVpnGatewayConnectionsConstants.Status | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listVpnGatewayConnections` operation. */
  export namespace ListVpnGatewayConnectionsConstants {
    /** Filters the collection to VPN gateway connections with a `status` property matching the specified value. */
    export enum Status {
      DOWN = 'down',
      UP = 'up',
    }
  }

  /** Parameters for the `createVpnGatewayConnection` operation. */
  export interface CreateVpnGatewayConnectionParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection prototype object. */
    vpnGatewayConnectionPrototype: VPNGatewayConnectionPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteVpnGatewayConnection` operation. */
  export interface DeleteVpnGatewayConnectionParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpnGatewayConnection` operation. */
  export interface GetVpnGatewayConnectionParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVpnGatewayConnection` operation. */
  export interface UpdateVpnGatewayConnectionParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The VPN gateway connection patch. */
    vpnGatewayConnectionPatch: VPNGatewayConnectionPatch;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVpnGatewayConnectionLocalCidrs` operation. */
  export interface ListVpnGatewayConnectionLocalCidrsParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `removeVpnGatewayConnectionLocalCidr` operation. */
  export interface RemoveVpnGatewayConnectionLocalCidrParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The address prefix part of the CIDR. */
    cidrPrefix: string;
    /** The prefix length part of the CIDR. */
    prefixLength: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `checkVpnGatewayConnectionLocalCidr` operation. */
  export interface CheckVpnGatewayConnectionLocalCidrParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The address prefix part of the CIDR. */
    cidrPrefix: string;
    /** The prefix length part of the CIDR. */
    prefixLength: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `addVpnGatewayConnectionLocalCidr` operation. */
  export interface AddVpnGatewayConnectionLocalCidrParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The address prefix part of the CIDR. */
    cidrPrefix: string;
    /** The prefix length part of the CIDR. */
    prefixLength: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVpnGatewayConnectionPeerCidrs` operation. */
  export interface ListVpnGatewayConnectionPeerCidrsParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `removeVpnGatewayConnectionPeerCidr` operation. */
  export interface RemoveVpnGatewayConnectionPeerCidrParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The address prefix part of the CIDR. */
    cidrPrefix: string;
    /** The prefix length part of the CIDR. */
    prefixLength: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `checkVpnGatewayConnectionPeerCidr` operation. */
  export interface CheckVpnGatewayConnectionPeerCidrParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The address prefix part of the CIDR. */
    cidrPrefix: string;
    /** The prefix length part of the CIDR. */
    prefixLength: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `addVpnGatewayConnectionPeerCidr` operation. */
  export interface AddVpnGatewayConnectionPeerCidrParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The address prefix part of the CIDR. */
    cidrPrefix: string;
    /** The prefix length part of the CIDR. */
    prefixLength: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVpnServers` operation. */
  export interface ListVpnServersParams {
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListVpnServersConstants.Sort | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listVpnServers` operation. */
  export namespace ListVpnServersConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createVpnServer` operation. */
  export interface CreateVpnServerParams {
    /** The certificate instance for this VPN server. */
    certificate: CertificateInstanceIdentity;
    /** The methods used to authenticate VPN clients to this VPN server. VPN clients must authenticate against all
     *  specified methods.
     */
    clientAuthentication: VPNServerAuthenticationPrototype[];
    /** The VPN client IPv4 address pool, expressed in CIDR format. The request must not overlap with any existing
     *  address prefixes in the VPC or any of the following reserved address ranges:
     *    - `127.0.0.0/8` (IPv4 loopback addresses)
     *    - `161.26.0.0/16` (IBM services)
     *    - `166.8.0.0/14` (Cloud Service Endpoints)
     *    - `169.254.0.0/16` (IPv4 link-local addresses)
     *    - `224.0.0.0/4` (IPv4 multicast addresses)
     *
     *  The prefix length of the client IP address pool's CIDR must be between
     *  `/9` (8,388,608 addresses) and `/22` (1024 addresses). A CIDR block that contains twice the number of IP
     *  addresses that are required to enable the maximum number of concurrent connections is recommended.
     */
    clientIpPool: string;
    /** The subnets to provision this VPN server in.  Use subnets in different zones for high availability. */
    subnets: SubnetIdentity[];
    /** The DNS server addresses that will be provided to VPN clients connected to this VPN server. */
    clientDnsServerIps?: IP[];
    /** The seconds a VPN client can be idle before this VPN server will disconnect it.   Specify `0` to prevent the
     *  server from disconnecting idle clients.
     */
    clientIdleTimeout?: number;
    /** Indicates whether the split tunneling is enabled on this VPN server. */
    enableSplitTunneling?: boolean;
    /** The name for this VPN server. The name must not be used by another VPN server in the VPC. If unspecified,
     *  the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The port number to use for this VPN server. */
    port?: number;
    /** The transport protocol to use for this VPN server. */
    protocol?: CreateVpnServerConstants.Protocol | string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** The security groups to use for this VPN server. If unspecified, the VPC's default security group is used. */
    securityGroups?: SecurityGroupIdentity[];
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createVpnServer` operation. */
  export namespace CreateVpnServerConstants {
    /** The transport protocol to use for this VPN server. */
    export enum Protocol {
      TCP = 'tcp',
      UDP = 'udp',
    }
  }

  /** Parameters for the `deleteVpnServer` operation. */
  export interface DeleteVpnServerParams {
    /** The VPN server identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpnServer` operation. */
  export interface GetVpnServerParams {
    /** The VPN server identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVpnServer` operation. */
  export interface UpdateVpnServerParams {
    /** The VPN server identifier. */
    id: string;
    /** The certificate instance for this VPN server. */
    certificate?: CertificateInstanceIdentity;
    /** The authentication methods to use to authenticate VPN client on this VPN server
     *  (replacing any existing methods).
     */
    clientAuthentication?: VPNServerAuthenticationPrototype[];
    /** The DNS server addresses that will be provided to VPN clients connected to this VPN server (replacing any
     *  existing addresses).
     */
    clientDnsServerIps?: IP[];
    /** The seconds a VPN client can be idle before this VPN server will disconnect it.  If `0`, the server will not
     *  disconnect idle clients.
     */
    clientIdleTimeout?: number;
    /** The VPN client IPv4 address pool, expressed in CIDR format. The request must not overlap with any existing
     *  address prefixes in the VPC or any of the following reserved address ranges:
     *    - `127.0.0.0/8` (IPv4 loopback addresses)
     *    - `161.26.0.0/16` (IBM services)
     *    - `166.8.0.0/14` (Cloud Service Endpoints)
     *    - `169.254.0.0/16` (IPv4 link-local addresses)
     *    - `224.0.0.0/4` (IPv4 multicast addresses)
     *
     *  The prefix length of the client IP address pool's CIDR must be between
     *  `/9` (8,388,608 addresses) and `/22` (1024 addresses). A CIDR block that contains twice the number of IP
     *  addresses that are required to enable the maximum number of concurrent connections is recommended.
     */
    clientIpPool?: string;
    /** Indicates whether the split tunneling is enabled on this VPN server. */
    enableSplitTunneling?: boolean;
    /** The name for this VPN server. The name must not be used by another VPN server in the VPC. */
    name?: string;
    /** The port number used by this VPN server. */
    port?: number;
    /** The transport protocol used by this VPN server. */
    protocol?: UpdateVpnServerConstants.Protocol | string;
    /** The subnets to provision this VPN server in (replacing the existing subnets). */
    subnets?: SubnetIdentity[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `updateVpnServer` operation. */
  export namespace UpdateVpnServerConstants {
    /** The transport protocol used by this VPN server. */
    export enum Protocol {
      TCP = 'tcp',
      UDP = 'udp',
    }
  }

  /** Parameters for the `getVpnServerClientConfiguration` operation. */
  export interface GetVpnServerClientConfigurationParams {
    /** The VPN server identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVpnServerClients` operation. */
  export interface ListVpnServerClientsParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order.
     */
    sort?: ListVpnServerClientsConstants.Sort | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listVpnServerClients` operation. */
  export namespace ListVpnServerClientsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
    }
  }

  /** Parameters for the `deleteVpnServerClient` operation. */
  export interface DeleteVpnServerClientParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN client identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpnServerClient` operation. */
  export interface GetVpnServerClientParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN client identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `disconnectVpnClient` operation. */
  export interface DisconnectVpnClientParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN client identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listVpnServerRoutes` operation. */
  export interface ListVpnServerRoutesParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListVpnServerRoutesConstants.Sort | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listVpnServerRoutes` operation. */
  export namespace ListVpnServerRoutesConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createVpnServerRoute` operation. */
  export interface CreateVpnServerRouteParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The destination to use for this VPN route in the VPN server. Must be unique within the VPN server. If an
     *  incoming packet does not match any destination, it will be dropped.
     */
    destination: string;
    /** The action to perform with a packet matching the VPN route:
     *  - `translate`: translate the source IP address to one of the private IP addresses of the VPN server, then
     *  deliver the packet to target.
     *  - `deliver`: deliver the packet to the target.
     *  - `drop`: drop the packet
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the VPN route on
     *  which the unexpected property value was encountered.
     */
    action?: CreateVpnServerRouteConstants.Action | string;
    /** The name for this VPN server route. The name must not be used by another route for the VPN server. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createVpnServerRoute` operation. */
  export namespace CreateVpnServerRouteConstants {
    /** The action to perform with a packet matching the VPN route: - `translate`: translate the source IP address to one of the private IP addresses of the VPN server, then deliver the packet to target. - `deliver`: deliver the packet to the target. - `drop`: drop the packet The enumerated values for this property are expected to expand in the future. When processing this property, check for and log unknown values. Optionally halt processing and surface the error, or bypass the VPN route on which the unexpected property value was encountered. */
    export enum Action {
      DELIVER = 'deliver',
      DROP = 'drop',
      TRANSLATE = 'translate',
    }
  }

  /** Parameters for the `deleteVpnServerRoute` operation. */
  export interface DeleteVpnServerRouteParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN route identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getVpnServerRoute` operation. */
  export interface GetVpnServerRouteParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN route identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVpnServerRoute` operation. */
  export interface UpdateVpnServerRouteParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN route identifier. */
    id: string;
    /** The name for this VPN server route. The name must not be used by another route for the VPN server. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listLoadBalancerProfiles` operation. */
  export interface ListLoadBalancerProfilesParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getLoadBalancerProfile` operation. */
  export interface GetLoadBalancerProfileParams {
    /** The load balancer profile name. */
    name: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listLoadBalancers` operation. */
  export interface ListLoadBalancersParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createLoadBalancer` operation. */
  export interface CreateLoadBalancerParams {
    /** Indicates whether this load balancer is public.
     *
     *  At present, if route mode is enabled, the load balancer must not be public.
     */
    isPublic: boolean;
    /** The subnets to provision this load balancer in. The subnets must be in the same VPC. The load balancer's
     *  availability will depend on the availability of the zones that the subnets reside in.
     *
     *  Load balancers in the `network` family allow only one subnet to be specified.
     */
    subnets: SubnetIdentity[];
    /** The datapath logging configuration for this load balancer. */
    datapath?: LoadBalancerLoggingDatapathPrototype;
    /** The DNS configuration for this load balancer.
     *
     *  If unspecified, DNS `A` records for this load balancer's `hostname` property will be added
     *  to the public DNS zone `lb.appdomain.cloud`. Otherwise, those DNS `A` records will be
     *  added to the specified `zone`.
     */
    dns?: LoadBalancerDNSPrototype;
    /** The listeners of this load balancer. */
    listeners?: LoadBalancerListenerPrototypeLoadBalancerContext[];
    /** The logging configuration to use for this load balancer. See [VPC Datapath
     *  Logging](https://cloud.ibm.com/docs/vpc?topic=vpc-datapath-logging) on the logging
     *  format, fields and permitted values.
     *
     *  To activate logging, the load balancer profile must support the specified logging type.
     */
    logging?: LoadBalancerLoggingPrototype;
    /** The name for this load balancer. The name must not be used by another load balancer in the VPC.  If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The pools of this load balancer. */
    pools?: LoadBalancerPoolPrototype[];
    /** The profile to use for this load balancer.
     *
     *  If unspecified, `application` will be used.
     */
    profile?: LoadBalancerProfileIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** Indicates whether route mode is enabled for this load balancer.
     *
     *  At present, public load balancers are not supported with route mode enabled.
     */
    routeMode?: boolean;
    /** The security groups to use for this load balancer. If unspecified, the VPC's default security group is used.
     *
     *  The load balancer profile must support security groups.
     */
    securityGroups?: SecurityGroupIdentity[];
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteLoadBalancer` operation. */
  export interface DeleteLoadBalancerParams {
    /** The load balancer identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getLoadBalancer` operation. */
  export interface GetLoadBalancerParams {
    /** The load balancer identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateLoadBalancer` operation. */
  export interface UpdateLoadBalancerParams {
    /** The load balancer identifier. */
    id: string;
    /** The DNS configuration for this load balancer.
     *
     *  Specify `null` to remove the existing DNS configuration, which will remove all DNS `A`
     *  records for this load balancer that had been added to `zone`, and add equivalent `A`
     *  records to the public DNS zone `lb.appdomain.cloud`.
     */
    dns?: LoadBalancerDNSPatch;
    /** The logging configuration to use for this load balancer.
     *
     *  To activate logging, the load balancer profile must support the specified logging type.
     */
    logging?: LoadBalancerLoggingPatch;
    /** The name for this load balancer. The name must not be used by another load balancer in the VPC. */
    name?: string;
    /** The subnets to provision this load balancer in. The load balancer's availability will depend on the
     *  availability of the zones that the subnets reside in.
     *
     *  The specified subnets must be in the same VPC as the existing subnets, and will completely replace the existing
     *  subnets.
     *
     *  The load balancer must be in the `application` family.
     */
    subnets?: SubnetIdentity[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getLoadBalancerStatistics` operation. */
  export interface GetLoadBalancerStatisticsParams {
    /** The load balancer identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listLoadBalancerListeners` operation. */
  export interface ListLoadBalancerListenersParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createLoadBalancerListener` operation. */
  export interface CreateLoadBalancerListenerParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener protocol. Each listener in the load balancer must have a unique `port` and `protocol`
     *  combination.
     *
     *  Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
     *  the `application` family support `tcp`, `http` and
     *  `https`.
     *
     *  Additional restrictions:
     *  - If `default_pool` is set, the pool's protocol must match, or be compatible with
     *    the listener's protocol. At present, the compatible protocols are `http` and
     *    `https`.
     *  - If `https_redirect` is set, the protocol must be `http`.
     */
    protocol: CreateLoadBalancerListenerConstants.Protocol | string;
    /** If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load
     *  balancers in the `application` family (otherwise always `false`). Additional restrictions:
     *  - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
     *    match the `accept_proxy_protocol` value of the `https_redirect` listener.
     *  - If this listener is the target of another listener's `https_redirect`, its
     *    `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
     */
    acceptProxyProtocol?: boolean;
    /** The certificate instance to use for SSL termination. The listener must have a `protocol` of `https`. */
    certificateInstance?: CertificateInstanceIdentity;
    /** The connection limit of the listener. */
    connectionLimit?: number;
    /** The default pool for this listener. If specified, the pool must:
     *  - Belong to this load balancer.
     *  - Have the same `protocol` as this listener, or have a compatible protocol.
     *    At present, the compatible protocols are `http` and `https`.
     *  - Not already be the `default_pool` for another listener.
     *
     *  If unspecified, this listener will be created with no default pool, but one may be
     *  subsequently set.
     */
    defaultPool?: LoadBalancerPoolIdentity;
    /** The target listener that requests will be redirected to. This listener must have a
     *  `protocol` of `http`, and the target listener must have a `protocol` of `https`.
     */
    httpsRedirect?: LoadBalancerListenerHTTPSRedirectPrototype;
    /** The idle connection timeout of the listener in seconds. Supported for load balancers in the `application`
     *  family.
     */
    idleConnectionTimeout?: number;
    /** The policy prototype objects for this listener. The load balancer must be in the `application` family. */
    policies?: LoadBalancerListenerPolicyPrototype[];
    /** The listener port number, or the inclusive lower bound of the port range. Each listener in the load balancer
     *  must have a unique `port` and `protocol` combination.
     *
     *  Not supported for load balancers operating with route mode enabled.
     */
    port?: number;
    /** The inclusive upper bound of the range of ports used by this listener. Must not be less than `port_min`.
     *
     *  At present, only load balancers operating with route mode enabled, and public load balancers in the `network`
     *  family support different values for `port_min` and
     *  `port_max`. When route mode is enabled, the value `65535` must be specified.
     *
     *  The specified port range must not overlap with port ranges used by other listeners for this load balancer using
     *  the same protocol.
     */
    portMax?: number;
    /** The inclusive lower bound of the range of ports used by this listener. Must not be greater than `port_max`.
     *
     *  At present, only load balancers operating with route mode enabled, and public load balancers in the `network`
     *  family support different values for `port_min` and
     *  `port_max`. When route mode is enabled, the value `1` must be specified.
     *
     *  The specified port range must not overlap with port ranges used by other listeners for this load balancer using
     *  the same protocol.
     */
    portMin?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createLoadBalancerListener` operation. */
  export namespace CreateLoadBalancerListenerConstants {
    /** The listener protocol. Each listener in the load balancer must have a unique `port` and `protocol` combination. Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the `application` family support `tcp`, `http` and `https`. Additional restrictions: - If `default_pool` is set, the pool's protocol must match, or be compatible with the listener's protocol. At present, the compatible protocols are `http` and `https`. - If `https_redirect` is set, the protocol must be `http`. */
    export enum Protocol {
      HTTP = 'http',
      HTTPS = 'https',
      TCP = 'tcp',
      UDP = 'udp',
    }
  }

  /** Parameters for the `deleteLoadBalancerListener` operation. */
  export interface DeleteLoadBalancerListenerParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getLoadBalancerListener` operation. */
  export interface GetLoadBalancerListenerParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateLoadBalancerListener` operation. */
  export interface UpdateLoadBalancerListenerParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    id: string;
    /** If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load
     *  balancers in the `application` family (otherwise always `false`). Additional restrictions:
     *  - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
     *    match the `accept_proxy_protocol` value of the `https_redirect` listener.
     *  - If this listener is the target of another listener's `https_redirect`, its
     *    `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
     */
    acceptProxyProtocol?: boolean;
    /** The certificate instance to use for SSL termination. The listener must have a `protocol` of `https`. */
    certificateInstance?: CertificateInstanceIdentity;
    /** The connection limit of the listener. */
    connectionLimit?: number;
    /** The default pool for this listener. The specified pool must:
     *
     *  - Belong to this load balancer
     *  - Have the same `protocol` as this listener, or have a compatible protocol.
     *    At present, the compatible protocols are `http` and `https`.
     *  - Not already be the `default_pool` for another listener
     *
     *  Specify `null` to remove an existing default pool.
     */
    defaultPool?: LoadBalancerPoolIdentity;
    /** The target listener that requests will be redirected to. This listener must have a
     *  `protocol` of `http`, and the target listener must have a `protocol` of `https`.
     *
     *  Specify `null` to remove any existing https redirect.
     */
    httpsRedirect?: LoadBalancerListenerHTTPSRedirectPatch;
    /** The idle connection timeout of the listener in seconds. Supported for load balancers in the `application`
     *  family.
     */
    idleConnectionTimeout?: number;
    /** The listener port number, or the inclusive lower bound of the port range. Each listener in the load balancer
     *  must have a unique `port` and `protocol` combination.
     *
     *  Not supported for load balancers operating with route mode enabled.
     */
    port?: number;
    /** The inclusive upper bound of the range of ports used by this listener. Must not be less than `port_min`.
     *
     *  At present, only load balancers operating with route mode enabled, and public load balancers in the `network`
     *  family support different values for `port_min` and
     *  `port_max`. When route mode is enabled, the value `65535` must be specified.
     *
     *  The specified port range must not overlap with port ranges used by other listeners for this load balancer using
     *  the same protocol.
     */
    portMax?: number;
    /** The inclusive lower bound of the range of ports used by this listener. Must not be greater than `port_max`.
     *
     *  At present, only load balancers operating with route mode enabled, and public load balancers in the `network`
     *  family support different values for `port_min` and
     *  `port_max`. When route mode is enabled, the value `1` must be specified.
     *
     *  The specified port range must not overlap with port ranges used by other listeners for this load balancer using
     *  the same protocol.
     */
    portMin?: number;
    /** The listener protocol. Each listener in the load balancer must have a unique `port` and `protocol`
     *  combination.
     *
     *  Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
     *  the `application` family support `tcp`, `http` and
     *  `https`.
     *
     *  Additional restrictions:
     *  - If `default_pool` is set, the protocol cannot be changed.
     *  - If `https_redirect` is set, the protocol must be `http`.
     *  - If another listener's `https_redirect` targets this listener, the protocol must be
     *  `https`.
     */
    protocol?: UpdateLoadBalancerListenerConstants.Protocol | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `updateLoadBalancerListener` operation. */
  export namespace UpdateLoadBalancerListenerConstants {
    /** The listener protocol. Each listener in the load balancer must have a unique `port` and `protocol` combination. Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the `application` family support `tcp`, `http` and `https`. Additional restrictions: - If `default_pool` is set, the protocol cannot be changed. - If `https_redirect` is set, the protocol must be `http`. - If another listener's `https_redirect` targets this listener, the protocol must be `https`. */
    export enum Protocol {
      HTTP = 'http',
      HTTPS = 'https',
      TCP = 'tcp',
      UDP = 'udp',
    }
  }

  /** Parameters for the `listLoadBalancerListenerPolicies` operation. */
  export interface ListLoadBalancerListenerPoliciesParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createLoadBalancerListenerPolicy` operation. */
  export interface CreateLoadBalancerListenerPolicyParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy action.
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on
     *  which the unexpected property value was encountered.
     */
    action: CreateLoadBalancerListenerPolicyConstants.Action | string;
    /** Priority of the policy. Lower value indicates higher priority. */
    priority: number;
    /** The name for this policy. The name must not be used by another policy for the load balancer listener. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The rule prototype objects for this policy. */
    rules?: LoadBalancerListenerPolicyRulePrototype[];
    /** - If `action` is `forward`, specify a `LoadBalancerPoolIdentity`.
     *  - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPrototype`.
     *  - If `action` is `https_redirect`, specify a
     *    `LoadBalancerListenerPolicyHTTPSRedirectPrototype`.
     */
    target?: LoadBalancerListenerPolicyTargetPrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createLoadBalancerListenerPolicy` operation. */
  export namespace CreateLoadBalancerListenerPolicyConstants {
    /** The policy action. The enumerated values for this property are expected to expand in the future. When processing this property, check for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on which the unexpected property value was encountered. */
    export enum Action {
      FORWARD = 'forward',
      HTTPS_REDIRECT = 'https_redirect',
      REDIRECT = 'redirect',
      REJECT = 'reject',
    }
  }

  /** Parameters for the `deleteLoadBalancerListenerPolicy` operation. */
  export interface DeleteLoadBalancerListenerPolicyParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getLoadBalancerListenerPolicy` operation. */
  export interface GetLoadBalancerListenerPolicyParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateLoadBalancerListenerPolicy` operation. */
  export interface UpdateLoadBalancerListenerPolicyParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    id: string;
    /** The name for this policy. The name must not be used by another policy for the load balancer listener. */
    name?: string;
    /** Priority of the policy. Lower value indicates higher priority. */
    priority?: number;
    /** - If `action` is `forward`, specify a `LoadBalancerPoolIdentity`.
     *  - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPatch`.
     *  - If `action` is `https_redirect`, specify a
     *    `LoadBalancerListenerPolicyHTTPSRedirectPatch`.
     */
    target?: LoadBalancerListenerPolicyTargetPatch;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listLoadBalancerListenerPolicyRules` operation. */
  export interface ListLoadBalancerListenerPolicyRulesParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    policyId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createLoadBalancerListenerPolicyRule` operation. */
  export interface CreateLoadBalancerListenerPolicyRuleParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    policyId: string;
    /** The condition of the rule. */
    condition: CreateLoadBalancerListenerPolicyRuleConstants.Condition | string;
    /** The type of the rule.
     *
     *  Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
     */
    type: CreateLoadBalancerListenerPolicyRuleConstants.Type | string;
    /** Value to be matched for rule condition.
     *
     *  If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
     */
    value: string;
    /** The field. This is applicable to `header`, `query`, and `body` rule types.
     *
     *  If the rule type is `header`, this property is required.
     *
     *  If the rule type is `query`, this is optional. If specified and the rule condition is not
     *  `matches_regex`, the value must be percent-encoded.
     *
     *  If the rule type is `body`, this is optional.
     */
    field?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createLoadBalancerListenerPolicyRule` operation. */
  export namespace CreateLoadBalancerListenerPolicyRuleConstants {
    /** The condition of the rule. */
    export enum Condition {
      CONTAINS = 'contains',
      EQUALS = 'equals',
      MATCHES_REGEX = 'matches_regex',
    }
    /** The type of the rule. Body rules are applied to form-encoded request bodies using the `UTF-8` character set. */
    export enum Type {
      BODY = 'body',
      HEADER = 'header',
      HOSTNAME = 'hostname',
      PATH = 'path',
      QUERY = 'query',
    }
  }

  /** Parameters for the `deleteLoadBalancerListenerPolicyRule` operation. */
  export interface DeleteLoadBalancerListenerPolicyRuleParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    policyId: string;
    /** The rule identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getLoadBalancerListenerPolicyRule` operation. */
  export interface GetLoadBalancerListenerPolicyRuleParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    policyId: string;
    /** The rule identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateLoadBalancerListenerPolicyRule` operation. */
  export interface UpdateLoadBalancerListenerPolicyRuleParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    policyId: string;
    /** The rule identifier. */
    id: string;
    /** The condition of the rule. */
    condition?: UpdateLoadBalancerListenerPolicyRuleConstants.Condition | string;
    /** The field. This is applicable to `header`, `query`, and `body` rule types.
     *
     *  If the rule type is `header`, this property is required.
     *
     *  If the rule type is `query`, this is optional. If specified and the rule condition is not
     *  `matches_regex`, the value must be percent-encoded.
     *
     *  If the rule type is `body`, this is optional.
     */
    field?: string;
    /** The type of the rule.
     *
     *  Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
     */
    type?: UpdateLoadBalancerListenerPolicyRuleConstants.Type | string;
    /** Value to be matched for rule condition.
     *
     *  If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
     */
    value?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `updateLoadBalancerListenerPolicyRule` operation. */
  export namespace UpdateLoadBalancerListenerPolicyRuleConstants {
    /** The condition of the rule. */
    export enum Condition {
      CONTAINS = 'contains',
      EQUALS = 'equals',
      MATCHES_REGEX = 'matches_regex',
    }
    /** The type of the rule. Body rules are applied to form-encoded request bodies using the `UTF-8` character set. */
    export enum Type {
      BODY = 'body',
      HEADER = 'header',
      HOSTNAME = 'hostname',
      PATH = 'path',
      QUERY = 'query',
    }
  }

  /** Parameters for the `listLoadBalancerPools` operation. */
  export interface ListLoadBalancerPoolsParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createLoadBalancerPool` operation. */
  export interface CreateLoadBalancerPoolParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The load balancing algorithm. */
    algorithm: CreateLoadBalancerPoolConstants.Algorithm | string;
    /** The health monitor of this pool. */
    healthMonitor: LoadBalancerPoolHealthMonitorPrototype;
    /** The protocol used for this load balancer pool. Load balancers in the `network` family support `tcp` and
     *  `udp` (if `udp_supported` is `true`). Load balancers in the
     *  `application` family support `tcp`, `http`, and `https`.
     */
    protocol: CreateLoadBalancerPoolConstants.Protocol | string;
    /** The members for this load balancer pool. For load balancers in the `network` family, the same `port` and
     *  `target` tuple cannot be shared by a pool member of any other load balancer in the same VPC.
     */
    members?: LoadBalancerPoolMemberPrototype[];
    /** The name for this load balancer pool. The name must not be used by another pool for the load balancer. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The PROXY protocol setting for this pool:
     *  - `v1`: Enabled with version 1 (human-readable header format)
     *  - `v2`: Enabled with version 2 (binary header format)
     *  - `disabled`: Disabled
     *
     *  Supported by load balancers in the `application` family (otherwise always `disabled`).
     */
    proxyProtocol?: CreateLoadBalancerPoolConstants.ProxyProtocol | string;
    /** The session persistence of this pool. */
    sessionPersistence?: LoadBalancerPoolSessionPersistencePrototype;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createLoadBalancerPool` operation. */
  export namespace CreateLoadBalancerPoolConstants {
    /** The load balancing algorithm. */
    export enum Algorithm {
      LEAST_CONNECTIONS = 'least_connections',
      ROUND_ROBIN = 'round_robin',
      WEIGHTED_ROUND_ROBIN = 'weighted_round_robin',
    }
    /** The protocol used for this load balancer pool. Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the `application` family support `tcp`, `http`, and `https`. */
    export enum Protocol {
      HTTP = 'http',
      HTTPS = 'https',
      TCP = 'tcp',
      UDP = 'udp',
    }
    /** The PROXY protocol setting for this pool: - `v1`: Enabled with version 1 (human-readable header format) - `v2`: Enabled with version 2 (binary header format) - `disabled`: Disabled Supported by load balancers in the `application` family (otherwise always `disabled`). */
    export enum ProxyProtocol {
      DISABLED = 'disabled',
      V1 = 'v1',
      V2 = 'v2',
    }
  }

  /** Parameters for the `deleteLoadBalancerPool` operation. */
  export interface DeleteLoadBalancerPoolParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getLoadBalancerPool` operation. */
  export interface GetLoadBalancerPoolParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateLoadBalancerPool` operation. */
  export interface UpdateLoadBalancerPoolParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    id: string;
    /** The load balancing algorithm. */
    algorithm?: UpdateLoadBalancerPoolConstants.Algorithm | string;
    /** The health monitor of this pool. */
    healthMonitor?: LoadBalancerPoolHealthMonitorPatch;
    /** The name for this load balancer pool. The name must not be used by another pool for the load balancer. */
    name?: string;
    /** The protocol for this load balancer pool.
     *
     *  Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
     *  the `application` family support `tcp`, `http` and
     *  `https`.
     *
     *  If this pool is associated with a load balancer listener, the specified protocol must match, or be compatible
     *  with the listener's protocol. At present, the compatible protocols are `http` and `https`.
     */
    protocol?: UpdateLoadBalancerPoolConstants.Protocol | string;
    /** The PROXY protocol setting for this pool:
     *  - `v1`: Enabled with version 1 (human-readable header format)
     *  - `v2`: Enabled with version 2 (binary header format)
     *  - `disabled`: Disabled
     *
     *  Supported by load balancers in the `application` family (otherwise always `disabled`).
     */
    proxyProtocol?: UpdateLoadBalancerPoolConstants.ProxyProtocol | string;
    /** The session persistence of this pool. */
    sessionPersistence?: LoadBalancerPoolSessionPersistencePatch;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `updateLoadBalancerPool` operation. */
  export namespace UpdateLoadBalancerPoolConstants {
    /** The load balancing algorithm. */
    export enum Algorithm {
      LEAST_CONNECTIONS = 'least_connections',
      ROUND_ROBIN = 'round_robin',
      WEIGHTED_ROUND_ROBIN = 'weighted_round_robin',
    }
    /** The protocol for this load balancer pool. Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the `application` family support `tcp`, `http` and `https`. If this pool is associated with a load balancer listener, the specified protocol must match, or be compatible with the listener's protocol. At present, the compatible protocols are `http` and `https`. */
    export enum Protocol {
      HTTP = 'http',
      HTTPS = 'https',
      TCP = 'tcp',
      UDP = 'udp',
    }
    /** The PROXY protocol setting for this pool: - `v1`: Enabled with version 1 (human-readable header format) - `v2`: Enabled with version 2 (binary header format) - `disabled`: Disabled Supported by load balancers in the `application` family (otherwise always `disabled`). */
    export enum ProxyProtocol {
      DISABLED = 'disabled',
      V1 = 'v1',
      V2 = 'v2',
    }
  }

  /** Parameters for the `listLoadBalancerPoolMembers` operation. */
  export interface ListLoadBalancerPoolMembersParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createLoadBalancerPoolMember` operation. */
  export interface CreateLoadBalancerPoolMemberParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
    /** The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on
     *  a listener with a single port. (If the traffic is received on a listener with a port range, the member will
     *  receive the traffic on the same port the listener received it on.)
     *
     *  This port will also be used for health checks unless the `port` property of
     *  `health_monitor` property is specified.
     *
     *  The port must be unique across all members for all pools associated with this pool's listener.
     */
    port: number;
    /** The pool member target. Load balancers in the `network` family support virtual server
     *  instances. Load balancers in the `application` family support IP addresses. If the load
     *  balancer has route mode enabled, the member must be in a zone the load balancer has a
     *  subnet in.
     */
    target: LoadBalancerPoolMemberTargetPrototype;
    /** Weight of the server member. Applicable only if the pool algorithm is `weighted_round_robin`. */
    weight?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `replaceLoadBalancerPoolMembers` operation. */
  export interface ReplaceLoadBalancerPoolMembersParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
    /** The member prototype objects for this pool. */
    members: LoadBalancerPoolMemberPrototype[];
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteLoadBalancerPoolMember` operation. */
  export interface DeleteLoadBalancerPoolMemberParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
    /** The member identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getLoadBalancerPoolMember` operation. */
  export interface GetLoadBalancerPoolMemberParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
    /** The member identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateLoadBalancerPoolMember` operation. */
  export interface UpdateLoadBalancerPoolMemberParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
    /** The member identifier. */
    id: string;
    /** The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on
     *  a listener with a single port. (If the traffic is received on a listener with a port range, the member will
     *  receive the traffic on the same port the listener received it on.)
     *
     *  This port will also be used for health checks unless the `port` property of
     *  `health_monitor` property is specified.
     *
     *  The port must be unique across all members for all pools associated with this pool's listener.
     */
    port?: number;
    /** The pool member target. Load balancers in the `network` family support virtual server
     *  instances. Load balancers in the `application` family support IP addresses. If the load
     *  balancer has route mode enabled, the member must be in a zone the load balancer has a
     *  subnet in.
     */
    target?: LoadBalancerPoolMemberTargetPrototype;
    /** Weight of the server member. Applicable only if the pool algorithm is `weighted_round_robin`. */
    weight?: number;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listEndpointGateways` operation. */
  export interface ListEndpointGatewaysParams {
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createEndpointGateway` operation. */
  export interface CreateEndpointGatewayParams {
    /** The target to use for this endpoint gateway. Must not already be the target of another
     *  endpoint gateway in the VPC.
     */
    target: EndpointGatewayTargetPrototype;
    /** The VPC this endpoint gateway will reside in. */
    vpc: VPCIdentity;
    /** The reserved IPs to bind to this endpoint gateway. At most one reserved IP per zone is allowed. */
    ips?: EndpointGatewayReservedIP[];
    /** The name for this endpoint gateway. The name must not be used by another endpoint gateway in the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** The security groups to use for this endpoint gateway. If unspecified, the VPC's default security group is
     *  used.
     */
    securityGroups?: SecurityGroupIdentity[];
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listEndpointGatewayIps` operation. */
  export interface ListEndpointGatewayIpsParams {
    /** The endpoint gateway identifier. */
    endpointGatewayId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListEndpointGatewayIpsConstants.Sort | string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `listEndpointGatewayIps` operation. */
  export namespace ListEndpointGatewayIpsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      ADDRESS = 'address',
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `removeEndpointGatewayIp` operation. */
  export interface RemoveEndpointGatewayIpParams {
    /** The endpoint gateway identifier. */
    endpointGatewayId: string;
    /** The reserved IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getEndpointGatewayIp` operation. */
  export interface GetEndpointGatewayIpParams {
    /** The endpoint gateway identifier. */
    endpointGatewayId: string;
    /** The reserved IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `addEndpointGatewayIp` operation. */
  export interface AddEndpointGatewayIpParams {
    /** The endpoint gateway identifier. */
    endpointGatewayId: string;
    /** The reserved IP identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteEndpointGateway` operation. */
  export interface DeleteEndpointGatewayParams {
    /** The endpoint gateway identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getEndpointGateway` operation. */
  export interface GetEndpointGatewayParams {
    /** The endpoint gateway identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateEndpointGateway` operation. */
  export interface UpdateEndpointGatewayParams {
    /** The endpoint gateway identifier. */
    id: string;
    /** The name for this endpoint gateway. The name must not be used by another endpoint gateway in the VPC. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listFlowLogCollectors` operation. */
  export interface ListFlowLogCollectorsParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to resources with a `vpc.id` property matching the specified identifier. */
    vpcId?: string;
    /** Filters the collection to resources with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to resources with a `vpc.name` property matching the exact specified name. */
    vpcName?: string;
    /** Filters the collection to resources with a `target.id` property matching the specified identifier. */
    targetId?: string;
    /** Filters the collection to resources with a `target.resource_type` property matching the specified value. */
    targetResourceType?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createFlowLogCollector` operation. */
  export interface CreateFlowLogCollectorParams {
    /** The Cloud Object Storage bucket where the collected flows will be logged.
     *  The bucket must exist and an IAM service authorization must grant
     *  `IBM Cloud Flow Logs` resources of `VPC Infrastructure Services` writer
     *  access to the bucket.
     */
    storageBucket: LegacyCloudObjectStorageBucketIdentity;
    /** The target this collector will collect flow logs for. If the target is an instance,
     *  subnet, or VPC, flow logs will not be collected for any instance network interfaces within
     *  the target that are themselves the target of a more specific flow log collector.
     */
    target: FlowLogCollectorTargetPrototype;
    /** Indicates whether this collector will be active upon creation. */
    active?: boolean;
    /** The name for this flow log collector. The name must not be used by another flow log collector in the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resourceGroup?: ResourceGroupIdentity;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteFlowLogCollector` operation. */
  export interface DeleteFlowLogCollectorParams {
    /** The flow log collector identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getFlowLogCollector` operation. */
  export interface GetFlowLogCollectorParams {
    /** The flow log collector identifier. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateFlowLogCollector` operation. */
  export interface UpdateFlowLogCollectorParams {
    /** The flow log collector identifier. */
    id: string;
    /** Indicates whether this collector is active. Updating to false deactivates the collector and updating to true
     *  activates the collector.
     */
    active?: boolean;
    /** The name for this flow log collector. The name must not be used by another flow log collector in the VPC. */
    name?: string;
    headers?: OutgoingHttpHeaders;
  }

  /*************************
   * model interfaces
   ************************/

  /** AccountReference. */
  export interface AccountReference {
    /** The unique identifier for this account. */
    id: string;
    /** The resource type. */
    resource_type: string;
  }

  /** AddressPrefix. */
  export interface AddressPrefix {
    /** The CIDR block for this prefix. */
    cidr: string;
    /** The date and time that the prefix was created. */
    created_at: string;
    /** Indicates whether subnets exist with addresses from this prefix. */
    has_subnets: boolean;
    /** The URL for this address prefix. */
    href: string;
    /** The unique identifier for this address prefix. */
    id: string;
    /** Indicates whether this is the default prefix for this zone in this VPC. If a default prefix was
     *  automatically created when the VPC was created, the prefix is automatically named using a hyphenated list of
     *  randomly-selected words, but may be changed.
     */
    is_default: boolean;
    /** The name for this address prefix. The name must not be used by another address prefix for the VPC. */
    name: string;
    /** The zone this address prefix resides in. */
    zone: ZoneReference;
  }

  /** AddressPrefixCollection. */
  export interface AddressPrefixCollection {
    /** Collection of address prefixes. */
    address_prefixes: AddressPrefix[];
    /** A link to the first page of resources. */
    first: AddressPrefixCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: AddressPrefixCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface AddressPrefixCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface AddressPrefixCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** BackupPolicy. */
  export interface BackupPolicy {
    /** The date and time that the backup policy was created. */
    created_at: string;
    /** The CRN for this backup policy. */
    crn: string;
    /** The URL for this backup policy. */
    href: string;
    /** The unique identifier for this backup policy. */
    id: string;
    /** The date and time that the most recent job for this backup policy completed.
     *
     *  If absent, no job has yet completed for this backup policy.
     */
    last_job_completed_at?: string;
    /** The lifecycle state of the backup policy. */
    lifecycle_state: string;
    /** The resource types this backup policy applies to. Resources that have both a matching type and a matching
     *  user tag will be subject to the backup policy.
     *
     *  The enumerated values for this property will expand in the future. When processing this property, check for and
     *  log unknown values. Optionally halt processing and surface the error, or bypass the backup policy on which the
     *  unexpected property value was encountered.
     */
    match_resource_types: string[];
    /** The user tags this backup policy applies to. Resources that have both a matching user tag and a matching
     *  type will be subject to the backup policy.
     */
    match_user_tags: string[];
    /** The name for this backup policy. The name is unique across all backup policies in the region. */
    name: string;
    /** The plans for the backup policy. */
    plans: BackupPolicyPlanReference[];
    /** The resource group for this backup policy. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
  }

  /** BackupPolicyCollection. */
  export interface BackupPolicyCollection {
    /** Collection of backup policies. */
    backup_policies: BackupPolicy[];
    /** A link to the first page of resources. */
    first: BackupPolicyCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: BackupPolicyCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface BackupPolicyCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface BackupPolicyCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** BackupPolicyJob. */
  export interface BackupPolicyJob {
    /** Indicates whether this backup policy job will be automatically deleted after it completes. At present, this
     *  is always `true`, but may be modifiable in the future.
     */
    auto_delete: boolean;
    /** If `auto_delete` is `true`, the days after completion that this backup policy job will be deleted. This
     *  value may be modifiable in the future.
     */
    auto_delete_after: number;
    /** The backup policy plan operated this backup policy job (may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     */
    backup_policy_plan: BackupPolicyPlanReference;
    /** The date and time that the backup policy job was completed.
     *
     *  If absent, the backup policy job has not yet completed.
     */
    completed_at?: string;
    /** The date and time that the backup policy job was created. */
    created_at: string;
    /** The URL for this backup policy job. */
    href: string;
    /** The unique identifier for this backup policy job. */
    id: string;
    /** The type of backup policy job.
     *
     *  The enumerated values for this property will expand in the future. When processing this property, check for and
     *  log unknown values. Optionally halt processing and surface the error, or bypass the backup policy job on which
     *  the unexpected property value was encountered.
     */
    job_type: string;
    /** The resource type. */
    resource_type: string;
    /** The source this backup was created from (may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     */
    source: BackupPolicyJobSource;
    /** The status of the backup policy job.
     *
     *  The enumerated values for this property will expand in the future. When processing this property, check for and
     *  log unknown values. Optionally halt processing and surface the error, or bypass the backup policy job on which
     *  the unexpected property value was encountered.
     */
    status: string;
    /** The reasons for the current status (if any).
     *
     *  The enumerated reason code values for this property will expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected reason code was encountered.
     */
    status_reasons: BackupPolicyJobStatusReason[];
    /** The snapshots operated on by this backup policy job (may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     */
    target_snapshots: SnapshotReference[];
  }

  /** BackupPolicyJobCollection. */
  export interface BackupPolicyJobCollection {
    /** A link to the first page of resources. */
    first: BackupPolicyJobCollectionFirst;
    /** Collection of backup policy jobs. */
    jobs: BackupPolicyJob[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: BackupPolicyJobCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface BackupPolicyJobCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface BackupPolicyJobCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** The source this backup was created from (may be [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)). */
  export interface BackupPolicyJobSource {
  }

  /** BackupPolicyJobStatusReason. */
  export interface BackupPolicyJobStatusReason {
    /** A snake case string succinctly identifying the status reason:
     *  - `internal_error`: Internal error (contact IBM support)
     *  - `snapshot_pending`: Cannot delete backup (snapshot) in the `pending` lifecycle state
     *  - `snapshot_volume_limit`: The snapshot limit for the source volume has been reached
     *  - `source_volume_busy`: The source volume has `busy` set (after multiple retries).
     */
    code: string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }

  /** BackupPolicyPlan. */
  export interface BackupPolicyPlan {
    /** Indicates whether the plan is active. */
    active: boolean;
    /** The user tags to attach to backups (snapshots) created by this plan. */
    attach_user_tags: string[];
    clone_policy: BackupPolicyPlanClonePolicy;
    /** Indicates whether to copy the source's user tags to the created backups (snapshots). */
    copy_user_tags: boolean;
    /** The date and time that the backup policy plan was created. */
    created_at: string;
    /** The cron specification for the backup schedule. The backup policy jobs
     *  (which create and delete backups for this plan) will not start until this time, and may start for up to 90
     *  minutes after this time.
     *
     *  All backup schedules for plans in the same policy must be at least an hour apart.
     */
    cron_spec: string;
    deletion_trigger: BackupPolicyPlanDeletionTrigger;
    /** The URL for this backup policy plan. */
    href: string;
    /** The unique identifier for this backup policy plan. */
    id: string;
    /** The lifecycle state of this backup policy plan. */
    lifecycle_state: string;
    /** The name for this backup policy plan. The name is unique across all plans in the backup policy. */
    name: string;
    /** The policies for additional backups in remote regions. */
    remote_region_policies: BackupPolicyPlanRemoteRegionPolicy[];
    /** The resource type. */
    resource_type: string;
  }

  /** BackupPolicyPlanClonePolicy. */
  export interface BackupPolicyPlanClonePolicy {
    /** The maximum number of recent snapshots (per source) that will keep clones. */
    max_snapshots: number;
    /** The zone this backup policy plan will create snapshot clones in. */
    zones: ZoneReference[];
  }

  /** BackupPolicyPlanClonePolicyPatch. */
  export interface BackupPolicyPlanClonePolicyPatch {
    /** The maximum number of recent snapshots (per source) that will keep clones. */
    max_snapshots?: number;
    /** The zones this backup policy plan will create snapshot clones in. Updating this value does not change the
     *  clones for snapshots that have already been created by this plan.
     */
    zones?: ZoneIdentity[];
  }

  /** BackupPolicyPlanClonePolicyPrototype. */
  export interface BackupPolicyPlanClonePolicyPrototype {
    /** The maximum number of recent snapshots (per source) that will keep clones. */
    max_snapshots?: number;
    /** The zone this backup policy plan will create snapshot clones in. */
    zones: ZoneIdentity[];
  }

  /** BackupPolicyPlanCollection. */
  export interface BackupPolicyPlanCollection {
    /** Collection of backup policy plans. */
    plans: BackupPolicyPlan[];
  }

  /** BackupPolicyPlanDeletionTrigger. */
  export interface BackupPolicyPlanDeletionTrigger {
    /** The maximum number of days to keep each backup after creation. */
    delete_after: number;
    /** The maximum number of recent backups to keep. If absent, there is no maximum. */
    delete_over_count?: number;
  }

  /** BackupPolicyPlanDeletionTriggerPatch. */
  export interface BackupPolicyPlanDeletionTriggerPatch {
    /** The maximum number of days to keep each backup after creation. */
    delete_after?: number;
    /** The maximum number of recent backups to keep. Specify `null` to remove any existing maximum. */
    delete_over_count?: number;
  }

  /** BackupPolicyPlanDeletionTriggerPrototype. */
  export interface BackupPolicyPlanDeletionTriggerPrototype {
    /** The maximum number of days to keep each backup after creation. */
    delete_after?: number;
    /** The maximum number of recent backups to keep. If unspecified, there will be no maximum. */
    delete_over_count?: number;
  }

  /** BackupPolicyPlanPrototype. */
  export interface BackupPolicyPlanPrototype {
    /** Indicates whether the plan is active. */
    active?: boolean;
    /** User tags to attach to each backup (snapshot) created by this plan. If unspecified, no user tags will be
     *  attached.
     */
    attach_user_tags?: string[];
    clone_policy?: BackupPolicyPlanClonePolicyPrototype;
    /** Indicates whether to copy the source's user tags to the created backups (snapshots). */
    copy_user_tags?: boolean;
    /** The cron specification for the backup schedule. The backup policy jobs
     *  (which create and delete backups for this plan) will not start until this time, and may start for up to 90
     *  minutes after this time.
     *
     *  All backup schedules for plans in the same policy must be at least an hour apart.
     */
    cron_spec: string;
    deletion_trigger?: BackupPolicyPlanDeletionTriggerPrototype;
    /** The name for this backup policy plan. The name must not be used by another plan for the backup policy. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The policies for additional backups in remote regions. */
    remote_region_policies?: BackupPolicyPlanRemoteRegionPolicyPrototype[];
  }

  /** BackupPolicyPlanReference. */
  export interface BackupPolicyPlanReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: BackupPolicyPlanReferenceDeleted;
    /** The URL for this backup policy plan. */
    href: string;
    /** The unique identifier for this backup policy plan. */
    id: string;
    /** The name for this backup policy plan. The name is unique across all plans in the backup policy. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: BackupPolicyPlanRemote;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface BackupPolicyPlanReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** If present, this property indicates that the resource associated with this reference is remote and therefore may not be directly retrievable. */
  export interface BackupPolicyPlanRemote {
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /** BackupPolicyPlanRemoteRegionPolicy. */
  export interface BackupPolicyPlanRemoteRegionPolicy {
    /** The region this backup policy plan will create backups in. */
    delete_over_count: number;
    /** The root key used to rewrap the data encryption key for the backup (snapshot). */
    encryption_key: EncryptionKeyReference;
    /** The region this backup policy plan will create backups in. */
    region: RegionReference;
  }

  /** BackupPolicyPlanRemoteRegionPolicyPrototype. */
  export interface BackupPolicyPlanRemoteRegionPolicyPrototype {
    /** The region this backup policy plan will create backups in. */
    delete_over_count?: number;
    /** The root key to use to rewrap the data encryption key for the backup (snapshot).
     *
     *  If unspecified, the source's `encryption_key` will be used.
     *  The specified key may be in a different account, subject to IAM policies.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The region this backup policy plan will create backups in. */
    region: RegionIdentity;
  }

  /** BareMetalServer. */
  export interface BareMetalServer {
    /** The total bandwidth (in megabits per second) shared across the bare metal server network interfaces. */
    bandwidth: number;
    /** The possible resource types for this property are expected to expand in the future. */
    boot_target: BareMetalServerBootTarget;
    /** The bare metal server CPU configuration. */
    cpu: BareMetalServerCPU;
    /** The date and time that the bare metal server was created. */
    created_at: string;
    /** The CRN for this bare metal server. */
    crn: string;
    /** The disks for this bare metal server, including any disks that are associated with the `boot_target`. */
    disks: BareMetalServerDisk[];
    /** Indicates whether secure boot is enabled. If enabled, the image must support secure boot or the server will
     *  fail to boot.
     */
    enable_secure_boot: boolean;
    /** The URL for this bare metal server. */
    href: string;
    /** The unique identifier for this bare metal server. */
    id: string;
    /** The reasons for the current `lifecycle_state` (if any).
     *
     *  The enumerated reason code values for this property will expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected reason code was encountered.
     */
    lifecycle_reasons: BareMetalServerLifecycleReason[];
    /** The lifecycle state of the bare metal server. */
    lifecycle_state: string;
    /** The amount of memory, truncated to whole gibibytes. */
    memory: number;
    /** The name for this bare metal server. The name is unique across all bare metal servers in the region. */
    name: string;
    /** The bare metal server network interfaces, including the primary interface. */
    network_interfaces: NetworkInterfaceBareMetalServerContextReference[];
    /** The primary bare metal server network interface. */
    primary_network_interface: NetworkInterfaceBareMetalServerContextReference;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
     *  for this bare metal server.
     */
    profile: BareMetalServerProfileReference;
    /** The resource group for this bare metal server. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The status of the bare metal server. */
    status: string;
    /** The reasons for the current status (if any).
     *
     *  The enumerated reason code values for this property will expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected reason code was encountered.
     */
    status_reasons: BareMetalServerStatusReason[];
    trusted_platform_module: BareMetalServerTrustedPlatformModule;
    /** The VPC this bare metal server resides in. */
    vpc: VPCReference;
    /** The zone this bare metal server resides in. */
    zone: ZoneReference;
  }

  /** The possible resource types for this property are expected to expand in the future. */
  export interface BareMetalServerBootTarget {
  }

  /** The bare metal server CPU configuration. */
  export interface BareMetalServerCPU {
    /** The CPU architecture. */
    architecture: string;
    /** The total number of cores. */
    core_count: number;
    /** The total number of CPU sockets. */
    socket_count: number;
    /** The total number of hardware threads per core. */
    threads_per_core: number;
  }

  /** BareMetalServerCollection. */
  export interface BareMetalServerCollection {
    /** Collection of bare metal servers. */
    bare_metal_servers: BareMetalServer[];
    /** A link to the first page of resources. */
    first: BareMetalServerCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: BareMetalServerCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface BareMetalServerCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface BareMetalServerCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** The bare metal server console access token information. */
  export interface BareMetalServerConsoleAccessToken {
    /** A URL safe single-use token used to access the console WebSocket. */
    access_token: string;
    /** The bare metal server console type for which this token may be used. */
    console_type: string;
    /** The date and time that the access token was created. */
    created_at: string;
    /** The date and time that the access token will expire. */
    expires_at: string;
    /** Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.
     *  This has no effect on VNC consoles.
     */
    force: boolean;
    /** The URL to access this bare metal server console. */
    href: string;
  }

  /** BareMetalServerDisk. */
  export interface BareMetalServerDisk {
    /** The date and time that the disk was created. */
    created_at: string;
    /** The URL for this bare metal server disk. */
    href: string;
    /** The unique identifier for this bare metal server disk. */
    id: string;
    /** The disk interface used for attaching the disk.
     *
     *  - `fcp`: Attached using Fiber Channel Protocol
     *  - `sata`: Attached using Serial Advanced Technology Attachment
     *  - `nvme`: Attached using Non-Volatile Memory Express
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected property value was encountered.
     */
    interface_type: string;
    /** The name for this bare metal server disk. The name is unique across all disks on the bare metal server. */
    name: string;
    /** The resource type. */
    resource_type: string;
    /** The size of the disk in GB (gigabytes). */
    size: number;
  }

  /** BareMetalServerDiskCollection. */
  export interface BareMetalServerDiskCollection {
    /** Collection of the bare metal server's disks. */
    disks: BareMetalServerDisk[];
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface BareMetalServerDiskReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** BareMetalServerInitialization. */
  export interface BareMetalServerInitialization {
    /** The image the bare metal server was provisioned from. */
    image: ImageReference;
    /** The public SSH keys used at initialization. */
    keys: KeyReference[];
    /** The user accounts that are created at initialization. There can be multiple account types distinguished by
     *  the `resource_type` property.
     */
    user_accounts: BareMetalServerInitializationUserAccount[];
  }

  /** BareMetalServerInitializationPrototype. */
  export interface BareMetalServerInitializationPrototype {
    /** The image to be used when provisioning the bare metal server. */
    image: ImageIdentity;
    /** The public SSH keys to install on the bare metal server. Keys will be made available to the bare metal
     *  server as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as SSH authorized
     *  keys for the administrative user.
     *
     *  For Windows images, at least one key must be specified, and one will be selected to encrypt the administrator
     *  password. Keys are optional for other images, but if no keys are specified, the instance will be inaccessible
     *  unless the specified image provides another means of access.
     */
    keys: KeyIdentity[];
    /** User data to be made available when initializing the bare metal server. */
    user_data?: string;
  }

  /** BareMetalServerInitializationUserAccount. */
  export interface BareMetalServerInitializationUserAccount {
  }

  /** BareMetalServerLifecycleReason. */
  export interface BareMetalServerLifecycleReason {
    /** A snake case string succinctly identifying the reason for this lifecycle state. */
    code: string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }

  /** BareMetalServerNetworkInterface. */
  export interface BareMetalServerNetworkInterface {
    /** Indicates whether source IP spoofing is allowed on this bare metal server network interface. */
    allow_ip_spoofing: boolean;
    /** The date and time that the bare metal server network interface was created. */
    created_at: string;
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the bare metal server network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - `interface_type` must not be `hipersocket`.
     */
    enable_infrastructure_nat: boolean;
    /** The floating IPs associated with this bare metal server network interface. */
    floating_ips: FloatingIPReference[];
    /** The URL for this bare metal server network interface. */
    href: string;
    /** The unique identifier for this bare metal server network interface. */
    id: string;
    /** The interface type:
     *  - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
     *    within a `s390x` based system
     *  - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI interface
     *    - Cannot directly use an IEEE 802.1q VLAN tag.
     *  - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its
     *    array of `allowed_vlans`.
     *    - Must use an IEEE 802.1q tag.
     *    - Has its own security groups and does not inherit those of the PCI device through
     *      which traffic flows.
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected property value was encountered.
     */
    interface_type: string;
    /** The MAC address of this bare metal server network interface. If the MAC address has not yet been selected,
     *  the value will be an empty string.
     */
    mac_address: string;
    /** The name for this bare metal server network interface. */
    name: string;
    /** The bare metal server network interface port speed in Mbps. */
    port_speed: number;
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: string;
    /** The security groups targeting this bare metal server network interface. */
    security_groups: SecurityGroupReference[];
    /** The status of the bare metal server network interface. */
    status: string;
    /** The associated subnet. */
    subnet: SubnetReference;
    /** The type of this bare metal server network interface. */
    type: string;
  }

  /** BareMetalServerNetworkInterfaceCollection. */
  export interface BareMetalServerNetworkInterfaceCollection {
    /** A link to the first page of resources. */
    first: BareMetalServerNetworkInterfaceCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** Collection of bare metal server network interfaces. */
    network_interfaces: BareMetalServerNetworkInterface[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: BareMetalServerNetworkInterfaceCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface BareMetalServerNetworkInterfaceCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface BareMetalServerNetworkInterfaceCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** BareMetalServerNetworkInterfacePrototype. */
  export interface BareMetalServerNetworkInterfacePrototype {
    /** Indicates whether source IP spoofing is allowed on this bare metal server network interface. */
    allow_ip_spoofing?: boolean;
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the bare metal server network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - `interface_type` must not be `hipersocket`.
     */
    enable_infrastructure_nat?: boolean;
    /** The interface type:
     *  - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
     *    within a `s390x` based system
     *    - Not supported on bare metal servers with a `cpu.architecture` of `amd64`
     *  - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI interface
     *    - Cannot directly use an IEEE 802.1q VLAN tag.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`
     *  - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its
     *    array of `allowed_vlans`.
     *    - Must use an IEEE 802.1q tag.
     *    - Has its own security groups and does not inherit those of the PCI device through
     *      which traffic flows.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type: string;
    /** The name for this bare metal server network interface. The name must not be used by another network
     *  interface on the bare metal server. If unspecified, the name will be a hyphenated list of randomly-selected
     *  words.
     */
    name?: string;
    /** The primary IP address to bind to the bare metal server network interface. This can be
     *  specified using an existing reserved IP, or a prototype object for a new reserved IP.
     *
     *  If an existing reserved IP or a prototype object with an address is specified, it must
     *  be available on the bare metal server network interface's subnet. Otherwise, an
     *  available address on the subnet will be automatically selected and reserved.
     */
    primary_ip?: NetworkInterfaceIPPrototype;
    /** The security groups to use for this bare metal server network interface. If unspecified, the VPC's default
     *  security group is used.
     */
    security_groups?: SecurityGroupIdentity[];
    /** The associated subnet. */
    subnet: SubnetIdentity;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface BareMetalServerNetworkInterfaceReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface BareMetalServerNetworkInterfaceReferenceTargetContextDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** BareMetalServerPrimaryNetworkInterfacePrototype. */
  export interface BareMetalServerPrimaryNetworkInterfacePrototype {
    /** Indicates whether source IP spoofing is allowed on this bare metal server network interface. */
    allow_ip_spoofing?: boolean;
    /** Indicates what VLAN IDs (for VLAN type only) can use this physical (PCI type) interface. */
    allowed_vlans?: number[];
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the bare metal server network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - `interface_type` must not be `hipersocket`.
     */
    enable_infrastructure_nat?: boolean;
    /** The interface type:
     *  - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
     *    within a `s390x` based system.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `amd64`
     *  - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI interface
     *    - Cannot directly use an IEEE 802.1q VLAN tag.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type?: string;
    /** The name for this bare metal server network interface. The name must not be used by another network
     *  interface on the bare metal server. If unspecified, the name will be a hyphenated list of randomly-selected
     *  words.
     */
    name?: string;
    /** The primary IP address to bind to the bare metal server network interface. This can be
     *  specified using an existing reserved IP, or a prototype object for a new reserved IP.
     *
     *  If an existing reserved IP or a prototype object with an address is specified, it must
     *  be available on the bare metal server network interface's subnet. Otherwise, an
     *  available address on the subnet will be automatically selected and reserved.
     */
    primary_ip?: NetworkInterfaceIPPrototype;
    /** The security groups to use for this bare metal server network interface. If unspecified, the VPC's default
     *  security group is used.
     */
    security_groups?: SecurityGroupIdentity[];
    /** The associated subnet. */
    subnet: SubnetIdentity;
  }

  /** BareMetalServerProfile. */
  export interface BareMetalServerProfile {
    bandwidth: BareMetalServerProfileBandwidth;
    /** The console type configuration for a bare metal server with this profile. */
    console_types: BareMetalServerProfileConsoleTypes;
    cpu_architecture: BareMetalServerProfileCPUArchitecture;
    cpu_core_count: BareMetalServerProfileCPUCoreCount;
    cpu_socket_count: BareMetalServerProfileCPUSocketCount;
    /** Collection of the bare metal server profile's disks. */
    disks: BareMetalServerProfileDisk[];
    /** The product family this bare metal server profile belongs to. */
    family: string;
    /** The URL for this bare metal server profile. */
    href: string;
    memory: BareMetalServerProfileMemory;
    /** The name for this bare metal server profile. */
    name: string;
    network_interface_count: BareMetalServerProfileNetworkInterfaceCount;
    os_architecture: BareMetalServerProfileOSArchitecture;
    /** The resource type. */
    resource_type: string;
    /** The supported trusted platform module modes for this bare metal server profile. */
    supported_trusted_platform_module_modes: BareMetalServerProfileSupportedTrustedPlatformModuleModes;
  }

  /** BareMetalServerProfileBandwidth. */
  export interface BareMetalServerProfileBandwidth {
  }

  /** BareMetalServerProfileCPUArchitecture. */
  export interface BareMetalServerProfileCPUArchitecture {
    /** The default CPU architecture for a bare metal server with this profile. */
    default?: string;
    /** The type for this profile field. */
    type: string;
    /** The CPU architecture for a bare metal server with this profile. */
    value: string;
  }

  /** BareMetalServerProfileCPUCoreCount. */
  export interface BareMetalServerProfileCPUCoreCount {
  }

  /** BareMetalServerProfileCPUSocketCount. */
  export interface BareMetalServerProfileCPUSocketCount {
  }

  /** BareMetalServerProfileCollection. */
  export interface BareMetalServerProfileCollection {
    /** A link to the first page of resources. */
    first: BareMetalServerProfileCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: BareMetalServerProfileCollectionNext;
    /** Collection of bare metal server profiles. */
    profiles: BareMetalServerProfile[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface BareMetalServerProfileCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface BareMetalServerProfileCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** The console type configuration for a bare metal server with this profile. */
  export interface BareMetalServerProfileConsoleTypes {
    /** The type for this profile field. */
    type: string;
    /** The console types for a bare metal server with this profile. */
    values: string[];
  }

  /** Disks provided by this profile. */
  export interface BareMetalServerProfileDisk {
    quantity: BareMetalServerProfileDiskQuantity;
    size: BareMetalServerProfileDiskSize;
    supported_interface_types: BareMetalServerProfileDiskSupportedInterfaces;
  }

  /** BareMetalServerProfileDiskQuantity. */
  export interface BareMetalServerProfileDiskQuantity {
  }

  /** BareMetalServerProfileDiskSize. */
  export interface BareMetalServerProfileDiskSize {
  }

  /** BareMetalServerProfileDiskSupportedInterfaces. */
  export interface BareMetalServerProfileDiskSupportedInterfaces {
    /** The disk interface used for attaching the disk.
     *
     *  - `fcp`: Attached using Fiber Channel Protocol
     *  - `sata`: Attached using Serial Advanced Technology Attachment
     *  - `nvme`: Attached using Non-Volatile Memory Express
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected property value was encountered.
     */
    default: string;
    /** The type for this profile field. */
    type: string;
    /** The supported disk interfaces used for attaching the disk. */
    values: string[];
  }

  /** Identifies a bare metal server profile by a unique property. */
  export interface BareMetalServerProfileIdentity {
  }

  /** BareMetalServerProfileMemory. */
  export interface BareMetalServerProfileMemory {
  }

  /** BareMetalServerProfileNetworkInterfaceCount. */
  export interface BareMetalServerProfileNetworkInterfaceCount {
  }

  /** BareMetalServerProfileOSArchitecture. */
  export interface BareMetalServerProfileOSArchitecture {
    /** The default OS architecture for a bare metal server with this profile. */
    default: string;
    /** The type for this profile field. */
    type: string;
    /** The supported OS architecture(s) for a bare metal server with this profile. */
    values: string[];
  }

  /** BareMetalServerProfileReference. */
  export interface BareMetalServerProfileReference {
    /** The URL for this bare metal server profile. */
    href: string;
    /** The name for this bare metal server profile. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** The supported trusted platform module modes for this bare metal server profile. */
  export interface BareMetalServerProfileSupportedTrustedPlatformModuleModes {
    /** The type for this profile field. */
    type: string;
    /** The supported trusted platform module modes. */
    values: string[];
  }

  /** BareMetalServerStatusReason. */
  export interface BareMetalServerStatusReason {
    /** The status reason code:
     *  - `cannot_start`: Failed to start due to an internal error
     *  - `cannot_start_capacity`: Insufficient capacity within the selected zone
     *  - `cannot_start_compute`: An error occurred while allocating compute resources
     *  - `cannot_start_ip_address`: An error occurred while allocating an IP address
     *  - `cannot_start_network`: An error occurred while allocating network resources.
     */
    code: string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }

  /** BareMetalServerTrustedPlatformModule. */
  export interface BareMetalServerTrustedPlatformModule {
    /** Indicates whether the trusted platform module is enabled. */
    enabled: boolean;
    /** The trusted platform module (TPM) mode:
     *  - `disabled`: No TPM functionality
     *  - `tpm_2`: TPM 2.0
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected property value was encountered.
     */
    mode: string;
    /** The supported trusted platform module modes. */
    supported_modes: string[];
  }

  /** BareMetalServerTrustedPlatformModulePatch. */
  export interface BareMetalServerTrustedPlatformModulePatch {
    /** The trusted platform module mode to use. The specified value must be listed in the bare metal server's
     *  `supported_modes`.
     *
     *  For the trusted platform module mode to be changed, the bare metal server `status` must be `stopped`.
     */
    mode?: string;
  }

  /** BareMetalServerTrustedPlatformModulePrototype. */
  export interface BareMetalServerTrustedPlatformModulePrototype {
    /** The trusted platform module mode to use. The specified value must be listed in the bare metal server
     *  profile's `supported_trusted_platform_module_modes`.
     */
    mode?: string;
  }

  /** Identifies a [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering by a unique property. */
  export interface CatalogOfferingIdentity {
  }

  /** Identifies a version of a [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering by a unique property. */
  export interface CatalogOfferingVersionIdentity {
  }

  /** CatalogOfferingVersionReference. */
  export interface CatalogOfferingVersionReference {
    /** The CRN for this version of a
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering.
     */
    crn: string;
  }

  /** Identifies a certificate instance by a unique property. */
  export interface CertificateInstanceIdentity {
  }

  /** CertificateInstanceReference. */
  export interface CertificateInstanceReference {
    /** The CRN for this certificate instance. */
    crn: string;
  }

  /** Identifies a Cloud Object Storage bucket by a unique property. */
  export interface CloudObjectStorageBucketIdentity {
  }

  /** CloudObjectStorageBucketReference. */
  export interface CloudObjectStorageBucketReference {
    /** The CRN of this Cloud Object Storage bucket. */
    crn: string;
    /** The globally unique name of this Cloud Object Storage bucket. */
    name: string;
  }

  /** CloudObjectStorageObjectReference. */
  export interface CloudObjectStorageObjectReference {
    /** The name of this Cloud Object Storage object. Names are unique within a Cloud Object Storage bucket. */
    name: string;
  }

  /** Identifies a DNS instance by a unique property. */
  export interface DNSInstanceIdentity {
  }

  /** DNSInstanceReference. */
  export interface DNSInstanceReference {
    /** The CRN for this DNS instance. */
    crn: string;
  }

  /** Identifies a DNS zone by a unique property. */
  export interface DNSZoneIdentity {
  }

  /** DNSZoneReference. */
  export interface DNSZoneReference {
    id: string;
  }

  /** DedicatedHost. */
  export interface DedicatedHost {
    /** The amount of memory in gibibytes that is currently available for instances. */
    available_memory: number;
    /** The available VCPU for the dedicated host. */
    available_vcpu: VCPU;
    /** The date and time that the dedicated host was created. */
    created_at: string;
    /** The CRN for this dedicated host. */
    crn: string;
    /** Collection of the dedicated host's disks. */
    disks: DedicatedHostDisk[];
    /** The dedicated host group this dedicated host is in. */
    group: DedicatedHostGroupReference;
    /** The URL for this dedicated host. */
    href: string;
    /** The unique identifier for this dedicated host. */
    id: string;
    /** If set to true, instances can be placed on this dedicated host. */
    instance_placement_enabled: boolean;
    /** The instances that are allocated to this dedicated host. */
    instances: InstanceReference[];
    /** The lifecycle state of the dedicated host. */
    lifecycle_state: string;
    /** The total amount of memory in gibibytes for this host. */
    memory: number;
    /** The name for this dedicated host. The name is unique across all dedicated hosts in the region. */
    name: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles) for this dedicated host. */
    profile: DedicatedHostProfileReference;
    /** Indicates whether this dedicated host is available for instance creation. */
    provisionable: boolean;
    /** The resource group for this dedicated host. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The total number of sockets for this host. */
    socket_count: number;
    /** The administrative state of the dedicated host.
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the dedicated host
     *  on which the unexpected property value was encountered.
     */
    state: string;
    /** The instance profiles usable by instances placed on this dedicated host. */
    supported_instance_profiles: InstanceProfileReference[];
    /** The total VCPU of the dedicated host. */
    vcpu: VCPU;
    /** The zone this dedicated host resides in. */
    zone: ZoneReference;
  }

  /** DedicatedHostCollection. */
  export interface DedicatedHostCollection {
    /** Collection of dedicated hosts. */
    dedicated_hosts: DedicatedHost[];
    /** A link to the first page of resources. */
    first: DedicatedHostCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: DedicatedHostCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface DedicatedHostCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface DedicatedHostCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** DedicatedHostDisk. */
  export interface DedicatedHostDisk {
    /** The remaining space left for instance placement in GB (gigabytes). */
    available: number;
    /** The date and time that the disk was created. */
    created_at: string;
    /** The URL for this disk. */
    href: string;
    /** The unique identifier for this disk. */
    id: string;
    /** Instance disks that are on this dedicated host disk. */
    instance_disks: InstanceDiskReference[];
    /** The disk interface used for attaching the disk
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected property value was encountered.
     */
    interface_type: string;
    /** The lifecycle state of this dedicated host disk. */
    lifecycle_state?: string;
    /** The name for this dedicated host disk. The name is unique across all disks on the dedicated host. */
    name: string;
    /** Indicates whether this dedicated host disk is available for instance disk creation. */
    provisionable: boolean;
    /** The resource type. */
    resource_type: string;
    /** The size of the disk in GB (gigabytes). */
    size: number;
    /** The instance disk interfaces supported for this dedicated host disk. */
    supported_instance_interface_types: string[];
  }

  /** DedicatedHostDiskCollection. */
  export interface DedicatedHostDiskCollection {
    /** Collection of the dedicated host's disks. */
    disks: DedicatedHostDisk[];
  }

  /** DedicatedHostGroup. */
  export interface DedicatedHostGroup {
    /** The dedicated host profile class for hosts in this group. */
    class: string;
    /** The date and time that the dedicated host group was created. */
    created_at: string;
    /** The CRN for this dedicated host group. */
    crn: string;
    /** The dedicated hosts that are in this dedicated host group. */
    dedicated_hosts: DedicatedHostReference[];
    /** The dedicated host profile family for hosts in this group. */
    family: string;
    /** The URL for this dedicated host group. */
    href: string;
    /** The unique identifier for this dedicated host group. */
    id: string;
    /** The name for this dedicated host group. The name is unique across all dedicated host groups in the region. */
    name: string;
    /** The resource group for this dedicated host group. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The instance profiles usable by instances placed on this dedicated host group. */
    supported_instance_profiles: InstanceProfileReference[];
    /** The zone this dedicated host group resides in. */
    zone: ZoneReference;
  }

  /** DedicatedHostGroupCollection. */
  export interface DedicatedHostGroupCollection {
    /** A link to the first page of resources. */
    first: DedicatedHostGroupCollectionFirst;
    /** Collection of dedicated host groups. */
    groups: DedicatedHostGroup[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: DedicatedHostGroupCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface DedicatedHostGroupCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface DedicatedHostGroupCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies a dedicated host group by a unique property. */
  export interface DedicatedHostGroupIdentity {
  }

  /** DedicatedHostGroupPrototypeDedicatedHostByZoneContext. */
  export interface DedicatedHostGroupPrototypeDedicatedHostByZoneContext {
    /** The name for this dedicated host group. The name must not be used by another dedicated host group in the
     *  region. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the host's resource group is used. */
    resource_group?: ResourceGroupIdentity;
  }

  /** DedicatedHostGroupReference. */
  export interface DedicatedHostGroupReference {
    /** The CRN for this dedicated host group. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: DedicatedHostGroupReferenceDeleted;
    /** The URL for this dedicated host group. */
    href: string;
    /** The unique identifier for this dedicated host group. */
    id: string;
    /** The name for this dedicated host group. The name is unique across all dedicated host groups in the region. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface DedicatedHostGroupReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** DedicatedHostProfile. */
  export interface DedicatedHostProfile {
    /** The product class this dedicated host profile belongs to. */
    class: string;
    /** Collection of the dedicated host profile's disks. */
    disks: DedicatedHostProfileDisk[];
    /** The product family this dedicated host profile belongs to
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected property value was encountered.
     */
    family: string;
    /** The URL for this dedicated host. */
    href: string;
    memory: DedicatedHostProfileMemory;
    /** The globally unique name for this dedicated host profile. */
    name: string;
    socket_count: DedicatedHostProfileSocket;
    /** The instance profiles usable by instances placed on dedicated hosts with this profile. */
    supported_instance_profiles: InstanceProfileReference[];
    vcpu_architecture: DedicatedHostProfileVCPUArchitecture;
    vcpu_count: DedicatedHostProfileVCPU;
    vcpu_manufacturer: DedicatedHostProfileVCPUManufacturer;
  }

  /** DedicatedHostProfileCollection. */
  export interface DedicatedHostProfileCollection {
    /** A link to the first page of resources. */
    first: DedicatedHostProfileCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: DedicatedHostProfileCollectionNext;
    /** Collection of dedicated host profiles. */
    profiles: DedicatedHostProfile[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface DedicatedHostProfileCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface DedicatedHostProfileCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Disks provided by this profile. */
  export interface DedicatedHostProfileDisk {
    interface_type: DedicatedHostProfileDiskInterface;
    /** The number of disks of this type for a dedicated host with this profile. */
    quantity: DedicatedHostProfileDiskQuantity;
    /** The size of the disk in GB (gigabytes). */
    size: DedicatedHostProfileDiskSize;
    supported_instance_interface_types: DedicatedHostProfileDiskSupportedInterfaces;
  }

  /** DedicatedHostProfileDiskInterface. */
  export interface DedicatedHostProfileDiskInterface {
    /** The type for this profile field. */
    type: string;
    /** The interface of the disk for a dedicated host with this profile
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected property value was encountered.
     */
    value: string;
  }

  /** The number of disks of this type for a dedicated host with this profile. */
  export interface DedicatedHostProfileDiskQuantity {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The size of the disk in GB (gigabytes). */
  export interface DedicatedHostProfileDiskSize {
    /** The type for this profile field. */
    type: string;
    /** The size of the disk in GB (gigabytes). */
    value: number;
  }

  /** DedicatedHostProfileDiskSupportedInterfaces. */
  export interface DedicatedHostProfileDiskSupportedInterfaces {
    /** The type for this profile field. */
    type: string;
    /** The instance disk interfaces supported for a dedicated host with this profile. */
    value: string[];
  }

  /** Identifies a dedicated host profile by a unique property. */
  export interface DedicatedHostProfileIdentity {
  }

  /** DedicatedHostProfileMemory. */
  export interface DedicatedHostProfileMemory {
  }

  /** DedicatedHostProfileReference. */
  export interface DedicatedHostProfileReference {
    /** The URL for this dedicated host. */
    href: string;
    /** The globally unique name for this dedicated host profile. */
    name: string;
  }

  /** DedicatedHostProfileSocket. */
  export interface DedicatedHostProfileSocket {
  }

  /** DedicatedHostProfileVCPU. */
  export interface DedicatedHostProfileVCPU {
  }

  /** DedicatedHostProfileVCPUArchitecture. */
  export interface DedicatedHostProfileVCPUArchitecture {
    /** The type for this profile field. */
    type: string;
    /** The VCPU architecture for a dedicated host with this profile. */
    value: string;
  }

  /** DedicatedHostProfileVCPUManufacturer. */
  export interface DedicatedHostProfileVCPUManufacturer {
    /** The type for this profile field. */
    type: string;
    /** The VCPU manufacturer for a dedicated host with this profile. */
    value: string;
  }

  /** DedicatedHostPrototype. */
  export interface DedicatedHostPrototype {
    /** If set to true, instances can be placed on this dedicated host. */
    instance_placement_enabled?: boolean;
    /** The name for this dedicated host. The name must not be used by another dedicated host in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles) to use for this dedicated host. */
    profile: DedicatedHostProfileIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
  }

  /** DedicatedHostReference. */
  export interface DedicatedHostReference {
    /** The CRN for this dedicated host. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: DedicatedHostReferenceDeleted;
    /** The URL for this dedicated host. */
    href: string;
    /** The unique identifier for this dedicated host. */
    id: string;
    /** The name for this dedicated host. The name is unique across all dedicated hosts in the region. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface DedicatedHostReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** DefaultNetworkACL. */
  export interface DefaultNetworkACL {
    /** The date and time that the network ACL was created. */
    created_at: string;
    /** The CRN for this network ACL. */
    crn: string;
    /** The URL for this network ACL. */
    href: string;
    /** The unique identifier for this network ACL. */
    id: string;
    /** The name of the default network ACL created for a VPC. The name will be a hyphenated list of
     *  randomly-selected words at creation, but may be changed.
     */
    name: string;
    /** The resource group for the default network ACL for a VPC. Set to the VPC's resource group at creation. */
    resource_group: ResourceGroupReference;
    /** The ordered rules for the default network ACL for a VPC. Defaults to two rules which allow all inbound and
     *  outbound traffic, respectively. Rules for the default network ACL may be changed, added, or removed.
     */
    rules: NetworkACLRuleItem[];
    /** The subnets to which this network ACL is attached. */
    subnets: SubnetReference[];
    /** The VPC this network ACL resides in. */
    vpc: VPCReference;
  }

  /** DefaultRoutingTable. */
  export interface DefaultRoutingTable {
    /** The filters specifying the resources that may create routes in this routing table.
     *
     *  At present, only the `resource_type` filter is permitted, and only the `vpn_server` value is supported, but
     *  filter support is expected to expand in the future.
     */
    accept_routes_from: ResourceFilter[];
    /** The date and time that this routing table was created. */
    created_at: string;
    /** The URL for this routing table. */
    href: string;
    /** The unique identifier for this routing table. */
    id: string;
    /** Indicates whether this is the default routing table for this VPC. */
    is_default: boolean;
    /** The lifecycle state of the routing table. */
    lifecycle_state: string;
    /** The name of the default routing table created for this VPC. The name will be a hyphenated list of
     *  randomly-selected words at creation, but may be changed.
     */
    name: string;
    /** The resource type. */
    resource_type: string;
    /** Indicates whether this routing table is used to route traffic that originates from
     *  [Direct Link](https://cloud.ibm.com/docs/dl) to this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     */
    route_direct_link_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from the internet.
     *
     *  Incoming traffic will be routed according to the routing table with two exceptions:
     *  - Traffic destined for IP addresses associated with public gateways will not be
     *    subject to routes in this routing table.
     *  - Routes with an action of deliver are treated as drop unless the `next_hop` is an
     *    IP address in a subnet in the route's `zone`. Therefore, if an incoming packet
     *    matches a route with a `next_hop` of an internet-bound IP address or a VPN gateway
     *    connection, the packet will be dropped.
     */
    route_internet_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from from [Transit
     *  Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     */
    route_transit_gateway_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from subnets in other zones in
     *  this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     */
    route_vpc_zone_ingress: boolean;
    /** The routes for the default routing table for this VPC. The table is created with no routes, but routes may
     *  be added, changed, or removed with a subsequent request.
     */
    routes: RouteReference[];
    /** The subnets to which this routing table is attached. */
    subnets: SubnetReference[];
  }

  /** DefaultSecurityGroup. */
  export interface DefaultSecurityGroup {
    /** The date and time that this security group was created. */
    created_at: string;
    /** The security group's CRN. */
    crn: string;
    /** The security group's canonical URL. */
    href: string;
    /** The unique identifier for this security group. */
    id: string;
    /** The name for the default security group for a VPC. The name will be a hyphenated list of randomly-selected
     *  words at creation, but may changed.
     */
    name: string;
    /** The resource group for this security group. */
    resource_group: ResourceGroupReference;
    /** The rules for the default security group for a VPC. Defaults to allowing all outbound traffic, and allowing
     *  all inbound traffic from other interfaces in the VPC's default security group. Rules for the default security
     *  group may be changed, added or removed.
     */
    rules: SecurityGroupRule[];
    /** The targets for this security group. */
    targets: SecurityGroupTargetReference[];
    /** The VPC this security group resides in. */
    vpc: VPCReference;
  }

  /** Identifies an encryption key by a unique property. */
  export interface EncryptionKeyIdentity {
  }

  /** EncryptionKeyReference. */
  export interface EncryptionKeyReference {
    /** The CRN of the [Key Protect Root
     *  Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
     *  Services Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
     */
    crn: string;
  }

  /** EndpointGateway. */
  export interface EndpointGateway {
    /** The date and time that the endpoint gateway was created. */
    created_at: string;
    /** The CRN for this endpoint gateway. */
    crn: string;
    /** The health of this resource.
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
     *  lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may
     *  also have this state.
     */
    health_state: string;
    /** The URL for this endpoint gateway. */
    href: string;
    /** The unique identifier for this endpoint gateway. */
    id: string;
    /** The reserved IPs bound to this endpoint gateway. */
    ips: ReservedIPReference[];
    /** The lifecycle state of the endpoint gateway. */
    lifecycle_state: string;
    /** The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC. */
    name: string;
    /** The resource group for this endpoint gateway. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The security groups targeting this endpoint gateway. */
    security_groups: SecurityGroupReference[];
    /** Deprecated: The fully qualified domain name for the target service. */
    service_endpoint?: string;
    /** The fully qualified domain names for the target service. */
    service_endpoints: string[];
    /** The target for this endpoint gateway. */
    target: EndpointGatewayTarget;
    /** The VPC this endpoint gateway resides in. */
    vpc: VPCReference;
  }

  /** EndpointGatewayCollection. */
  export interface EndpointGatewayCollection {
    /** Collection of endpoint gateways. */
    endpoint_gateways: EndpointGateway[];
    /** A link to the first page of resources. */
    first: EndpointGatewayCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: EndpointGatewayCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface EndpointGatewayCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface EndpointGatewayCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface EndpointGatewayReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** A reserved IP to bind to the endpoint gateway. This can be specified using an existing reserved IP, or a prototype object for a new reserved IP. The reserved IP will be bound to the endpoint gateway to function as a virtual private endpoint for the service. */
  export interface EndpointGatewayReservedIP {
  }

  /** The target for this endpoint gateway. */
  export interface EndpointGatewayTarget {
  }

  /** The target to use for this endpoint gateway. Must not already be the target of another endpoint gateway in the VPC. */
  export interface EndpointGatewayTargetPrototype {
    /** The type of target for this endpoint gateway. */
    resource_type: string;
  }

  /** FloatingIP. */
  export interface FloatingIP {
    /** The globally unique IP address. */
    address: string;
    /** The date and time that the floating IP was created. */
    created_at: string;
    /** The CRN for this floating IP. */
    crn: string;
    /** The URL for this floating IP. */
    href: string;
    /** The unique identifier for this floating IP. */
    id: string;
    /** The name for this floating IP. The name is unique across all floating IPs in the region. */
    name: string;
    /** The resource group for this floating IP. */
    resource_group: ResourceGroupReference;
    /** The status of the floating IP. */
    status: string;
    /** The target of this floating IP. */
    target?: FloatingIPTarget;
    /** The zone this floating IP resides in. */
    zone: ZoneReference;
  }

  /** FloatingIPCollection. */
  export interface FloatingIPCollection {
    /** A link to the first page of resources. */
    first: FloatingIPCollectionFirst;
    /** Collection of floating IPs. */
    floating_ips: FloatingIP[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: FloatingIPCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface FloatingIPCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface FloatingIPCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** FloatingIPPrototype. */
  export interface FloatingIPPrototype {
    /** The name for this floating IP. The name must not be used by another floating IP in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
  }

  /** FloatingIPReference. */
  export interface FloatingIPReference {
    /** The globally unique IP address. */
    address: string;
    /** The CRN for this floating IP. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: FloatingIPReferenceDeleted;
    /** The URL for this floating IP. */
    href: string;
    /** The unique identifier for this floating IP. */
    id: string;
    /** The name for this floating IP. The name is unique across all floating IPs in the region. */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface FloatingIPReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** The target of this floating IP. */
  export interface FloatingIPTarget {
  }

  /** The target resource to bind this floating IP to, replacing any existing binding. The floating IP must not be required by another resource, such as a public gateway. The target resource must not already have a floating IP bound to it if the target resource is: - an instance network interface - a bare metal server network interface with `enable_infrastructure_nat` set to `true`. */
  export interface FloatingIPTargetPatch {
  }

  /** The target resource to bind this floating IP to. The target resource must not already have a floating IP bound to it if the target resource is: - an instance network interface - a bare metal server network interface with `enable_infrastructure_nat` set to `true`. */
  export interface FloatingIPTargetPrototype {
  }

  /** FloatingIPUnpaginatedCollection. */
  export interface FloatingIPUnpaginatedCollection {
    /** Collection of floating IPs. */
    floating_ips: FloatingIP[];
  }

  /** FlowLogCollector. */
  export interface FlowLogCollector {
    /** Indicates whether this collector is active. */
    active: boolean;
    /** Indicates whether this flow log collector will be automatically deleted when `target` is deleted. At
     *  present, this is always `true`, but may be modifiable in the future.
     */
    auto_delete: boolean;
    /** The date and time that the flow log collector was created. */
    created_at: string;
    /** The CRN for this flow log collector. */
    crn: string;
    /** The URL for this flow log collector. */
    href: string;
    /** The unique identifier for this flow log collector. */
    id: string;
    /** The lifecycle state of the flow log collector. */
    lifecycle_state: string;
    /** The name for this flow log collector. The name is unique across all flow log collectors in the VPC. */
    name: string;
    /** The resource group for this flow log collector. */
    resource_group: ResourceGroupReference;
    /** The Cloud Object Storage bucket where the collected flows are logged. */
    storage_bucket: LegacyCloudObjectStorageBucketReference;
    /** The target this collector is collecting flow logs for.
     *  - If the target is an instance network interface, flow logs will be collected
     *    for that instance network interface.
     *  - If the target is a virtual server instance, flow logs will be collected
     *    for all network interfaces on that instance.
     *  - If the target is a subnet, flow logs will be collected
     *    for all instance network interfaces attached to that subnet.
     *  - If the target is a VPC, flow logs will be collected for instance network interfaces
     *    attached to all subnets within that VPC.
     *  If the target is an instance, subnet, or VPC, flow logs will not be collected
     *  for any instance network interfaces within the target that are themselves the target of
     *  a more specific flow log collector.
     */
    target: FlowLogCollectorTarget;
    /** The VPC this flow log collector resides in. */
    vpc: VPCReference;
  }

  /** FlowLogCollectorCollection. */
  export interface FlowLogCollectorCollection {
    /** A link to the first page of resources. */
    first: FlowLogCollectorCollectionFirst;
    /** Collection of flow log collectors. */
    flow_log_collectors: FlowLogCollector[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: FlowLogCollectorCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface FlowLogCollectorCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface FlowLogCollectorCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** The target this collector is collecting flow logs for. - If the target is an instance network interface, flow logs will be collected for that instance network interface. - If the target is a virtual server instance, flow logs will be collected for all network interfaces on that instance. - If the target is a subnet, flow logs will be collected for all instance network interfaces attached to that subnet. - If the target is a VPC, flow logs will be collected for instance network interfaces attached to all subnets within that VPC. If the target is an instance, subnet, or VPC, flow logs will not be collected for any instance network interfaces within the target that are themselves the target of a more specific flow log collector. */
  export interface FlowLogCollectorTarget {
  }

  /** The target this collector will collect flow logs for. If the target is an instance, subnet, or VPC, flow logs will not be collected for any instance network interfaces within the target that are themselves the target of a more specific flow log collector. */
  export interface FlowLogCollectorTargetPrototype {
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface GenericResourceReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** IKEPolicy. */
  export interface IKEPolicy {
    /** The authentication algorithm
     *
     *  The `md5` and `sha1` algorithms have been deprecated.
     */
    authentication_algorithm: string;
    /** The VPN gateway connections that use this IKE policy. */
    connections: VPNGatewayConnectionReference[];
    /** The date and time that this IKE policy was created. */
    created_at: string;
    /** The Diffie-Hellman group
     *
     *  Groups `2` and `5` have been deprecated.
     */
    dh_group: number;
    /** The encryption algorithm
     *
     *  The `triple_des` algorithm has been deprecated.
     */
    encryption_algorithm: string;
    /** The IKE policy's canonical URL. */
    href: string;
    /** The unique identifier for this IKE policy. */
    id: string;
    /** The IKE protocol version. */
    ike_version: number;
    /** The key lifetime in seconds. */
    key_lifetime: number;
    /** The name for this IKE policy. The name is unique across all IKE policies in the region. */
    name: string;
    /** The IKE negotiation mode. Only `main` is supported. */
    negotiation_mode: string;
    /** The resource group for this IKE policy. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
  }

  /** IKEPolicyCollection. */
  export interface IKEPolicyCollection {
    /** A link to the first page of resources. */
    first: IKEPolicyCollectionFirst;
    /** Collection of IKE policies. */
    ike_policies: IKEPolicy[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: IKEPolicyCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface IKEPolicyCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface IKEPolicyCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** IKEPolicyReference. */
  export interface IKEPolicyReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: IKEPolicyReferenceDeleted;
    /** The IKE policy's canonical URL. */
    href: string;
    /** The unique identifier for this IKE policy. */
    id: string;
    /** The name for this IKE policy. The name is unique across all IKE policies in the region. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface IKEPolicyReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** IP. */
  export interface IP {
    /** The IP address.
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
  }

  /** IPsecPolicy. */
  export interface IPsecPolicy {
    /** The authentication algorithm
     *
     *  The `md5` and `sha1` algorithms have been deprecated
     *
     *  Must be `disabled` if and only if the `encryption_algorithm` is
     *  `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`.
     */
    authentication_algorithm: string;
    /** The VPN gateway connections that use this IPsec policy. */
    connections: VPNGatewayConnectionReference[];
    /** The date and time that this IPsec policy was created. */
    created_at: string;
    /** The encapsulation mode used. Only `tunnel` is supported. */
    encapsulation_mode: string;
    /** The encryption algorithm
     *
     *  The `triple_des` algorithm has been deprecated
     *
     *  The `authentication_algorithm` must be `disabled` if and only if
     *  `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or
     *  `aes256gcm16`.
     */
    encryption_algorithm: string;
    /** The IPsec policy's canonical URL. */
    href: string;
    /** The unique identifier for this IPsec policy. */
    id: string;
    /** The key lifetime in seconds. */
    key_lifetime: number;
    /** The name for this IPsec policy. The name is unique across all IPsec policies in the region. */
    name: string;
    /** Perfect Forward Secrecy
     *
     *  Groups `group_2` and `group_5` have been deprecated.
     */
    pfs: string;
    /** The resource group for this IPsec policy. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The transform protocol used. Only `esp` is supported. */
    transform_protocol: string;
  }

  /** IPsecPolicyCollection. */
  export interface IPsecPolicyCollection {
    /** A link to the first page of resources. */
    first: IPsecPolicyCollectionFirst;
    /** Collection of IPsec policies. */
    ipsec_policies: IPsecPolicy[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: IPsecPolicyCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface IPsecPolicyCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface IPsecPolicyCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** IPsecPolicyReference. */
  export interface IPsecPolicyReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: IPsecPolicyReferenceDeleted;
    /** The IPsec policy's canonical URL. */
    href: string;
    /** The unique identifier for this IPsec policy. */
    id: string;
    /** The name for this IPsec policy. The name is unique across all IPsec policies in the region. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface IPsecPolicyReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** Image. */
  export interface Image {
    catalog_offering: ImageCatalogOffering;
    /** The date and time that the image was created. */
    created_at: string;
    /** The CRN for this image. */
    crn: string;
    /** The deprecation date and time (UTC) for this image.
     *
     *  If absent, no deprecation date and time has been set.
     */
    deprecation_at?: string;
    /** The type of encryption used on the image. */
    encryption: string;
    /** The key that will be used to encrypt volumes created from this image (unless an
     *  alternate `encryption_key` is specified at volume creation).
     *
     *  This property will be present for images with an `encryption` type of `user_managed`.
     */
    encryption_key?: EncryptionKeyReference;
    /** Details for the stored image file. */
    file: ImageFile;
    /** The URL for this image. */
    href: string;
    /** The unique identifier for this image. */
    id: string;
    /** The minimum size (in gigabytes) of a volume onto which this image may be provisioned.
     *
     *  This property may be absent if the image has a `status` of `pending` or `failed`.
     */
    minimum_provisioned_size?: number;
    /** The name for this image. The name is unique across all images in the region. */
    name: string;
    /** The obsolescence date and time (UTC) for this image.
     *
     *  If absent, no obsolescence date and time has been set.
     */
    obsolescence_at?: string;
    /** The operating system included in this image. */
    operating_system?: OperatingSystem;
    /** The resource group for this image. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The volume used to create this image (this may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     *  If absent, this image was not created from a volume.
     */
    source_volume?: VolumeReference;
    /** The status of this image
     *  - available: image can be used (provisionable)
     *  - deleting: image is being deleted, and can no longer be used to provision new
     *    resources
     *  - deprecated: image is administratively slated to become `obsolete`
     *  - failed: image is corrupt or did not pass validation
     *  - obsolete: image administratively set to not be used for new resources
     *  - pending: image is being imported and is not yet `available`
     *  - unusable: image cannot be used (see `status_reasons[]` for possible remediation)
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the image on which
     *  the unexpected property value was encountered.
     */
    status: string;
    /** The reasons for the current status (if any):
     *  - `encrypted_data_key_invalid`: image cannot be decrypted with the specified
     *    `encryption_key`
     *  - `encryption_key_deleted`: image unusable because its `encryption_key` was deleted
     *  - `encryption_key_disabled`: image unusable until its `encryption_key` is re-enabled
     *  - `image_data_corrupted`: image data is corrupt, or is not in the specified format
     *  - `image_provisioned_size_unsupported`: image requires a boot volume size greater
     *    than the maximum supported value
     *  - `image_request_in_progress`: image operation is in progress (such as an import from
     *     Cloud Object Storage)
     *  - `image_request_queued`: image request has been accepted but the requested
     *    operation has not started
     *
     *  The enumerated reason code values for this property will expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected reason code was encountered.
     */
    status_reasons: ImageStatusReason[];
    /** The visibility of this image. - `private`: Visible only to this account - `public`: Visible to all accounts. */
    visibility: string;
  }

  /** ImageCatalogOffering. */
  export interface ImageCatalogOffering {
    /** Indicates whether this image is managed as part of a
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering. If an image is managed,
     *  accounts in the same
     *  [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise) with access to that catalog
     *  can specify the image's catalog offering version CRN to provision virtual server instances using the image.
     */
    managed: boolean;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering version associated with this image.
     *
     *  If absent, this image is not associated with a cloud catalog offering.
     */
    version?: CatalogOfferingVersionReference;
  }

  /** ImageCollection. */
  export interface ImageCollection {
    /** A link to the first page of resources. */
    first: ImageCollectionFirst;
    /** Collection of images. */
    images: Image[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: ImageCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface ImageCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface ImageCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** ImageExportJob. */
  export interface ImageExportJob {
    /** The date and time that the image export job was completed.
     *
     *  If absent, the export job has not yet completed.
     */
    completed_at?: string;
    /** The date and time that the image export job was created. */
    created_at: string;
    /** A base64-encoded, encrypted representation of the key that was used to encrypt the data for the exported
     *  image. This key can be unwrapped with the image's `encryption_key` root key using either Key Protect or Hyper
     *  Protect Crypto Services.
     *
     *  If absent, the export job is for an unencrypted image.
     */
    encrypted_data_key?: string;
    /** The format of the exported image. */
    format: string;
    /** The URL for this image export job. */
    href: string;
    /** The unique identifier for this image export job. */
    id: string;
    /** The name for this image export job. The name must not be used by another export job for the image. Changing
     *  the name will not affect the exported image name,
     *  `storage_object.name`, or `storage_href` values.
     */
    name: string;
    /** The type of resource referenced. */
    resource_type: string;
    /** The date and time that the image export job started running.
     *
     *  If absent, the export job has not yet started.
     */
    started_at?: string;
    /** The status of this image export job:
     *  - `deleting`: Export job is being deleted
     *  - `failed`: Export job could not be completed successfully
     *  - `queued`: Export job is queued
     *  - `running`: Export job is in progress
     *  - `succeeded`: Export job was completed successfully
     *
     *  The exported image object is automatically deleted for `failed` jobs.
     */
    status: string;
    /** The reasons for the current status (if any).
     *
     *  The enumerated reason code values for this property will expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected reason code was encountered.
     */
    status_reasons: ImageExportJobStatusReason[];
    /** The Cloud Object Storage bucket of the exported image object. */
    storage_bucket: CloudObjectStorageBucketReference;
    /** The Cloud Object Storage location of the exported image object. The object at this location will not exist
     *  until the job completes successfully. The exported image object is not managed by the IBM VPC service, and may
     *  be removed or replaced with a different object by any user or service with IAM authorization to the storage
     *  bucket.
     */
    storage_href: string;
    /** The Cloud Object Storage object for the exported image. This object will not exist until
     *  the job completes successfully. The exported image object is not managed by the IBM VPC
     *  service, and may be removed or replaced with a different object by any user or service
     *  with IAM authorization to the storage bucket.
     */
    storage_object: CloudObjectStorageObjectReference;
  }

  /** ImageExportJobStatusReason. */
  export interface ImageExportJobStatusReason {
    /** A snake case string succinctly identifying the status reason. */
    code: string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }

  /** ImageExportJobUnpaginatedCollection. */
  export interface ImageExportJobUnpaginatedCollection {
    /** Collection of image export jobs. */
    export_jobs: ImageExportJob[];
  }

  /** ImageFile. */
  export interface ImageFile {
    /** Checksums for this image file.
     *
     *  This property may be absent if the associated image has a `status` of `pending` or
     *  `failed`.
     */
    checksums?: ImageFileChecksums;
    /** The size of the stored image file rounded up to the next gigabyte.
     *
     *  This property may be absent if the associated image has a `status` of `pending` or
     *  `failed`.
     */
    size?: number;
  }

  /** ImageFileChecksums. */
  export interface ImageFileChecksums {
    /** The SHA256 fingerprint of the image file. */
    sha256?: string;
  }

  /** ImageFilePrototype. */
  export interface ImageFilePrototype {
    /** The Cloud Object Storage location of the image file.
     *
     *  The image file format is specified by the file's extension, which must be either
     *  `qcow2` or `vhd`.
     */
    href: string;
  }

  /** Identifies an image by a unique property. */
  export interface ImageIdentity {
  }

  /** ImagePrototype. */
  export interface ImagePrototype {
    /** The deprecation date and time to set for this image.
     *
     *  The date and time must not be in the past, and must be earlier than `obsolescence_at`
     *  (if `obsolescence_at` is set).
     *
     *  If unspecified, no deprecation date and time will be set.
     *
     *  If the deprecation date and time is reached while the image has a status of `pending`, the image's status will
     *  transition to `deprecated` upon its successful creation (or
     *  `obsolete` if the obsolescence date and time was also reached).
     */
    deprecation_at?: string;
    /** The name for this image. The name must not be used by another image in the region. Names starting with
     *  `ibm-` are reserved for system-provided images, and are not allowed. If unspecified, the name will be a
     *  hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The obsolescence date and time to set for this image.
     *
     *  The date and time must not be in the past, and must be later than `deprecation_at` (if
     *  `deprecation_at` is set).
     *
     *  If unspecified, no obsolescence date and time will be set.
     *
     *  If the obsolescence date and time is reached while the image has a status of
     *  `pending`, the image's status will transition to `obsolete` upon its successful creation.
     */
    obsolescence_at?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
  }

  /** ImageReference. */
  export interface ImageReference {
    /** The CRN for this image. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: ImageReferenceDeleted;
    /** The URL for this image. */
    href: string;
    /** The unique identifier for this image. */
    id: string;
    /** The name for this image. The name is unique across all images in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: ImageRemote;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface ImageReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** If present, this property indicates that the resource associated with this reference is remote and therefore may not be directly retrievable. */
  export interface ImageRemote {
    /** If present, this property indicates that the referenced resource is remote to this
     *  account, and identifies the owning account.
     */
    account?: AccountReference;
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /** ImageStatusReason. */
  export interface ImageStatusReason {
    /** A snake case string succinctly identifying the status reason. */
    code: string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }

  /** Instance. */
  export interface Instance {
    /** The availability policy for this virtual server instance. */
    availability_policy: InstanceAvailabilityPolicy;
    /** The total bandwidth (in megabits per second) shared across the instance network interfaces and storage
     *  volumes of virtual server instance.
     */
    bandwidth: number;
    /** Boot volume attachment. */
    boot_volume_attachment: VolumeAttachmentReferenceInstanceContext;
    /** If present, this virtual server instance was provisioned from a
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user).
     */
    catalog_offering?: InstanceCatalogOffering;
    /** The date and time that the virtual server instance was created. */
    created_at: string;
    /** The CRN for this virtual server instance. */
    crn: string;
    /** If present, the dedicated host this virtual server instance has been placed on. */
    dedicated_host?: DedicatedHostReference;
    /** The instance disks for this virtual server instance. */
    disks: InstanceDisk[];
    /** The virtual server instance GPU configuration. */
    gpu?: InstanceGPU;
    /** The URL for this virtual server instance. */
    href: string;
    /** The unique identifier for this virtual server instance. */
    id: string;
    /** The image the virtual server instance was provisioned from. */
    image?: ImageReference;
    /** The reasons for the current `lifecycle_state` (if any).
     *
     *  The enumerated reason code values for this property will expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected reason code was encountered.
     */
    lifecycle_reasons: InstanceLifecycleReason[];
    /** The lifecycle state of the virtual server instance. */
    lifecycle_state: string;
    /** The amount of memory, truncated to whole gibibytes. */
    memory: number;
    /** The metadata service configuration. */
    metadata_service: InstanceMetadataService;
    /** The name for this virtual server instance. The name is unique across all virtual server instances in the
     *  region.
     */
    name: string;
    /** The instance network interfaces, including the primary instance network interface. */
    network_interfaces: NetworkInterfaceInstanceContextReference[];
    /** The placement restrictions for the virtual server instance. */
    placement_target?: InstancePlacementTarget;
    /** The primary instance network interface. */
    primary_network_interface: NetworkInterfaceInstanceContextReference;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) for this virtual server instance. */
    profile: InstanceProfileReference;
    /** The resource group for this instance. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** Indicates whether the state of the virtual server instance permits a start request. */
    startable: boolean;
    /** The status of the virtual server instance.
     *
     *  The enumerated values for this property will expand in the future. When processing this property, check for and
     *  log unknown values. Optionally halt processing and surface the error, or bypass the instance on which the
     *  unexpected property value was encountered.
     */
    status: string;
    /** The reasons for the current status (if any).
     *
     *  The enumerated reason code values for this property will expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected reason code was encountered.
     */
    status_reasons: InstanceStatusReason[];
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance network interfaces. */
    total_network_bandwidth: number;
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An
     *  increase in this value will result in a corresponding decrease to
     *  `total_network_bandwidth`.
     */
    total_volume_bandwidth: number;
    /** The virtual server instance VCPU configuration. */
    vcpu: InstanceVCPU;
    /** The volume attachments for this virtual server instance, including the boot volume attachment. */
    volume_attachments: VolumeAttachmentReferenceInstanceContext[];
    /** The VPC this virtual server instance resides in. */
    vpc: VPCReference;
    /** The zone this virtual server instance resides in. */
    zone: ZoneReference;
  }

  /** InstanceAction. */
  export interface InstanceAction {
    /** Deprecated: The date and time that the action was completed. */
    completed_at?: string;
    /** The date and time that the action was created. */
    created_at: string;
    /** If set to true, the action will be forced immediately, and all queued actions deleted. Ignored for the start
     *  action.
     */
    force?: boolean;
    /** Deprecated: The URL for this instance action. */
    href: string;
    /** Deprecated: The identifier for this instance action. */
    id: string;
    /** Deprecated: The date and time that the action was started. */
    started_at?: string;
    /** Deprecated: The current status of this action. */
    status: string;
    /** The type of action. */
    type: string;
  }

  /** InstanceAvailabilityPolicy. */
  export interface InstanceAvailabilityPolicy {
    /** The action to perform if the compute host experiences a failure.
     *  - `restart`: Automatically restart the virtual server instance after host failure
     *  - `stop`: Leave the virtual server instance stopped after host failure
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the instance on
     *  which the unexpected property value was encountered.
     */
    host_failure: string;
  }

  /** InstanceAvailabilityPolicyPatch. */
  export interface InstanceAvailabilityPolicyPatch {
    /** The action to perform if the compute host experiences a failure.
     *  - `restart`: Automatically restart the virtual server instance after host failure
     *  - `stop`: Leave the virtual server instance stopped after host failure.
     */
    host_failure?: string;
  }

  /** InstanceAvailabilityPolicyPrototype. */
  export interface InstanceAvailabilityPolicyPrototype {
    /** The action to perform if the compute host experiences a failure.
     *  - `restart`: Automatically restart the virtual server instance after host failure
     *  - `stop`: Leave the virtual server instance stopped after host failure.
     */
    host_failure?: string;
  }

  /** InstanceCatalogOffering. */
  export interface InstanceCatalogOffering {
    /** The catalog offering version this virtual server instance was provisioned from.
     *
     *  The catalog offering version is not managed by the IBM VPC service, and may no longer
     *  exist, or may refer to a different image CRN than the `image.crn` for this virtual
     *  server instance. However, all images associated with a catalog offering version will
     *  have the same checksum, and therefore will have the same data.
     */
    version: CatalogOfferingVersionReference;
  }

  /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering or offering version to use when provisioning this virtual server instance. If an offering is specified, the latest version of that offering will be used. The specified offering or offering version may be in a different account in the same [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise), subject to IAM policies. */
  export interface InstanceCatalogOfferingPrototype {
  }

  /** InstanceCollection. */
  export interface InstanceCollection {
    /** A link to the first page of resources. */
    first: InstanceCollectionFirst;
    /** Collection of virtual server instances. */
    instances: Instance[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: InstanceCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface InstanceCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface InstanceCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** The instance console access token information. */
  export interface InstanceConsoleAccessToken {
    /** A URL safe single-use token used to access the console WebSocket. */
    access_token: string;
    /** The instance console type for which this token may be used. */
    console_type: string;
    /** The date and time that the access token was created. */
    created_at: string;
    /** The date and time that the access token will expire. */
    expires_at: string;
    /** Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.
     *  This has no effect on VNC consoles.
     */
    force: boolean;
    /** The URL to access this instance console. */
    href: string;
  }

  /** InstanceDefaultTrustedProfilePrototype. */
  export interface InstanceDefaultTrustedProfilePrototype {
    /** If set to `true`, the system will create a link to the specified `target` trusted profile during instance
     *  creation. Regardless of whether a link is created by the system or manually using the IAM Identity service, it
     *  will be automatically deleted when the instance is deleted.
     */
    auto_link?: boolean;
    /** The default IAM trusted profile to use for this virtual server instance. */
    target: TrustedProfileIdentity;
  }

  /** InstanceDisk. */
  export interface InstanceDisk {
    /** The date and time that the disk was created. */
    created_at: string;
    /** The URL for this instance disk. */
    href: string;
    /** The unique identifier for this instance disk. */
    id: string;
    /** The disk interface used for attaching the disk.
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected property value was encountered.
     */
    interface_type: string;
    /** The name for this instance disk. The name is unique across all disks on the instance. */
    name: string;
    /** The resource type. */
    resource_type: string;
    /** The size of the disk in GB (gigabytes). */
    size: number;
  }

  /** InstanceDiskCollection. */
  export interface InstanceDiskCollection {
    /** Collection of the instance's disks. */
    disks: InstanceDisk[];
  }

  /** InstanceDiskReference. */
  export interface InstanceDiskReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: InstanceDiskReferenceDeleted;
    /** The URL for this instance disk. */
    href: string;
    /** The unique identifier for this instance disk. */
    id: string;
    /** The name for this instance disk. The name is unique across all disks on the instance. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface InstanceDiskReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** The virtual server instance GPU configuration. */
  export interface InstanceGPU {
    /** The number of GPUs assigned to the instance. */
    count: number;
    /** The GPU manufacturer. */
    manufacturer: string;
    /** The overall amount of GPU memory in GiB (gibibytes). */
    memory: number;
    /** The GPU model. */
    model: string;
  }

  /** InstanceGroup. */
  export interface InstanceGroup {
    /** The port used for new load balancer pool members created by this instance group.
     *
     *  This property will be present if and only if `load_balancer_pool` is present.
     */
    application_port?: number;
    /** The date and time that the instance group was created. */
    created_at: string;
    /** The CRN for this instance group. */
    crn: string;
    /** The URL for this instance group. */
    href: string;
    /** The unique identifier for this instance group. */
    id: string;
    /** The template used to create new instances for this group. */
    instance_template: InstanceTemplateReference;
    /** If present, the load balancer pool this instance group manages. A pool member will
     *  be created for each instance created by this group.
     */
    load_balancer_pool?: LoadBalancerPoolReference;
    /** The managers for the instance group. */
    managers: InstanceGroupManagerReference[];
    /** The number of instances in the instance group. */
    membership_count: number;
    /** The name for this instance group. The name is unique across all instance groups in the region. */
    name: string;
    resource_group: ResourceGroupReference;
    /** The status of the instance group
     *  - `deleting`: Group is being deleted
     *  - `healthy`: Group has `membership_count` instances
     *  - `scaling`: Instances in the group are being created or deleted to reach
     *               `membership_count`
     *  - `unhealthy`: Group is unable to reach `membership_count` instances.
     */
    status: string;
    /** The subnets to use when creating new instances. */
    subnets: SubnetReference[];
    /** The date and time that the instance group was updated. */
    updated_at: string;
    /** The VPC the instance group resides in. */
    vpc: VPCReference;
  }

  /** InstanceGroupCollection. */
  export interface InstanceGroupCollection {
    /** A link to the first page of resources. */
    first: InstanceGroupCollectionFirst;
    /** Collection of instance groups. */
    instance_groups: InstanceGroup[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: InstanceGroupCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface InstanceGroupCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface InstanceGroupCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** InstanceGroupManager. */
  export interface InstanceGroupManager {
    /** The date and time that the instance group manager was created. */
    created_at: string;
    /** The URL for this instance group manager. */
    href: string;
    /** The unique identifier for this instance group manager. */
    id: string;
    /** Indicates whether this manager will control the instance group. */
    management_enabled: boolean;
    /** The name for this instance group manager. The name is unique across all managers for the instance group. */
    name: string;
    /** The date and time that the instance group manager was updated. */
    updated_at: string;
  }

  /** InstanceGroupManagerAction. */
  export interface InstanceGroupManagerAction {
    /** Indicates whether this scheduled action will be automatically deleted after it has completed and
     *  `auto_delete_timeout` hours have passed. At present, this is always
     *  `true`, but may be modifiable in the future.
     */
    auto_delete: boolean;
    /** If `auto_delete` is `true`, and this scheduled action has finished, the hours after which it will be
     *  automatically deleted. If the value is `0`, the action will be deleted once it has finished. This value may be
     *  modifiable in the future.
     */
    auto_delete_timeout: number;
    /** The date and time that the instance group manager action was created. */
    created_at: string;
    /** The URL for this instance group manager action. */
    href: string;
    /** The unique identifier for this instance group manager action. */
    id: string;
    /** The name for this instance group manager action. The name is unique across all actions for the instance
     *  group manager.
     */
    name: string;
    /** The resource type. */
    resource_type: string;
    /** The status of the instance group action
     *  - `active`: Action is ready to be run
     *  - `completed`: Action was completed successfully
     *  - `failed`: Action could not be completed successfully
     *  - `incompatible`: Action parameters are not compatible with the group or manager
     *  - `omitted`: Action was not applied because this action's manager was disabled.
     */
    status: string;
    /** The date and time that the instance group manager action was updated. */
    updated_at: string;
  }

  /** InstanceGroupManagerActionGroupPatch. */
  export interface InstanceGroupManagerActionGroupPatch {
    /** The desired number of instance group members at the scheduled time. */
    membership_count?: number;
  }

  /** InstanceGroupManagerActionManagerPatch. */
  export interface InstanceGroupManagerActionManagerPatch {
    /** The desired maximum number of instance group members at the scheduled time. */
    max_membership_count?: number;
    /** The desired minimum number of instance group members at the scheduled time. */
    min_membership_count?: number;
  }

  /** InstanceGroupManagerActionPrototype. */
  export interface InstanceGroupManagerActionPrototype {
    /** The name for this instance group manager action. The name must not be used by another action for the
     *  instance group manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /** InstanceGroupManagerActionReference. */
  export interface InstanceGroupManagerActionReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: InstanceGroupManagerActionReferenceDeleted;
    /** The URL for this instance group manager action. */
    href: string;
    /** The unique identifier for this instance group manager action. */
    id: string;
    /** The name for this instance group manager action. The name is unique across all actions for the instance
     *  group manager.
     */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface InstanceGroupManagerActionReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** InstanceGroupManagerActionsCollection. */
  export interface InstanceGroupManagerActionsCollection {
    /** Collection of instance group manager actions. */
    actions: InstanceGroupManagerAction[];
    /** A link to the first page of resources. */
    first: InstanceGroupManagerActionsCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: InstanceGroupManagerActionsCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface InstanceGroupManagerActionsCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface InstanceGroupManagerActionsCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** InstanceGroupManagerCollection. */
  export interface InstanceGroupManagerCollection {
    /** A link to the first page of resources. */
    first: InstanceGroupManagerCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** Collection of instance group managers. */
    managers: InstanceGroupManager[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: InstanceGroupManagerCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface InstanceGroupManagerCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface InstanceGroupManagerCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** InstanceGroupManagerPolicy. */
  export interface InstanceGroupManagerPolicy {
    /** The date and time that the instance group manager policy was created. */
    created_at: string;
    /** The URL for this instance group manager policy. */
    href: string;
    /** The unique identifier for this instance group manager policy. */
    id: string;
    /** The name for this instance group manager policy. The name is unique across all policies for the instance
     *  group manager.
     */
    name: string;
    /** The date and time that the instance group manager policy was updated. */
    updated_at: string;
  }

  /** InstanceGroupManagerPolicyCollection. */
  export interface InstanceGroupManagerPolicyCollection {
    /** A link to the first page of resources. */
    first: InstanceGroupManagerPolicyCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: InstanceGroupManagerPolicyCollectionNext;
    /** Collection of instance group manager policies. */
    policies: InstanceGroupManagerPolicy[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface InstanceGroupManagerPolicyCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface InstanceGroupManagerPolicyCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** InstanceGroupManagerPolicyPrototype. */
  export interface InstanceGroupManagerPolicyPrototype {
    /** The name for this instance group manager policy. The name must not be used by another policy for the
     *  instance group manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /** InstanceGroupManagerPolicyReference. */
  export interface InstanceGroupManagerPolicyReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: InstanceGroupManagerPolicyReferenceDeleted;
    /** The URL for this instance group manager policy. */
    href: string;
    /** The unique identifier for this instance group manager policy. */
    id: string;
    /** The name for this instance group manager policy. The name is unique across all policies for the instance
     *  group manager.
     */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface InstanceGroupManagerPolicyReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** InstanceGroupManagerPrototype. */
  export interface InstanceGroupManagerPrototype {
    /** Indicates whether this manager will control the instance group. */
    management_enabled?: boolean;
    /** The name for this instance group manager. The name must not be used by another manager for the instance
     *  group. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /** InstanceGroupManagerReference. */
  export interface InstanceGroupManagerReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: InstanceGroupManagerReferenceDeleted;
    /** The URL for this instance group manager. */
    href: string;
    /** The unique identifier for this instance group manager. */
    id: string;
    /** The name for this instance group manager. The name is unique across all managers for the instance group. */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface InstanceGroupManagerReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** InstanceGroupManagerScheduledActionGroup. */
  export interface InstanceGroupManagerScheduledActionGroup {
    /** The desired number of instance group members at the scheduled time. */
    membership_count: number;
  }

  /** InstanceGroupManagerScheduledActionGroupPrototype. */
  export interface InstanceGroupManagerScheduledActionGroupPrototype {
    /** The desired number of instance group members at the scheduled time. */
    membership_count: number;
  }

  /** InstanceGroupManagerScheduledActionManager. */
  export interface InstanceGroupManagerScheduledActionManager {
  }

  /** InstanceGroupManagerScheduledActionManagerPrototype. */
  export interface InstanceGroupManagerScheduledActionManagerPrototype {
  }

  /** InstanceGroupMembership. */
  export interface InstanceGroupMembership {
    /** The date and time that the instance group manager policy was created. */
    created_at: string;
    /** If set to true, when deleting the membership the instance will also be deleted. */
    delete_instance_on_membership_delete: boolean;
    /** The URL for this instance group membership. */
    href: string;
    /** The unique identifier for this instance group membership. */
    id: string;
    instance: InstanceReference;
    instance_template: InstanceTemplateReference;
    /** The name for this instance group membership. The name is unique across all memberships for the instance
     *  group.
     */
    name: string;
    pool_member?: LoadBalancerPoolMemberReference;
    /** The status of the instance group membership
     *  - `deleting`: Membership is deleting dependent resources
     *  - `failed`: Membership was unable to maintain dependent resources
     *  - `healthy`: Membership is active and serving in the group
     *  - `pending`: Membership is waiting for dependent resources
     *  - `unhealthy`: Membership has unhealthy dependent resources.
     */
    status: string;
    /** The date and time that the instance group membership was updated. */
    updated_at: string;
  }

  /** InstanceGroupMembershipCollection. */
  export interface InstanceGroupMembershipCollection {
    /** A link to the first page of resources. */
    first: InstanceGroupMembershipCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** Collection of instance group memberships. */
    memberships: InstanceGroupMembership[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: InstanceGroupMembershipCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface InstanceGroupMembershipCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface InstanceGroupMembershipCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** InstanceGroupReference. */
  export interface InstanceGroupReference {
    /** The CRN for this instance group. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: InstanceGroupReferenceDeleted;
    /** The URL for this instance group. */
    href: string;
    /** The unique identifier for this instance group. */
    id: string;
    /** The name for this instance group. The name is unique across all instance groups in the region. */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface InstanceGroupReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** InstanceInitialization. */
  export interface InstanceInitialization {
    /** The default trusted profile configuration specified at virtual server instance
     *  creation. If absent, no default trusted profile was specified.
     */
    default_trusted_profile?: InstanceInitializationDefaultTrustedProfile;
    /** The public SSH keys used at instance initialization. */
    keys: KeyReference[];
    password?: InstanceInitializationPassword;
  }

  /** InstanceInitializationDefaultTrustedProfile. */
  export interface InstanceInitializationDefaultTrustedProfile {
    /** If set to `true`, the system created a link to the specified `target` trusted profile during instance
     *  creation. Regardless of whether a link was created by the system or manually using the IAM Identity service, it
     *  will be automatically deleted when the instance is deleted.
     */
    auto_link: boolean;
    /** The default IAM trusted profile to use for this virtual server instance. */
    target: TrustedProfileReference;
  }

  /** InstanceInitializationPassword. */
  export interface InstanceInitializationPassword {
    /** The administrator password at initialization, encrypted using `encryption_key`, and returned base64-encoded. */
    encrypted_password: string;
    /** The public SSH key used to encrypt the administrator password. */
    encryption_key: KeyIdentityByFingerprint;
  }

  /** InstanceLifecycleReason. */
  export interface InstanceLifecycleReason {
    /** A snake case string succinctly identifying the reason for this lifecycle state. */
    code: string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }

  /** The metadata service configuration. */
  export interface InstanceMetadataService {
    /** Indicates whether the metadata service endpoint is available to the virtual server instance. */
    enabled: boolean;
    /** The communication protocol to use for the metadata service endpoint. Applies only when the metadata service
     *  is enabled.
     *  - `http`: HTTP protocol (unencrypted)
     *  - `https`: HTTP Secure protocol.
     */
    protocol: string;
    /** The hop limit (IP time to live) for IP response packets from the metadata service. Applies only when the
     *  metadata service is enabled.
     */
    response_hop_limit: number;
  }

  /** The metadata service configuration. */
  export interface InstanceMetadataServicePatch {
    /** Indicates whether the metadata service endpoint will be available to the virtual server instance. */
    enabled?: boolean;
    /** The communication protocol to use for the metadata service endpoint. Applies only when the metadata service
     *  is enabled.
     *  - `http`: HTTP protocol (unencrypted)
     *  - `https`: HTTP Secure protocol.
     */
    protocol?: string;
    /** The hop limit (IP time to live) for IP response packets from the metadata service. Applies only when the
     *  metadata service is enabled.
     */
    response_hop_limit?: number;
  }

  /** The metadata service configuration. */
  export interface InstanceMetadataServicePrototype {
    /** Indicates whether the metadata service endpoint will be available to the virtual server instance. */
    enabled?: boolean;
    /** The communication protocol to use for the metadata service endpoint. Applies only when the metadata service
     *  is enabled.
     *  - `http`: HTTP protocol (unencrypted)
     *  - `https`: HTTP Secure protocol.
     */
    protocol?: string;
    /** The hop limit (IP time to live) for IP response packets from the metadata service. Applies only when the
     *  metadata service is enabled.
     */
    response_hop_limit?: number;
  }

  /** The profile to use for this virtual server instance. For the profile to be changed, the instance `status` must be `stopping` or `stopped`. In addition, the requested profile must: - Have matching instance disk support. Any disks associated with the current profile will be deleted, and any disks associated with the requested profile will be created. - Be compatible with any `placement_target` constraints. For example, if the instance is placed on a dedicated host, the requested profile `family` must be the same as the dedicated host `family`. - Have the same `vcpu.architecture`. - Support the number of network interfaces the instance currently has. */
  export interface InstancePatchProfile {
  }

  /** InstancePlacementTarget. */
  export interface InstancePlacementTarget {
  }

  /** InstancePlacementTargetPatch. */
  export interface InstancePlacementTargetPatch {
  }

  /** InstancePlacementTargetPrototype. */
  export interface InstancePlacementTargetPrototype {
  }

  /** InstanceProfile. */
  export interface InstanceProfile {
    bandwidth: InstanceProfileBandwidth;
    /** Collection of the instance profile's disks. */
    disks: InstanceProfileDisk[];
    /** The product family this virtual server instance profile belongs to. */
    family: string;
    gpu_count?: InstanceProfileGPU;
    gpu_manufacturer?: InstanceProfileGPUManufacturer;
    gpu_memory?: InstanceProfileGPUMemory;
    gpu_model?: InstanceProfileGPUModel;
    /** The URL for this virtual server instance profile. */
    href: string;
    memory: InstanceProfileMemory;
    /** The globally unique name for this virtual server instance profile. */
    name: string;
    network_interface_count: InstanceProfileNetworkInterfaceCount;
    os_architecture: InstanceProfileOSArchitecture;
    port_speed: InstanceProfilePortSpeed;
    total_volume_bandwidth: InstanceProfileVolumeBandwidth;
    vcpu_architecture: InstanceProfileVCPUArchitecture;
    vcpu_count: InstanceProfileVCPU;
    vcpu_manufacturer: InstanceProfileVCPUManufacturer;
  }

  /** InstanceProfileBandwidth. */
  export interface InstanceProfileBandwidth {
  }

  /** InstanceProfileCollection. */
  export interface InstanceProfileCollection {
    /** Collection of virtual server instance profiles. */
    profiles: InstanceProfile[];
  }

  /** Disks provided by this profile. */
  export interface InstanceProfileDisk {
    quantity: InstanceProfileDiskQuantity;
    size: InstanceProfileDiskSize;
    supported_interface_types: InstanceProfileDiskSupportedInterfaces;
  }

  /** InstanceProfileDiskQuantity. */
  export interface InstanceProfileDiskQuantity {
  }

  /** InstanceProfileDiskSize. */
  export interface InstanceProfileDiskSize {
  }

  /** InstanceProfileDiskSupportedInterfaces. */
  export interface InstanceProfileDiskSupportedInterfaces {
    /** The disk interface used for attaching the disk.
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected property value was encountered.
     */
    default: string;
    /** The type for this profile field. */
    type: string;
    /** The supported disk interfaces used for attaching the disk. */
    values: string[];
  }

  /** InstanceProfileGPU. */
  export interface InstanceProfileGPU {
  }

  /** InstanceProfileGPUManufacturer. */
  export interface InstanceProfileGPUManufacturer {
    /** The type for this profile field. */
    type: string;
    /** The possible GPU manufacturer(s) for an instance with this profile. */
    values: string[];
  }

  /** InstanceProfileGPUMemory. */
  export interface InstanceProfileGPUMemory {
  }

  /** InstanceProfileGPUModel. */
  export interface InstanceProfileGPUModel {
    /** The type for this profile field. */
    type: string;
    /** The possible GPU model(s) for an instance with this profile. */
    values: string[];
  }

  /** Identifies an instance profile by a unique property. */
  export interface InstanceProfileIdentity {
  }

  /** InstanceProfileMemory. */
  export interface InstanceProfileMemory {
  }

  /** InstanceProfileNetworkInterfaceCount. */
  export interface InstanceProfileNetworkInterfaceCount {
  }

  /** InstanceProfileOSArchitecture. */
  export interface InstanceProfileOSArchitecture {
    /** The default OS architecture for an instance with this profile. */
    default: string;
    /** The type for this profile field. */
    type: string;
    /** The supported OS architecture(s) for an instance with this profile. */
    values: string[];
  }

  /** InstanceProfilePortSpeed. */
  export interface InstanceProfilePortSpeed {
  }

  /** InstanceProfileReference. */
  export interface InstanceProfileReference {
    /** The URL for this virtual server instance profile. */
    href: string;
    /** The globally unique name for this virtual server instance profile. */
    name: string;
  }

  /** InstanceProfileVCPU. */
  export interface InstanceProfileVCPU {
  }

  /** InstanceProfileVCPUArchitecture. */
  export interface InstanceProfileVCPUArchitecture {
    /** The default VCPU architecture for an instance with this profile. */
    default?: string;
    /** The type for this profile field. */
    type: string;
    /** The VCPU architecture for an instance with this profile. */
    value: string;
  }

  /** InstanceProfileVCPUManufacturer. */
  export interface InstanceProfileVCPUManufacturer {
    /** The default VCPU manufacturer for an instance with this profile. */
    default?: string;
    /** The type for this profile field. */
    type: string;
    /** The VCPU manufacturer for an instance with this profile. */
    value: string;
  }

  /** InstanceProfileVolumeBandwidth. */
  export interface InstanceProfileVolumeBandwidth {
  }

  /** InstancePrototype. */
  export interface InstancePrototype {
    /** The availability policy to use for this virtual server instance. */
    availability_policy?: InstanceAvailabilityPolicyPrototype;
    /** The default trusted profile configuration to use for this virtual server instance
     *
     *  This property's value is used when provisioning the virtual server instance, but not
     *  subsequently managed. Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization)
     *  property.
     */
    default_trusted_profile?: InstanceDefaultTrustedProfilePrototype;
    /** The public SSH keys for the administrative user of the virtual server instance. Keys will be made available
     *  to the virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be
     *  added as SSH authorized keys for the administrative user.
     *
     *  For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the
     *  administrator password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for
     *  other images, but if no keys are specified, the instance will be inaccessible unless the specified image
     *  provides another means of access.
     *
     *  This property's value is used when provisioning the virtual server instance, but not subsequently managed.
     *  Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
     */
    keys?: KeyIdentity[];
    /** The metadata service configuration. */
    metadata_service?: InstanceMetadataServicePrototype;
    /** The name for this virtual server instance. The name must not be used by another virtual server instance in
     *  the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
     *
     *  The system hostname will be based on this name.
     */
    name?: string;
    /** The placement restrictions to use for the virtual server instance. */
    placement_target?: InstancePlacementTargetPrototype;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this
     *  virtual server instance.
     *
     *  If unspecified, `bx2-2x8` will be used, but this default value is expected to change
     *  in the future.
     */
    profile?: InstanceProfileIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An
     *  increase in this value will result in a corresponding decrease to
     *  `total_network_bandwidth`.
     */
    total_volume_bandwidth?: number;
    /** [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the
     *  virtual server instance.
     */
    user_data?: string;
    /** The additional volume attachments to create for the virtual server instance. */
    volume_attachments?: VolumeAttachmentPrototype[];
    /** The VPC this virtual server instance will reside in.
     *
     *  If specified, it must match the VPC for the subnets of the instance network
     *  interfaces.
     */
    vpc?: VPCIdentity;
  }

  /** InstanceReference. */
  export interface InstanceReference {
    /** The CRN for this virtual server instance. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: InstanceReferenceDeleted;
    /** The URL for this virtual server instance. */
    href: string;
    /** The unique identifier for this virtual server instance. */
    id: string;
    /** The name for this virtual server instance. The name is unique across all virtual server instances in the
     *  region.
     */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface InstanceReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** InstanceStatusReason. */
  export interface InstanceStatusReason {
    /** A snake case string succinctly identifying the status reason. */
    code: string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }

  /** InstanceTemplate. */
  export interface InstanceTemplate {
    /** The availability policy to use for this virtual server instance. */
    availability_policy?: InstanceAvailabilityPolicyPrototype;
    /** The date and time that the instance template was created. */
    created_at: string;
    /** The CRN for this instance template. */
    crn: string;
    /** The default trusted profile configuration to use for this virtual server instance
     *
     *  This property's value is used when provisioning the virtual server instance, but not
     *  subsequently managed. Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization)
     *  property.
     */
    default_trusted_profile?: InstanceDefaultTrustedProfilePrototype;
    /** The URL for this instance template. */
    href: string;
    /** The unique identifier for this instance template. */
    id: string;
    /** The public SSH keys for the administrative user of the virtual server instance. Keys will be made available
     *  to the virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be
     *  added as SSH authorized keys for the administrative user.
     *
     *  For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the
     *  administrator password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for
     *  other images, but if no keys are specified, the instance will be inaccessible unless the specified image
     *  provides another means of access.
     *
     *  This property's value is used when provisioning the virtual server instance, but not subsequently managed.
     *  Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
     */
    keys?: KeyIdentity[];
    /** The metadata service configuration. */
    metadata_service?: InstanceMetadataServicePrototype;
    /** The name for this instance template. The name is unique across all instance templates in the region. */
    name: string;
    /** The placement restrictions to use for the virtual server instance. */
    placement_target?: InstancePlacementTargetPrototype;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this
     *  virtual server instance.
     *
     *  If unspecified, `bx2-2x8` will be used, but this default value is expected to change
     *  in the future.
     */
    profile?: InstanceProfileIdentity;
    /** The resource group for this instance template. */
    resource_group: ResourceGroupReference;
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An
     *  increase in this value will result in a corresponding decrease to
     *  `total_network_bandwidth`.
     */
    total_volume_bandwidth?: number;
    /** [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the
     *  virtual server instance.
     */
    user_data?: string;
    /** The additional volume attachments to create for the virtual server instance. */
    volume_attachments?: VolumeAttachmentPrototype[];
    /** The VPC this virtual server instance will reside in.
     *
     *  If specified, it must match the VPC for the subnets of the instance network
     *  interfaces.
     */
    vpc?: VPCIdentity;
  }

  /** InstanceTemplateCollection. */
  export interface InstanceTemplateCollection {
    /** A link to the first page of resources. */
    first: InstanceTemplateCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: InstanceTemplateCollectionNext;
    /** Collection of instance templates. */
    templates: InstanceTemplate[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface InstanceTemplateCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface InstanceTemplateCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies an instance template by a unique property. */
  export interface InstanceTemplateIdentity {
  }

  /** InstanceTemplatePrototype. */
  export interface InstanceTemplatePrototype {
    /** The availability policy to use for this virtual server instance. */
    availability_policy?: InstanceAvailabilityPolicyPrototype;
    /** The default trusted profile configuration to use for this virtual server instance
     *
     *  This property's value is used when provisioning the virtual server instance, but not
     *  subsequently managed. Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization)
     *  property.
     */
    default_trusted_profile?: InstanceDefaultTrustedProfilePrototype;
    /** The public SSH keys for the administrative user of the virtual server instance. Keys will be made available
     *  to the virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be
     *  added as SSH authorized keys for the administrative user.
     *
     *  For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the
     *  administrator password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for
     *  other images, but if no keys are specified, the instance will be inaccessible unless the specified image
     *  provides another means of access.
     *
     *  This property's value is used when provisioning the virtual server instance, but not subsequently managed.
     *  Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
     */
    keys?: KeyIdentity[];
    /** The metadata service configuration. */
    metadata_service?: InstanceMetadataServicePrototype;
    /** The name for this instance template. The name must not be used by another instance template in the region.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The placement restrictions to use for the virtual server instance. */
    placement_target?: InstancePlacementTargetPrototype;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this
     *  virtual server instance.
     *
     *  If unspecified, `bx2-2x8` will be used, but this default value is expected to change
     *  in the future.
     */
    profile?: InstanceProfileIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An
     *  increase in this value will result in a corresponding decrease to
     *  `total_network_bandwidth`.
     */
    total_volume_bandwidth?: number;
    /** [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the
     *  virtual server instance.
     */
    user_data?: string;
    /** The additional volume attachments to create for the virtual server instance. */
    volume_attachments?: VolumeAttachmentPrototype[];
    /** The VPC this virtual server instance will reside in.
     *
     *  If specified, it must match the VPC for the subnets of the instance network
     *  interfaces.
     */
    vpc?: VPCIdentity;
  }

  /** InstanceTemplateReference. */
  export interface InstanceTemplateReference {
    /** The CRN for this instance template. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: InstanceTemplateReferenceDeleted;
    /** The URL for this instance template. */
    href: string;
    /** The unique identifier for this instance template. */
    id: string;
    /** The name for this instance template. The name is unique across all instance templates in the region. */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface InstanceTemplateReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** The virtual server instance VCPU configuration. */
  export interface InstanceVCPU {
    /** The VCPU architecture. */
    architecture: string;
    /** The number of VCPUs assigned. */
    count: number;
    /** The VCPU manufacturer. */
    manufacturer: string;
  }

  /** Key. */
  export interface Key {
    /** The date and time that the key was created. */
    created_at: string;
    /** The CRN for this key. */
    crn: string;
    /** The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm
     *  (always `SHA256`).
     */
    fingerprint: string;
    /** The URL for this key. */
    href: string;
    /** The unique identifier for this key. */
    id: string;
    /** The length of this key (in bits). */
    length: number;
    /** The name for this key. The name must not be used by another key in the region. If unspecified, the name will
     *  be a hyphenated list of randomly-selected words.
     */
    name: string;
    /** The public SSH key, consisting of two space-separated fields: the algorithm name, and the base64-encoded
     *  key.
     */
    public_key: string;
    /** The resource group for this key. */
    resource_group: ResourceGroupReference;
    /** The crypto-system used by this key. */
    type: string;
  }

  /** KeyCollection. */
  export interface KeyCollection {
    /** A link to the first page of resources. */
    first: KeyCollectionFirst;
    /** Collection of keys. */
    keys: Key[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: KeyCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface KeyCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface KeyCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies a key by a unique property. */
  export interface KeyIdentity {
  }

  /** KeyReference. */
  export interface KeyReference {
    /** The CRN for this key. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: KeyReferenceDeleted;
    /** The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm
     *  (always `SHA256`).
     */
    fingerprint: string;
    /** The URL for this key. */
    href: string;
    /** The unique identifier for this key. */
    id: string;
    /** The name for this key. The name is unique across all keys in the region. */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface KeyReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** Identifies a Cloud Object Storage bucket by a unique property. */
  export interface LegacyCloudObjectStorageBucketIdentity {
  }

  /** LegacyCloudObjectStorageBucketReference. */
  export interface LegacyCloudObjectStorageBucketReference {
    /** The globally unique name of this Cloud Object Storage bucket. */
    name: string;
  }

  /** LoadBalancer. */
  export interface LoadBalancer {
    /** The date and time that this load balancer was created. */
    created_at: string;
    /** The load balancer's CRN. */
    crn: string;
    /** The DNS configuration for this load balancer.
     *
     *  If absent, DNS `A` records for this load balancer's `hostname` property will be added to
     *  the public DNS zone `lb.appdomain.cloud`.
     */
    dns?: LoadBalancerDNS;
    /** Fully qualified domain name assigned to this load balancer. */
    hostname: string;
    /** The load balancer's canonical URL. */
    href: string;
    /** The unique identifier for this load balancer. */
    id: string;
    /** Indicates whether this load balancer supports instance groups. */
    instance_groups_supported: boolean;
    /** The type of this load balancer, public or private. */
    is_public: boolean;
    /** The listeners of this load balancer. */
    listeners: LoadBalancerListenerReference[];
    /** The logging configuration for this load balancer. */
    logging: LoadBalancerLogging;
    /** The name for this load balancer. The name is unique across all load balancers in the VPC. */
    name: string;
    /** The operating status of this load balancer. */
    operating_status: string;
    /** The pools of this load balancer. */
    pools: LoadBalancerPoolReference[];
    /** The private IP addresses assigned to this load balancer. */
    private_ips: LoadBalancerPrivateIpsItem[];
    /** The profile for this load balancer. */
    profile: LoadBalancerProfileReference;
    /** The provisioning status of this load balancer:
     *
     *  - `active`: The load balancer is running.
     *  - `create_pending`: The load balancer is being created.
     *  - `delete_pending`: The load balancer is being deleted.
     *  - `maintenance_pending`: The load balancer is unavailable due to an internal
     *                            error (contact IBM support).
     *  - `migrate_pending`: The load balancer is migrating to the requested configuration.
     *                        Performance may be degraded.
     *  - `update_pending`: The load balancer is being updated
     *      to the requested configuration.
     *
     *    The enumerated values for this property are expected to expand in the future. When
     *    processing this property, check for and log unknown values. Optionally halt
     *    processing and surface the error, or bypass the load balancer on which the
     *    unexpected property value was encountered.
     */
    provisioning_status: string;
    /** The public IP addresses assigned to this load balancer.
     *
     *  Applicable only for public load balancers.
     */
    public_ips: IP[];
    /** The resource group for this load balancer. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** Indicates whether route mode is enabled for this load balancer.
     *
     *  At present, public load balancers are not supported with route mode enabled.
     */
    route_mode: boolean;
    /** The security groups targeting this load balancer.
     *
     *  Applicable only for load balancers that support security groups.
     */
    security_groups: SecurityGroupReference[];
    /** Indicates whether this load balancer supports security groups. */
    security_groups_supported: boolean;
    /** The subnets this load balancer is provisioned in.  The load balancer's availability depends on the
     *  availability of the zones that the subnets reside in.
     *
     *  All subnets will be in the same VPC.
     */
    subnets: SubnetReference[];
    /** Indicates whether this load balancer supports UDP. */
    udp_supported: boolean;
  }

  /** LoadBalancerCollection. */
  export interface LoadBalancerCollection {
    /** A link to the first page of resources. */
    first: LoadBalancerCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** Collection of load balancers. */
    load_balancers: LoadBalancer[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: LoadBalancerCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface LoadBalancerCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface LoadBalancerCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** The DNS configuration for this load balancer. If absent, DNS `A` records for this load balancer's `hostname` property will be added to the public DNS zone `lb.appdomain.cloud`. */
  export interface LoadBalancerDNS {
    /** The DNS instance associated with this load balancer. */
    instance: DNSInstanceReference;
    /** The DNS zone associated with this load balancer. */
    zone: DNSZoneReference;
  }

  /** The DNS configuration for this load balancer. Specify `null` to remove the existing DNS configuration, which will remove all DNS `A` records for this load balancer that had been added to `zone`, and add equivalent `A` records to the public DNS zone `lb.appdomain.cloud`. */
  export interface LoadBalancerDNSPatch {
    /** The DNS instance to associate with this load balancer.
     *
     *  The specified instance may be in a different region or account, subject to IAM
     *  policies.
     */
    instance?: DNSInstanceIdentity;
    /** The DNS zone to associate with this load balancer.
     *
     *  The specified zone may be in a different region or account, subject to IAM policies.
     */
    zone?: DNSZoneIdentity;
  }

  /** The DNS configuration for this load balancer. If unspecified, DNS `A` records for this load balancer's `hostname` property will be added to the public DNS zone `lb.appdomain.cloud`. Otherwise, those DNS `A` records will be added to the specified `zone`. */
  export interface LoadBalancerDNSPrototype {
    /** The DNS instance to associate with this load balancer.
     *
     *  The specified instance may be in a different region or account, subject to IAM
     *  policies.
     */
    instance: DNSInstanceIdentity;
    /** The DNS zone to associate with this load balancer.
     *
     *  The specified zone may be in a different region or account, subject to IAM policies.
     */
    zone: DNSZoneIdentity;
  }

  /** Identifies a load balancer by a unique property. */
  export interface LoadBalancerIdentity {
  }

  /** LoadBalancerListener. */
  export interface LoadBalancerListener {
    /** If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load
     *  balancers in the `application` family (otherwise always `false`). Additional restrictions:
     *  - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
     *    match the `accept_proxy_protocol` value of the `https_redirect` listener.
     *  - If this listener is the target of another listener's `https_redirect`, its
     *    `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
     */
    accept_proxy_protocol: boolean;
    /** The certificate instance used for SSL termination.
     *
     *  If absent, this listener is not using a certificate instance.
     */
    certificate_instance?: CertificateInstanceReference;
    /** The connection limit of the listener. */
    connection_limit?: number;
    /** The date and time that this listener was created. */
    created_at: string;
    /** The default pool for this listener. If absent, this listener has no default pool. */
    default_pool?: LoadBalancerPoolReference;
    /** The listener's canonical URL. */
    href: string;
    /** If present, the target listener that requests are redirected to. */
    https_redirect?: LoadBalancerListenerHTTPSRedirect;
    /** The unique identifier for this load balancer listener. */
    id: string;
    /** The idle connection timeout of the listener in seconds. This property will be present for load balancers in
     *  the `application` family.
     */
    idle_connection_timeout?: number;
    /** The policies for this listener. */
    policies?: LoadBalancerListenerPolicyReference[];
    /** The listener port number, or the inclusive lower bound of the port range. */
    port: number;
    /** The inclusive upper bound of the range of ports used by this listener.
     *
     *  At present, only load balancers in the `network` family support more than one port per listener.
     */
    port_max: number;
    /** The inclusive lower bound of the range of ports used by this listener.
     *
     *  At present, only load balancers in the `network` family support more than one port per listener.
     */
    port_min: number;
    /** The listener protocol.
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the listener on
     *  which the unexpected property value was encountered.
     */
    protocol: string;
    /** The provisioning status of this listener
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the listener on
     *  which the unexpected property value was encountered.
     */
    provisioning_status: string;
  }

  /** LoadBalancerListenerCollection. */
  export interface LoadBalancerListenerCollection {
    /** Collection of listeners. */
    listeners: LoadBalancerListener[];
  }

  /** LoadBalancerListenerHTTPSRedirect. */
  export interface LoadBalancerListenerHTTPSRedirect {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    listener: LoadBalancerListenerReference;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /** LoadBalancerListenerHTTPSRedirectPatch. */
  export interface LoadBalancerListenerHTTPSRedirectPatch {
    /** The HTTP status code for this redirect. */
    http_status_code?: number;
    /** Identifies a load balancer listener by a unique property. */
    listener?: LoadBalancerListenerIdentity;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /** LoadBalancerListenerHTTPSRedirectPrototype. */
  export interface LoadBalancerListenerHTTPSRedirectPrototype {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    /** Identifies a load balancer listener by a unique property. */
    listener: LoadBalancerListenerIdentity;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /** Identifies a load balancer listener by a unique property. */
  export interface LoadBalancerListenerIdentity {
  }

  /** LoadBalancerListenerPolicy. */
  export interface LoadBalancerListenerPolicy {
    /** The policy action.
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on
     *  which the unexpected property value was encountered.
     */
    action: string;
    /** The date and time that this policy was created. */
    created_at: string;
    /** The listener policy's canonical URL. */
    href: string;
    /** The policy's unique identifier. */
    id: string;
    /** The name for this load balancer listener policy. The name is unique across all policies for the load
     *  balancer listener.
     */
    name: string;
    /** Priority of the policy. Lower value indicates higher priority. */
    priority: number;
    /** The provisioning status of this policy
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on
     *  which the unexpected property value was encountered.
     */
    provisioning_status: string;
    /** The rules for this policy. */
    rules: LoadBalancerListenerPolicyRuleReference[];
    /** - If `action` is `forward`, the response is a `LoadBalancerPoolReference`
     *  - If `action` is `redirect`, the response is a `LoadBalancerListenerPolicyRedirectURL`
     *  - If `action` is `https_redirect`, the response is a `LoadBalancerListenerHTTPSRedirect`.
     */
    target?: LoadBalancerListenerPolicyTarget;
  }

  /** LoadBalancerListenerPolicyCollection. */
  export interface LoadBalancerListenerPolicyCollection {
    /** Collection of policies. */
    policies: LoadBalancerListenerPolicy[];
  }

  /** LoadBalancerListenerPolicyPrototype. */
  export interface LoadBalancerListenerPolicyPrototype {
    /** The policy action.
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on
     *  which the unexpected property value was encountered.
     */
    action: string;
    /** The name for this policy. The name must not be used by another policy for the load balancer listener. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** Priority of the policy. Lower value indicates higher priority. */
    priority: number;
    /** The rule prototype objects for this policy. */
    rules?: LoadBalancerListenerPolicyRulePrototype[];
    /** - If `action` is `forward`, specify a `LoadBalancerPoolIdentity`.
     *  - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPrototype`.
     *  - If `action` is `https_redirect`, specify a
     *    `LoadBalancerListenerPolicyHTTPSRedirectPrototype`.
     */
    target?: LoadBalancerListenerPolicyTargetPrototype;
  }

  /** LoadBalancerListenerPolicyReference. */
  export interface LoadBalancerListenerPolicyReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: LoadBalancerListenerPolicyReferenceDeleted;
    /** The listener policy's canonical URL. */
    href: string;
    /** The policy's unique identifier. */
    id: string;
    name: any;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface LoadBalancerListenerPolicyReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** LoadBalancerListenerPolicyRule. */
  export interface LoadBalancerListenerPolicyRule {
    /** The condition of the rule. */
    condition: string;
    /** The date and time that this rule was created. */
    created_at: string;
    /** The field. This is applicable to `header`, `query`, and `body` rule types.
     *
     *  If the rule type is `header`, this property is required.
     *
     *  If the rule type is `query`, this is optional. If specified and the rule condition is not
     *  `matches_regex`, the value must be percent-encoded.
     *
     *  If the rule type is `body`, this is optional.
     */
    field?: string;
    /** The rule's canonical URL. */
    href: string;
    /** The rule's unique identifier. */
    id: string;
    /** The provisioning status of this rule
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the rule on which
     *  the unexpected property value was encountered.
     */
    provisioning_status: string;
    /** The type of the rule.
     *
     *  Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
     */
    type: string;
    /** Value to be matched for rule condition.
     *
     *  If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
     */
    value: string;
  }

  /** LoadBalancerListenerPolicyRuleCollection. */
  export interface LoadBalancerListenerPolicyRuleCollection {
    /** Collection of rules. */
    rules: LoadBalancerListenerPolicyRule[];
  }

  /** LoadBalancerListenerPolicyRulePrototype. */
  export interface LoadBalancerListenerPolicyRulePrototype {
    /** The condition of the rule. */
    condition: string;
    /** The field. This is applicable to `header`, `query`, and `body` rule types.
     *
     *  If the rule type is `header`, this property is required.
     *
     *  If the rule type is `query`, this is optional. If specified and the rule condition is not
     *  `matches_regex`, the value must be percent-encoded.
     *
     *  If the rule type is `body`, this is optional.
     */
    field?: string;
    /** The type of the rule.
     *
     *  Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
     */
    type: string;
    /** Value to be matched for rule condition.
     *
     *  If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
     */
    value: string;
  }

  /** LoadBalancerListenerPolicyRuleReference. */
  export interface LoadBalancerListenerPolicyRuleReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: LoadBalancerListenerPolicyRuleReferenceDeleted;
    /** The rule's canonical URL. */
    href: string;
    /** The rule's unique identifier. */
    id: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface LoadBalancerListenerPolicyRuleReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** - If `action` is `forward`, the response is a `LoadBalancerPoolReference` - If `action` is `redirect`, the response is a `LoadBalancerListenerPolicyRedirectURL` - If `action` is `https_redirect`, the response is a `LoadBalancerListenerHTTPSRedirect`. */
  export interface LoadBalancerListenerPolicyTarget {
  }

  /** - If `action` is `forward`, specify a `LoadBalancerPoolIdentity`. - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPatch`. - If `action` is `https_redirect`, specify a `LoadBalancerListenerPolicyHTTPSRedirectPatch`. */
  export interface LoadBalancerListenerPolicyTargetPatch {
  }

  /** - If `action` is `forward`, specify a `LoadBalancerPoolIdentity`. - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPrototype`. - If `action` is `https_redirect`, specify a `LoadBalancerListenerPolicyHTTPSRedirectPrototype`. */
  export interface LoadBalancerListenerPolicyTargetPrototype {
  }

  /** LoadBalancerListenerPrototypeLoadBalancerContext. */
  export interface LoadBalancerListenerPrototypeLoadBalancerContext {
    /** If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load
     *  balancers in the `application` family (otherwise always `false`). Additional restrictions:
     *  - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
     *    match the `accept_proxy_protocol` value of the `https_redirect` listener.
     *  - If this listener is the target of another listener's `https_redirect`, its
     *    `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
     */
    accept_proxy_protocol?: boolean;
    /** The certificate instance to use for SSL termination. The listener must have a `protocol` of `https`. */
    certificate_instance?: CertificateInstanceIdentity;
    /** The connection limit of the listener. */
    connection_limit?: number;
    /** The default pool for this listener. If specified, the pool must:
     *    - Belong to this load balancer.
     *    - Have the same `protocol` as this listener, or have a compatible protocol.
     *      At present, the compatible protocols are `http` and `https`.
     *    - Not already be the `default_pool` for another listener.
     *
     *  If unspecified, this listener will be created with no default pool, but one may be
     *  subsequently set.
     */
    default_pool?: LoadBalancerPoolIdentityByName;
    /** The target listener that requests will be redirected to. This listener must have a
     *  `protocol` of `http`, and the target listener must have a `protocol` of `https`.
     */
    https_redirect?: LoadBalancerListenerHTTPSRedirectPrototype;
    /** The idle connection timeout of the listener in seconds. Supported for load balancers in the `application`
     *  family.
     */
    idle_connection_timeout?: number;
    /** The listener port number, or the inclusive lower bound of the port range. Each listener in the load balancer
     *  must have a unique `port` and `protocol` combination.
     *
     *  Not supported for load balancers operating with route mode enabled.
     */
    port?: number;
    /** The inclusive upper bound of the range of ports used by this listener. Must not be less than `port_min`.
     *
     *  At present, only load balancers operating with route mode enabled, and public load balancers in the `network`
     *  family support different values for `port_min` and
     *  `port_max`. When route mode is enabled, the value `65535` must be specified.
     *
     *  The specified port range must not overlap with port ranges used by other listeners for this load balancer using
     *  the same protocol.
     */
    port_max?: number;
    /** The inclusive lower bound of the range of ports used by this listener. Must not be greater than `port_max`.
     *
     *  At present, only load balancers operating with route mode enabled, and public load balancers in the `network`
     *  family support different values for `port_min` and
     *  `port_max`. When route mode is enabled, the value `1` must be specified.
     *
     *  The specified port range must not overlap with port ranges used by other listeners for this load balancer using
     *  the same protocol.
     */
    port_min?: number;
    /** The listener protocol. Each listener in the load balancer must have a unique `port` and `protocol`
     *  combination.
     *
     *  Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
     *  the `application` family support `tcp`, `http` and
     *  `https`.
     *
     *  Additional restrictions:
     *  - If `default_pool` is set, the pool's protocol must match, or be compatible with
     *    the listener's protocol. At present, the compatible protocols are `http` and
     *    `https`.
     *  - If `https_redirect` is set, the protocol must be `http`.
     */
    protocol: string;
  }

  /** LoadBalancerListenerReference. */
  export interface LoadBalancerListenerReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: LoadBalancerListenerReferenceDeleted;
    /** The listener's canonical URL. */
    href: string;
    /** The unique identifier for this load balancer listener. */
    id: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface LoadBalancerListenerReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** LoadBalancerLogging. */
  export interface LoadBalancerLogging {
    /** The datapath logging configuration for this load balancer. */
    datapath: LoadBalancerLoggingDatapath;
  }

  /** The datapath logging configuration for this load balancer. */
  export interface LoadBalancerLoggingDatapath {
    /** Indicates whether datapath logging is active for this load balancer. */
    active: boolean;
  }

  /** The datapath logging configuration for this load balancer. */
  export interface LoadBalancerLoggingDatapathPatch {
    /** Indicates whether datapath logging will be active for this load balancer. */
    active?: boolean;
  }

  /** The datapath logging configuration for this load balancer. */
  export interface LoadBalancerLoggingDatapathPrototype {
    /** Indicates whether datapath logging will be active for this load balancer. */
    active?: boolean;
  }

  /** LoadBalancerLoggingPatch. */
  export interface LoadBalancerLoggingPatch {
    /** The datapath logging configuration for this load balancer. */
    datapath?: LoadBalancerLoggingDatapathPatch;
  }

  /** LoadBalancerLoggingPrototype. */
  export interface LoadBalancerLoggingPrototype {
    /** The datapath logging configuration for this load balancer. */
    datapath?: LoadBalancerLoggingDatapathPrototype;
  }

  /** LoadBalancerPool. */
  export interface LoadBalancerPool {
    /** The load balancing algorithm. */
    algorithm: string;
    /** The date and time that this pool was created. */
    created_at: string;
    /** The health monitor of this pool. */
    health_monitor: LoadBalancerPoolHealthMonitor;
    /** The pool's canonical URL. */
    href: string;
    /** The unique identifier for this load balancer pool. */
    id: string;
    /** The instance group that is managing this pool. */
    instance_group?: InstanceGroupReference;
    /** The backend server members of the pool. */
    members?: LoadBalancerPoolMemberReference[];
    /** The name for this load balancer pool. The name is unique across all pools for the load balancer. */
    name: string;
    /** The protocol for this load balancer pool.
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which
     *  the unexpected property value was encountered.
     */
    protocol: string;
    /** The provisioning status of this pool
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which
     *  the unexpected property value was encountered.
     */
    provisioning_status: string;
    /** The PROXY protocol setting for this pool:
     *  - `v1`: Enabled with version 1 (human-readable header format)
     *  - `v2`: Enabled with version 2 (binary header format)
     *  - `disabled`: Disabled
     *
     *  Supported by load balancers in the `application` family (otherwise always `disabled`).
     */
    proxy_protocol: string;
    /** The session persistence of this pool.
     *
     *  The enumerated values for this property are expected to expand in the future. When
     *  processing this property, check for and log unknown values. Optionally halt
     *  processing and surface the error, or bypass the pool on which the unexpected
     *  property value was encountered.
     */
    session_persistence?: LoadBalancerPoolSessionPersistence;
  }

  /** LoadBalancerPoolCollection. */
  export interface LoadBalancerPoolCollection {
    /** Collection of pools. */
    pools: LoadBalancerPool[];
  }

  /** LoadBalancerPoolHealthMonitor. */
  export interface LoadBalancerPoolHealthMonitor {
    /** The seconds to wait between health checks. */
    delay: number;
    /** The health check max retries. */
    max_retries: number;
    /** The health check port.
     *
     *  If present, this overrides the pool member port values.
     */
    port?: number;
    /** The seconds to wait for a response to a health check. */
    timeout: number;
    /** The protocol type to use for health checks.
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the health monitor
     *  on which the unexpected property value was encountered.
     */
    type: string;
    /** The health check URL path. Applicable when `type` is `http` or `https`.
     *
     *  Must be in the format of an [origin-form request target](https://tools.ietf.org/html/rfc7230#section-5.3.1).
     */
    url_path?: string;
  }

  /** LoadBalancerPoolHealthMonitorPatch. */
  export interface LoadBalancerPoolHealthMonitorPatch {
    /** The seconds to wait between health checks.  Must be greater than `timeout`. */
    delay: number;
    /** The health check max retries. */
    max_retries: number;
    /** The health check port.
     *
     *  If set, this overrides the pool member port values.
     *
     *  Specify `null` to remove an existing health check port.
     */
    port?: number;
    /** The seconds to wait for a response to a health check.  Must be less than `delay`. */
    timeout: number;
    /** The protocol type to use for health checks. */
    type: string;
    /** The health check URL path. Applicable when `type` is `http` or `https`.
     *
     *  Must be in the format of an [origin-form request target](https://tools.ietf.org/html/rfc7230#section-5.3.1).
     */
    url_path?: string;
  }

  /** LoadBalancerPoolHealthMonitorPrototype. */
  export interface LoadBalancerPoolHealthMonitorPrototype {
    /** The seconds to wait between health checks.  Must be greater than `timeout`. */
    delay: number;
    /** The health check max retries. */
    max_retries: number;
    /** The health check port.
     *
     *  If specified, this overrides the pool member port values.
     */
    port?: number;
    /** The seconds to wait for a response to a health check.  Must be less than `delay`. */
    timeout: number;
    /** The protocol type to use for health checks. */
    type: string;
    /** The health check URL path. Applicable when `type` is `http` or `https`.
     *
     *  Must be in the format of an [origin-form request target](https://tools.ietf.org/html/rfc7230#section-5.3.1).
     */
    url_path?: string;
  }

  /** Identifies a load balancer pool by a unique property. */
  export interface LoadBalancerPoolIdentity {
  }

  /** LoadBalancerPoolIdentityByName. */
  export interface LoadBalancerPoolIdentityByName {
    /** The name for this load balancer pool. The name is unique across all pools for the load balancer. */
    name: string;
  }

  /** LoadBalancerPoolMember. */
  export interface LoadBalancerPoolMember {
    /** The date and time that this member was created. */
    created_at: string;
    /** Health of the server member in the pool. */
    health: string;
    /** The member's canonical URL. */
    href: string;
    /** The unique identifier for this load balancer pool member. */
    id: string;
    /** The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on
     *  a listener with a single port. (If the traffic is received on a listener with a port range, the member will
     *  receive the traffic on the same port the listener received it on.)
     *
     *  This port will also be used for health checks unless the `port` property of
     *  `health_monitor` property is specified.
     */
    port: number;
    /** The provisioning status of this member
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the pool member on
     *  which the unexpected property value was encountered.
     */
    provisioning_status: string;
    /** The pool member target. Load balancers in the `network` family support virtual server
     *  instances. Load balancers in the `application` family support IP addresses. If the load
     *  balancer has route mode enabled, the member must be in a zone the load balancer has a
     *  subnet in.
     */
    target: LoadBalancerPoolMemberTarget;
    /** Weight of the server member. Applicable only if the pool algorithm is `weighted_round_robin`. */
    weight?: number;
  }

  /** LoadBalancerPoolMemberCollection. */
  export interface LoadBalancerPoolMemberCollection {
    /** Collection of members. */
    members: LoadBalancerPoolMember[];
  }

  /** LoadBalancerPoolMemberPrototype. */
  export interface LoadBalancerPoolMemberPrototype {
    /** The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on
     *  a listener with a single port. (If the traffic is received on a listener with a port range, the member will
     *  receive the traffic on the same port the listener received it on.)
     *
     *  This port will also be used for health checks unless the `port` property of
     *  `health_monitor` property is specified.
     *
     *  The port must be unique across all members for all pools associated with this pool's listener.
     */
    port: number;
    /** The pool member target. Load balancers in the `network` family support virtual server
     *  instances. Load balancers in the `application` family support IP addresses. If the load
     *  balancer has route mode enabled, the member must be in a zone the load balancer has a
     *  subnet in.
     */
    target: LoadBalancerPoolMemberTargetPrototype;
    /** Weight of the server member. Applicable only if the pool algorithm is `weighted_round_robin`. */
    weight?: number;
  }

  /** LoadBalancerPoolMemberReference. */
  export interface LoadBalancerPoolMemberReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: LoadBalancerPoolMemberReferenceDeleted;
    /** The member's canonical URL. */
    href: string;
    /** The unique identifier for this load balancer pool member. */
    id: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface LoadBalancerPoolMemberReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** The pool member target. Load balancers in the `network` family support virtual server instances. Load balancers in the `application` family support IP addresses. If the load balancer has route mode enabled, the member must be in a zone the load balancer has a subnet in. */
  export interface LoadBalancerPoolMemberTarget {
  }

  /** The pool member target. Load balancers in the `network` family support virtual server instances. Load balancers in the `application` family support IP addresses. If the load balancer has route mode enabled, the member must be in a zone the load balancer has a subnet in. */
  export interface LoadBalancerPoolMemberTargetPrototype {
  }

  /** LoadBalancerPoolPrototype. */
  export interface LoadBalancerPoolPrototype {
    /** The load balancing algorithm. */
    algorithm: string;
    /** The health monitor of this pool. */
    health_monitor: LoadBalancerPoolHealthMonitorPrototype;
    /** The members for this load balancer pool. For load balancers in the `network` family, the same `port` and
     *  `target` tuple cannot be shared by a pool member of any other load balancer in the same VPC.
     */
    members?: LoadBalancerPoolMemberPrototype[];
    /** The name for this load balancer pool. The name must not be used by another pool for the load balancer. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The protocol used for this load balancer pool. Load balancers in the `network` family support `tcp` and
     *  `udp` (if `udp_supported` is `true`). Load balancers in the
     *  `application` family support `tcp`, `http`, and `https`.
     */
    protocol: string;
    /** The PROXY protocol setting for this pool:
     *  - `v1`: Enabled with version 1 (human-readable header format)
     *  - `v2`: Enabled with version 2 (binary header format)
     *  - `disabled`: Disabled
     *
     *  Supported by load balancers in the `application` family (otherwise always `disabled`).
     */
    proxy_protocol?: string;
    /** The session persistence of this pool. */
    session_persistence?: LoadBalancerPoolSessionPersistencePrototype;
  }

  /** LoadBalancerPoolReference. */
  export interface LoadBalancerPoolReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: LoadBalancerPoolReferenceDeleted;
    /** The pool's canonical URL. */
    href: string;
    /** The unique identifier for this load balancer pool. */
    id: string;
    /** The name for this load balancer pool. The name is unique across all pools for the load balancer. */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface LoadBalancerPoolReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** LoadBalancerPoolSessionPersistence. */
  export interface LoadBalancerPoolSessionPersistence {
    /** The session persistence cookie name. Applicable only for type `app_cookie`. Names starting with `IBM` are
     *  not allowed.
     */
    cookie_name?: string;
    /** The session persistence type. The `http_cookie` and `app_cookie` types are applicable only to the `http` and
     *  `https` protocols.
     */
    type: string;
  }

  /** The session persistence configuration. Specify `null` to remove any existing session persistence configuration. */
  export interface LoadBalancerPoolSessionPersistencePatch {
    /** The session persistence cookie name. Applicable only for type `app_cookie`. Names starting with `IBM` are
     *  not allowed.
     */
    cookie_name?: string;
    /** The session persistence type. The `http_cookie` and `app_cookie` types are applicable only to the `http` and
     *  `https` protocols.
     */
    type?: string;
  }

  /** LoadBalancerPoolSessionPersistencePrototype. */
  export interface LoadBalancerPoolSessionPersistencePrototype {
    /** The session persistence cookie name. Applicable only for type `app_cookie`. Names starting with `IBM` are
     *  not allowed.
     */
    cookie_name?: string;
    /** The session persistence type. The `http_cookie` and `app_cookie` types are applicable only to the `http` and
     *  `https` protocols.
     */
    type: string;
  }

  /** LoadBalancerPrivateIpsItem. */
  export interface LoadBalancerPrivateIpsItem {
    /** The IP address.
     *
     *  If the address has not yet been selected, the value will be `0.0.0.0`.
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: ReservedIPReferenceDeleted;
    /** The URL for this reserved IP. */
    href: string;
    /** The unique identifier for this reserved IP. */
    id: string;
    /** The name for this reserved IP. The name is unique across all reserved IPs in a subnet. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** LoadBalancerProfile. */
  export interface LoadBalancerProfile {
    /** The product family this load balancer profile belongs to. */
    family: string;
    /** The URL for this load balancer profile. */
    href: string;
    instance_groups_supported: LoadBalancerProfileInstanceGroupsSupported;
    /** Indicates which logging type(s) are supported for a load balancer with this profile. */
    logging_supported: LoadBalancerProfileLoggingSupported;
    /** The globally unique name for this load balancer profile. */
    name: string;
    route_mode_supported: LoadBalancerProfileRouteModeSupported;
    security_groups_supported: LoadBalancerProfileSecurityGroupsSupported;
    udp_supported: LoadBalancerProfileUDPSupported;
  }

  /** LoadBalancerProfileCollection. */
  export interface LoadBalancerProfileCollection {
    /** A link to the first page of resources. */
    first: LoadBalancerProfileCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: LoadBalancerProfileCollectionNext;
    /** Collection of load balancer profiles. */
    profiles: LoadBalancerProfile[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface LoadBalancerProfileCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface LoadBalancerProfileCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies a load balancer profile by a unique property. */
  export interface LoadBalancerProfileIdentity {
  }

  /** LoadBalancerProfileInstanceGroupsSupported. */
  export interface LoadBalancerProfileInstanceGroupsSupported {
  }

  /** Indicates which logging type(s) are supported for a load balancer with this profile. */
  export interface LoadBalancerProfileLoggingSupported {
    /** The type for this profile field. */
    type: string;
    /** The supported logging type(s) for a load balancer with this profile. */
    value: string[];
  }

  /** LoadBalancerProfileReference. */
  export interface LoadBalancerProfileReference {
    /** The product family this load balancer profile belongs to. */
    family: string;
    /** The URL for this load balancer profile. */
    href: string;
    /** The globally unique name for this load balancer profile. */
    name: string;
  }

  /** LoadBalancerProfileRouteModeSupported. */
  export interface LoadBalancerProfileRouteModeSupported {
  }

  /** LoadBalancerProfileSecurityGroupsSupported. */
  export interface LoadBalancerProfileSecurityGroupsSupported {
  }

  /** LoadBalancerProfileUDPSupported. */
  export interface LoadBalancerProfileUDPSupported {
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface LoadBalancerReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** LoadBalancerStatistics. */
  export interface LoadBalancerStatistics {
    /** Number of active connections of this load balancer. */
    active_connections: number;
    /** Current connection rate (connections per second) of this load balancer. */
    connection_rate: number;
    /** Total number of data processed (bytes) of this load balancer within current calendar month. */
    data_processed_this_month: number;
    /** Current throughput (Mbps) of this load balancer. */
    throughput: number;
  }

  /** NetworkACL. */
  export interface NetworkACL {
    /** The date and time that the network ACL was created. */
    created_at: string;
    /** The CRN for this network ACL. */
    crn: string;
    /** The URL for this network ACL. */
    href: string;
    /** The unique identifier for this network ACL. */
    id: string;
    /** The name for this network ACL. The name is unique across all network ACLs for the VPC. */
    name: string;
    /** The resource group for this network ACL. */
    resource_group: ResourceGroupReference;
    /** The ordered rules for this network ACL. If no rules exist, all traffic will be denied. */
    rules: NetworkACLRuleItem[];
    /** The subnets to which this network ACL is attached. */
    subnets: SubnetReference[];
    /** The VPC this network ACL resides in. */
    vpc: VPCReference;
  }

  /** NetworkACLCollection. */
  export interface NetworkACLCollection {
    /** A link to the first page of resources. */
    first: NetworkACLCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** Collection of network ACLs. */
    network_acls: NetworkACL[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: NetworkACLCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface NetworkACLCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface NetworkACLCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies a network ACL by a unique property. */
  export interface NetworkACLIdentity {
  }

  /** NetworkACLPrototype. */
  export interface NetworkACLPrototype {
    /** The name for this network ACL. The name must not be used by another network ACL for the VPC. If unspecified,
     *  the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The VPC this network ACL will reside in. */
    vpc: VPCIdentity;
  }

  /** NetworkACLReference. */
  export interface NetworkACLReference {
    /** The CRN for this network ACL. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: NetworkACLReferenceDeleted;
    /** The URL for this network ACL. */
    href: string;
    /** The unique identifier for this network ACL. */
    id: string;
    /** The name for this network ACL. The name is unique across all network ACLs for the VPC. */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface NetworkACLReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** NetworkACLRule. */
  export interface NetworkACLRule {
    /** The action to perform for a packet matching the rule. */
    action: string;
    /** The rule that this rule is immediately before. If absent, this is the last rule. */
    before?: NetworkACLRuleReference;
    /** The date and time that the rule was created. */
    created_at: string;
    /** The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination
     *  addresses.
     */
    destination: string;
    /** The direction of traffic to match. */
    direction: string;
    /** The URL for this network ACL rule. */
    href: string;
    /** The unique identifier for this network ACL rule. */
    id: string;
    /** The IP version for this rule. */
    ip_version: string;
    /** The name for this network ACL rule. The name is unique across all rules for the network ACL. */
    name: string;
    /** The protocol to enforce. */
    protocol: string;
    /** The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses. */
    source: string;
  }

  /** The rule to move this rule immediately before. Specify `null` to move this rule after all existing rules. */
  export interface NetworkACLRuleBeforePatch {
  }

  /** The rule to insert this rule immediately before. If unspecified, this rule will be inserted after all existing rules. */
  export interface NetworkACLRuleBeforePrototype {
  }

  /** NetworkACLRuleCollection. */
  export interface NetworkACLRuleCollection {
    /** A link to the first page of resources. */
    first: NetworkACLRuleCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: NetworkACLRuleCollectionNext;
    /** Ordered collection of network ACL rules. */
    rules: NetworkACLRuleItem[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface NetworkACLRuleCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface NetworkACLRuleCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** NetworkACLRuleItem. */
  export interface NetworkACLRuleItem {
    /** The action to perform for a packet matching the rule. */
    action: string;
    /** The rule that this rule is immediately before. In a rule collection, this always
     *  refers to the next item in the collection. If absent, this is the last rule.
     */
    before?: NetworkACLRuleReference;
    /** The date and time that the rule was created. */
    created_at: string;
    /** The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination
     *  addresses.
     */
    destination: string;
    /** The direction of traffic to match. */
    direction: string;
    /** The URL for this network ACL rule. */
    href: string;
    /** The unique identifier for this network ACL rule. */
    id: string;
    /** The IP version for this rule. */
    ip_version: string;
    /** The name for this network ACL rule. The name is unique across all rules for the network ACL. */
    name: string;
    /** The protocol to enforce. */
    protocol: string;
    /** The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses. */
    source: string;
  }

  /** NetworkACLRulePrototype. */
  export interface NetworkACLRulePrototype {
    /** The action to perform for a packet matching the rule. */
    action: string;
    /** The rule to insert this rule immediately before.
     *
     *  If unspecified, this rule will be inserted after all existing rules.
     */
    before?: NetworkACLRuleBeforePrototype;
    /** The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination
     *  addresses.
     */
    destination: string;
    /** The direction of traffic to match. */
    direction: string;
    /** The IP version for this rule. */
    ip_version?: string;
    /** The name for this network ACL rule. The name must not be used by another rule for the network ACL. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The protocol to enforce. */
    protocol: string;
    /** The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses. */
    source: string;
  }

  /** NetworkACLRulePrototypeNetworkACLContext. */
  export interface NetworkACLRulePrototypeNetworkACLContext {
    /** The action to perform for a packet matching the rule. */
    action: string;
    /** The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination
     *  addresses.
     */
    destination: string;
    /** The direction of traffic to match. */
    direction: string;
    /** The IP version for this rule. */
    ip_version?: string;
    /** The name for this network ACL rule. The name must not be used by another rule for the network ACL. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The protocol to enforce. */
    protocol: string;
    /** The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses. */
    source: string;
  }

  /** NetworkACLRuleReference. */
  export interface NetworkACLRuleReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: NetworkACLRuleReferenceDeleted;
    /** The URL for this network ACL rule. */
    href: string;
    /** The unique identifier for this network ACL rule. */
    id: string;
    /** The name for this network ACL rule. The name is unique across all rules for the network ACL. */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface NetworkACLRuleReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** NetworkInterface. */
  export interface NetworkInterface {
    /** Indicates whether source IP spoofing is allowed on this instance interface. */
    allow_ip_spoofing: boolean;
    /** The date and time that the instance network interface was created. */
    created_at: string;
    /** The floating IPs associated with this instance network interface. */
    floating_ips: FloatingIPReference[];
    /** The URL for this instance network interface. */
    href: string;
    /** The unique identifier for this instance network interface. */
    id: string;
    /** The name for this instance network interface. */
    name: string;
    /** The instance network interface port speed in Mbps. */
    port_speed: number;
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: string;
    /** The security groups targeting this instance network interface. */
    security_groups: SecurityGroupReference[];
    /** The status of the instance network interface. */
    status: string;
    /** The associated subnet. */
    subnet: SubnetReference;
    /** The type of this instance network interface as it relates to an instance. */
    type: string;
  }

  /** NetworkInterfaceBareMetalServerContextReference. */
  export interface NetworkInterfaceBareMetalServerContextReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: NetworkInterfaceBareMetalServerContextReferenceDeleted;
    /** The URL for this bare metal server network interface. */
    href: string;
    /** The unique identifier for this bare metal server network interface. */
    id: string;
    /** The name for this bare metal server network interface. */
    name: string;
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: string;
    /** The associated subnet. */
    subnet: SubnetReference;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface NetworkInterfaceBareMetalServerContextReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** NetworkInterfaceIPPrototype. */
  export interface NetworkInterfaceIPPrototype {
  }

  /** NetworkInterfaceInstanceContextReference. */
  export interface NetworkInterfaceInstanceContextReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: NetworkInterfaceInstanceContextReferenceDeleted;
    /** The URL for this instance network interface. */
    href: string;
    /** The unique identifier for this instance network interface. */
    id: string;
    /** The name for this instance network interface. */
    name: string;
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: string;
    /** The associated subnet. */
    subnet: SubnetReference;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface NetworkInterfaceInstanceContextReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** NetworkInterfacePrototype. */
  export interface NetworkInterfacePrototype {
    /** Indicates whether source IP spoofing is allowed on this instance interface. */
    allow_ip_spoofing?: boolean;
    /** The name for the instance network interface. The name must not be used by another network interface on the
     *  virtual server instance. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The primary IP address to bind to the instance network interface. This can be
     *  specified using an existing reserved IP, or a prototype object for a new reserved IP.
     *
     *  If an existing reserved IP or a prototype object with an address is specified, it must
     *  be available on the instance network interface's subnet. Otherwise, an
     *  available address on the subnet will be automatically selected and reserved.
     */
    primary_ip?: NetworkInterfaceIPPrototype;
    /** The security groups to use for this instance network interface. If unspecified, the VPC's default security
     *  group is used.
     */
    security_groups?: SecurityGroupIdentity[];
    /** The associated subnet. */
    subnet: SubnetIdentity;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface NetworkInterfaceReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface NetworkInterfaceReferenceTargetContextDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** NetworkInterfaceUnpaginatedCollection. */
  export interface NetworkInterfaceUnpaginatedCollection {
    /** Collection of instance network interfaces. */
    network_interfaces: NetworkInterface[];
  }

  /** OperatingSystem. */
  export interface OperatingSystem {
    /** The operating system architecture. */
    architecture: string;
    /** Images with this operating system can only be used on dedicated hosts or dedicated host groups. */
    dedicated_host_only: boolean;
    /** A unique, display-friendly name for the operating system. */
    display_name: string;
    /** The software family for this operating system. */
    family: string;
    /** The URL for this operating system. */
    href: string;
    /** The globally unique name for this operating system. */
    name: string;
    /** The vendor of the operating system. */
    vendor: string;
    /** The major release version of this operating system. */
    version: string;
  }

  /** OperatingSystemCollection. */
  export interface OperatingSystemCollection {
    /** A link to the first page of resources. */
    first: OperatingSystemCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: OperatingSystemCollectionNext;
    /** Collection of operating systems. */
    operating_systems: OperatingSystem[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface OperatingSystemCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface OperatingSystemCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies an operating system by a unique property. */
  export interface OperatingSystemIdentity {
  }

  /** PlacementGroup. */
  export interface PlacementGroup {
    /** The date and time that the placement group was created. */
    created_at: string;
    /** The CRN for this placement group. */
    crn: string;
    /** The URL for this placement group. */
    href: string;
    /** The unique identifier for this placement group. */
    id: string;
    /** The lifecycle state of the placement group. */
    lifecycle_state: string;
    /** The name for this placement group. The name is unique across all placement groups in the region. */
    name: string;
    /** The resource group for this placement group. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The strategy for this placement group
     *  - `host_spread`: place on different compute hosts
     *  - `power_spread`: place on compute hosts that use different power sources
     *
     *  The enumerated values for this property may expand in the future. When processing this property, check for and
     *  log unknown values. Optionally halt processing and surface the error, or bypass the placement group on which the
     *  unexpected strategy was encountered.
     */
    strategy: string;
  }

  /** PlacementGroupCollection. */
  export interface PlacementGroupCollection {
    /** A link to the first page of resources. */
    first: PlacementGroupCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PlacementGroupCollectionNext;
    /** Collection of placement groups. */
    placement_groups: PlacementGroup[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface PlacementGroupCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface PlacementGroupCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface PlacementGroupReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** PublicGateway. */
  export interface PublicGateway {
    /** The date and time that the public gateway was created. */
    created_at: string;
    /** The CRN for this public gateway. */
    crn: string;
    /** The floating IP bound to this public gateway. */
    floating_ip: PublicGatewayFloatingIp;
    /** The URL for this public gateway. */
    href: string;
    /** The unique identifier for this public gateway. */
    id: string;
    /** The name for this public gateway. The name is unique across all public gateways in the VPC. */
    name: string;
    /** The resource group for this public gateway. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The status of this public gateway. */
    status: string;
    /** The VPC this public gateway resides in. */
    vpc: VPCReference;
    /** The zone this public gateway resides in. */
    zone: ZoneReference;
  }

  /** PublicGatewayCollection. */
  export interface PublicGatewayCollection {
    /** A link to the first page of resources. */
    first: PublicGatewayCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PublicGatewayCollectionNext;
    /** Collection of public gateways. */
    public_gateways: PublicGateway[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface PublicGatewayCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface PublicGatewayCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** PublicGatewayFloatingIPPrototype. */
  export interface PublicGatewayFloatingIPPrototype {
  }

  /** The floating IP bound to this public gateway. */
  export interface PublicGatewayFloatingIp {
    /** The globally unique IP address. */
    address: string;
    /** The CRN for this floating IP. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: FloatingIPReferenceDeleted;
    /** The URL for this floating IP. */
    href: string;
    /** The unique identifier for this floating IP. */
    id: string;
    /** The name for this floating IP. The name is unique across all floating IPs in the region. */
    name: string;
  }

  /** Identifies a public gateway by a unique property. */
  export interface PublicGatewayIdentity {
  }

  /** PublicGatewayReference. */
  export interface PublicGatewayReference {
    /** The CRN for this public gateway. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: PublicGatewayReferenceDeleted;
    /** The URL for this public gateway. */
    href: string;
    /** The unique identifier for this public gateway. */
    id: string;
    /** The name for this public gateway. The name is unique across all public gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface PublicGatewayReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** Region. */
  export interface Region {
    /** The API endpoint for this region. */
    endpoint: string;
    /** The URL for this region. */
    href: string;
    /** The globally unique name for this region. */
    name: string;
    /** The availability status of this region. */
    status: string;
  }

  /** RegionCollection. */
  export interface RegionCollection {
    /** Collection of regions. */
    regions: Region[];
  }

  /** Identifies a region by a unique property. */
  export interface RegionIdentity {
  }

  /** RegionReference. */
  export interface RegionReference {
    /** The URL for this region. */
    href: string;
    /** The globally unique name for this region. */
    name: string;
  }

  /** ReservedIP. */
  export interface ReservedIP {
    /** The IP address.
     *
     *  If the address has not yet been selected, the value will be `0.0.0.0`.
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound.
     */
    auto_delete: boolean;
    /** The date and time that the reserved IP was created. */
    created_at: string;
    /** The URL for this reserved IP. */
    href: string;
    /** The unique identifier for this reserved IP. */
    id: string;
    /** The lifecycle state of the reserved IP. */
    lifecycle_state: string;
    /** The name for this reserved IP. The name is unique across all reserved IPs in a subnet. */
    name: string;
    /** The owner of the reserved IP. */
    owner: string;
    /** The resource type. */
    resource_type: string;
    /** The target this reserved IP is bound to.
     *
     *  If absent, this reserved IP is provider-owned or unbound.
     */
    target?: ReservedIPTarget;
  }

  /** ReservedIPCollection. */
  export interface ReservedIPCollection {
    /** A link to the first page of resources. */
    first: ReservedIPCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: ReservedIPCollectionNext;
    /** Collection of reserved IPs in this subnet. */
    reserved_ips: ReservedIP[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** ReservedIPCollectionBareMetalServerNetworkInterfaceContext. */
  export interface ReservedIPCollectionBareMetalServerNetworkInterfaceContext {
    /** A link to the first page of resources. */
    first: ReservedIPCollectionBareMetalServerNetworkInterfaceContextFirst;
    /** Collection of reserved IPs bound to a bare metal server network interface. */
    ips: ReservedIP[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: ReservedIPCollectionBareMetalServerNetworkInterfaceContextNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface ReservedIPCollectionBareMetalServerNetworkInterfaceContextFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface ReservedIPCollectionBareMetalServerNetworkInterfaceContextNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** ReservedIPCollectionEndpointGatewayContext. */
  export interface ReservedIPCollectionEndpointGatewayContext {
    /** A link to the first page of resources. */
    first: ReservedIPCollectionEndpointGatewayContextFirst;
    /** Collection of reserved IPs bound to an endpoint gateway. */
    ips: ReservedIP[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: ReservedIPCollectionEndpointGatewayContextNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface ReservedIPCollectionEndpointGatewayContextFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface ReservedIPCollectionEndpointGatewayContextNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the first page of resources. */
  export interface ReservedIPCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** ReservedIPCollectionInstanceNetworkInterfaceContext. */
  export interface ReservedIPCollectionInstanceNetworkInterfaceContext {
    /** A link to the first page of resources. */
    first: ReservedIPCollectionInstanceNetworkInterfaceContextFirst;
    /** Collection of reserved IPs bound to an instance network interface. */
    ips: ReservedIP[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: ReservedIPCollectionInstanceNetworkInterfaceContextNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface ReservedIPCollectionInstanceNetworkInterfaceContextFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface ReservedIPCollectionInstanceNetworkInterfaceContextNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface ReservedIPCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** ReservedIPReference. */
  export interface ReservedIPReference {
    /** The IP address.
     *
     *  If the address has not yet been selected, the value will be `0.0.0.0`.
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: ReservedIPReferenceDeleted;
    /** The URL for this reserved IP. */
    href: string;
    /** The unique identifier for this reserved IP. */
    id: string;
    /** The name for this reserved IP. The name is unique across all reserved IPs in a subnet. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface ReservedIPReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** The target this reserved IP is bound to. If absent, this reserved IP is provider-owned or unbound. */
  export interface ReservedIPTarget {
  }

  /** The target to bind this reserved IP to.  The target must be in the same VPC. At present, only endpoint gateway targets are supported.  The endpoint gateway must not be already bound to a reserved IP in the subnet's zone. If unspecified, the reserved IP will be created unbound. */
  export interface ReservedIPTargetPrototype {
  }

  /** Identifies one or more resources according to the specified filter property. */
  export interface ResourceFilter {
    /** The resource type. */
    resource_type?: string;
  }

  /** The resource group to use. If unspecified, the account's [default resource group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used. */
  export interface ResourceGroupIdentity {
  }

  /** ResourceGroupReference. */
  export interface ResourceGroupReference {
    /** The URL for this resource group. */
    href: string;
    /** The unique identifier for this resource group. */
    id: string;
    /** The name for this resource group. */
    name: string;
  }

  /** Route. */
  export interface Route {
    /** The action to perform with a packet matching the route:
     *  - `delegate`: delegate to system-provided routes
     *  - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
     *  - `deliver`: deliver the packet to the specified `next_hop`
     *  - `drop`: drop the packet.
     */
    action: string;
    /** The date and time that the route was created. */
    created_at: string;
    /** If present, the resource that created the route. Routes with this property present cannot
     *  be directly deleted. All routes with an `origin` of `service` will have this property set,
     *  and future `origin` values may also have this property set.
     */
    creator?: RouteCreator;
    /** The destination CIDR of the route. */
    destination: string;
    /** The URL for this route. */
    href: string;
    /** The unique identifier for this route. */
    id: string;
    /** The lifecycle state of the route. */
    lifecycle_state: string;
    /** The name for this route. The name is unique across all routes in the routing table. */
    name: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to.  For
     *  other `action` values, its `address` will be `0.0.0.0`.
     */
    next_hop: RouteNextHop;
    /** The origin of this route:
     *  - `service`: route was directly created by a service
     *  - `user`: route was directly created by a user
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the route on which
     *  the unexpected property value was encountered.
     */
    origin?: string;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority: number;
    /** The zone the route applies to. (Traffic from subnets in this zone will be subject to this route.). */
    zone: ZoneReference;
  }

  /** RouteCollection. */
  export interface RouteCollection {
    /** A link to the first page of resources. */
    first: RouteCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: RouteCollectionNext;
    /** Collection of routes. */
    routes: Route[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface RouteCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface RouteCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** RouteCollectionVPCContext. */
  export interface RouteCollectionVPCContext {
    /** A link to the first page of resources. */
    first: RouteCollectionVPCContextFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: RouteCollectionVPCContextNext;
    /** Collection of routes. */
    routes: RouteCollectionVPCContextRoutesItem[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface RouteCollectionVPCContextFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface RouteCollectionVPCContextNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** RouteCollectionVPCContextRoutesItem. */
  export interface RouteCollectionVPCContextRoutesItem {
    /** The action to perform with a packet matching the route:
     *  - `delegate`: delegate to system-provided routes
     *  - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
     *  - `deliver`: deliver the packet to the specified `next_hop`
     *  - `drop`: drop the packet.
     */
    action: string;
    /** The date and time that the route was created. */
    created_at: string;
    /** If present, the resource that created the route. Routes with this property present cannot
     *  be directly deleted. All routes with an `origin` of `service` will have this property set,
     *  and future `origin` values may also have this property set.
     */
    creator?: RouteCreator;
    /** The destination CIDR of the route. */
    destination: string;
    /** The URL for this route. */
    href: string;
    /** The unique identifier for this route. */
    id: string;
    /** The lifecycle state of the route. */
    lifecycle_state: string;
    /** The name for this route. The name is unique across all routes in the routing table. */
    name: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to.  For
     *  other `action` values, its `address` will be `0.0.0.0`.
     */
    next_hop: RouteNextHop;
    /** The origin of this route:
     *  - `service`: route was directly created by a service
     *  - `user`: route was directly created by a user
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the route on which
     *  the unexpected property value was encountered.
     */
    origin?: string;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority: number;
    /** The zone the route applies to. (Traffic from subnets in this zone will be subject to this route.). */
    zone: ZoneReference;
  }

  /** If present, the resource that created the route. Routes with this property present cannot be directly deleted. All routes with an `origin` of `service` will have this property set, and future `origin` values may also have this property set. */
  export interface RouteCreator {
  }

  /** RouteNextHop. */
  export interface RouteNextHop {
  }

  /** If `action` is `deliver`, the next hop that packets will be delivered to. For other `action` values, specify `0.0.0.0` or remove it by specifying `null`. At most two routes per `zone` in a table can have the same `destination` and `priority`, and only when each route has an `action` of `deliver` and `next_hop` is an IP address. */
  export interface RouteNextHopPatch {
  }

  /** RoutePrototype. */
  export interface RoutePrototype {
    /** The action to perform with a packet matching the route:
     *  - `delegate`: delegate to system-provided routes
     *  - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
     *  - `deliver`: deliver the packet to the specified `next_hop`
     *  - `drop`: drop the packet.
     */
    action?: string;
    /** The destination CIDR of the route. The host identifier in the CIDR must be zero.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and
     *  `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
     */
    destination: string;
    /** The name for this route. The name must not be used by another route in the routing table. Names starting
     *  with `ibm-` are reserved for system-provided routes, and are not allowed. If unspecified, the name will be a
     *  hyphenated list of randomly-selected words.
     */
    name?: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to. For other
     *  `action` values, it must be omitted or specified as `0.0.0.0`.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and `priority`,
     *  and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
     */
    next_hop?: RoutePrototypeNextHop;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority?: number;
    /** The zone to apply the route to. (Traffic from subnets in this zone will be subject to this route.). */
    zone: ZoneIdentity;
  }

  /** If `action` is `deliver`, the next hop that packets will be delivered to. For other `action` values, it must be omitted or specified as `0.0.0.0`. At most two routes per `zone` in a table can have the same `destination` and `priority`, and only when each route has an `action` of `deliver` and `next_hop` is an IP address. */
  export interface RoutePrototypeNextHop {
  }

  /** RouteReference. */
  export interface RouteReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: RouteReferenceDeleted;
    /** The URL for this route. */
    href: string;
    /** The unique identifier for this route. */
    id: string;
    /** The name for this route. The name is unique across all routes in the routing table. */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface RouteReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** RoutingTable. */
  export interface RoutingTable {
    /** The filters specifying the resources that may create routes in this routing table.
     *
     *  At present, only the `resource_type` filter is permitted, and only the `vpn_server` value is supported, but
     *  filter support is expected to expand in the future.
     */
    accept_routes_from: ResourceFilter[];
    /** The date and time that this routing table was created. */
    created_at: string;
    /** The URL for this routing table. */
    href: string;
    /** The unique identifier for this routing table. */
    id: string;
    /** Indicates whether this is the default routing table for this VPC. */
    is_default: boolean;
    /** The lifecycle state of the routing table. */
    lifecycle_state: string;
    /** The name for this routing table. The name is unique across all routing tables for the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
    /** Indicates whether this routing table is used to route traffic that originates from
     *  [Direct Link](https://cloud.ibm.com/docs/dl) to this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     */
    route_direct_link_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from the internet.
     *
     *  Incoming traffic will be routed according to the routing table with two exceptions:
     *  - Traffic destined for IP addresses associated with public gateways will not be
     *    subject to routes in this routing table.
     *  - Routes with an action of deliver are treated as drop unless the `next_hop` is an
     *    IP address in a subnet in the route's `zone`. Therefore, if an incoming packet
     *    matches a route with a `next_hop` of an internet-bound IP address or a VPN gateway
     *    connection, the packet will be dropped.
     */
    route_internet_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from from [Transit
     *  Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     */
    route_transit_gateway_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from subnets in other zones in
     *  this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone`.
     *  Therefore, if an incoming packet matches a route with a `next_hop` of an internet-bound IP address or a VPN
     *  gateway connection, the packet will be dropped.
     */
    route_vpc_zone_ingress: boolean;
    /** The routes for this routing table. */
    routes: RouteReference[];
    /** The subnets to which this routing table is attached. */
    subnets: SubnetReference[];
  }

  /** RoutingTableCollection. */
  export interface RoutingTableCollection {
    /** A link to the first page of resources. */
    first: RoutingTableCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: RoutingTableCollectionNext;
    /** Collection of routing tables. */
    routing_tables: RoutingTable[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface RoutingTableCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface RoutingTableCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies a routing table by a unique property. */
  export interface RoutingTableIdentity {
  }

  /** RoutingTableReference. */
  export interface RoutingTableReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: RoutingTableReferenceDeleted;
    /** The URL for this routing table. */
    href: string;
    /** The unique identifier for this routing table. */
    id: string;
    /** The name for this routing table. The name is unique across all routing tables for the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface RoutingTableReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** SecurityGroup. */
  export interface SecurityGroup {
    /** The date and time that this security group was created. */
    created_at: string;
    /** The security group's CRN. */
    crn: string;
    /** The security group's canonical URL. */
    href: string;
    /** The unique identifier for this security group. */
    id: string;
    /** The name for this security group. The name is unique across all security groups for the VPC. */
    name: string;
    /** The resource group for this security group. */
    resource_group: ResourceGroupReference;
    /** The rules for this security group. If no rules exist, all traffic will be denied. */
    rules: SecurityGroupRule[];
    /** The targets for this security group. */
    targets: SecurityGroupTargetReference[];
    /** The VPC this security group resides in. */
    vpc: VPCReference;
  }

  /** SecurityGroupCollection. */
  export interface SecurityGroupCollection {
    /** A link to the first page of resources. */
    first: SecurityGroupCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: SecurityGroupCollectionNext;
    /** Collection of security groups. */
    security_groups: SecurityGroup[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface SecurityGroupCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface SecurityGroupCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies a security group by a unique property. */
  export interface SecurityGroupIdentity {
  }

  /** SecurityGroupReference. */
  export interface SecurityGroupReference {
    /** The security group's CRN. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: SecurityGroupReferenceDeleted;
    /** The security group's canonical URL. */
    href: string;
    /** The unique identifier for this security group. */
    id: string;
    /** The name for this security group. The name is unique across all security groups for the VPC. */
    name: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface SecurityGroupReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** SecurityGroupRule. */
  export interface SecurityGroupRule {
    /** The direction of traffic to enforce. */
    direction: string;
    /** The URL for this security group rule. */
    href: string;
    /** The unique identifier for this security group rule. */
    id: string;
    /** The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property,
     *  if they are used. Alternatively, if `remote` references a security group, then this rule only applies to IP
     *  addresses (network interfaces) in that group matching this IP version.
     */
    ip_version: string;
    /** The protocol to enforce. */
    protocol: string;
    /** The remote IP addresses or security groups from which this rule allows traffic (or to
     *  which, for outbound rules). A CIDR block of `0.0.0.0/0` allows traffic from any source
     *  (or to any destination, for outbound rules).
     */
    remote: SecurityGroupRuleRemote;
  }

  /** Collection of rules in a security group. */
  export interface SecurityGroupRuleCollection {
    /** Array of rules. */
    rules: SecurityGroupRule[];
  }

  /** SecurityGroupRulePrototype. */
  export interface SecurityGroupRulePrototype {
    /** The direction of traffic to enforce. */
    direction: string;
    /** The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property,
     *  if they are used. Alternatively, if `remote` references a security group, then this rule only applies to IP
     *  addresses (network interfaces) in that group matching this IP version.
     */
    ip_version?: string;
    /** The protocol to enforce. */
    protocol: string;
    /** The remote IP addresses or security groups from which this rule will allow traffic (or to
     *  which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
     *  security group within the VPC.
     *
     *  If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source
     *  (or to any destination, for outbound rules).
     */
    remote?: SecurityGroupRuleRemotePrototype;
  }

  /** The remote IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). A CIDR block of `0.0.0.0/0` allows traffic from any source (or to any destination, for outbound rules). */
  export interface SecurityGroupRuleRemote {
  }

  /** The remote IP addresses or security groups from which this rule will allow traffic (or to which, for outbound rules). Can be specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` will allow traffic from any source (or to any destination, for outbound rules). */
  export interface SecurityGroupRuleRemotePatch {
  }

  /** The remote IP addresses or security groups from which this rule will allow traffic (or to which, for outbound rules). Can be specified as an IP address, a CIDR block, or a security group within the VPC. If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source (or to any destination, for outbound rules). */
  export interface SecurityGroupRuleRemotePrototype {
  }

  /** SecurityGroupTargetCollection. */
  export interface SecurityGroupTargetCollection {
    /** A link to the first page of resources. */
    first: SecurityGroupTargetCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: SecurityGroupTargetCollectionNext;
    /** Collection of targets for this security group. */
    targets: SecurityGroupTargetReference[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface SecurityGroupTargetCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface SecurityGroupTargetCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** The resource types that can be security group targets are expected to expand in the future. When iterating over security group targets, do not assume that every target resource will be from a known set of resource types. Optionally halt processing and surface an error, or bypass resources of unrecognized types. */
  export interface SecurityGroupTargetReference {
  }

  /** Share. */
  export interface Share {
    /** The access control mode for the share:
     *
     *  - `security_group`: The security groups on the virtual network interface for a mount
     *    target control access to the mount target.
     *  - `vpc`: All clients in the VPC for a mount target have access to the mount target.
     *
     *  The enumerated access control mode values for this property may expand in the future. When processing this
     *  property, check for and log unknown values. Optionally halt processing and surface the error, or bypass the
     *  resource on which the unexpected access control mode was encountered.
     */
    access_control_mode: string;
    /** The date and time that the file share is created. */
    created_at: string;
    /** The CRN for this file share. */
    crn: string;
    /** The type of encryption used for this file share. */
    encryption: string;
    /** The key used to encrypt this file share.
     *
     *  This property will be present if `encryption_type` is `user_managed`.
     */
    encryption_key?: EncryptionKeyReference;
    /** The URL for this file share. */
    href: string;
    /** The unique identifier for this file share. */
    id: string;
    /** The maximum input/output operations per second (IOPS) for the file share. In addition, each client accessing
     *  the share will be restricted to 48,000 IOPS.
     *
     *  The maximum IOPS for a share may increase in the future.
     */
    iops: number;
    /** The latest job associated with this file share.
     *
     *  This property will be absent if no jobs have been created for this file share.
     */
    latest_job?: ShareJob;
    /** The lifecycle state of the file share. */
    lifecycle_state: string;
    /** The mount targets for the file share. */
    mount_targets: ShareMountTargetReference[];
    /** The name for this share. The name is unique across all shares in the region. */
    name: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) for this file share. */
    profile: ShareProfileReference;
    /** The replica file share for this source file share.
     *
     *  This property will be present when the `replication_role` is `source`.
     */
    replica_share?: ShareReference;
    /** The cron specification for the file share replication schedule.
     *
     *  This property will be present when the `replication_role` is `replica`.
     */
    replication_cron_spec?: string;
    /** The replication role of the file share.
     *
     *  * `none`: This share is not participating in replication.
     *  * `replica`: This share is a replication target.
     *  * `source`: This share is a replication source.
     */
    replication_role: string;
    /** The replication status of the file share.
     *
     *  * `active`: This share is actively participating in replication, and the replica's data is up-to-date with the
     *  replication schedule.
     *  * `failover_pending`: This share is performing a replication failover.
     *  * `initializing`: This share is initializing replication.
     *  * `none`: This share is not participating in replication.
     *  * `split_pending`: This share is performing a replication split.
     */
    replication_status: string;
    /** The reasons for the current replication status (if any).
     *
     *  The enumerated reason code values for this property will expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected reason code was encountered.
     */
    replication_status_reasons: ShareReplicationStatusReason[];
    /** The resource group for this file share. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The size of the file share rounded up to the next gigabyte.
     *
     *  The maximum size for a share may increase in the future.
     */
    size: number;
    /** The source file share for this replica file share.
     *
     *  This property will be present when the `replication_role` is `replica`.
     */
    source_share?: ShareReference;
    /** Tags for this resource. */
    user_tags: string[];
    /** The zone this file share will reside in. */
    zone: ZoneReference;
  }

  /** ShareCollection. */
  export interface ShareCollection {
    /** A link to the first page of resources. */
    first: ShareCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: ShareCollectionNext;
    /** Collection of file shares. */
    shares: Share[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface ShareCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface ShareCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies a file share by a unique property. */
  export interface ShareIdentity {
  }

  /** ShareInitialOwner. */
  export interface ShareInitialOwner {
    /** The initial group identifier for the file share. */
    gid?: number;
    /** The initial user identifier for the file share. */
    uid?: number;
  }

  /** ShareJob. */
  export interface ShareJob {
    /** The status of the file share job.
     *
     *  The enumerated values for this property will expand in the future. When processing this property, check for and
     *  log unknown values. Optionally halt processing and surface the error, or bypass the file share job on which the
     *  unexpected property value was encountered.
     *
     *  * `cancelled`: This job has been cancelled.
     *  * `failed`: This job has failed.
     *  * `queued`: This job is queued.
     *  * `running`: This job is running.
     *  * `succeeded`: This job completed successfully.
     */
    status: string;
    /** The reasons for the file share job status (if any).
     *
     *  The enumerated reason code values for this property will expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected reason code was encountered.
     */
    status_reasons: ShareJobStatusReason[];
    /** The type of the file share job.
     *
     *  The enumerated values for this property will expand in the future. When processing this property, check for and
     *  log unknown values. Optionally halt processing and surface the error, or bypass the file share job on which the
     *  unexpected property value was encountered.
     *
     *  * `replication_failover`: This is a share replication failover job.
     *  * `replication_init`: This is a share replication is initialization job.
     *  * `replication_split`: This is a share replication split job.
     */
    type: string;
  }

  /** ShareJobStatusReason. */
  export interface ShareJobStatusReason {
    /** A snake case string succinctly identifying the status reason. */
    code: string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }

  /** ShareMountTarget. */
  export interface ShareMountTarget {
    /** The access control mode for the share:
     *
     *  - `security_group`: The security groups on the virtual network interface for a mount
     *    target control access to the mount target.
     *  - `vpc`: All clients in the VPC for a mount target have access to the mount target.
     *
     *  The enumerated access control mode values for this property may expand in the future. When processing this
     *  property, check for and log unknown values. Optionally halt processing and surface the error, or bypass the
     *  resource on which the unexpected access control mode was encountered.
     */
    access_control_mode: string;
    /** The date and time that the share mount target was created. */
    created_at: string;
    /** The URL for this share mount target. */
    href: string;
    /** The unique identifier for this share mount target. */
    id: string;
    /** The lifecycle state of the mount target. */
    lifecycle_state: string;
    /** The mount path for the share.  The server component of the mount path may be either an IP address or a fully
     *  qualified domain name.
     *
     *  This property will be absent if the `lifecycle_state` of the mount target is
     *  'pending', `failed`, or `deleting`.
     *
     *  If the share's `access_control_mode` is:
     *
     *  - `security_group`: The IP address used in the mount path is the `primary_ip`
     *    address of the virtual network interface for this share mount target.
     *  - `vpc`: The fully-qualified domain name used in the mount path is an address that
     *    resolves to the share mount target.
     */
    mount_path?: string;
    /** The name for this share mount target. The name is unique across all mount targets for the file share. */
    name: string;
    /** The primary IP address of the virtual network interface for the share mount target.
     *
     *  Absent if `access_control_mode` is `vpc`.
     */
    primary_ip?: ReservedIPReference;
    /** The resource type. */
    resource_type: string;
    /** The subnet of the virtual network interface for the share mount target.
     *
     *  Absent if `access_control_mode` is `vpc`.
     */
    subnet?: SubnetReference;
    /** The transit encryption mode for this share mount target:
     *  - `none`: Not encrypted in transit
     *  - `user_managed`: Encrypted in transit using an instance identity certificate
     *
     *  The enumerated values for this property will expand in the future. When processing this property, check for and
     *  log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
     *  unexpected property value was encountered.
     */
    transit_encryption: string;
    /** The virtual network interface for this file share mount target.
     *
     *  This property will be present when the `access_control_mode` is `security_group`.
     */
    virtual_network_interface?: VirtualNetworkInterfaceReferenceAttachmentContext;
    /** If `access_control_mode` is:
     *
     *  - `security_group`: The VPC for the virtual network interface for this share mount
     *    target
     *  - `vpc`: The VPC in which clients can mount the file share using this share
     *    mount target.
     */
    vpc: VPCReference;
  }

  /** ShareMountTargetCollection. */
  export interface ShareMountTargetCollection {
    /** A link to the first page of resources. */
    first: ShareMountTargetCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** Collection of share mount targets. */
    mount_targets: ShareMountTarget[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: ShareMountTargetCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface ShareMountTargetCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface ShareMountTargetCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** ShareMountTargetPrototype. */
  export interface ShareMountTargetPrototype {
    /** The name for this share mount target. The name must not be used by another mount target for the file share. */
    name?: string;
    /** The transit encryption mode to use for this share mount target:
     *  - `none`: Not encrypted in transit.
     *  - `user_managed`: Encrypted in transit using an instance identity certificate.  The
     *                    `access_control_mode` for the share must be `security_group`.
     */
    transit_encryption?: string;
  }

  /** ShareMountTargetReference. */
  export interface ShareMountTargetReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: ShareMountTargetReferenceDeleted;
    /** The URL for this share mount target. */
    href: string;
    /** The unique identifier for this share mount target. */
    id: string;
    /** The name for this share mount target. The name is unique across all mount targets for the file share. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface ShareMountTargetReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** ShareMountTargetVirtualNetworkInterfacePrototype. */
  export interface ShareMountTargetVirtualNetworkInterfacePrototype {
  }

  /** ShareProfile. */
  export interface ShareProfile {
    /** The permitted capacity range (in gigabytes) for a share with this profile. */
    capacity: ShareProfileCapacity;
    /** The product family this share profile belongs to. */
    family: string;
    /** The URL for this share profile. */
    href: string;
    /** The permitted IOPS range for a share with this profile. */
    iops: ShareProfileIOPS;
    /** The globally unique name for this share profile. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** ShareProfileCapacity. */
  export interface ShareProfileCapacity {
  }

  /** ShareProfileCollection. */
  export interface ShareProfileCollection {
    /** A link to the first page of resources. */
    first: ShareProfileCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: ShareProfileCollectionNext;
    /** Collection of share profiles. */
    profiles: ShareProfile[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface ShareProfileCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface ShareProfileCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** ShareProfileIOPS. */
  export interface ShareProfileIOPS {
  }

  /** Identifies a share profile by a unique property. */
  export interface ShareProfileIdentity {
  }

  /** ShareProfileReference. */
  export interface ShareProfileReference {
    /** The URL for this share profile. */
    href: string;
    /** The globally unique name for this share profile. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** SharePrototype. */
  export interface SharePrototype {
    /** The maximum input/output operations per second (IOPS) for the file share. The share must be in the
     *  `defined_performance` profile family, and the value must be in the range supported by the share's specified
     *  size.
     *
     *  In addition, each client accessing the share will be restricted to 48,000 IOPS.
     */
    iops?: number;
    /** The mount targets for the file share. Each mount target must be in a unique VPC. */
    mount_targets?: ShareMountTargetPrototype[];
    /** The name for this share. The name must not be used by another share in the region. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) to use
     *  for this file share. The profile must support the share's specified IOPS and size.
     */
    profile: ShareProfileIdentity;
    /** Configuration for a replica file share to create and associate with this file share. If
     *  unspecified, a replica may be subsequently added by creating a new file share with a
     *  `source_share` referencing this file share.
     */
    replica_share?: SharePrototypeShareContext;
    /** Tags for this resource. */
    user_tags?: string[];
    /** The zone this file share will reside in.
     *  For a replica share, this must be a different zone in the same region as the source share.
     */
    zone: ZoneIdentity;
  }

  /** Configuration for a replica file share to create and associate with this file share. If unspecified, a replica may be subsequently added by creating a new file share with a `source_share` referencing this file share. */
  export interface SharePrototypeShareContext {
    /** The maximum input/output operations per second (IOPS) for the file share. The share must be in the
     *  `defined_performance` profile family, and the value must be in the range supported by the share's specified
     *  size.
     *
     *  In addition, each client accessing the share will be restricted to 48,000 IOPS.
     */
    iops?: number;
    /** The mount targets for this replica file share. Each mount target must be in a unique VPC.
     *
     *  A replica's mount targets must be mounted read-only.
     */
    mount_targets?: ShareMountTargetPrototype[];
    /** The name for this share. The name must not be used by another share in the region. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) to use
     *  for this file share. The profile must support the share's specified IOPS and size.
     */
    profile: ShareProfileIdentity;
    /** The cron specification for the file share replication schedule.
     *
     *  Replication of a share can be scheduled to occur at most once per hour.
     */
    replication_cron_spec: string;
    /** The resource group to use. If unspecified, the resource group from the source share will be used. */
    resource_group?: ResourceGroupIdentity;
    /** Tags for this resource. */
    user_tags?: string[];
    /** The zone this replica file share will reside in.
     *
     *  Must be a different zone in the same region as the source share.
     */
    zone: ZoneIdentity;
  }

  /** ShareReference. */
  export interface ShareReference {
    /** The CRN for this file share. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: ShareReferenceDeleted;
    /** The URL for this file share. */
    href: string;
    /** The unique identifier for this file share. */
    id: string;
    /** The name for this share. The name is unique across all shares in the region. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface ShareReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** ShareReplicationStatusReason. */
  export interface ShareReplicationStatusReason {
    /** A snake case string succinctly identifying the status reason. */
    code: string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }

  /** Snapshot. */
  export interface Snapshot {
    /** If present, the backup policy plan which created this snapshot. */
    backup_policy_plan?: BackupPolicyPlanReference;
    /** Indicates if a boot volume attachment can be created with a volume created from this snapshot. */
    bootable: boolean;
    /** The date and time the data capture for this snapshot was completed.
     *
     *  If absent, this snapshot's data has not yet been captured. Additionally, this property may be absent for
     *  snapshots created before 1 January 2022.
     */
    captured_at?: string;
    /** Clones for this snapshot. */
    clones: SnapshotClone[];
    /** The copies of this snapshot. */
    copies: SnapshotCopiesItem[];
    /** The date and time that this snapshot was created. */
    created_at: string;
    /** The CRN of this snapshot. */
    crn: string;
    /** Deprecated: Indicates whether this snapshot can be deleted. This value will always be `true`. */
    deletable: boolean;
    /** The type of encryption used on the source volume. */
    encryption: string;
    /** The root key used to wrap the data encryption key for the source volume.
     *
     *  This property will be present for volumes with an `encryption` type of
     *  `user_managed`.
     */
    encryption_key?: EncryptionKeyReference;
    /** The URL for this snapshot. */
    href: string;
    /** The unique identifier for this snapshot. */
    id: string;
    /** The lifecycle state of this snapshot. */
    lifecycle_state: string;
    /** The minimum capacity of a volume created from this snapshot. When a snapshot is created, this will be set to
     *  the capacity of the `source_volume`.
     */
    minimum_capacity: number;
    /** The name for this snapshot. The name is unique across all snapshots in the region. */
    name: string;
    /** The operating system included in this image. */
    operating_system?: OperatingSystem;
    /** The resource group for this snapshot. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The [service tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) prefixed with `is.snapshot:`
     *  associated with this snapshot.
     */
    service_tags: string[];
    /** The size of this snapshot rounded up to the next gigabyte. */
    size: number;
    /** If present, the image from which the data on this snapshot was most directly provisioned. */
    source_image?: ImageReference;
    /** If present, the source snapshot this snapshot was created from. */
    source_snapshot?: SnapshotSourceSnapshot;
    /** The source volume this snapshot was created from (may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     */
    source_volume: VolumeReference;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot. */
    user_tags: string[];
  }

  /** SnapshotClone. */
  export interface SnapshotClone {
    /** Indicates whether this snapshot clone is available for use. */
    available: boolean;
    /** The date and time that this snapshot clone was created. */
    created_at: string;
    /** The zone this snapshot clone resides in. */
    zone: ZoneReference;
  }

  /** SnapshotCloneCollection. */
  export interface SnapshotCloneCollection {
    /** Collection of snapshot clones. */
    clones: SnapshotClone[];
  }

  /** SnapshotClonePrototype. */
  export interface SnapshotClonePrototype {
    /** The zone this snapshot clone will reside in. Must be in the same region as the snapshot. */
    zone: ZoneIdentity;
  }

  /** SnapshotCollection. */
  export interface SnapshotCollection {
    /** A link to the first page of resources. */
    first: SnapshotCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: SnapshotCollectionNext;
    /** Collection of snapshots. */
    snapshots: Snapshot[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface SnapshotCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface SnapshotCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** SnapshotCopiesItem. */
  export interface SnapshotCopiesItem {
    /** The CRN for the copied snapshot. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: SnapshotReferenceDeleted;
    /** The URL for the copied snapshot. */
    href: string;
    /** The unique identifier for the copied snapshot. */
    id: string;
    /** The name for the copied snapshot. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: SnapshotRemote;
    /** The resource type. */
    resource_type: string;
  }

  /** Identifies a snapshot by a unique property. */
  export interface SnapshotIdentity {
  }

  /** SnapshotPrototype. */
  export interface SnapshotPrototype {
    /** Clones to create for this snapshot. */
    clones?: SnapshotClonePrototype[];
    /** The name for this snapshot. The name must not be used by another snapshot in the region. If unspecified, the
     *  name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot. */
    user_tags?: string[];
  }

  /** SnapshotReference. */
  export interface SnapshotReference {
    /** The CRN of this snapshot. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: SnapshotReferenceDeleted;
    /** The URL for this snapshot. */
    href: string;
    /** The unique identifier for this snapshot. */
    id: string;
    /** The name for this snapshot. The name is unique across all snapshots in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: SnapshotRemote;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface SnapshotReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** If present, this property indicates that the resource associated with this reference is remote and therefore may not be directly retrievable. */
  export interface SnapshotRemote {
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /** If present, the source snapshot this snapshot was created from. */
  export interface SnapshotSourceSnapshot {
    /** The CRN of the source snapshot. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: SnapshotReferenceDeleted;
    /** The URL for the source snapshot. */
    href: string;
    /** The unique identifier for the source snapshot. */
    id: string;
    /** The name for the source snapshot. The name is unique across all snapshots in the source snapshot's native
     *  region.
     */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: SnapshotRemote;
    /** The resource type. */
    resource_type: string;
  }

  /** Subnet. */
  export interface Subnet {
    /** The number of IPv4 addresses in this subnet that are not in-use, and have not been reserved by the user or
     *  the provider.
     */
    available_ipv4_address_count: number;
    /** The date and time that the subnet was created. */
    created_at: string;
    /** The CRN for this subnet. */
    crn: string;
    /** The URL for this subnet. */
    href: string;
    /** The unique identifier for this subnet. */
    id: string;
    /** The IP version(s) supported by this subnet. */
    ip_version: string;
    /** The IPv4 range of the subnet, expressed in CIDR format. */
    ipv4_cidr_block: string;
    /** The name for this subnet. The name is unique across all subnets in the VPC. */
    name: string;
    /** The network ACL for this subnet. */
    network_acl: NetworkACLReference;
    /** The public gateway to use for internet-bound traffic for this subnet. */
    public_gateway?: PublicGatewayReference;
    /** The resource group for this subnet. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The routing table for this subnet. */
    routing_table: RoutingTableReference;
    /** The status of the subnet. */
    status: string;
    /** The total number of IPv4 addresses in this subnet.
     *
     *  Note: This is calculated as 2<sup>(32 - prefix length)</sup>. For example, the prefix length `/24` gives:<br>
     *  2<sup>(32 - 24)</sup> = 2<sup>8</sup> = 256 addresses.
     */
    total_ipv4_address_count: number;
    /** The VPC this subnet resides in. */
    vpc: VPCReference;
    /** The zone this subnet resides in. */
    zone: ZoneReference;
  }

  /** SubnetCollection. */
  export interface SubnetCollection {
    /** A link to the first page of resources. */
    first: SubnetCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: SubnetCollectionNext;
    /** Collection of subnets. */
    subnets: Subnet[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface SubnetCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface SubnetCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies a subnet by a unique property. */
  export interface SubnetIdentity {
  }

  /** SubnetPrototype. */
  export interface SubnetPrototype {
    /** The IP version(s) to support for this subnet. */
    ip_version?: string;
    /** The name for this subnet. The name must not be used by another subnet in the VPC. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The network ACL to use for this subnet. */
    network_acl?: NetworkACLIdentity;
    /** The public gateway to use for internet-bound traffic for this subnet. If
     *  unspecified, the subnet will not be attached to a public gateway.
     */
    public_gateway?: PublicGatewayIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The routing table to use for this subnet. If unspecified, the default routing table
     *  for the VPC is used. The routing table properties `route_direct_link_ingress`,
     *  `route_internet_ingress`, `route_transit_gateway_ingress`, and
     *  `route_vpc_zone_ingress` must be `false`.
     */
    routing_table?: RoutingTableIdentity;
    /** The VPC the subnet will reside in. */
    vpc: VPCIdentity;
  }

  /** The public gateway to use for internet-bound traffic for this subnet. */
  export interface SubnetPublicGatewayPatch {
  }

  /** SubnetReference. */
  export interface SubnetReference {
    /** The CRN for this subnet. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: SubnetReferenceDeleted;
    /** The URL for this subnet. */
    href: string;
    /** The unique identifier for this subnet. */
    id: string;
    /** The name for this subnet. The name is unique across all subnets in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface SubnetReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** Identifies a trusted profile by a unique property. */
  export interface TrustedProfileIdentity {
  }

  /** TrustedProfileReference. */
  export interface TrustedProfileReference {
    /** The CRN for this trusted profile. */
    crn: string;
    /** The unique identifier for this trusted profile. */
    id: string;
    /** The resource type. */
    resource_type: string;
  }

  /** The VCPU configuration. */
  export interface VCPU {
    /** The VCPU architecture. */
    architecture: string;
    /** The number of VCPUs assigned. */
    count: number;
    /** The VCPU manufacturer. */
    manufacturer: string;
  }

  /** VPC. */
  export interface VPC {
    /** Indicates whether this VPC is connected to Classic Infrastructure. If true, this VPC's resources have
     *  private network connectivity to the account's Classic Infrastructure resources. Only one VPC, per region, may be
     *  connected in this way. This value is set at creation and subsequently immutable.
     */
    classic_access: boolean;
    /** The date and time that the VPC was created. */
    created_at: string;
    /** The CRN for this VPC. */
    crn: string;
    /** The CSE ([Cloud Service Endpoint](https://cloud.ibm.com/docs/resources?topic=resources-service-endpoints))
     *  source IP addresses for the VPC. The VPC will have one CSE source IP address per zone.
     */
    cse_source_ips?: VPCCSESourceIP[];
    /** The default network ACL to use for subnets created in this VPC. */
    default_network_acl: NetworkACLReference;
    /** The default routing table to use for subnets created in this VPC. */
    default_routing_table: RoutingTableReference;
    /** The default security group for this VPC. Resources created in this VPC that allow
     *  a security group to be optionally specified will use this security group by
     *  default.
     */
    default_security_group: SecurityGroupReference;
    /** The URL for this VPC. */
    href: string;
    /** The unique identifier for this VPC. */
    id: string;
    /** The name for this VPC. The name is unique across all VPCs in the region. */
    name: string;
    /** The resource group for this VPC. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The status of this VPC. */
    status: string;
  }

  /** VPCCSESourceIP. */
  export interface VPCCSESourceIP {
    /** The cloud service endpoint source IP address for this zone. */
    ip: IP;
    /** The zone this cloud service endpoint source IP resides in. */
    zone: ZoneReference;
  }

  /** VPCCollection. */
  export interface VPCCollection {
    /** A link to the first page of resources. */
    first: VPCCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: VPCCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
    /** Collection of VPCs. */
    vpcs: VPC[];
  }

  /** A link to the first page of resources. */
  export interface VPCCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface VPCCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies a VPC by a unique property. */
  export interface VPCIdentity {
  }

  /** VPCReference. */
  export interface VPCReference {
    /** The CRN for this VPC. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VPCReferenceDeleted;
    /** The URL for this VPC. */
    href: string;
    /** The unique identifier for this VPC. */
    id: string;
    /** The name for this VPC. The name is unique across all VPCs in the region. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface VPCReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** VPNGateway. */
  export interface VPNGateway {
    /** Connections for this VPN gateway. */
    connections: VPNGatewayConnectionReference[];
    /** The date and time that this VPN gateway was created. */
    created_at: string;
    /** The VPN gateway's CRN. */
    crn: string;
    /** The VPN gateway's canonical URL. */
    href: string;
    /** The unique identifier for this VPN gateway. */
    id: string;
    /** Collection of VPN gateway members. */
    members: VPNGatewayMember[];
    /** The name for this VPN gateway. The name is unique across all VPN gateways in the VPC. */
    name: string;
    /** The resource group for this VPN gateway. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The status of the VPN gateway. */
    status: string;
    subnet: SubnetReference;
    /** The VPC this VPN gateway resides in. */
    vpc: VPCReference;
  }

  /** VPNGatewayCollection. */
  export interface VPNGatewayCollection {
    /** A link to the first page of resources. */
    first: VPNGatewayCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: VPNGatewayCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
    /** Collection of VPN gateways. */
    vpn_gateways: VPNGateway[];
  }

  /** A link to the first page of resources. */
  export interface VPNGatewayCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface VPNGatewayCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** VPNGatewayConnection. */
  export interface VPNGatewayConnection {
    /** If set to false, the VPN gateway connection is shut down. */
    admin_state_up: boolean;
    /** The authentication mode. Only `psk` is currently supported. */
    authentication_mode: string;
    /** The date and time that this VPN gateway connection was created. */
    created_at: string;
    /** The Dead Peer Detection settings. */
    dead_peer_detection: VPNGatewayConnectionDPD;
    /** The VPN connection's canonical URL. */
    href: string;
    /** The unique identifier for this VPN gateway connection. */
    id: string;
    /** The IKE policy. If absent, [auto-negotiation is
     *  used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
     */
    ike_policy?: IKEPolicyReference;
    /** The IPsec policy. If absent, [auto-negotiation is
     *  used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
     */
    ipsec_policy?: IPsecPolicyReference;
    /** The mode of the VPN gateway. */
    mode: string;
    /** The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway. */
    name: string;
    /** The IP address of the peer VPN gateway. */
    peer_address: string;
    /** The pre-shared key. */
    psk: string;
    /** The resource type. */
    resource_type: string;
    /** The status of a VPN gateway connection. */
    status: string;
  }

  /** Collection of VPN gateway connections in a VPN gateway. */
  export interface VPNGatewayConnectionCollection {
    /** Array of VPN gateway connections. */
    connections: VPNGatewayConnection[];
  }

  /** The Dead Peer Detection settings. */
  export interface VPNGatewayConnectionDPD {
    /** Dead Peer Detection actions. */
    action: string;
    /** Dead Peer Detection interval in seconds. */
    interval: number;
    /** Dead Peer Detection timeout in seconds. Must be at least the interval. */
    timeout: number;
  }

  /** The Dead Peer Detection settings. */
  export interface VPNGatewayConnectionDPDPatch {
    /** Dead Peer Detection actions. */
    action?: string;
    /** Dead Peer Detection interval in seconds. */
    interval?: number;
    /** Dead Peer Detection timeout in seconds. Must be at least the interval. */
    timeout?: number;
  }

  /** The Dead Peer Detection settings. */
  export interface VPNGatewayConnectionDPDPrototype {
    /** Dead Peer Detection actions. */
    action?: string;
    /** Dead Peer Detection interval in seconds. */
    interval?: number;
    /** Dead Peer Detection timeout in seconds. Must be at least the interval. */
    timeout?: number;
  }

  /** The IKE policy to use. Specify `null` to remove any existing policy, [resulting in auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1). */
  export interface VPNGatewayConnectionIKEPolicyPatch {
  }

  /** The IKE policy to use. If unspecified, [auto-negotiation will be used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1). */
  export interface VPNGatewayConnectionIKEPolicyPrototype {
  }

  /** The IPsec policy to use. Specify `null` to remove any existing policy, [resulting in auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2). */
  export interface VPNGatewayConnectionIPsecPolicyPatch {
  }

  /** The IPsec policy to use. If unspecified, [auto-negotiation will be used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2). */
  export interface VPNGatewayConnectionIPsecPolicyPrototype {
  }

  /** VPNGatewayConnectionLocalCIDRs. */
  export interface VPNGatewayConnectionLocalCIDRs {
    /** The local CIDRs for this resource. */
    local_cidrs?: string[];
  }

  /** VPNGatewayConnectionPatch. */
  export interface VPNGatewayConnectionPatch {
    /** If set to false, the VPN gateway connection is shut down. */
    admin_state_up?: boolean;
    /** The Dead Peer Detection settings. */
    dead_peer_detection?: VPNGatewayConnectionDPDPatch;
    /** The IKE policy to use. Specify `null` to remove any existing policy, [resulting in
     *  auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
     */
    ike_policy?: VPNGatewayConnectionIKEPolicyPatch;
    /** The IPsec policy to use. Specify `null` to remove any existing policy, [resulting in
     *  auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
     */
    ipsec_policy?: VPNGatewayConnectionIPsecPolicyPatch;
    /** The name for this VPN gateway connection. The name must not be used by another connection for the VPN
     *  gateway.
     */
    name?: string;
    /** The IP address of the peer VPN gateway. */
    peer_address?: string;
    /** The pre-shared key. */
    psk?: string;
  }

  /** VPNGatewayConnectionPeerCIDRs. */
  export interface VPNGatewayConnectionPeerCIDRs {
    /** The peer CIDRs for this resource. */
    peer_cidrs?: string[];
  }

  /** VPNGatewayConnectionPrototype. */
  export interface VPNGatewayConnectionPrototype {
    /** If set to false, the VPN gateway connection is shut down. */
    admin_state_up?: boolean;
    /** The Dead Peer Detection settings. */
    dead_peer_detection?: VPNGatewayConnectionDPDPrototype;
    /** The IKE policy to use. If unspecified, [auto-negotiation will be
     *  used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
     */
    ike_policy?: VPNGatewayConnectionIKEPolicyPrototype;
    /** The IPsec policy to use. If unspecified, [auto-negotiation will be
     *  used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
     */
    ipsec_policy?: VPNGatewayConnectionIPsecPolicyPrototype;
    /** The name for this VPN gateway connection. The name must not be used by another connection for the VPN
     *  gateway. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The IP address of the peer VPN gateway. */
    peer_address: string;
    /** The pre-shared key. */
    psk: string;
  }

  /** VPNGatewayConnectionReference. */
  export interface VPNGatewayConnectionReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VPNGatewayConnectionReferenceDeleted;
    /** The VPN connection's canonical URL. */
    href: string;
    /** The unique identifier for this VPN gateway connection. */
    id: string;
    /** The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface VPNGatewayConnectionReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** VPNGatewayConnectionStaticRouteModeTunnel. */
  export interface VPNGatewayConnectionStaticRouteModeTunnel {
    /** The IP address of the VPN gateway member in which the tunnel resides. */
    public_ip: IP;
    /** The status of the VPN Tunnel. */
    status: string;
  }

  /** VPNGatewayMember. */
  export interface VPNGatewayMember {
    /** The reserved IP address assigned to the VPN gateway member.
     *
     *  This property will be present only when the VPN gateway status is `available`.
     */
    private_ip: ReservedIPReference;
    /** The public IP address assigned to the VPN gateway member. */
    public_ip: IP;
    /** The high availability role assigned to the VPN gateway member. */
    role: string;
    /** The status of the VPN gateway member. */
    status: string;
  }

  /** VPNGatewayPrototype. */
  export interface VPNGatewayPrototype {
    /** The name for this VPN gateway. The name must not be used by another VPN gateway in the VPC. If unspecified,
     *  the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
    /** Identifies a subnet by a unique property. */
    subnet: SubnetIdentity;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface VPNGatewayReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** VPNServer. */
  export interface VPNServer {
    /** The certificate instance for this VPN server. */
    certificate: CertificateInstanceReference;
    /** The methods used to authenticate VPN clients to this VPN server. VPN clients must authenticate against all
     *  specified methods.
     */
    client_authentication: VPNServerAuthentication[];
    /** Indicates whether disconnected VPN clients will be automatically deleted after
     *  `client_auto_delete_timeout` hours have passed. At present, this is always `true`, but may be modifiable in the
     *  future.
     */
    client_auto_delete: boolean;
    /** If `client_auto_delete` is `true`, the hours after which disconnected VPN clients will be automatically
     *  deleted. If the value is `0`, disconnected VPN clients will be deleted immediately. This value may be modifiable
     *  in the future.
     */
    client_auto_delete_timeout: number;
    /** The DNS server addresses that will be provided to VPN clients that are connected to this VPN server. */
    client_dns_server_ips: IP[];
    /** The seconds a VPN client can be idle before this VPN server will disconnect it.  If `0`, the server will not
     *  disconnect idle clients.
     */
    client_idle_timeout: number;
    /** The VPN client IPv4 address pool, expressed in CIDR format. */
    client_ip_pool: string;
    /** The date and time that the VPN server was created. */
    created_at: string;
    /** The CRN for this VPN server. */
    crn: string;
    /** Indicates whether the split tunneling is enabled on this VPN server. */
    enable_split_tunneling: boolean;
    /** The health of this resource.
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
     *  lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may
     *  also have this state.
     */
    health_state: string;
    /** Fully qualified domain name assigned to this VPN server. */
    hostname: string;
    /** The URL for this VPN server. */
    href: string;
    /** The unique identifier for this VPN server. */
    id: string;
    /** The lifecycle state of the VPN server. */
    lifecycle_state: string;
    /** The name for this VPN server. The name is unique across all VPN servers in the VPC. */
    name: string;
    /** The port number used by this VPN server. */
    port: number;
    /** The reserved IPs bound to this VPN server. */
    private_ips: ReservedIPReference[];
    /** The transport protocol used by this VPN server. */
    protocol: string;
    /** The resource group for this VPN server. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The security groups targeting this VPN server. */
    security_groups: SecurityGroupReference[];
    /** The subnets this VPN server is provisioned in. */
    subnets: SubnetReference[];
    /** The VPC this VPN server resides in. */
    vpc: VPCReference;
  }

  /** An authentication method for this VPN server. */
  export interface VPNServerAuthentication {
    /** The type of authentication. */
    method: string;
  }

  /** The type of identity provider to be used by VPN client. */
  export interface VPNServerAuthenticationByUsernameIdProvider {
  }

  /** An authentication method for this VPN server. */
  export interface VPNServerAuthenticationPrototype {
    /** The type of authentication. */
    method: string;
  }

  /** VPNServerClient. */
  export interface VPNServerClient {
    /** The IP address assigned to this VPN client from `client_ip_pool`. */
    client_ip: IP;
    /** The common name of client certificate that the VPN client provided when connecting to the server.
     *
     *  This property will be present only when the `certificate` client authentication method is enabled on the VPN
     *  server.
     */
    common_name?: string;
    /** The date and time that the VPN client was created. */
    created_at: string;
    /** The date and time that the VPN client was disconnected.
     *
     *  This property will be present only when the client `status` is `disconnected`.
     */
    disconnected_at?: string;
    /** The URL for this VPN client. */
    href: string;
    /** The unique identifier for this VPN client. */
    id: string;
    /** The remote IP address of this VPN client. */
    remote_ip: IP;
    /** The remote port of this VPN client. */
    remote_port: number;
    /** The resource type. */
    resource_type: string;
    /** The status of the VPN client:
     *  - `connected`: the VPN client is `connected` to this VPN server.
     *  - `disconnected`: the VPN client is `disconnected` from this VPN server.
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the VPN client on
     *  which the unexpected property value was encountered.
     */
    status: string;
    /** The username that this VPN client provided when connecting to the VPN server.
     *
     *  This property will be present only when the `username` client authentication method is enabled on the VPN
     *  server.
     */
    username?: string;
  }

  /** VPNServerClientCollection. */
  export interface VPNServerClientCollection {
    /** Collection of VPN clients. */
    clients: VPNServerClient[];
    /** A link to the first page of resources. */
    first: VPNServerClientCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: VPNServerClientCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface VPNServerClientCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface VPNServerClientCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** VPNServerCollection. */
  export interface VPNServerCollection {
    /** A link to the first page of resources. */
    first: VPNServerCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: VPNServerCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
    /** Collection of VPN servers. */
    vpn_servers: VPNServer[];
  }

  /** A link to the first page of resources. */
  export interface VPNServerCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface VPNServerCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface VPNServerReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** VPNServerRoute. */
  export interface VPNServerRoute {
    /** The action to perform with a packet matching the VPN route:
     *  - `translate`: translate the source IP address to one of the private IP addresses of the VPN server.
     *  - `deliver`: deliver the packet into the VPC.
     *  - `drop`: drop the packet
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the VPN route on
     *  which the unexpected property value was encountered.
     */
    action: string;
    /** The date and time that the VPN route was created. */
    created_at: string;
    /** The destination for this VPN route in the VPN server. If an incoming packet does not match any destination,
     *  it will be dropped.
     */
    destination: string;
    /** The URL for this VPN route. */
    href: string;
    /** The unique identifier for this VPN route. */
    id: string;
    /** The lifecycle state of the VPN route. */
    lifecycle_state: string;
    /** The name for this VPN route. The name is unique across all routes for a VPN server. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** VPNServerRouteCollection. */
  export interface VPNServerRouteCollection {
    /** A link to the first page of resources. */
    first: VPNServerRouteCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: VPNServerRouteCollectionNext;
    /** Collection of VPN routes. */
    routes: VPNServerRoute[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface VPNServerRouteCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface VPNServerRouteCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** VirtualNetworkInterface. */
  export interface VirtualNetworkInterface {
    /** Indicates whether this virtual network interface will be automatically deleted when `target` is deleted. */
    auto_delete: boolean;
    /** The date and time that the virtual network interface was created. */
    created_at: string;
    /** The CRN for this virtual network interface. */
    crn: string;
    /** The URL for this virtual network interface. */
    href: string;
    /** The unique identifier for this virtual network interface. */
    id: string;
    /** The lifecycle state of the virtual network interface. */
    lifecycle_state: string;
    /** The name for this virtual network interface. The name is unique across all virtual network interfaces in the
     *  VPC.
     */
    name: string;
    /** The reserved IP for this virtual network interface. */
    primary_ip: ReservedIPReference;
    /** The resource group for this virtual network interface. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The security groups for this virtual network interface. */
    security_groups: SecurityGroupReference[];
    /** The associated subnet. */
    subnet: SubnetReference;
    /** The target of this virtual network interface.
     *
     *  If absent, this virtual network interface is not attached to a target.
     */
    target?: VirtualNetworkInterfaceTarget;
    /** The VPC this virtual network interface resides in. */
    vpc: VPCReference;
    /** The zone this virtual network interface resides in. */
    zone: ZoneReference;
  }

  /** VirtualNetworkInterfaceCollection. */
  export interface VirtualNetworkInterfaceCollection {
    /** A link to the first page of resources. */
    first: VirtualNetworkInterfaceCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: VirtualNetworkInterfaceCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
    /** Collection of virtual network interfaces. */
    virtual_network_interfaces: VirtualNetworkInterface[];
  }

  /** A link to the first page of resources. */
  export interface VirtualNetworkInterfaceCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface VirtualNetworkInterfaceCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** VirtualNetworkInterfacePrimaryIPPrototype. */
  export interface VirtualNetworkInterfacePrimaryIPPrototype {
  }

  /** VirtualNetworkInterfaceReferenceAttachmentContext. */
  export interface VirtualNetworkInterfaceReferenceAttachmentContext {
    /** The CRN for this virtual network interface. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VirtualNetworkInterfaceReferenceAttachmentContextDeleted;
    /** The URL for this virtual network interface. */
    href: string;
    /** The unique identifier for this virtual network interface. */
    id: string;
    /** The name for this virtual network interface. The name is unique across all virtual network interfaces in the
     *  VPC.
     */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface VirtualNetworkInterfaceReferenceAttachmentContextDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface VirtualNetworkInterfaceReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface VirtualNetworkInterfaceReferenceReservedIPTargetContextDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** A virtual network interface target. The resource types that can be virtual network interface targets are expected to expand in the future. When iterating over virtual network interface targets, do not assume that every target resource will be from a known set of resource types. Optionally halt processing and surface an error, or bypass resources of unrecognized types. */
  export interface VirtualNetworkInterfaceTarget {
  }

  /** Volume. */
  export interface Volume {
    /** Indicates whether a running virtual server instance has an attachment to this volume. */
    active: boolean;
    /** The attachment state of the volume
     *  - `unattached`: Not attached to any virtual server instances
     *  - `attached`: Attached to a virtual server instance (even if the instance is stopped)
     *  - `unusable`: Not able to be attached to any virtual server instances.
     */
    attachment_state: string;
    /** The maximum bandwidth (in megabits per second) for the volume. */
    bandwidth: number;
    /** Indicates whether this volume is performing an operation that must be serialized. This must be `false` to
     *  perform an operation that is specified to require serialization.
     */
    busy: boolean;
    /** The capacity to use for the volume (in gigabytes). The specified minimum and maximum capacity values for
     *  creating or updating volumes may expand in the future.
     */
    capacity: number;
    /** The date and time that the volume was created. */
    created_at: string;
    /** The CRN for this volume. */
    crn: string;
    /** The type of encryption used on the volume. */
    encryption: string;
    /** The root key used to wrap the data encryption key for the volume.
     *
     *  This property will be present for volumes with an `encryption` type of
     *  `user_managed`.
     */
    encryption_key?: EncryptionKeyReference;
    /** The reasons for the current `health_state` (if any).
     *
     *  The enumerated reason code values for this property will expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected reason code was encountered.
     */
    health_reasons: VolumeHealthReason[];
    /** The health of this resource.
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
     *  lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may
     *  also have this state.
     */
    health_state: string;
    /** The URL for this volume. */
    href: string;
    /** The unique identifier for this volume. */
    id: string;
    /** The maximum I/O operations per second (IOPS) for this volume. */
    iops: number;
    /** The name for this volume. The name is unique across all volumes in the region. */
    name: string;
    /** The operating system associated with this volume. If absent, this volume was not
     *  created from an image, or the image did not include an operating system.
     */
    operating_system?: OperatingSystem;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) for this volume. */
    profile: VolumeProfileReference;
    /** The resource group for this volume. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: string;
    /** The image from which this volume was created (this may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     *  If absent, this volume was not created from an image.
     */
    source_image?: ImageReference;
    /** The snapshot from which this volume was cloned. */
    source_snapshot?: SnapshotReference;
    /** The status of the volume.
     *
     *  The enumerated values for this property will expand in the future. When processing this property, check for and
     *  log unknown values. Optionally halt processing and surface the error, or bypass the volume on which the
     *  unexpected property value was encountered.
     */
    status: string;
    /** The reasons for the current status (if any).
     *
     *  The enumerated reason code values for this property will expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on
     *  which the unexpected reason code was encountered.
     */
    status_reasons: VolumeStatusReason[];
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume. */
    user_tags: string[];
    /** The volume attachments for this volume. */
    volume_attachments: VolumeAttachmentReferenceVolumeContext[];
    /** The zone this volume resides in. */
    zone: ZoneReference;
  }

  /** VolumeAttachment. */
  export interface VolumeAttachment {
    /** The maximum bandwidth (in megabits per second) for the volume when attached to this instance. This may be
     *  lower than the volume bandwidth depending on the configuration of the instance.
     */
    bandwidth: number;
    /** The date and time that the volume was attached. */
    created_at: string;
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete: boolean;
    /** Information about how the volume is exposed to the instance operating system.
     *
     *  This property may be absent if the volume attachment's `status` is not `attached`.
     */
    device?: VolumeAttachmentDevice;
    /** The URL for this volume attachment. */
    href: string;
    /** The unique identifier for this volume attachment. */
    id: string;
    /** The name for this volume attachment. The name is unique across all volume attachments on the instance. */
    name: string;
    /** The status of this volume attachment. */
    status: string;
    /** The type of volume attachment. */
    type: string;
    /** The attached volume.
     *
     *  This property will be absent if the volume has not yet been provisioned.
     */
    volume?: VolumeReferenceVolumeAttachmentContext;
  }

  /** VolumeAttachmentCollection. */
  export interface VolumeAttachmentCollection {
    /** Collection of volume attachments. */
    volume_attachments: VolumeAttachment[];
  }

  /** VolumeAttachmentDevice. */
  export interface VolumeAttachmentDevice {
    /** A unique identifier for the device which is exposed to the instance operating system. */
    id?: string;
  }

  /** VolumeAttachmentPrototype. */
  export interface VolumeAttachmentPrototype {
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** An existing volume to attach to the instance, or a prototype object for a new volume. */
    volume: VolumeAttachmentPrototypeVolume;
  }

  /** VolumeAttachmentPrototypeInstanceByImageContext. */
  export interface VolumeAttachmentPrototypeInstanceByImageContext {
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** A prototype object for a new volume. */
    volume: VolumePrototypeInstanceByImageContext;
  }

  /** VolumeAttachmentPrototypeInstanceBySourceSnapshotContext. */
  export interface VolumeAttachmentPrototypeInstanceBySourceSnapshotContext {
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** A prototype object for a new volume from a snapshot. */
    volume: VolumePrototypeInstanceBySourceSnapshotContext;
  }

  /** VolumeAttachmentPrototypeInstanceByVolumeContext. */
  export interface VolumeAttachmentPrototypeInstanceByVolumeContext {
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** An existing volume to attach. */
    volume: VolumeIdentity;
  }

  /** An existing volume to attach to the instance, or a prototype object for a new volume. */
  export interface VolumeAttachmentPrototypeVolume {
  }

  /** VolumeAttachmentReferenceInstanceContext. */
  export interface VolumeAttachmentReferenceInstanceContext {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VolumeAttachmentReferenceInstanceContextDeleted;
    /** Information about how the volume is exposed to the instance operating system.
     *
     *  This property may be absent if the volume attachment's `status` is not `attached`.
     */
    device?: VolumeAttachmentDevice;
    /** The URL for this volume attachment. */
    href: string;
    /** The unique identifier for this volume attachment. */
    id: string;
    /** The name for this volume attachment. The name is unique across all volume attachments on the instance. */
    name: string;
    /** The attached volume.
     *
     *  This property will be absent if the volume has not yet been provisioned.
     */
    volume?: VolumeReferenceVolumeAttachmentContext;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface VolumeAttachmentReferenceInstanceContextDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** VolumeAttachmentReferenceVolumeContext. */
  export interface VolumeAttachmentReferenceVolumeContext {
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete: boolean;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VolumeAttachmentReferenceVolumeContextDeleted;
    /** Information about how the volume is exposed to the instance operating system.
     *
     *  This property may be absent if the volume attachment's `status` is not `attached`.
     */
    device?: VolumeAttachmentDevice;
    /** The URL for this volume attachment. */
    href: string;
    /** The unique identifier for this volume attachment. */
    id: string;
    /** The attached instance. */
    instance: InstanceReference;
    /** The name for this volume attachment. The name is unique across all volume attachments on the instance. */
    name: string;
    /** The type of volume attachment. */
    type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface VolumeAttachmentReferenceVolumeContextDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** VolumeCollection. */
  export interface VolumeCollection {
    /** A link to the first page of resources. */
    first: VolumeCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: VolumeCollectionNext;
    /** The total number of resources across all pages. */
    total_count: number;
    /** Collection of volumes. */
    volumes: Volume[];
  }

  /** A link to the first page of resources. */
  export interface VolumeCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface VolumeCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** VolumeHealthReason. */
  export interface VolumeHealthReason {
    /** A snake case string succinctly identifying the reason for this health state. */
    code: string;
    /** An explanation of the reason for this health state. */
    message: string;
    /** Link to documentation about the reason for this health state. */
    more_info?: string;
  }

  /** Identifies a volume by a unique property. */
  export interface VolumeIdentity {
  }

  /** VolumeProfile. */
  export interface VolumeProfile {
    /** The product family this volume profile belongs to.
     *
     *  The enumerated values for this property will expand in the future. When processing this property, check for and
     *  log unknown values. Optionally halt processing and surface the error, or bypass the volume profile on which the
     *  unexpected property value was encountered.
     */
    family: string;
    /** The URL for this volume profile. */
    href: string;
    /** The globally unique name for this volume profile. */
    name: string;
  }

  /** VolumeProfileCollection. */
  export interface VolumeProfileCollection {
    /** A link to the first page of resources. */
    first: VolumeProfileCollectionFirst;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: VolumeProfileCollectionNext;
    /** Collection of volume profiles. */
    profiles: VolumeProfile[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /** A link to the first page of resources. */
  export interface VolumeProfileCollectionFirst {
    /** The URL for a page of resources. */
    href: string;
  }

  /** A link to the next page of resources. This property is present for all pages except the last page. */
  export interface VolumeProfileCollectionNext {
    /** The URL for a page of resources. */
    href: string;
  }

  /** Identifies a volume profile by a unique property. */
  export interface VolumeProfileIdentity {
  }

  /** VolumeProfileReference. */
  export interface VolumeProfileReference {
    /** The URL for this volume profile. */
    href: string;
    /** The globally unique name for this volume profile. */
    name: string;
  }

  /** VolumePrototype. */
  export interface VolumePrototype {
    /** The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a
     *  profile `family` of `custom`.
     */
    iops?: number;
    /** The name for this volume. The name must not be used by another volume in the region. If unspecified, the
     *  name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to use for this volume. */
    profile: VolumeProfileIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume. */
    user_tags?: string[];
    /** The zone this volume will reside in. */
    zone: ZoneIdentity;
  }

  /** VolumePrototypeInstanceByImageContext. */
  export interface VolumePrototypeInstanceByImageContext {
    /** The capacity to use for the volume (in gigabytes). Must be at least the image's
     *  `minimum_provisioned_size`. The maximum value may increase in the future.
     *
     *  If unspecified, the capacity will be the image's `minimum_provisioned_size`.
     */
    capacity?: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a
     *  profile `family` of `custom`.
     */
    iops?: number;
    /** The name for this volume. The name must not be used by another volume in the region. If unspecified, the
     *  name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to use for this volume. */
    profile: VolumeProfileIdentity;
    /** The resource group to use for this volume. If unspecified, the instance's resource group will be used. */
    resource_group?: ResourceGroupIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume. */
    user_tags?: string[];
  }

  /** VolumePrototypeInstanceBySourceSnapshotContext. */
  export interface VolumePrototypeInstanceBySourceSnapshotContext {
    /** The capacity to use for the volume (in gigabytes). Must be at least the snapshot's
     *  `minimum_capacity`. The maximum value may increase in the future.
     *
     *  If unspecified, the capacity will be the source snapshot's `minimum_capacity`.
     */
    capacity?: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a
     *  profile `family` of `custom`.
     */
    iops?: number;
    /** The name for this volume. The name must not be used by another volume in the region. If unspecified, the
     *  name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to use for this volume. */
    profile: VolumeProfileIdentity;
    /** The resource group to use for this volume. If unspecified, the instance's resource group will be used. */
    resource_group?: ResourceGroupIdentity;
    /** The snapshot from which to clone the volume. */
    source_snapshot: SnapshotIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume. */
    user_tags?: string[];
  }

  /** VolumeReference. */
  export interface VolumeReference {
    /** The CRN for this volume. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VolumeReferenceDeleted;
    /** The URL for this volume. */
    href: string;
    /** The unique identifier for this volume. */
    id: string;
    /** The name for this volume. The name is unique across all volumes in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: VolumeRemote;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface VolumeReferenceDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** VolumeReferenceVolumeAttachmentContext. */
  export interface VolumeReferenceVolumeAttachmentContext {
    /** The CRN for this volume. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VolumeReferenceVolumeAttachmentContextDeleted;
    /** The URL for this volume. */
    href: string;
    /** The unique identifier for this volume. */
    id: string;
    /** The name for this volume. The name is unique across all volumes in the region. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** If present, this property indicates the referenced resource has been deleted, and provides some supplementary information. */
  export interface VolumeReferenceVolumeAttachmentContextDeleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /** If present, this property indicates that the resource associated with this reference is remote and therefore may not be directly retrievable. */
  export interface VolumeRemote {
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /** VolumeStatusReason. */
  export interface VolumeStatusReason {
    /** A snake case string succinctly identifying the status reason. */
    code: string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }

  /** Zone. */
  export interface Zone {
    /** The URL for this zone. */
    href: string;
    /** The globally unique name for this zone. */
    name: string;
    /** The region this zone resides in. */
    region: RegionReference;
    /** The availability status of this zone. */
    status: string;
  }

  /** ZoneCollection. */
  export interface ZoneCollection {
    /** Collection of zones. */
    zones: Zone[];
  }

  /** Identifies a zone by a unique property. */
  export interface ZoneIdentity {
  }

  /** ZoneReference. */
  export interface ZoneReference {
    /** The URL for this zone. */
    href: string;
    /** The globally unique name for this zone. */
    name: string;
  }

  /** BackupPolicyJobSourceVolumeReference. */
  export interface BackupPolicyJobSourceVolumeReference extends BackupPolicyJobSource {
    /** The CRN for this volume. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VolumeReferenceDeleted;
    /** The URL for this volume. */
    href: string;
    /** The unique identifier for this volume. */
    id: string;
    /** The name for this volume. The name is unique across all volumes in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: VolumeRemote;
    /** The resource type. */
    resource_type: string;
  }

  /** BareMetalServerBootTargetBareMetalServerDiskReference. */
  export interface BareMetalServerBootTargetBareMetalServerDiskReference extends BareMetalServerBootTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: BareMetalServerDiskReferenceDeleted;
    /** The URL for this bare metal server disk. */
    href: string;
    /** The unique identifier for this bare metal server disk. */
    id: string;
    /** The name for this bare metal server disk. The name is unique across all disks on the bare metal server. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount. */
  export interface BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount extends BareMetalServerInitializationUserAccount {
    /** The password at initialization, encrypted using `encryption_key`, and returned base64-encoded. */
    encrypted_password: string;
    /** The public SSH key used to encrypt the password. */
    encryption_key: KeyReference;
    /** The resource type. */
    resource_type: string;
    /** The username for the account created at initialization. */
    username: string;
  }

  /** BareMetalServerNetworkInterfaceByHiperSocket. */
  export interface BareMetalServerNetworkInterfaceByHiperSocket extends BareMetalServerNetworkInterface {
    /** - `hipersocket`: a virtual network device that provides high-speed TCP/IP connectivity
     *    within a `s390x` based system.
     */
    interface_type: string;
  }

  /** BareMetalServerNetworkInterfaceByPCI. */
  export interface BareMetalServerNetworkInterfaceByPCI extends BareMetalServerNetworkInterface {
    /** Indicates what VLAN IDs (for VLAN type only) can use this physical (PCI type) interface. */
    allowed_vlans: number[];
    /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI interface
     *    - Cannot directly use an IEEE 802.1q VLAN tag.
     */
    interface_type: string;
  }

  /** BareMetalServerNetworkInterfaceByVLAN. */
  export interface BareMetalServerNetworkInterfaceByVLAN extends BareMetalServerNetworkInterface {
    /** Indicates if the interface can float to any other server within the same
     *  `resource_group`. The interface will float automatically if the network detects a GARP or RARP on another bare
     *  metal server in the resource group.  Applies only to `vlan` type interfaces.
     */
    allow_interface_to_float: boolean;
    /** - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array
     *     of `allowed_vlans`.
     *    - Must use an IEEE 802.1q tag.
     *    - Has its own security groups and does not inherit those of the PCI device through
     *      which traffic flows.
     */
    interface_type: string;
    /** Indicates the 802.1Q VLAN ID tag that must be used for all traffic on this interface. */
    vlan: number;
  }

  /** BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype. */
  export interface BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype extends BareMetalServerNetworkInterfacePrototype {
    /** - `hipersocket`: a virtual network device that provides high-speed TCP/IP connectivity
     *    within a `s390x` based system.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `amd64`.
     */
    interface_type: string;
  }

  /** BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPCIPrototype. */
  export interface BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPCIPrototype extends BareMetalServerNetworkInterfacePrototype {
    /** Indicates what VLAN IDs (for VLAN type only) can use this physical (PCI type) interface. */
    allowed_vlans?: number[];
    /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI interface
     *    - Cannot directly use an IEEE 802.1q VLAN tag.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type: string;
  }

  /** BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVLANPrototype. */
  export interface BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVLANPrototype extends BareMetalServerNetworkInterfacePrototype {
    /** Indicates if the interface can float to any other server within the same
     *  `resource_group`. The interface will float automatically if the network detects a GARP or RARP on another bare
     *  metal server in the resource group.  Applies only to `vlan` type interfaces.
     */
    allow_interface_to_float?: boolean;
    /** - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array
     *     of `allowed_vlans`.
     *    - Must use an IEEE 802.1q tag.
     *    - Has its own security groups and does not inherit those of the PCI device through
     *      which traffic flows.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type: string;
    /** Indicates the 802.1Q VLAN ID tag that must be used for all traffic on this interface. */
    vlan: number;
  }

  /** The total bandwidth shared across the bare metal server network interfaces of a bare metal server with this profile depends on its configuration. */
  export interface BareMetalServerProfileBandwidthDependent extends BareMetalServerProfileBandwidth {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted total bandwidth values (in megabits per second) shared across the bare metal server network interfaces of a bare metal server with this profile. */
  export interface BareMetalServerProfileBandwidthEnum extends BareMetalServerProfileBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The total bandwidth (in megabits per second) shared across the bare metal server network interfaces of a bare metal server with this profile. */
  export interface BareMetalServerProfileBandwidthFixed extends BareMetalServerProfileBandwidth {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted total bandwidth range (in megabits per second) shared across the bare metal server network interfaces of a bare metal server with this profile. */
  export interface BareMetalServerProfileBandwidthRange extends BareMetalServerProfileBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The CPU core count for a bare metal server with this profile depends on its configuration. */
  export interface BareMetalServerProfileCPUCoreCountDependent extends BareMetalServerProfileCPUCoreCount {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted values for CPU cores for a bare metal server with this profile. */
  export interface BareMetalServerProfileCPUCoreCountEnum extends BareMetalServerProfileCPUCoreCount {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The CPU core count for a bare metal server with this profile. */
  export interface BareMetalServerProfileCPUCoreCountFixed extends BareMetalServerProfileCPUCoreCount {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted range for the number of CPU cores for a bare metal server with this profile. */
  export interface BareMetalServerProfileCPUCoreCountRange extends BareMetalServerProfileCPUCoreCount {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The CPU socket count for a bare metal server with this profile depends on its configuration. */
  export interface BareMetalServerProfileCPUSocketCountDependent extends BareMetalServerProfileCPUSocketCount {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted values for CPU sockets for a bare metal server with this profile. */
  export interface BareMetalServerProfileCPUSocketCountEnum extends BareMetalServerProfileCPUSocketCount {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The number of CPU sockets for a bare metal server with this profile. */
  export interface BareMetalServerProfileCPUSocketCountFixed extends BareMetalServerProfileCPUSocketCount {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted range for the number of CPU sockets for a bare metal server with this profile. */
  export interface BareMetalServerProfileCPUSocketCountRange extends BareMetalServerProfileCPUSocketCount {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The number of disks of this configuration for a bare metal server with this profile depends on its bare metal server configuration. */
  export interface BareMetalServerProfileDiskQuantityDependent extends BareMetalServerProfileDiskQuantity {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted the number of disks of this configuration for a bare metal server with this profile. */
  export interface BareMetalServerProfileDiskQuantityEnum extends BareMetalServerProfileDiskQuantity {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The number of disks of this configuration for a bare metal server with this profile. */
  export interface BareMetalServerProfileDiskQuantityFixed extends BareMetalServerProfileDiskQuantity {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted range for the number of disks of this configuration for a bare metal server with this profile. */
  export interface BareMetalServerProfileDiskQuantityRange extends BareMetalServerProfileDiskQuantity {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The disk size in GB (gigabytes) of this configuration for a bare metal server with this profile depends on its bare metal server configuration. */
  export interface BareMetalServerProfileDiskSizeDependent extends BareMetalServerProfileDiskSize {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted disk size in GB (gigabytes) of this configuration for a bare metal server with this profile. */
  export interface BareMetalServerProfileDiskSizeEnum extends BareMetalServerProfileDiskSize {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The size of the disk in GB (gigabytes). */
  export interface BareMetalServerProfileDiskSizeFixed extends BareMetalServerProfileDiskSize {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted range for the disk size of this configuration in GB (gigabytes) for a bare metal server with this profile. */
  export interface BareMetalServerProfileDiskSizeRange extends BareMetalServerProfileDiskSize {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** BareMetalServerProfileIdentityByHref. */
  export interface BareMetalServerProfileIdentityByHref extends BareMetalServerProfileIdentity {
    /** The URL for this bare metal server profile. */
    href: string;
  }

  /** BareMetalServerProfileIdentityByName. */
  export interface BareMetalServerProfileIdentityByName extends BareMetalServerProfileIdentity {
    /** The name for this bare metal server profile. */
    name: string;
  }

  /** The memory value for a bare metal server with this profile depends on its configuration. */
  export interface BareMetalServerProfileMemoryDependent extends BareMetalServerProfileMemory {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted memory values (in gibibytes) for a bare metal server with this profile. */
  export interface BareMetalServerProfileMemoryEnum extends BareMetalServerProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The memory (in gibibytes) for a bare metal server with this profile. */
  export interface BareMetalServerProfileMemoryFixed extends BareMetalServerProfileMemory {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted memory range (in gibibytes) for a bare metal server with this profile. */
  export interface BareMetalServerProfileMemoryRange extends BareMetalServerProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The number of bare metal server network interfaces supported on a bare metal server with this profile is dependent on its configuration. */
  export interface BareMetalServerProfileNetworkInterfaceCountDependent extends BareMetalServerProfileNetworkInterfaceCount {
    /** The type for this profile field. */
    type: string;
  }

  /** The number of bare metal server network interfaces supported on a bare metal server with this profile. */
  export interface BareMetalServerProfileNetworkInterfaceCountRange extends BareMetalServerProfileNetworkInterfaceCount {
    /** The maximum value for this profile field. */
    max?: number;
    /** The minimum value for this profile field. */
    min?: number;
    /** The type for this profile field. */
    type: string;
  }

  /** CatalogOfferingIdentityCatalogOfferingByCRN. */
  export interface CatalogOfferingIdentityCatalogOfferingByCRN extends CatalogOfferingIdentity {
    /** The CRN for this [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering. */
    crn: string;
  }

  /** CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN. */
  export interface CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN extends CatalogOfferingVersionIdentity {
    /** The CRN for this version of a
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering.
     */
    crn: string;
  }

  /** CertificateInstanceIdentityByCRN. */
  export interface CertificateInstanceIdentityByCRN extends CertificateInstanceIdentity {
    /** The CRN for this certificate instance. */
    crn: string;
  }

  /** CloudObjectStorageBucketIdentityByCRN. */
  export interface CloudObjectStorageBucketIdentityByCRN extends CloudObjectStorageBucketIdentity {
    /** The CRN of this Cloud Object Storage bucket. */
    crn: string;
  }

  /** CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName. */
  export interface CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName extends CloudObjectStorageBucketIdentity {
    /** The globally unique name of this Cloud Object Storage bucket. */
    name: string;
  }

  /** DNSInstanceIdentityByCRN. */
  export interface DNSInstanceIdentityByCRN extends DNSInstanceIdentity {
    /** The CRN for this DNS instance. */
    crn: string;
  }

  /** DNSZoneIdentityById. */
  export interface DNSZoneIdentityById extends DNSZoneIdentity {
    id: string;
  }

  /** DedicatedHostGroupIdentityByCRN. */
  export interface DedicatedHostGroupIdentityByCRN extends DedicatedHostGroupIdentity {
    /** The CRN for this dedicated host group. */
    crn: string;
  }

  /** DedicatedHostGroupIdentityByHref. */
  export interface DedicatedHostGroupIdentityByHref extends DedicatedHostGroupIdentity {
    /** The URL for this dedicated host group. */
    href: string;
  }

  /** DedicatedHostGroupIdentityById. */
  export interface DedicatedHostGroupIdentityById extends DedicatedHostGroupIdentity {
    /** The unique identifier for this dedicated host group. */
    id: string;
  }

  /** DedicatedHostProfileIdentityByHref. */
  export interface DedicatedHostProfileIdentityByHref extends DedicatedHostProfileIdentity {
    /** The URL for this dedicated host profile. */
    href: string;
  }

  /** DedicatedHostProfileIdentityByName. */
  export interface DedicatedHostProfileIdentityByName extends DedicatedHostProfileIdentity {
    /** The globally unique name for this dedicated host profile. */
    name: string;
  }

  /** The memory value for a dedicated host with this profile depends on its configuration. */
  export interface DedicatedHostProfileMemoryDependent extends DedicatedHostProfileMemory {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted memory values (in gibibytes) for a dedicated host with this profile. */
  export interface DedicatedHostProfileMemoryEnum extends DedicatedHostProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The memory (in gibibytes) for a dedicated host with this profile. */
  export interface DedicatedHostProfileMemoryFixed extends DedicatedHostProfileMemory {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted memory range (in gibibytes) for a dedicated host with this profile. */
  export interface DedicatedHostProfileMemoryRange extends DedicatedHostProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The CPU socket count for a dedicated host with this profile depends on its configuration. */
  export interface DedicatedHostProfileSocketDependent extends DedicatedHostProfileSocket {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted values for CPU socket count for a dedicated host with this profile. */
  export interface DedicatedHostProfileSocketEnum extends DedicatedHostProfileSocket {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The CPU socket count for a dedicated host with this profile. */
  export interface DedicatedHostProfileSocketFixed extends DedicatedHostProfileSocket {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted range for CPU socket count for a dedicated host with this profile. */
  export interface DedicatedHostProfileSocketRange extends DedicatedHostProfileSocket {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The VCPU count for a dedicated host with this profile depends on its configuration. */
  export interface DedicatedHostProfileVCPUDependent extends DedicatedHostProfileVCPU {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted values for VCPU count for a dedicated host with this profile. */
  export interface DedicatedHostProfileVCPUEnum extends DedicatedHostProfileVCPU {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The VCPU count for a dedicated host with this profile. */
  export interface DedicatedHostProfileVCPUFixed extends DedicatedHostProfileVCPU {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted range for VCPU count for a dedicated host with this profile. */
  export interface DedicatedHostProfileVCPURange extends DedicatedHostProfileVCPU {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** DedicatedHostPrototypeDedicatedHostByGroup. */
  export interface DedicatedHostPrototypeDedicatedHostByGroup extends DedicatedHostPrototype {
    /** The dedicated host group for this dedicated host. */
    group: DedicatedHostGroupIdentity;
  }

  /** DedicatedHostPrototypeDedicatedHostByZone. */
  export interface DedicatedHostPrototypeDedicatedHostByZone extends DedicatedHostPrototype {
    group?: DedicatedHostGroupPrototypeDedicatedHostByZoneContext;
    /** The zone this dedicated host will reside in. */
    zone: ZoneIdentity;
  }

  /** EncryptionKeyIdentityByCRN. */
  export interface EncryptionKeyIdentityByCRN extends EncryptionKeyIdentity {
    /** The CRN of the [Key Protect Root
     *  Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
     *  Services Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
     */
    crn: string;
  }

  /** Identifies a reserved IP by a unique property. */
  export interface EndpointGatewayReservedIPReservedIPIdentity extends EndpointGatewayReservedIP {
  }

  /** EndpointGatewayReservedIPReservedIPPrototypeTargetContext. */
  export interface EndpointGatewayReservedIPReservedIPPrototypeTargetContext extends EndpointGatewayReservedIP {
    /** The IP address to reserve, which must not already be reserved on the subnet.
     *
     *  If unspecified, an available address on the subnet will automatically be selected.
     */
    address?: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound.
     */
    auto_delete?: boolean;
    /** The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The subnet in which to create this reserved IP. */
    subnet: SubnetIdentity;
  }

  /** EndpointGatewayTargetPrototypeProviderCloudServiceIdentity. */
  export interface EndpointGatewayTargetPrototypeProviderCloudServiceIdentity extends EndpointGatewayTargetPrototype {
  }

  /** EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity. */
  export interface EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity extends EndpointGatewayTargetPrototype {
  }

  /** EndpointGatewayTargetProviderCloudServiceReference. */
  export interface EndpointGatewayTargetProviderCloudServiceReference extends EndpointGatewayTarget {
    /** The CRN for this provider cloud service, or the CRN for the user's instance of a provider cloud service. */
    crn: string;
    /** The type of target. */
    resource_type: string;
  }

  /** The name of this provider infrastructure service. */
  export interface EndpointGatewayTargetProviderInfrastructureServiceReference extends EndpointGatewayTarget {
    /** The name of a provider infrastructure service. Must be:
     *  - `ibm-ntp-server`: An NTP (Network Time Protocol) server provided by IBM.
     */
    name: string;
    /** The type of target. */
    resource_type: string;
  }

  /** FloatingIPPrototypeFloatingIPByTarget. */
  export interface FloatingIPPrototypeFloatingIPByTarget extends FloatingIPPrototype {
    /** The target resource to bind this floating IP to.
     *
     *  The target resource must not already have a floating IP bound to it if the target
     *  resource is:
     *
     *  - an instance network interface
     *  - a bare metal server network interface with `enable_infrastructure_nat` set to `true`.
     */
    target: FloatingIPTargetPrototype;
  }

  /** FloatingIPPrototypeFloatingIPByZone. */
  export interface FloatingIPPrototypeFloatingIPByZone extends FloatingIPPrototype {
    /** The zone this floating IP will reside in. */
    zone: ZoneIdentity;
  }

  /** Identifies an instance network interface by a unique property. */
  export interface FloatingIPTargetPatchNetworkInterfaceIdentity extends FloatingIPTargetPatch {
  }

  /** Identifies an instance network interface by a unique property. */
  export interface FloatingIPTargetPrototypeNetworkInterfaceIdentity extends FloatingIPTargetPrototype {
  }

  /** FloatingIPTargetBareMetalServerNetworkInterfaceReference. */
  export interface FloatingIPTargetBareMetalServerNetworkInterfaceReference extends FloatingIPTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: BareMetalServerNetworkInterfaceReferenceDeleted;
    /** The URL for this bare metal server network interface. */
    href: string;
    /** The unique identifier for this bare metal server network interface. */
    id: string;
    /** The name for this bare metal server network interface. */
    name: string;
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: string;
  }

  /** FloatingIPTargetNetworkInterfaceReference. */
  export interface FloatingIPTargetNetworkInterfaceReference extends FloatingIPTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: NetworkInterfaceReferenceDeleted;
    /** The URL for this instance network interface. */
    href: string;
    /** The unique identifier for this instance network interface. */
    id: string;
    /** The name for this instance network interface. */
    name: string;
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: string;
  }

  /** FloatingIPTargetPublicGatewayReference. */
  export interface FloatingIPTargetPublicGatewayReference extends FloatingIPTarget {
    /** The CRN for this public gateway. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: PublicGatewayReferenceDeleted;
    /** The URL for this public gateway. */
    href: string;
    /** The unique identifier for this public gateway. */
    id: string;
    /** The name for this public gateway. The name is unique across all public gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** Identifies a virtual server instance by a unique property. */
  export interface FlowLogCollectorTargetPrototypeInstanceIdentity extends FlowLogCollectorTargetPrototype {
  }

  /** Identifies an instance network interface by a unique property. */
  export interface FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity extends FlowLogCollectorTargetPrototype {
  }

  /** Identifies a subnet by a unique property. */
  export interface FlowLogCollectorTargetPrototypeSubnetIdentity extends FlowLogCollectorTargetPrototype {
  }

  /** Identifies a VPC by a unique property. */
  export interface FlowLogCollectorTargetPrototypeVPCIdentity extends FlowLogCollectorTargetPrototype {
  }

  /** FlowLogCollectorTargetInstanceReference. */
  export interface FlowLogCollectorTargetInstanceReference extends FlowLogCollectorTarget {
    /** The CRN for this virtual server instance. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: InstanceReferenceDeleted;
    /** The URL for this virtual server instance. */
    href: string;
    /** The unique identifier for this virtual server instance. */
    id: string;
    /** The name for this virtual server instance. The name is unique across all virtual server instances in the
     *  region.
     */
    name: string;
  }

  /** FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext. */
  export interface FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext extends FlowLogCollectorTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: NetworkInterfaceReferenceTargetContextDeleted;
    /** The URL for this instance network interface. */
    href: string;
    /** The unique identifier for this instance network interface. */
    id: string;
    /** The name for this instance network interface. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** FlowLogCollectorTargetSubnetReference. */
  export interface FlowLogCollectorTargetSubnetReference extends FlowLogCollectorTarget {
    /** The CRN for this subnet. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: SubnetReferenceDeleted;
    /** The URL for this subnet. */
    href: string;
    /** The unique identifier for this subnet. */
    id: string;
    /** The name for this subnet. The name is unique across all subnets in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** FlowLogCollectorTargetVPCReference. */
  export interface FlowLogCollectorTargetVPCReference extends FlowLogCollectorTarget {
    /** The CRN for this VPC. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VPCReferenceDeleted;
    /** The URL for this VPC. */
    href: string;
    /** The unique identifier for this VPC. */
    id: string;
    /** The name for this VPC. The name is unique across all VPCs in the region. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** ImageIdentityByCRN. */
  export interface ImageIdentityByCRN extends ImageIdentity {
    /** The CRN for this image. */
    crn: string;
  }

  /** ImageIdentityByHref. */
  export interface ImageIdentityByHref extends ImageIdentity {
    /** The URL for this image. */
    href: string;
  }

  /** ImageIdentityById. */
  export interface ImageIdentityById extends ImageIdentity {
    /** The unique identifier for this image. */
    id: string;
  }

  /** ImagePrototypeImageByFile. */
  export interface ImagePrototypeImageByFile extends ImagePrototype {
    /** A base64-encoded, encrypted representation of the key that was used to encrypt the data for this image.
     *
     *  That representation is created by wrapping the key's value with the `encryption_key` root key (which must also
     *  be specified), using either [Key Protect](https://cloud.ibm.com/docs/key-protect?topic=key-protect-wrap-keys) or
     *  the
     *  [Hyper Protect Crypto Services](https://cloud.ibm.com/docs/services/hs-crypto?topic=hs-crypto-wrap-keys).
     *
     *  If unspecified, the imported image is treated as unencrypted.
     */
    encrypted_data_key?: string;
    /** The root key that was used to wrap the data key (which is ultimately represented as
     *  `encrypted_data_key`). Additionally, the root key will be used to encrypt volumes
     *  created from this image (unless an alternate `encryption_key` is specified at volume
     *  creation).
     *
     *  If unspecified, the imported image is treated as unencrypted.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The file from which to create the image. */
    file: ImageFilePrototype;
    /** The [supported operating
     *  system](https://cloud.ibm.com/apidocs/vpc#list-operating-systems) included in this
     *  image.
     */
    operating_system: OperatingSystemIdentity;
  }

  /** ImagePrototypeImageBySourceVolume. */
  export interface ImagePrototypeImageBySourceVolume extends ImagePrototype {
    /** The root key used to wrap the system-generated data encryption key for the image.
     *
     *  If unspecified, the root key from `source_volume` will be used.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The volume from which to create the image. The specified volume must:
     *  - Have an `operating_system`, which will be used to populate this image's
     *    operating system information.
     *  - Not be `active` or `busy`.
     *
     *  During image creation, the specified volume may briefly become `busy`.
     */
    source_volume: VolumeIdentity;
  }

  /** InstanceCatalogOfferingPrototypeCatalogOfferingByOffering. */
  export interface InstanceCatalogOfferingPrototypeCatalogOfferingByOffering extends InstanceCatalogOfferingPrototype {
    /** Identifies a [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering by a unique property.
     */
    offering: CatalogOfferingIdentity;
  }

  /** InstanceCatalogOfferingPrototypeCatalogOfferingByVersion. */
  export interface InstanceCatalogOfferingPrototypeCatalogOfferingByVersion extends InstanceCatalogOfferingPrototype {
    /** Identifies a version of a
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering by a
     *  unique property.
     */
    version: CatalogOfferingVersionIdentity;
  }

  /** InstanceGroupManagerActionPrototypeScheduledActionPrototype. */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototype extends InstanceGroupManagerActionPrototype {
  }

  /** InstanceGroupManagerActionScheduledAction. */
  export interface InstanceGroupManagerActionScheduledAction extends InstanceGroupManagerAction {
    /** The type of action for the instance group. */
    action_type: string;
    /** The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within
     *  a 5 min period.
     */
    cron_spec?: string;
    /** The date and time the scheduled action was last applied. If absent, the action has never been applied. */
    last_applied_at?: string;
    /** The date and time the scheduled action will next run. If absent, the system is currently calculating the
     *  next run time.
     */
    next_run_at?: string;
  }

  /** InstanceGroupManagerAutoScale. */
  export interface InstanceGroupManagerAutoScale extends InstanceGroupManager {
    /** The time window in seconds to aggregate metrics prior to evaluation. */
    aggregation_window: number;
    /** The duration of time in seconds to pause further scale actions after scaling has taken place. */
    cooldown: number;
    /** The type of instance group manager. */
    manager_type: string;
    /** The maximum number of members in a managed instance group. */
    max_membership_count: number;
    /** The minimum number of members in a managed instance group. */
    min_membership_count: number;
    /** The policies of the instance group manager. */
    policies: InstanceGroupManagerPolicyReference[];
  }

  /** InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype. */
  export interface InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype extends InstanceGroupManagerPolicyPrototype {
    /** The type of metric to be evaluated. */
    metric_type: string;
    /** The metric value to be evaluated. */
    metric_value: number;
    /** The type of policy for the instance group. */
    policy_type: string;
  }

  /** InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy. */
  export interface InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy extends InstanceGroupManagerPolicy {
    /** The type of metric to be evaluated. */
    metric_type: string;
    /** The metric value to be evaluated. */
    metric_value: number;
    /** The type of policy for the instance group. */
    policy_type: string;
  }

  /** InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype. */
  export interface InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype extends InstanceGroupManagerPrototype {
    /** The time window in seconds to aggregate metrics prior to evaluation. */
    aggregation_window?: number;
    /** The duration of time in seconds to pause further scale actions after scaling has taken place. */
    cooldown?: number;
    /** The type of instance group manager. */
    manager_type: string;
    /** The maximum number of members in a managed instance group. */
    max_membership_count: number;
    /** The minimum number of members in a managed instance group. */
    min_membership_count?: number;
  }

  /** InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype. */
  export interface InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype extends InstanceGroupManagerPrototype {
    /** The type of instance group manager. */
    manager_type: string;
  }

  /** InstanceGroupManagerScheduled. */
  export interface InstanceGroupManagerScheduled extends InstanceGroupManager {
    /** The actions of the instance group manager. */
    actions: InstanceGroupManagerActionReference[];
    /** The type of instance group manager. */
    manager_type: string;
  }

  /** InstanceGroupManagerScheduledActionManagerAutoScale. */
  export interface InstanceGroupManagerScheduledActionManagerAutoScale extends InstanceGroupManagerScheduledActionManager {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: InstanceGroupManagerReferenceDeleted;
    /** The URL for this instance group manager. */
    href: string;
    /** The unique identifier for this instance group manager. */
    id: string;
    /** The name for this instance group manager. The name is unique across all managers for the instance group. */
    name: string;
    /** The desired maximum number of instance group members at the scheduled time. */
    max_membership_count?: number;
    /** The desired minimum number of instance group members at the scheduled time. */
    min_membership_count?: number;
  }

  /** The auto scale manager to update, and one or more properties to be updated. Either `id` or `href` must be specified, in addition to at least one of `min_membership_count` and `max_membership_count`. */
  export interface InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype extends InstanceGroupManagerScheduledActionManagerPrototype {
    /** The desired maximum number of instance group members at the scheduled time. */
    max_membership_count?: number;
    /** The desired minimum number of instance group members at the scheduled time. */
    min_membership_count?: number;
  }

  /** InstancePatchProfileInstanceProfileIdentityByHref. */
  export interface InstancePatchProfileInstanceProfileIdentityByHref extends InstancePatchProfile {
    /** The URL for this virtual server instance profile. */
    href: string;
  }

  /** InstancePatchProfileInstanceProfileIdentityByName. */
  export interface InstancePatchProfileInstanceProfileIdentityByName extends InstancePatchProfile {
    /** The globally unique name for this virtual server instance profile. */
    name: string;
  }

  /** Identifies a dedicated host group by a unique property. */
  export interface InstancePlacementTargetPatchDedicatedHostGroupIdentity extends InstancePlacementTargetPatch {
  }

  /** Identifies a dedicated host by a unique property. */
  export interface InstancePlacementTargetPatchDedicatedHostIdentity extends InstancePlacementTargetPatch {
  }

  /** Identifies a dedicated host group by a unique property. */
  export interface InstancePlacementTargetPrototypeDedicatedHostGroupIdentity extends InstancePlacementTargetPrototype {
  }

  /** Identifies a dedicated host by a unique property. */
  export interface InstancePlacementTargetPrototypeDedicatedHostIdentity extends InstancePlacementTargetPrototype {
  }

  /** Identifies a placement group by a unique property. */
  export interface InstancePlacementTargetPrototypePlacementGroupIdentity extends InstancePlacementTargetPrototype {
  }

  /** InstancePlacementTargetDedicatedHostGroupReference. */
  export interface InstancePlacementTargetDedicatedHostGroupReference extends InstancePlacementTarget {
    /** The CRN for this dedicated host group. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: DedicatedHostGroupReferenceDeleted;
    /** The URL for this dedicated host group. */
    href: string;
    /** The unique identifier for this dedicated host group. */
    id: string;
    /** The name for this dedicated host group. The name is unique across all dedicated host groups in the region. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** InstancePlacementTargetDedicatedHostReference. */
  export interface InstancePlacementTargetDedicatedHostReference extends InstancePlacementTarget {
    /** The CRN for this dedicated host. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: DedicatedHostReferenceDeleted;
    /** The URL for this dedicated host. */
    href: string;
    /** The unique identifier for this dedicated host. */
    id: string;
    /** The name for this dedicated host. The name is unique across all dedicated hosts in the region. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** InstancePlacementTargetPlacementGroupReference. */
  export interface InstancePlacementTargetPlacementGroupReference extends InstancePlacementTarget {
    /** The CRN for this placement group. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: PlacementGroupReferenceDeleted;
    /** The URL for this placement group. */
    href: string;
    /** The unique identifier for this placement group. */
    id: string;
    /** The name for this placement group. The name is unique across all placement groups in the region. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** The total bandwidth shared across the network interfaces and storage volumes of an instance with this profile depends on its configuration. */
  export interface InstanceProfileBandwidthDependent extends InstanceProfileBandwidth {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted total bandwidth values (in megabits per second) shared across the network interfaces and storage volumes of an instance with this profile. */
  export interface InstanceProfileBandwidthEnum extends InstanceProfileBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The total bandwidth (in megabits per second) shared across the network interfaces and storage volumes of an instance with this profile. */
  export interface InstanceProfileBandwidthFixed extends InstanceProfileBandwidth {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted total bandwidth range (in megabits per second) shared across the network interfaces and storage volumes of an instance with this profile. */
  export interface InstanceProfileBandwidthRange extends InstanceProfileBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The number of disks of this configuration for an instance with this profile depends on its instance configuration. */
  export interface InstanceProfileDiskQuantityDependent extends InstanceProfileDiskQuantity {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted the number of disks of this configuration for an instance with this profile. */
  export interface InstanceProfileDiskQuantityEnum extends InstanceProfileDiskQuantity {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The number of disks of this configuration for an instance with this profile. */
  export interface InstanceProfileDiskQuantityFixed extends InstanceProfileDiskQuantity {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted range for the number of disks of this configuration for an instance with this profile. */
  export interface InstanceProfileDiskQuantityRange extends InstanceProfileDiskQuantity {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The disk size in GB (gigabytes) of this configuration for an instance with this profile depends on its instance configuration. */
  export interface InstanceProfileDiskSizeDependent extends InstanceProfileDiskSize {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted disk size in GB (gigabytes) of this configuration for an instance with this profile. */
  export interface InstanceProfileDiskSizeEnum extends InstanceProfileDiskSize {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The size of the disk in GB (gigabytes). */
  export interface InstanceProfileDiskSizeFixed extends InstanceProfileDiskSize {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted range for the disk size of this configuration in GB (gigabytes) for an instance with this profile. */
  export interface InstanceProfileDiskSizeRange extends InstanceProfileDiskSize {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The GPU count for an instance with this profile depends on its configuration. */
  export interface InstanceProfileGPUDependent extends InstanceProfileGPU {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted GPU count values for an instance with this profile. */
  export interface InstanceProfileGPUEnum extends InstanceProfileGPU {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The GPU count for an instance with this profile. */
  export interface InstanceProfileGPUFixed extends InstanceProfileGPU {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The overall GPU memory value for an instance with this profile depends on its configuration. */
  export interface InstanceProfileGPUMemoryDependent extends InstanceProfileGPUMemory {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted overall GPU memory values in GiB (gibibytes) for an instance with this profile. */
  export interface InstanceProfileGPUMemoryEnum extends InstanceProfileGPUMemory {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The overall GPU memory in GiB (gibibytes) for an instance with this profile. */
  export interface InstanceProfileGPUMemoryFixed extends InstanceProfileGPUMemory {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted overall GPU memory range in GiB (gibibytes) for an instance with this profile. */
  export interface InstanceProfileGPUMemoryRange extends InstanceProfileGPUMemory {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted GPU count range for an instance with this profile. */
  export interface InstanceProfileGPURange extends InstanceProfileGPU {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** InstanceProfileIdentityByHref. */
  export interface InstanceProfileIdentityByHref extends InstanceProfileIdentity {
    /** The URL for this virtual server instance profile. */
    href: string;
  }

  /** InstanceProfileIdentityByName. */
  export interface InstanceProfileIdentityByName extends InstanceProfileIdentity {
    /** The globally unique name for this virtual server instance profile. */
    name: string;
  }

  /** The memory value for an instance with this profile depends on its configuration. */
  export interface InstanceProfileMemoryDependent extends InstanceProfileMemory {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted memory values (in gibibytes) for an instance with this profile. */
  export interface InstanceProfileMemoryEnum extends InstanceProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The memory (in gibibytes) for an instance with this profile. */
  export interface InstanceProfileMemoryFixed extends InstanceProfileMemory {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted memory range (in gibibytes) for an instance with this profile. */
  export interface InstanceProfileMemoryRange extends InstanceProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The number of network interfaces supported on an instance with this profile is dependent on its configuration. */
  export interface InstanceProfileNetworkInterfaceCountDependent extends InstanceProfileNetworkInterfaceCount {
    /** The type for this profile field. */
    type: string;
  }

  /** The number of network interfaces supported on an instance with this profile. */
  export interface InstanceProfileNetworkInterfaceCountRange extends InstanceProfileNetworkInterfaceCount {
    /** The maximum value for this profile field. */
    max?: number;
    /** The minimum value for this profile field. */
    min?: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The port speed of each network interface of an instance with this profile depends on its configuration. */
  export interface InstanceProfilePortSpeedDependent extends InstanceProfilePortSpeed {
    /** The type for this profile field. */
    type: string;
  }

  /** The maximum speed (in megabits per second) of each network interface of an instance with this profile. */
  export interface InstanceProfilePortSpeedFixed extends InstanceProfilePortSpeed {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The VCPU count for an instance with this profile depends on its configuration. */
  export interface InstanceProfileVCPUDependent extends InstanceProfileVCPU {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted values for VCPU count for an instance with this profile. */
  export interface InstanceProfileVCPUEnum extends InstanceProfileVCPU {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The VCPU count for an instance with this profile. */
  export interface InstanceProfileVCPUFixed extends InstanceProfileVCPU {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted range for VCPU count for an instance with this profile. */
  export interface InstanceProfileVCPURange extends InstanceProfileVCPU {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The storage bandwidth shared across the storage volumes of an instance with this profile depends on its configuration. */
  export interface InstanceProfileVolumeBandwidthDependent extends InstanceProfileVolumeBandwidth {
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted storage bandwidth values (in megabits per second) shared across the storage volumes of an instance with this profile. */
  export interface InstanceProfileVolumeBandwidthEnum extends InstanceProfileVolumeBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The storage bandwidth (in megabits per second) shared across the storage volumes of an instance with this profile. */
  export interface InstanceProfileVolumeBandwidthFixed extends InstanceProfileVolumeBandwidth {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted storage bandwidth range (in megabits per second) shared across the storage volumes of an instance with this profile. */
  export interface InstanceProfileVolumeBandwidthRange extends InstanceProfileVolumeBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** Create an instance by using a catalog offering. */
  export interface InstancePrototypeInstanceByCatalogOffering extends InstancePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering
     *  or offering version to use when provisioning this virtual server instance.
     *
     *  If an offering is specified, the latest version of that offering will be used.
     *
     *  The specified offering or offering version may be in a different account in the same
     *  [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise), subject
     *  to IAM policies.
     */
    catalog_offering: InstanceCatalogOfferingPrototype;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }

  /** Create an instance by using an image. */
  export interface InstancePrototypeInstanceByImage extends InstancePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The image to use when provisioning the virtual server instance. */
    image: ImageIdentity;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }

  /** Create an instance by using a snapshot. */
  export interface InstancePrototypeInstanceBySourceSnapshot extends InstancePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment: VolumeAttachmentPrototypeInstanceBySourceSnapshotContext;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }

  /** Create an instance by using an instance template. The `primary_network_interface` and `network_interfaces` properties may only be specified if `primary_network_interface` is specified in the source template. */
  export interface InstancePrototypeInstanceBySourceTemplate extends InstancePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering version to use when provisioning this virtual server instance.
     *  If an offering is specified, the latest version of that offering will be used.
     *
     *  The specified offering or offering version may be in a different account, subject to
     *  IAM policies.
     *
     *  If specified, `image` must not be specified, and `source_template` must not have
     *  `image` specified.
     */
    catalog_offering?: InstanceCatalogOfferingPrototype;
    /** The image to use when provisioning the virtual server instance. */
    image?: ImageIdentity;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface?: NetworkInterfacePrototype;
    /** The template to create this virtual server instance from. */
    source_template: InstanceTemplateIdentity;
    /** The zone this virtual server instance will reside in. */
    zone?: ZoneIdentity;
  }

  /** Create an instance by using a boot volume. */
  export interface InstancePrototypeInstanceByVolume extends InstancePrototype {
    /** The boot volume attachment for the virtual server instance. */
    boot_volume_attachment: VolumeAttachmentPrototypeInstanceByVolumeContext;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }

  /** InstanceTemplateIdentityByCRN. */
  export interface InstanceTemplateIdentityByCRN extends InstanceTemplateIdentity {
    /** The CRN for this instance template. */
    crn: string;
  }

  /** InstanceTemplateIdentityByHref. */
  export interface InstanceTemplateIdentityByHref extends InstanceTemplateIdentity {
    /** The URL for this instance template. */
    href: string;
  }

  /** InstanceTemplateIdentityById. */
  export interface InstanceTemplateIdentityById extends InstanceTemplateIdentity {
    /** The unique identifier for this instance template. */
    id: string;
  }

  /** Create an instance template that creates instances by using a catalog offering. */
  export interface InstanceTemplatePrototypeInstanceTemplateByCatalogOffering extends InstanceTemplatePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering
     *  or offering version to use when provisioning this virtual server instance.
     *
     *  If an offering is specified, the latest version of that offering will be used.
     *
     *  The specified offering or offering version may be in a different account in the same
     *  [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise), subject
     *  to IAM policies.
     */
    catalog_offering: InstanceCatalogOfferingPrototype;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }

  /** Create an instance template that creates instances by using an image. */
  export interface InstanceTemplatePrototypeInstanceTemplateByImage extends InstanceTemplatePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The image to use when provisioning the virtual server instance. */
    image: ImageIdentity;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }

  /** Create an instance template that creates instances by using a snapshot. */
  export interface InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot extends InstanceTemplatePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment: VolumeAttachmentPrototypeInstanceBySourceSnapshotContext;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }

  /** Create an instance template from an existing instance template. */
  export interface InstanceTemplatePrototypeInstanceTemplateBySourceTemplate extends InstanceTemplatePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering version to use when provisioning this virtual server instance.
     *  If an offering is specified, the latest version of that offering will be used.
     *
     *  The specified offering or offering version may be in a different account, subject to
     *  IAM policies.
     *
     *  If specified, `image` must not be specified, and `source_template` must not have
     *  `image` specified.
     */
    catalog_offering?: InstanceCatalogOfferingPrototype;
    /** The image to use when provisioning the virtual server instance. */
    image?: ImageIdentity;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface?: NetworkInterfacePrototype;
    /** The template to create this virtual server instance from. */
    source_template: InstanceTemplateIdentity;
    /** The zone this virtual server instance will reside in. */
    zone?: ZoneIdentity;
  }

  /** Create an instance by using a catalog offering. */
  export interface InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext extends InstanceTemplate {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering
     *  or offering version to use when provisioning this virtual server instance.
     *
     *  If an offering is specified, the latest version of that offering will be used.
     *
     *  The specified offering or offering version may be in a different account in the same
     *  [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise), subject
     *  to IAM policies.
     */
    catalog_offering: InstanceCatalogOfferingPrototype;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface?: NetworkInterfacePrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }

  /** Create an instance by using an image. */
  export interface InstanceTemplateInstanceByImageInstanceTemplateContext extends InstanceTemplate {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The image to use when provisioning the virtual server instance. */
    image: ImageIdentity;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface?: NetworkInterfacePrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }

  /** Create an instance by using a snapshot. */
  export interface InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext extends InstanceTemplate {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment: VolumeAttachmentPrototypeInstanceBySourceSnapshotContext;
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface?: NetworkInterfacePrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }

  /** KeyIdentityByCRN. */
  export interface KeyIdentityByCRN extends KeyIdentity {
    /** The CRN for this key. */
    crn: string;
  }

  /** KeyIdentityByFingerprint. */
  export interface KeyIdentityByFingerprint extends KeyIdentity {
    /** The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm
     *  (always `SHA256`).
     */
    fingerprint: string;
  }

  /** KeyIdentityByHref. */
  export interface KeyIdentityByHref extends KeyIdentity {
    /** The URL for this key. */
    href: string;
  }

  /** KeyIdentityById. */
  export interface KeyIdentityById extends KeyIdentity {
    /** The unique identifier for this key. */
    id: string;
  }

  /** LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName. */
  export interface LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName extends LegacyCloudObjectStorageBucketIdentity {
    /** The globally unique name of this Cloud Object Storage bucket. */
    name: string;
  }

  /** LoadBalancerIdentityByCRN. */
  export interface LoadBalancerIdentityByCRN extends LoadBalancerIdentity {
    /** The load balancer's CRN. */
    crn: string;
  }

  /** LoadBalancerIdentityByHref. */
  export interface LoadBalancerIdentityByHref extends LoadBalancerIdentity {
    /** The load balancer's canonical URL. */
    href: string;
  }

  /** LoadBalancerIdentityById. */
  export interface LoadBalancerIdentityById extends LoadBalancerIdentity {
    /** The unique identifier for this load balancer. */
    id: string;
  }

  /** LoadBalancerListenerIdentityByHref. */
  export interface LoadBalancerListenerIdentityByHref extends LoadBalancerListenerIdentity {
    /** The listener's canonical URL. */
    href: string;
  }

  /** LoadBalancerListenerIdentityById. */
  export interface LoadBalancerListenerIdentityById extends LoadBalancerListenerIdentity {
    /** The unique identifier for this load balancer listener. */
    id: string;
  }

  /** LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerHTTPSRedirectPatch. */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerHTTPSRedirectPatch extends LoadBalancerListenerPolicyTargetPatch {
    /** The HTTP status code for this redirect. */
    http_status_code?: number;
    /** Identifies a load balancer listener by a unique property. */
    listener?: LoadBalancerListenerIdentity;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /** LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch. */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch extends LoadBalancerListenerPolicyTargetPatch {
    /** The HTTP status code for this redirect. */
    http_status_code?: number;
    /** The redirect target URL. */
    url?: string;
  }

  /** Identifies a load balancer pool by a unique property. */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity extends LoadBalancerListenerPolicyTargetPatch {
  }

  /** LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype. */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype extends LoadBalancerListenerPolicyTargetPrototype {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    /** Identifies a load balancer listener by a unique property. */
    listener: LoadBalancerListenerIdentity;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /** LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype. */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype extends LoadBalancerListenerPolicyTargetPrototype {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    /** The redirect target URL. */
    url: string;
  }

  /** Identifies a load balancer pool by a unique property. */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity extends LoadBalancerListenerPolicyTargetPrototype {
  }

  /** LoadBalancerListenerPolicyTargetLoadBalancerListenerHTTPSRedirect. */
  export interface LoadBalancerListenerPolicyTargetLoadBalancerListenerHTTPSRedirect extends LoadBalancerListenerPolicyTarget {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    listener: LoadBalancerListenerReference;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /** LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL. */
  export interface LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL extends LoadBalancerListenerPolicyTarget {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    /** The redirect target URL. */
    url: string;
  }

  /** LoadBalancerListenerPolicyTargetLoadBalancerPoolReference. */
  export interface LoadBalancerListenerPolicyTargetLoadBalancerPoolReference extends LoadBalancerListenerPolicyTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: LoadBalancerPoolReferenceDeleted;
    /** The pool's canonical URL. */
    href: string;
    /** The unique identifier for this load balancer pool. */
    id: string;
    /** The name for this load balancer pool. The name is unique across all pools for the load balancer. */
    name: string;
  }

  /** LoadBalancerPoolIdentityByHref. */
  export interface LoadBalancerPoolIdentityByHref extends LoadBalancerPoolIdentity {
    /** The pool's canonical URL. */
    href: string;
  }

  /** LoadBalancerPoolIdentityById. */
  export interface LoadBalancerPoolIdentityById extends LoadBalancerPoolIdentity {
    /** The unique identifier for this load balancer pool. */
    id: string;
  }

  /** LoadBalancerPoolMemberTargetPrototypeIP. */
  export interface LoadBalancerPoolMemberTargetPrototypeIP extends LoadBalancerPoolMemberTargetPrototype {
    /** The IP address.
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
  }

  /** Identifies a virtual server instance by a unique property. */
  export interface LoadBalancerPoolMemberTargetPrototypeInstanceIdentity extends LoadBalancerPoolMemberTargetPrototype {
  }

  /** LoadBalancerPoolMemberTargetIP. */
  export interface LoadBalancerPoolMemberTargetIP extends LoadBalancerPoolMemberTarget {
    /** The IP address.
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
  }

  /** LoadBalancerPoolMemberTargetInstanceReference. */
  export interface LoadBalancerPoolMemberTargetInstanceReference extends LoadBalancerPoolMemberTarget {
    /** The CRN for this virtual server instance. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: InstanceReferenceDeleted;
    /** The URL for this virtual server instance. */
    href: string;
    /** The unique identifier for this virtual server instance. */
    id: string;
    /** The name for this virtual server instance. The name is unique across all virtual server instances in the
     *  region.
     */
    name: string;
  }

  /** LoadBalancerProfileIdentityByHref. */
  export interface LoadBalancerProfileIdentityByHref extends LoadBalancerProfileIdentity {
    /** The URL for this load balancer profile. */
    href: string;
  }

  /** LoadBalancerProfileIdentityByName. */
  export interface LoadBalancerProfileIdentityByName extends LoadBalancerProfileIdentity {
    /** The globally unique name for this load balancer profile. */
    name: string;
  }

  /** The instance groups support for a load balancer with this profile depends on its configuration. */
  export interface LoadBalancerProfileInstanceGroupsSupportedDependent extends LoadBalancerProfileInstanceGroupsSupported {
    /** The type for this profile field. */
    type: string;
  }

  /** The instance groups support for a load balancer with this profile. */
  export interface LoadBalancerProfileInstanceGroupsSupportedFixed extends LoadBalancerProfileInstanceGroupsSupported {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: boolean;
  }

  /** The route mode support for a load balancer with this profile depends on its configuration. */
  export interface LoadBalancerProfileRouteModeSupportedDependent extends LoadBalancerProfileRouteModeSupported {
    /** The type for this profile field. */
    type: string;
  }

  /** The route mode support for a load balancer with this profile. */
  export interface LoadBalancerProfileRouteModeSupportedFixed extends LoadBalancerProfileRouteModeSupported {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: boolean;
  }

  /** The security group support for a load balancer with this profile depends on its configuration. */
  export interface LoadBalancerProfileSecurityGroupsSupportedDependent extends LoadBalancerProfileSecurityGroupsSupported {
    /** The type for this profile field. */
    type: string;
  }

  /** The security group support for a load balancer with this profile. */
  export interface LoadBalancerProfileSecurityGroupsSupportedFixed extends LoadBalancerProfileSecurityGroupsSupported {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: boolean;
  }

  /** The UDP support for a load balancer with this profile depends on its configuration. */
  export interface LoadBalancerProfileUDPSupportedDependent extends LoadBalancerProfileUDPSupported {
    /** The type for this profile field. */
    type: string;
  }

  /** The UDP support for a load balancer with this profile. */
  export interface LoadBalancerProfileUDPSupportedFixed extends LoadBalancerProfileUDPSupported {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: boolean;
  }

  /** NetworkACLIdentityByCRN. */
  export interface NetworkACLIdentityByCRN extends NetworkACLIdentity {
    /** The CRN for this network ACL. */
    crn: string;
  }

  /** NetworkACLIdentityByHref. */
  export interface NetworkACLIdentityByHref extends NetworkACLIdentity {
    /** The URL for this network ACL. */
    href: string;
  }

  /** NetworkACLIdentityById. */
  export interface NetworkACLIdentityById extends NetworkACLIdentity {
    /** The unique identifier for this network ACL. */
    id: string;
  }

  /** NetworkACLPrototypeNetworkACLByRules. */
  export interface NetworkACLPrototypeNetworkACLByRules extends NetworkACLPrototype {
    /** The prototype objects for rules to create along with this network ACL. If unspecified, no rules will be
     *  created, resulting in all traffic being denied.
     */
    rules?: NetworkACLRulePrototypeNetworkACLContext[];
  }

  /** NetworkACLPrototypeNetworkACLBySourceNetworkACL. */
  export interface NetworkACLPrototypeNetworkACLBySourceNetworkACL extends NetworkACLPrototype {
    /** Network ACL to copy rules from. */
    source_network_acl: NetworkACLIdentity;
  }

  /** NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref. */
  export interface NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref extends NetworkACLRuleBeforePatch {
    /** The URL for this network ACL rule. */
    href: string;
  }

  /** NetworkACLRuleBeforePatchNetworkACLRuleIdentityById. */
  export interface NetworkACLRuleBeforePatchNetworkACLRuleIdentityById extends NetworkACLRuleBeforePatch {
    /** The unique identifier for this network ACL rule. */
    id: string;
  }

  /** NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref. */
  export interface NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref extends NetworkACLRuleBeforePrototype {
    /** The URL for this network ACL rule. */
    href: string;
  }

  /** NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityById. */
  export interface NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityById extends NetworkACLRuleBeforePrototype {
    /** The unique identifier for this network ACL rule. */
    id: string;
  }

  /** NetworkACLRuleItemNetworkACLRuleProtocolAll. */
  export interface NetworkACLRuleItemNetworkACLRuleProtocolAll extends NetworkACLRuleItem {
    /** The protocol to enforce. */
    protocol: string;
  }

  /** NetworkACLRuleItemNetworkACLRuleProtocolICMP. */
  export interface NetworkACLRuleItemNetworkACLRuleProtocolICMP extends NetworkACLRuleItem {
    /** The ICMP traffic code to match.
     *
     *  If absent, all codes are matched.
     */
    code?: number;
    /** The protocol to enforce. */
    protocol: string;
    /** The ICMP traffic type to match.
     *
     *  If absent, all types are matched.
     */
    type?: number;
  }

  /** NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP. */
  export interface NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP extends NetworkACLRuleItem {
    /** The inclusive upper bound of TCP/UDP destination port range. */
    destination_port_max: number;
    /** The inclusive lower bound of TCP/UDP destination port range. */
    destination_port_min: number;
    /** The protocol to enforce. */
    protocol: string;
    /** The inclusive upper bound of TCP/UDP source port range. */
    source_port_max: number;
    /** The inclusive lower bound of TCP/UDP source port range. */
    source_port_min: number;
  }

  /** NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype. */
  export interface NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype extends NetworkACLRulePrototypeNetworkACLContext {
    /** The protocol to enforce. */
    protocol: string;
  }

  /** NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPPrototype. */
  export interface NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPPrototype extends NetworkACLRulePrototypeNetworkACLContext {
    /** The ICMP traffic code to match.
     *
     *  If specified, `type` must also be specified.  If unspecified, all codes are matched.
     */
    code?: number;
    /** The protocol to enforce. */
    protocol: string;
    /** The ICMP traffic type to match.
     *
     *  If unspecified, all types are matched.
     */
    type?: number;
  }

  /** NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPPrototype. */
  export interface NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPPrototype extends NetworkACLRulePrototypeNetworkACLContext {
    /** The inclusive upper bound of TCP/UDP destination port range. */
    destination_port_max?: number;
    /** The inclusive lower bound of TCP/UDP destination port range. */
    destination_port_min?: number;
    /** The protocol to enforce. */
    protocol: string;
    /** The inclusive upper bound of TCP/UDP source port range. */
    source_port_max?: number;
    /** The inclusive lower bound of TCP/UDP source port range. */
    source_port_min?: number;
  }

  /** NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype. */
  export interface NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype extends NetworkACLRulePrototype {
    /** The protocol to enforce. */
    protocol: string;
  }

  /** NetworkACLRulePrototypeNetworkACLRuleProtocolICMPPrototype. */
  export interface NetworkACLRulePrototypeNetworkACLRuleProtocolICMPPrototype extends NetworkACLRulePrototype {
    /** The ICMP traffic code to match.
     *
     *  If specified, `type` must also be specified.  If unspecified, all codes are matched.
     */
    code?: number;
    /** The protocol to enforce. */
    protocol: string;
    /** The ICMP traffic type to match.
     *
     *  If unspecified, all types are matched.
     */
    type?: number;
  }

  /** NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPPrototype. */
  export interface NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPPrototype extends NetworkACLRulePrototype {
    /** The inclusive upper bound of TCP/UDP destination port range. */
    destination_port_max?: number;
    /** The inclusive lower bound of TCP/UDP destination port range. */
    destination_port_min?: number;
    /** The protocol to enforce. */
    protocol: string;
    /** The inclusive upper bound of TCP/UDP source port range. */
    source_port_max?: number;
    /** The inclusive lower bound of TCP/UDP source port range. */
    source_port_min?: number;
  }

  /** NetworkACLRuleNetworkACLRuleProtocolAll. */
  export interface NetworkACLRuleNetworkACLRuleProtocolAll extends NetworkACLRule {
    /** The protocol to enforce. */
    protocol: string;
  }

  /** NetworkACLRuleNetworkACLRuleProtocolICMP. */
  export interface NetworkACLRuleNetworkACLRuleProtocolICMP extends NetworkACLRule {
    /** The ICMP traffic code to match.
     *
     *  If absent, all codes are matched.
     */
    code?: number;
    /** The protocol to enforce. */
    protocol: string;
    /** The ICMP traffic type to match.
     *
     *  If absent, all types are matched.
     */
    type?: number;
  }

  /** NetworkACLRuleNetworkACLRuleProtocolTCPUDP. */
  export interface NetworkACLRuleNetworkACLRuleProtocolTCPUDP extends NetworkACLRule {
    /** The inclusive upper bound of TCP/UDP destination port range. */
    destination_port_max: number;
    /** The inclusive lower bound of TCP/UDP destination port range. */
    destination_port_min: number;
    /** The protocol to enforce. */
    protocol: string;
    /** The inclusive upper bound of TCP/UDP source port range. */
    source_port_max: number;
    /** The inclusive lower bound of TCP/UDP source port range. */
    source_port_min: number;
  }

  /** Identifies a reserved IP by a unique property. */
  export interface NetworkInterfaceIPPrototypeReservedIPIdentity extends NetworkInterfaceIPPrototype {
  }

  /** NetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext. */
  export interface NetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext extends NetworkInterfaceIPPrototype {
    /** The IP address to reserve, which must not already be reserved on the subnet.
     *
     *  If unspecified, an available address on the subnet will automatically be selected.
     */
    address?: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound.
     */
    auto_delete?: boolean;
    /** The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /** OperatingSystemIdentityByHref. */
  export interface OperatingSystemIdentityByHref extends OperatingSystemIdentity {
    /** The URL for this operating system. */
    href: string;
  }

  /** OperatingSystemIdentityByName. */
  export interface OperatingSystemIdentityByName extends OperatingSystemIdentity {
    /** The globally unique name for this operating system. */
    name: string;
  }

  /** Identifies a floating IP by a unique property. */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPIdentity extends PublicGatewayFloatingIPPrototype {
  }

  /** PublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext. */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext extends PublicGatewayFloatingIPPrototype {
    /** The name for this floating IP. The name must not be used by another floating IP in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
  }

  /** PublicGatewayIdentityPublicGatewayIdentityByCRN. */
  export interface PublicGatewayIdentityPublicGatewayIdentityByCRN extends PublicGatewayIdentity {
    /** The CRN for this public gateway. */
    crn: string;
  }

  /** PublicGatewayIdentityPublicGatewayIdentityByHref. */
  export interface PublicGatewayIdentityPublicGatewayIdentityByHref extends PublicGatewayIdentity {
    /** The URL for this public gateway. */
    href: string;
  }

  /** PublicGatewayIdentityPublicGatewayIdentityById. */
  export interface PublicGatewayIdentityPublicGatewayIdentityById extends PublicGatewayIdentity {
    /** The unique identifier for this public gateway. */
    id: string;
  }

  /** RegionIdentityByHref. */
  export interface RegionIdentityByHref extends RegionIdentity {
    /** The URL for this region. */
    href: string;
  }

  /** RegionIdentityByName. */
  export interface RegionIdentityByName extends RegionIdentity {
    /** The globally unique name for this region. */
    name: string;
  }

  /** ReservedIPTargetPrototypeEndpointGatewayIdentity. */
  export interface ReservedIPTargetPrototypeEndpointGatewayIdentity extends ReservedIPTargetPrototype {
  }

  /** ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext. */
  export interface ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext extends ReservedIPTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: BareMetalServerNetworkInterfaceReferenceTargetContextDeleted;
    /** The URL for this bare metal server network interface. */
    href: string;
    /** The unique identifier for this bare metal server network interface. */
    id: string;
    /** The name for this bare metal server network interface. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** ReservedIPTargetEndpointGatewayReference. */
  export interface ReservedIPTargetEndpointGatewayReference extends ReservedIPTarget {
    /** The CRN for this endpoint gateway. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: EndpointGatewayReferenceDeleted;
    /** The URL for this endpoint gateway. */
    href: string;
    /** The unique identifier for this endpoint gateway. */
    id: string;
    /** The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** Identifying information for a resource that is not native to the VPC API. */
  export interface ReservedIPTargetGenericResourceReference extends ReservedIPTarget {
    /** The CRN for the resource. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: GenericResourceReferenceDeleted;
    /** The resource type. */
    resource_type: string;
  }

  /** ReservedIPTargetLoadBalancerReference. */
  export interface ReservedIPTargetLoadBalancerReference extends ReservedIPTarget {
    /** The load balancer's CRN. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: LoadBalancerReferenceDeleted;
    /** The load balancer's canonical URL. */
    href: string;
    /** The unique identifier for this load balancer. */
    id: string;
    /** The name for this load balancer. The name is unique across all load balancers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** ReservedIPTargetNetworkInterfaceReferenceTargetContext. */
  export interface ReservedIPTargetNetworkInterfaceReferenceTargetContext extends ReservedIPTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: NetworkInterfaceReferenceTargetContextDeleted;
    /** The URL for this instance network interface. */
    href: string;
    /** The unique identifier for this instance network interface. */
    id: string;
    /** The name for this instance network interface. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** ReservedIPTargetVPNGatewayReference. */
  export interface ReservedIPTargetVPNGatewayReference extends ReservedIPTarget {
    /** The VPN gateway's CRN. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VPNGatewayReferenceDeleted;
    /** The VPN gateway's canonical URL. */
    href: string;
    /** The unique identifier for this VPN gateway. */
    id: string;
    /** The name for this VPN gateway. The name is unique across all VPN gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** ReservedIPTargetVPNServerReference. */
  export interface ReservedIPTargetVPNServerReference extends ReservedIPTarget {
    /** The CRN for this VPN server. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VPNServerReferenceDeleted;
    /** The URL for this VPN server. */
    href: string;
    /** The unique identifier for this VPN server. */
    id: string;
    /** The name for this VPN server. The name is unique across all VPN servers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext. */
  export interface ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext extends ReservedIPTarget {
    /** The CRN for this virtual network interface. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VirtualNetworkInterfaceReferenceReservedIPTargetContextDeleted;
    /** The URL for this virtual network interface. */
    href: string;
    /** The unique identifier for this virtual network interface. */
    id: string;
    /** The name for this virtual network interface. The name is unique across all virtual network interfaces in the
     *  VPC.
     */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** ResourceGroupIdentityById. */
  export interface ResourceGroupIdentityById extends ResourceGroupIdentity {
    /** The unique identifier for this resource group. */
    id: string;
  }

  /** RouteCreatorVPNGatewayReference. */
  export interface RouteCreatorVPNGatewayReference extends RouteCreator {
    /** The VPN gateway's CRN. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VPNGatewayReferenceDeleted;
    /** The VPN gateway's canonical URL. */
    href: string;
    /** The unique identifier for this VPN gateway. */
    id: string;
    /** The name for this VPN gateway. The name is unique across all VPN gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** RouteCreatorVPNServerReference. */
  export interface RouteCreatorVPNServerReference extends RouteCreator {
    /** The CRN for this VPN server. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VPNServerReferenceDeleted;
    /** The URL for this VPN server. */
    href: string;
    /** The unique identifier for this VPN server. */
    id: string;
    /** The name for this VPN server. The name is unique across all VPN servers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** RouteNextHopIP. */
  export interface RouteNextHopIP extends RouteNextHop {
    /** The IP address.
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
  }

  /** RouteNextHopPatchRouteNextHopIP. */
  export interface RouteNextHopPatchRouteNextHopIP extends RouteNextHopPatch {
  }

  /** Identifies a VPN gateway connection by a unique property. */
  export interface RouteNextHopPatchVPNGatewayConnectionIdentity extends RouteNextHopPatch {
  }

  /** RouteNextHopVPNGatewayConnectionReference. */
  export interface RouteNextHopVPNGatewayConnectionReference extends RouteNextHop {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VPNGatewayConnectionReferenceDeleted;
    /** The VPN connection's canonical URL. */
    href: string;
    /** The unique identifier for this VPN gateway connection. */
    id: string;
    /** The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP. */
  export interface RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP extends RoutePrototypeNextHop {
  }

  /** Identifies a VPN gateway connection by a unique property. */
  export interface RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity extends RoutePrototypeNextHop {
  }

  /** RoutingTableIdentityByHref. */
  export interface RoutingTableIdentityByHref extends RoutingTableIdentity {
    /** The URL for this routing table. */
    href: string;
  }

  /** RoutingTableIdentityById. */
  export interface RoutingTableIdentityById extends RoutingTableIdentity {
    /** The unique identifier for this routing table. */
    id: string;
  }

  /** SecurityGroupIdentityByCRN. */
  export interface SecurityGroupIdentityByCRN extends SecurityGroupIdentity {
    /** The security group's CRN. */
    crn: string;
  }

  /** SecurityGroupIdentityByHref. */
  export interface SecurityGroupIdentityByHref extends SecurityGroupIdentity {
    /** The security group's canonical URL. */
    href: string;
  }

  /** SecurityGroupIdentityById. */
  export interface SecurityGroupIdentityById extends SecurityGroupIdentity {
    /** The unique identifier for this security group. */
    id: string;
  }

  /** A rule allowing traffic for all supported protocols. */
  export interface SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll extends SecurityGroupRulePrototype {
    /** The direction of traffic to enforce. */
    direction: string;
    /** The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property,
     *  if they are used. Alternatively, if `remote` references a security group, then this rule only applies to IP
     *  addresses (network interfaces) in that group matching this IP version.
     */
    ip_version?: string;
    /** The protocol to enforce. */
    protocol: string;
    /** The remote IP addresses or security groups from which this rule will allow traffic (or to
     *  which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
     *  security group within the VPC.
     *
     *  If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source
     *  (or to any destination, for outbound rules).
     */
    remote?: SecurityGroupRuleRemotePrototype;
  }

  /** A rule specifying the ICMP traffic to allow. */
  export interface SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP extends SecurityGroupRulePrototype {
    /** The ICMP traffic code to allow.
     *
     *  If specified, `type` must also be specified.  If unspecified, all codes are allowed.
     */
    code?: number;
    /** The direction of traffic to enforce. */
    direction: string;
    /** The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property,
     *  if they are used. Alternatively, if `remote` references a security group, then this rule only applies to IP
     *  addresses (network interfaces) in that group matching this IP version.
     */
    ip_version?: string;
    /** The protocol to enforce. */
    protocol: string;
    /** The remote IP addresses or security groups from which this rule will allow traffic (or to
     *  which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
     *  security group within the VPC.
     *
     *  If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source
     *  (or to any destination, for outbound rules).
     */
    remote?: SecurityGroupRuleRemotePrototype;
    /** The ICMP traffic type to allow.
     *
     *  If unspecified, all types are allowed.
     */
    type?: number;
  }

  /** A rule specifying the TCP or UDP traffic to allow. Either both `port_min` and `port_max` will be present, or neither. When neither is present, all destination ports are allowed for the protocol. When both have the same value, that single destination port is allowed. */
  export interface SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP extends SecurityGroupRulePrototype {
    /** The direction of traffic to enforce. */
    direction: string;
    /** The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property,
     *  if they are used. Alternatively, if `remote` references a security group, then this rule only applies to IP
     *  addresses (network interfaces) in that group matching this IP version.
     */
    ip_version?: string;
    /** The inclusive upper bound of TCP/UDP destination port range.
     *
     *  If specified, `port_min` must also be specified, and must not be larger. If unspecified,
     *  `port_min` must also be unspecified, allowing traffic on all destination ports.
     */
    port_max?: number;
    /** The inclusive lower bound of TCP/UDP destination port range
     *
     *  If specified, `port_max` must also be specified, and must not be smaller. If unspecified, `port_max` must also
     *  be unspecified, allowing traffic on all destination ports.
     */
    port_min?: number;
    /** The protocol to enforce. */
    protocol: string;
    /** The remote IP addresses or security groups from which this rule will allow traffic (or to
     *  which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
     *  security group within the VPC.
     *
     *  If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source
     *  (or to any destination, for outbound rules).
     */
    remote?: SecurityGroupRuleRemotePrototype;
  }

  /** SecurityGroupRuleRemotePatchCIDR. */
  export interface SecurityGroupRuleRemotePatchCIDR extends SecurityGroupRuleRemotePatch {
    /** The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in
     *  this property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
     *  processing and surface the error, or bypass the resource on which the unexpected CIDR block format was
     *  encountered.
     */
    cidr_block: string;
  }

  /** SecurityGroupRuleRemotePatchIP. */
  export interface SecurityGroupRuleRemotePatchIP extends SecurityGroupRuleRemotePatch {
    /** The IP address.
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
  }

  /** Identifies a security group by a unique property. */
  export interface SecurityGroupRuleRemotePatchSecurityGroupIdentity extends SecurityGroupRuleRemotePatch {
  }

  /** SecurityGroupRuleRemotePrototypeCIDR. */
  export interface SecurityGroupRuleRemotePrototypeCIDR extends SecurityGroupRuleRemotePrototype {
    /** The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in
     *  this property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
     *  processing and surface the error, or bypass the resource on which the unexpected CIDR block format was
     *  encountered.
     */
    cidr_block: string;
  }

  /** SecurityGroupRuleRemotePrototypeIP. */
  export interface SecurityGroupRuleRemotePrototypeIP extends SecurityGroupRuleRemotePrototype {
    /** The IP address.
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
  }

  /** Identifies a security group by a unique property. */
  export interface SecurityGroupRuleRemotePrototypeSecurityGroupIdentity extends SecurityGroupRuleRemotePrototype {
  }

  /** SecurityGroupRuleRemoteCIDR. */
  export interface SecurityGroupRuleRemoteCIDR extends SecurityGroupRuleRemote {
    /** The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in
     *  this property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
     *  processing and surface the error, or bypass the resource on which the unexpected CIDR block format was
     *  encountered.
     */
    cidr_block: string;
  }

  /** SecurityGroupRuleRemoteIP. */
  export interface SecurityGroupRuleRemoteIP extends SecurityGroupRuleRemote {
    /** The IP address.
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
  }

  /** SecurityGroupRuleRemoteSecurityGroupReference. */
  export interface SecurityGroupRuleRemoteSecurityGroupReference extends SecurityGroupRuleRemote {
    /** The security group's CRN. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: SecurityGroupReferenceDeleted;
    /** The security group's canonical URL. */
    href: string;
    /** The unique identifier for this security group. */
    id: string;
    /** The name for this security group. The name is unique across all security groups for the VPC. */
    name: string;
  }

  /** A rule allowing traffic for all supported protocols. */
  export interface SecurityGroupRuleSecurityGroupRuleProtocolAll extends SecurityGroupRule {
    /** The protocol to enforce. */
    protocol: string;
  }

  /** A rule specifying the ICMP traffic to allow. */
  export interface SecurityGroupRuleSecurityGroupRuleProtocolICMP extends SecurityGroupRule {
    /** The ICMP traffic code to allow. If absent, all codes are allowed. */
    code?: number;
    /** The protocol to enforce. */
    protocol: string;
    /** The ICMP traffic type to allow. If absent, all types are allowed. */
    type?: number;
  }

  /** A rule specifying the TCP or UDP traffic to allow. Either both `port_min` and `port_max` will be present, or neither. When neither is present, all destination ports are allowed for the protocol. When both have the same value, that single destination port is allowed. */
  export interface SecurityGroupRuleSecurityGroupRuleProtocolTCPUDP extends SecurityGroupRule {
    /** The inclusive upper bound of TCP/UDP destination port range. */
    port_max?: number;
    /** The inclusive lower bound of TCP/UDP destination port range. */
    port_min?: number;
    /** The protocol to enforce. */
    protocol: string;
  }

  /** SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext. */
  export interface SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext extends SecurityGroupTargetReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: BareMetalServerNetworkInterfaceReferenceTargetContextDeleted;
    /** The URL for this bare metal server network interface. */
    href: string;
    /** The unique identifier for this bare metal server network interface. */
    id: string;
    /** The name for this bare metal server network interface. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** SecurityGroupTargetReferenceEndpointGatewayReference. */
  export interface SecurityGroupTargetReferenceEndpointGatewayReference extends SecurityGroupTargetReference {
    /** The CRN for this endpoint gateway. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: EndpointGatewayReferenceDeleted;
    /** The URL for this endpoint gateway. */
    href: string;
    /** The unique identifier for this endpoint gateway. */
    id: string;
    /** The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** SecurityGroupTargetReferenceLoadBalancerReference. */
  export interface SecurityGroupTargetReferenceLoadBalancerReference extends SecurityGroupTargetReference {
    /** The load balancer's CRN. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: LoadBalancerReferenceDeleted;
    /** The load balancer's canonical URL. */
    href: string;
    /** The unique identifier for this load balancer. */
    id: string;
    /** The name for this load balancer. The name is unique across all load balancers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext. */
  export interface SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext extends SecurityGroupTargetReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: NetworkInterfaceReferenceTargetContextDeleted;
    /** The URL for this instance network interface. */
    href: string;
    /** The unique identifier for this instance network interface. */
    id: string;
    /** The name for this instance network interface. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** SecurityGroupTargetReferenceVPNServerReference. */
  export interface SecurityGroupTargetReferenceVPNServerReference extends SecurityGroupTargetReference {
    /** The CRN for this VPN server. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VPNServerReferenceDeleted;
    /** The URL for this VPN server. */
    href: string;
    /** The unique identifier for this VPN server. */
    id: string;
    /** The name for this VPN server. The name is unique across all VPN servers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** SecurityGroupTargetReferenceVirtualNetworkInterfaceReference. */
  export interface SecurityGroupTargetReferenceVirtualNetworkInterfaceReference extends SecurityGroupTargetReference {
    /** The CRN for this virtual network interface. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: VirtualNetworkInterfaceReferenceDeleted;
    /** The URL for this virtual network interface. */
    href: string;
    /** The unique identifier for this virtual network interface. */
    id: string;
    /** The name for this virtual network interface. The name is unique across all virtual network interfaces in the
     *  VPC.
     */
    name: string;
    /** The primary IP for this virtual network interface. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: string;
    /** The associated subnet. */
    subnet: SubnetReference;
  }

  /** ShareIdentityByCRN. */
  export interface ShareIdentityByCRN extends ShareIdentity {
    /** The CRN for this file share. */
    crn: string;
  }

  /** ShareIdentityByHref. */
  export interface ShareIdentityByHref extends ShareIdentity {
    /** The URL for this file share. */
    href: string;
  }

  /** ShareIdentityById. */
  export interface ShareIdentityById extends ShareIdentity {
    /** The unique identifier for this file share. */
    id: string;
  }

  /** The virtual network interface for this share mount target.  The virtual network interface's VPC must not be used by a virtual network interface for another mount target for this share. Required if the share's `access_control_mode` is `security_group`. */
  export interface ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup extends ShareMountTargetPrototype {
    virtual_network_interface: ShareMountTargetVirtualNetworkInterfacePrototype;
  }

  /** The VPC in which clients can mount the file share using this mount target.  The VPC must not be used by another mount target for this share. Required if the share's `access_control_mode` is `vpc`. */
  export interface ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC extends ShareMountTargetPrototype {
    /** Identifies a VPC by a unique property. */
    vpc: VPCIdentity;
  }

  /** The virtual network interface for this target. */
  export interface ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext extends ShareMountTargetVirtualNetworkInterfacePrototype {
    /** The name for this virtual network interface. The name must not be used by another virtual network interface
     *  in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words. Names beginning with
     *  `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
    /** The primary IP address to bind to the virtual network interface. May be either a
     *  reserved IP identity, or a reserved IP prototype object which will be used to create a
     *  new reserved IP.
     *
     *  If a reserved IP identity is provided, the specified reserved IP must be unbound.
     *
     *  If a reserved IP prototype object with an address is provided, the address must be
     *  available on the virtual network interface's subnet. If no address is specified,
     *  an available address on the subnet will be automatically selected and reserved.
     */
    primary_ip?: VirtualNetworkInterfacePrimaryIPPrototype;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The security groups to use for this virtual network interface. If unspecified, the default security group of
     *  the VPC for the subnet is used.
     */
    security_groups?: SecurityGroupIdentity[];
    /** The associated subnet. Required if `primary_ip` does not specify a reserved IP and
     *  `primary_ip.address` is not specified.
     */
    subnet?: SubnetIdentity;
  }

  /** The permitted total capacity (in gigabytes) of a share with this profile depends on its configuration. */
  export interface ShareProfileCapacityDependentRange extends ShareProfileCapacity {
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted total capacities (in gigabytes) of a share with this profile. */
  export interface ShareProfileCapacityEnum extends ShareProfileCapacity {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The permitted total capacity (in gigabytes) of a share with this profile is fixed. */
  export interface ShareProfileCapacityFixed extends ShareProfileCapacity {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted total capacity range (in gigabytes) of a share with this profile. */
  export interface ShareProfileCapacityRange extends ShareProfileCapacity {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted IOPS range of a share with this profile depends on its configuration. */
  export interface ShareProfileIOPSDependentRange extends ShareProfileIOPS {
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** The permitted IOPS values of a share with this profile. */
  export interface ShareProfileIOPSEnum extends ShareProfileIOPS {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: string;
    /** The permitted values for this profile field. */
    values: number[];
  }

  /** The permitted IOPS of a share with this profile is fixed. */
  export interface ShareProfileIOPSFixed extends ShareProfileIOPS {
    /** The type for this profile field. */
    type: string;
    /** The value for this profile field. */
    value: number;
  }

  /** The permitted IOPS range of a share with this profile. */
  export interface ShareProfileIOPSRange extends ShareProfileIOPS {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: string;
  }

  /** ShareProfileIdentityByHref. */
  export interface ShareProfileIdentityByHref extends ShareProfileIdentity {
    /** The URL for this share profile. */
    href: string;
  }

  /** ShareProfileIdentityByName. */
  export interface ShareProfileIdentityByName extends ShareProfileIdentity {
    /** The globally unique name for this share profile. */
    name: string;
  }

  /** Create a file share by size. */
  export interface SharePrototypeShareBySize extends SharePrototype {
    /** The access control mode for the share:
     *
     *  - `security_group`: The security groups on the virtual network interface for a
     *    mount target control access to the mount target. Mount targets for this share
     *    require a virtual network interface.
     *  - `vpc`: All clients in the VPC for a mount target have access to the mount target.
     *    Mount targets for this share require a VPC.
     */
    access_control_mode?: string;
    /** The root key to use to wrap the data encryption key for the share.
     *
     *  If unspecified, the `encryption` type for the share will be `provider_managed`.
     *
     *  The specified key may be in a different account, subject to IAM policies.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The owner assigned to the file share at creation. Subsequent changes to the owner
     *  must be performed by a client that has mounted the file share.
     */
    initial_owner?: ShareInitialOwner;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The size of the file share rounded up to the next gigabyte.
     *
     *  The maximum size for a share may increase in the future.
     */
    size: number;
  }

  /** Create a replica file share for an existing file share. The values for `access_control_mode`, `encryption_key`, `initial_owner`, and `size` will be inherited from `source_share`. */
  export interface SharePrototypeShareBySourceShare extends SharePrototype {
    /** The cron specification for the file share replication schedule.
     *
     *  Replication of a share can be scheduled to occur at most once per hour.
     */
    replication_cron_spec: string;
    /** The resource group to use. If unspecified, the resource group from the source share will be used. */
    resource_group?: ResourceGroupIdentity;
    /** The source file share for this replica file share. The specified file share must not
     *  already have a replica, and must not be a replica.
     */
    source_share: ShareIdentity;
  }

  /** SnapshotIdentityByCRN. */
  export interface SnapshotIdentityByCRN extends SnapshotIdentity {
    /** The CRN of this snapshot. */
    crn: string;
  }

  /** SnapshotIdentityByHref. */
  export interface SnapshotIdentityByHref extends SnapshotIdentity {
    /** The URL for this snapshot. */
    href: string;
  }

  /** SnapshotIdentityById. */
  export interface SnapshotIdentityById extends SnapshotIdentity {
    /** The unique identifier for this snapshot. */
    id: string;
  }

  /** SnapshotPrototypeSnapshotBySourceSnapshot. */
  export interface SnapshotPrototypeSnapshotBySourceSnapshot extends SnapshotPrototype {
    /** The root key to use to wrap the data encryption key for this snapshot.
     *
     *  A key must be specified if and only if the source snapshot has an `encryption` type of
     *  `user_managed`. To maximize snapshot availability and sharing of snapshot data, specify
     *  a key in the same region as the new snapshot, and use the same encryption key for all
     *  snapshots using the same source volume.
     *
     *  The specified key may be in a different account, subject to IAM policies.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The source snapshot (in another region) to create this snapshot from.
     *  The specified snapshot must not already be the source of another snapshot in this
     *  region.
     */
    source_snapshot: SnapshotIdentityByCRN;
  }

  /** SnapshotPrototypeSnapshotBySourceVolume. */
  export interface SnapshotPrototypeSnapshotBySourceVolume extends SnapshotPrototype {
    /** The volume to create this snapshot from. */
    source_volume: VolumeIdentity;
  }

  /** SubnetIdentityByCRN. */
  export interface SubnetIdentityByCRN extends SubnetIdentity {
    /** The CRN for this subnet. */
    crn: string;
  }

  /** SubnetIdentityByHref. */
  export interface SubnetIdentityByHref extends SubnetIdentity {
    /** The URL for this subnet. */
    href: string;
  }

  /** SubnetIdentityById. */
  export interface SubnetIdentityById extends SubnetIdentity {
    /** The unique identifier for this subnet. */
    id: string;
  }

  /** SubnetPrototypeSubnetByCIDR. */
  export interface SubnetPrototypeSubnetByCIDR extends SubnetPrototype {
    /** The IPv4 range of the subnet, expressed in CIDR format. The prefix length of the subnet's CIDR must be
     *  between `/9` (8,388,608 addresses) and `/29` (8 addresses). The IPv4 range of the subnet's CIDR must fall within
     *  an existing address prefix in the VPC and must not overlap with any existing subnet. The subnet will be created
     *  in the zone of the address prefix that contains the IPv4 CIDR. If zone is specified, it must match the zone of
     *  the address prefix that contains the subnet's IPv4 CIDR.
     */
    ipv4_cidr_block: string;
    /** The zone this subnet will reside in. */
    zone?: ZoneIdentity;
  }

  /** SubnetPrototypeSubnetByTotalCount. */
  export interface SubnetPrototypeSubnetByTotalCount extends SubnetPrototype {
    /** The total number of IPv4 addresses required. Must be a power of 2. The VPC must have a default address
     *  prefix in the specified zone, and that prefix must have a free CIDR range with at least this number of
     *  addresses.
     */
    total_ipv4_address_count: number;
    /** The zone this subnet will reside in. */
    zone: ZoneIdentity;
  }

  /** SubnetPublicGatewayPatchPublicGatewayIdentityByCRN. */
  export interface SubnetPublicGatewayPatchPublicGatewayIdentityByCRN extends SubnetPublicGatewayPatch {
    /** The CRN for this public gateway. */
    crn: string;
  }

  /** SubnetPublicGatewayPatchPublicGatewayIdentityByHref. */
  export interface SubnetPublicGatewayPatchPublicGatewayIdentityByHref extends SubnetPublicGatewayPatch {
    /** The URL for this public gateway. */
    href: string;
  }

  /** SubnetPublicGatewayPatchPublicGatewayIdentityById. */
  export interface SubnetPublicGatewayPatchPublicGatewayIdentityById extends SubnetPublicGatewayPatch {
    /** The unique identifier for this public gateway. */
    id: string;
  }

  /** TrustedProfileIdentityTrustedProfileByCRN. */
  export interface TrustedProfileIdentityTrustedProfileByCRN extends TrustedProfileIdentity {
    /** The CRN for this trusted profile. */
    crn: string;
  }

  /** TrustedProfileIdentityTrustedProfileById. */
  export interface TrustedProfileIdentityTrustedProfileById extends TrustedProfileIdentity {
    /** The unique identifier for this trusted profile. */
    id: string;
  }

  /** VPCIdentityByCRN. */
  export interface VPCIdentityByCRN extends VPCIdentity {
    /** The CRN for this VPC. */
    crn: string;
  }

  /** VPCIdentityByHref. */
  export interface VPCIdentityByHref extends VPCIdentity {
    /** The URL for this VPC. */
    href: string;
  }

  /** VPCIdentityById. */
  export interface VPCIdentityById extends VPCIdentity {
    /** The unique identifier for this VPC. */
    id: string;
  }

  /** VPNGatewayConnectionIKEPolicyPatchIKEPolicyIdentityByHref. */
  export interface VPNGatewayConnectionIKEPolicyPatchIKEPolicyIdentityByHref extends VPNGatewayConnectionIKEPolicyPatch {
    /** The IKE policy's canonical URL. */
    href: string;
  }

  /** VPNGatewayConnectionIKEPolicyPatchIKEPolicyIdentityById. */
  export interface VPNGatewayConnectionIKEPolicyPatchIKEPolicyIdentityById extends VPNGatewayConnectionIKEPolicyPatch {
    /** The unique identifier for this IKE policy. */
    id: string;
  }

  /** VPNGatewayConnectionIKEPolicyPrototypeIKEPolicyIdentityByHref. */
  export interface VPNGatewayConnectionIKEPolicyPrototypeIKEPolicyIdentityByHref extends VPNGatewayConnectionIKEPolicyPrototype {
    /** The IKE policy's canonical URL. */
    href: string;
  }

  /** VPNGatewayConnectionIKEPolicyPrototypeIKEPolicyIdentityById. */
  export interface VPNGatewayConnectionIKEPolicyPrototypeIKEPolicyIdentityById extends VPNGatewayConnectionIKEPolicyPrototype {
    /** The unique identifier for this IKE policy. */
    id: string;
  }

  /** VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref. */
  export interface VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref extends VPNGatewayConnectionIPsecPolicyPatch {
    /** The IPsec policy's canonical URL. */
    href: string;
  }

  /** VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityById. */
  export interface VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityById extends VPNGatewayConnectionIPsecPolicyPatch {
    /** The unique identifier for this IPsec policy. */
    id: string;
  }

  /** VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref. */
  export interface VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref extends VPNGatewayConnectionIPsecPolicyPrototype {
    /** The IPsec policy's canonical URL. */
    href: string;
  }

  /** VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityById. */
  export interface VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityById extends VPNGatewayConnectionIPsecPolicyPrototype {
    /** The unique identifier for this IPsec policy. */
    id: string;
  }

  /** VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch. */
  export interface VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch extends VPNGatewayConnectionPatch {
    /** Routing protocols are disabled for this VPN gateway connection. */
    routing_protocol?: string;
  }

  /** VPNGatewayConnectionPolicyMode. */
  export interface VPNGatewayConnectionPolicyMode extends VPNGatewayConnection {
    /** The local CIDRs for this resource. */
    local_cidrs: string[];
    /** The peer CIDRs for this resource. */
    peer_cidrs: string[];
  }

  /** VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype. */
  export interface VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype extends VPNGatewayConnectionPrototype {
    /** The local CIDRs for this resource. */
    local_cidrs: string[];
    /** The peer CIDRs for this resource. */
    peer_cidrs: string[];
  }

  /** VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype. */
  export interface VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype extends VPNGatewayConnectionPrototype {
    /** Routing protocols are disabled for this VPN gateway connection. */
    routing_protocol?: string;
  }

  /** VPNGatewayConnectionStaticRouteMode. */
  export interface VPNGatewayConnectionStaticRouteMode extends VPNGatewayConnection {
    /** Routing protocols are disabled for this VPN gateway connection. */
    routing_protocol: string;
    /** The VPN tunnel configuration for this VPN gateway connection (in static route mode). */
    tunnels: VPNGatewayConnectionStaticRouteModeTunnel[];
  }

  /** VPNGatewayPolicyMode. */
  export interface VPNGatewayPolicyMode extends VPNGateway {
    /** Policy mode VPN gateway. */
    mode: string;
  }

  /** VPNGatewayPrototypeVPNGatewayPolicyModePrototype. */
  export interface VPNGatewayPrototypeVPNGatewayPolicyModePrototype extends VPNGatewayPrototype {
    /** Policy mode VPN gateway. */
    mode?: string;
  }

  /** VPNGatewayPrototypeVPNGatewayRouteModePrototype. */
  export interface VPNGatewayPrototypeVPNGatewayRouteModePrototype extends VPNGatewayPrototype {
    /** Route mode VPN gateway. */
    mode?: string;
  }

  /** VPNGatewayRouteMode. */
  export interface VPNGatewayRouteMode extends VPNGateway {
    /** Route mode VPN gateway. */
    mode: string;
  }

  /** VPNServerAuthenticationByCertificate. */
  export interface VPNServerAuthenticationByCertificate extends VPNServerAuthentication {
    /** The certificate instance used for the VPN client certificate authority (CA). */
    client_ca: CertificateInstanceReference;
    /** The certificate revocation list contents, encoded in PEM format. */
    crl?: string;
  }

  /** VPNServerAuthenticationByUsername. */
  export interface VPNServerAuthenticationByUsername extends VPNServerAuthentication {
    /** The type of identity provider to be used by VPN client. */
    identity_provider: VPNServerAuthenticationByUsernameIdProvider;
  }

  /** VPNServerAuthenticationByUsernameIdProviderByIAM. */
  export interface VPNServerAuthenticationByUsernameIdProviderByIAM extends VPNServerAuthenticationByUsernameIdProvider {
    /** The type of identity provider to be used by the VPN client.
     *  - `iam`: IBM identity and access management
     *
     *  The enumerated values for this property are expected to expand in the future. When processing this property,
     *  check for and log unknown values. Optionally halt processing and surface the error, or bypass the route on which
     *  the unexpected property value was encountered.
     */
    provider_type: string;
  }

  /** VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype. */
  export interface VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype extends VPNServerAuthenticationPrototype {
    /** The certificate instance to use for the VPN client certificate authority (CA). */
    client_ca: CertificateInstanceIdentity;
    /** The certificate revocation list contents, encoded in PEM format. */
    crl?: string;
  }

  /** VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype. */
  export interface VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype extends VPNServerAuthenticationPrototype {
    /** The type of identity provider to be used by VPN client. */
    identity_provider: VPNServerAuthenticationByUsernameIdProvider;
  }

  /** Identifies a reserved IP by a unique property. Required if `subnet` is not specified. The reserved IP must be currently unbound. */
  export interface VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext extends VirtualNetworkInterfacePrimaryIPPrototype {
  }

  /** The prototype for a new reserved IP. Requires `subnet` to be specified. */
  export interface VirtualNetworkInterfacePrimaryIPPrototypeReservedIPPrototypeVirtualNetworkInterfacePrimaryIPContext extends VirtualNetworkInterfacePrimaryIPPrototype {
    /** The IP address to reserve, which must not already be reserved on the subnet.
     *
     *  If unspecified, an available address on the subnet will automatically be selected.
     */
    address?: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound.
     */
    auto_delete?: boolean;
    /** The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /** VirtualNetworkInterfaceTargetShareMountTargetReference. */
  export interface VirtualNetworkInterfaceTargetShareMountTargetReference extends VirtualNetworkInterfaceTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: ShareMountTargetReferenceDeleted;
    /** The URL for this share mount target. */
    href: string;
    /** The unique identifier for this share mount target. */
    id: string;
    /** The name for this share mount target. The name is unique across all mount targets for the file share. */
    name: string;
    /** The resource type. */
    resource_type: string;
  }

  /** Identifies a volume by a unique property. */
  export interface VolumeAttachmentPrototypeVolumeVolumeIdentity extends VolumeAttachmentPrototypeVolume {
  }

  /** VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext. */
  export interface VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext extends VolumeAttachmentPrototypeVolume {
    /** The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a
     *  profile `family` of `custom`.
     */
    iops?: number;
    /** The name for this volume. The name must not be used by another volume in the region. If unspecified, the
     *  name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to use for this volume. */
    profile: VolumeProfileIdentity;
    /** The resource group to use for this volume. If unspecified, the instance's resource group will be used. */
    resource_group?: ResourceGroupIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume. */
    user_tags?: string[];
  }

  /** VolumeIdentityByCRN. */
  export interface VolumeIdentityByCRN extends VolumeIdentity {
    /** The CRN for this volume. */
    crn: string;
  }

  /** VolumeIdentityByHref. */
  export interface VolumeIdentityByHref extends VolumeIdentity {
    /** The URL for this volume. */
    href: string;
  }

  /** VolumeIdentityById. */
  export interface VolumeIdentityById extends VolumeIdentity {
    /** The unique identifier for this volume. */
    id: string;
  }

  /** VolumeProfileIdentityByHref. */
  export interface VolumeProfileIdentityByHref extends VolumeProfileIdentity {
    /** The URL for this volume profile. */
    href: string;
  }

  /** VolumeProfileIdentityByName. */
  export interface VolumeProfileIdentityByName extends VolumeProfileIdentity {
    /** The globally unique name for this volume profile. */
    name: string;
  }

  /** VolumePrototypeVolumeByCapacity. */
  export interface VolumePrototypeVolumeByCapacity extends VolumePrototype {
    /** The capacity to use for the volume (in gigabytes). The specified minimum and maximum capacity values for
     *  creating or updating volumes may expand in the future.
     */
    capacity: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
  }

  /** VolumePrototypeVolumeBySourceSnapshot. */
  export interface VolumePrototypeVolumeBySourceSnapshot extends VolumePrototype {
    /** The capacity to use for the volume (in gigabytes). Must be at least the snapshot's
     *  `minimum_capacity`. The maximum value may increase in the future.
     *
     *  If unspecified, the capacity will be the source snapshot's `minimum_capacity`.
     */
    capacity?: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The snapshot from which to clone the volume. */
    source_snapshot: SnapshotIdentity;
  }

  /** ZoneIdentityByHref. */
  export interface ZoneIdentityByHref extends ZoneIdentity {
    /** The URL for this zone. */
    href: string;
  }

  /** ZoneIdentityByName. */
  export interface ZoneIdentityByName extends ZoneIdentity {
    /** The globally unique name for this zone. */
    name: string;
  }

  /** EndpointGatewayReservedIPReservedIPIdentityByHref. */
  export interface EndpointGatewayReservedIPReservedIPIdentityByHref extends EndpointGatewayReservedIPReservedIPIdentity {
    /** The URL for this reserved IP. */
    href: string;
  }

  /** EndpointGatewayReservedIPReservedIPIdentityById. */
  export interface EndpointGatewayReservedIPReservedIPIdentityById extends EndpointGatewayReservedIPReservedIPIdentity {
    /** The unique identifier for this reserved IP. */
    id: string;
  }

  /** EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN. */
  export interface EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN extends EndpointGatewayTargetPrototypeProviderCloudServiceIdentity {
    /** The CRN for this provider cloud service, or the CRN for the user's instance of a provider cloud service. */
    crn: string;
  }

  /** The name of this provider infrastructure service. */
  export interface EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName extends EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity {
    /** The name of a provider infrastructure service. Must be:
     *  - `ibm-ntp-server`: An NTP (Network Time Protocol) server provided by IBM.
     */
    name: string;
  }

  /** FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref. */
  export interface FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref extends FloatingIPTargetPatchNetworkInterfaceIdentity {
    /** The URL for this instance network interface. */
    href: string;
  }

  /** FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityById. */
  export interface FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityById extends FloatingIPTargetPatchNetworkInterfaceIdentity {
    /** The unique identifier for this instance network interface. */
    id: string;
  }

  /** FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref. */
  export interface FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref extends FloatingIPTargetPrototypeNetworkInterfaceIdentity {
    /** The URL for this instance network interface. */
    href: string;
  }

  /** FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityById. */
  export interface FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityById extends FloatingIPTargetPrototypeNetworkInterfaceIdentity {
    /** The unique identifier for this instance network interface. */
    id: string;
  }

  /** FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN. */
  export interface FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN extends FlowLogCollectorTargetPrototypeInstanceIdentity {
    /** The CRN for this virtual server instance. */
    crn: string;
  }

  /** FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref. */
  export interface FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref extends FlowLogCollectorTargetPrototypeInstanceIdentity {
    /** The URL for this virtual server instance. */
    href: string;
  }

  /** FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityById. */
  export interface FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityById extends FlowLogCollectorTargetPrototypeInstanceIdentity {
    /** The unique identifier for this virtual server instance. */
    id: string;
  }

  /** FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref. */
  export interface FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref extends FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity {
    /** The URL for this instance network interface. */
    href: string;
  }

  /** FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityById. */
  export interface FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityById extends FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity {
    /** The unique identifier for this instance network interface. */
    id: string;
  }

  /** FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN. */
  export interface FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN extends FlowLogCollectorTargetPrototypeSubnetIdentity {
    /** The CRN for this subnet. */
    crn: string;
  }

  /** FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref. */
  export interface FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref extends FlowLogCollectorTargetPrototypeSubnetIdentity {
    /** The URL for this subnet. */
    href: string;
  }

  /** FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityById. */
  export interface FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityById extends FlowLogCollectorTargetPrototypeSubnetIdentity {
    /** The unique identifier for this subnet. */
    id: string;
  }

  /** FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN. */
  export interface FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN extends FlowLogCollectorTargetPrototypeVPCIdentity {
    /** The CRN for this VPC. */
    crn: string;
  }

  /** FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref. */
  export interface FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref extends FlowLogCollectorTargetPrototypeVPCIdentity {
    /** The URL for this VPC. */
    href: string;
  }

  /** FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityById. */
  export interface FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityById extends FlowLogCollectorTargetPrototypeVPCIdentity {
    /** The unique identifier for this VPC. */
    id: string;
  }

  /** InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec. */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec extends InstanceGroupManagerActionPrototypeScheduledActionPrototype {
    /** The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within
     *  a 5 min period.
     */
    cron_spec?: string;
  }

  /** InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt. */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt extends InstanceGroupManagerActionPrototypeScheduledActionPrototype {
    /** The date and time the scheduled action will run. */
    run_at?: string;
  }

  /** InstanceGroupManagerActionScheduledActionGroupTarget. */
  export interface InstanceGroupManagerActionScheduledActionGroupTarget extends InstanceGroupManagerActionScheduledAction {
    group: InstanceGroupManagerScheduledActionGroup;
  }

  /** InstanceGroupManagerActionScheduledActionManagerTarget. */
  export interface InstanceGroupManagerActionScheduledActionManagerTarget extends InstanceGroupManagerActionScheduledAction {
    manager: InstanceGroupManagerScheduledActionManager;
  }

  /** InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref. */
  export interface InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref extends InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype {
    /** The URL for this instance group manager. */
    href: string;
  }

  /** InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeById. */
  export interface InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeById extends InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype {
    /** The unique identifier for this instance group manager. */
    id: string;
  }

  /** InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN. */
  export interface InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN extends InstancePlacementTargetPatchDedicatedHostGroupIdentity {
    /** The CRN for this dedicated host group. */
    crn: string;
  }

  /** InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref. */
  export interface InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref extends InstancePlacementTargetPatchDedicatedHostGroupIdentity {
    /** The URL for this dedicated host group. */
    href: string;
  }

  /** InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityById. */
  export interface InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityById extends InstancePlacementTargetPatchDedicatedHostGroupIdentity {
    /** The unique identifier for this dedicated host group. */
    id: string;
  }

  /** InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN. */
  export interface InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN extends InstancePlacementTargetPatchDedicatedHostIdentity {
    /** The CRN for this dedicated host. */
    crn: string;
  }

  /** InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref. */
  export interface InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref extends InstancePlacementTargetPatchDedicatedHostIdentity {
    /** The URL for this dedicated host. */
    href: string;
  }

  /** InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityById. */
  export interface InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityById extends InstancePlacementTargetPatchDedicatedHostIdentity {
    /** The unique identifier for this dedicated host. */
    id: string;
  }

  /** InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN. */
  export interface InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN extends InstancePlacementTargetPrototypeDedicatedHostGroupIdentity {
    /** The CRN for this dedicated host group. */
    crn: string;
  }

  /** InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref. */
  export interface InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref extends InstancePlacementTargetPrototypeDedicatedHostGroupIdentity {
    /** The URL for this dedicated host group. */
    href: string;
  }

  /** InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityById. */
  export interface InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityById extends InstancePlacementTargetPrototypeDedicatedHostGroupIdentity {
    /** The unique identifier for this dedicated host group. */
    id: string;
  }

  /** InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN. */
  export interface InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN extends InstancePlacementTargetPrototypeDedicatedHostIdentity {
    /** The CRN for this dedicated host. */
    crn: string;
  }

  /** InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref. */
  export interface InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref extends InstancePlacementTargetPrototypeDedicatedHostIdentity {
    /** The URL for this dedicated host. */
    href: string;
  }

  /** InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityById. */
  export interface InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityById extends InstancePlacementTargetPrototypeDedicatedHostIdentity {
    /** The unique identifier for this dedicated host. */
    id: string;
  }

  /** InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN. */
  export interface InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN extends InstancePlacementTargetPrototypePlacementGroupIdentity {
    /** The CRN for this placement group. */
    crn: string;
  }

  /** InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref. */
  export interface InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref extends InstancePlacementTargetPrototypePlacementGroupIdentity {
    /** The URL for this placement group. */
    href: string;
  }

  /** InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityById. */
  export interface InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityById extends InstancePlacementTargetPrototypePlacementGroupIdentity {
    /** The unique identifier for this placement group. */
    id: string;
  }

  /** LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref. */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref extends LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity {
    /** The pool's canonical URL. */
    href: string;
  }

  /** LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityById. */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityById extends LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity {
    /** The unique identifier for this load balancer pool. */
    id: string;
  }

  /** LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref. */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref extends LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity {
    /** The pool's canonical URL. */
    href: string;
  }

  /** LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityById. */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityById extends LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity {
    /** The unique identifier for this load balancer pool. */
    id: string;
  }

  /** LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN. */
  export interface LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN extends LoadBalancerPoolMemberTargetPrototypeInstanceIdentity {
    /** The CRN for this virtual server instance. */
    crn: string;
  }

  /** LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref. */
  export interface LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref extends LoadBalancerPoolMemberTargetPrototypeInstanceIdentity {
    /** The URL for this virtual server instance. */
    href: string;
  }

  /** LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityById. */
  export interface LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityById extends LoadBalancerPoolMemberTargetPrototypeInstanceIdentity {
    /** The unique identifier for this virtual server instance. */
    id: string;
  }

  /** NetworkInterfaceIPPrototypeReservedIPIdentityByHref. */
  export interface NetworkInterfaceIPPrototypeReservedIPIdentityByHref extends NetworkInterfaceIPPrototypeReservedIPIdentity {
    /** The URL for this reserved IP. */
    href: string;
  }

  /** NetworkInterfaceIPPrototypeReservedIPIdentityById. */
  export interface NetworkInterfaceIPPrototypeReservedIPIdentityById extends NetworkInterfaceIPPrototypeReservedIPIdentity {
    /** The unique identifier for this reserved IP. */
    id: string;
  }

  /** PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress. */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress extends PublicGatewayFloatingIPPrototypeFloatingIPIdentity {
    /** The globally unique IP address. */
    address: string;
  }

  /** PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN. */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN extends PublicGatewayFloatingIPPrototypeFloatingIPIdentity {
    /** The CRN for this floating IP. */
    crn: string;
  }

  /** PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref. */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref extends PublicGatewayFloatingIPPrototypeFloatingIPIdentity {
    /** The URL for this floating IP. */
    href: string;
  }

  /** PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityById. */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityById extends PublicGatewayFloatingIPPrototypeFloatingIPIdentity {
    /** The unique identifier for this floating IP. */
    id: string;
  }

  /** ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN. */
  export interface ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN extends ReservedIPTargetPrototypeEndpointGatewayIdentity {
    /** The CRN for this endpoint gateway. */
    crn: string;
  }

  /** ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref. */
  export interface ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref extends ReservedIPTargetPrototypeEndpointGatewayIdentity {
    /** The URL for this endpoint gateway. */
    href: string;
  }

  /** ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityById. */
  export interface ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityById extends ReservedIPTargetPrototypeEndpointGatewayIdentity {
    /** The unique identifier for this endpoint gateway. */
    id: string;
  }

  /** RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP. */
  export interface RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP extends RouteNextHopPatchRouteNextHopIP {
    /** The sentinel IP address (`0.0.0.0`).
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
  }

  /** RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP. */
  export interface RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP extends RouteNextHopPatchRouteNextHopIP {
    /** A unicast IP address, which must not be any of the following values:
     *
     *  - `0.0.0.0` (the sentinel IP address)
     *  - `224.0.0.0` to `239.255.255.255` (multicast IP addresses)
     *  - `255.255.255.255` (the broadcast IP address)
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
  }

  /** RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref. */
  export interface RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref extends RouteNextHopPatchVPNGatewayConnectionIdentity {
    /** The VPN connection's canonical URL. */
    href: string;
  }

  /** RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityById. */
  export interface RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityById extends RouteNextHopPatchVPNGatewayConnectionIdentity {
    /** The unique identifier for this VPN gateway connection. */
    id: string;
  }

  /** RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP. */
  export interface RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP extends RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP {
    /** The sentinel IP address (`0.0.0.0`).
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
  }

  /** RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP. */
  export interface RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP extends RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP {
    /** A unicast IP address, which must not be any of the following values:
     *
     *  - `0.0.0.0` (the sentinel IP address)
     *  - `224.0.0.0` to `239.255.255.255` (multicast IP addresses)
     *  - `255.255.255.255` (the broadcast IP address)
     *
     *  This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
     *  that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface
     *  the error, or bypass the resource on which the unexpected IP address format was encountered.
     */
    address: string;
  }

  /** RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref. */
  export interface RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref extends RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity {
    /** The VPN connection's canonical URL. */
    href: string;
  }

  /** RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityById. */
  export interface RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityById extends RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity {
    /** The unique identifier for this VPN gateway connection. */
    id: string;
  }

  /** SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN. */
  export interface SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN extends SecurityGroupRuleRemotePatchSecurityGroupIdentity {
    /** The security group's CRN. */
    crn: string;
  }

  /** SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref. */
  export interface SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref extends SecurityGroupRuleRemotePatchSecurityGroupIdentity {
    /** The security group's canonical URL. */
    href: string;
  }

  /** SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityById. */
  export interface SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityById extends SecurityGroupRuleRemotePatchSecurityGroupIdentity {
    /** The unique identifier for this security group. */
    id: string;
  }

  /** SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN. */
  export interface SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN extends SecurityGroupRuleRemotePrototypeSecurityGroupIdentity {
    /** The security group's CRN. */
    crn: string;
  }

  /** SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref. */
  export interface SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref extends SecurityGroupRuleRemotePrototypeSecurityGroupIdentity {
    /** The security group's canonical URL. */
    href: string;
  }

  /** SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityById. */
  export interface SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityById extends SecurityGroupRuleRemotePrototypeSecurityGroupIdentity {
    /** The unique identifier for this security group. */
    id: string;
  }

  /** VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref. */
  export interface VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref extends VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext {
    /** The URL for this reserved IP. */
    href: string;
  }

  /** VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextById. */
  export interface VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextById extends VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext {
    /** The unique identifier for this reserved IP. */
    id: string;
  }

  /** VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN. */
  export interface VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN extends VolumeAttachmentPrototypeVolumeVolumeIdentity {
    /** The CRN for this volume. */
    crn: string;
  }

  /** VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref. */
  export interface VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref extends VolumeAttachmentPrototypeVolumeVolumeIdentity {
    /** The URL for this volume. */
    href: string;
  }

  /** VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityById. */
  export interface VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityById extends VolumeAttachmentPrototypeVolumeVolumeIdentity {
    /** The unique identifier for this volume. */
    id: string;
  }

  /** VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity. */
  export interface VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity extends VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext {
    /** The capacity to use for the volume (in gigabytes). The specified minimum and maximum capacity values for
     *  creating or updating volumes may expand in the future.
     */
    capacity: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
  }

  /** VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot. */
  export interface VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot extends VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext {
    /** The capacity to use for the volume (in gigabytes). Must be at least the snapshot's
     *  `minimum_capacity`. The maximum value may increase in the future.
     *
     *  If unspecified, the capacity will be the source snapshot's `minimum_capacity`.
     */
    capacity?: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The snapshot from which to clone the volume. */
    source_snapshot: SnapshotIdentity;
  }

  /** InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup. */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup extends InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec {
    group: InstanceGroupManagerScheduledActionGroupPrototype;
  }

  /** InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager. */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager extends InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec {
    manager: InstanceGroupManagerScheduledActionManagerPrototype;
  }

  /** InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup. */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup extends InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt {
    group: InstanceGroupManagerScheduledActionGroupPrototype;
  }

  /** InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager. */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager extends InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt {
    manager: InstanceGroupManagerScheduledActionManagerPrototype;
  }

  /*************************
   * pager classes
   ************************/

  /**
   * VpcsPager can be used to simplify the use of listVpcs().
   */
  export class VpcsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpcsParams;

    /**
     * Construct a VpcsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpcs()
     * @param {Object} [params] - The parameters to be passed to listVpcs()
     * @constructor
     * @returns {VpcsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListVpcsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpcs().
     * @returns {Promise<VpcV1.VPC[]>}
     */
    public async getNext(): Promise<VpcV1.VPC[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpcs(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.vpcs;
    }

    /**
     * Returns all results by invoking listVpcs() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPC[]>}
     */
    public async getAll(): Promise<VpcV1.VPC[]> {
      const results: VPC[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpcAddressPrefixesPager can be used to simplify the use of listVpcAddressPrefixes().
   */
  export class VpcAddressPrefixesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpcAddressPrefixesParams;

    /**
     * Construct a VpcAddressPrefixesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpcAddressPrefixes()
     * @param {Object} params - The parameters to be passed to listVpcAddressPrefixes()
     * @constructor
     * @returns {VpcAddressPrefixesPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListVpcAddressPrefixesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpcAddressPrefixes().
     * @returns {Promise<VpcV1.AddressPrefix[]>}
     */
    public async getNext(): Promise<VpcV1.AddressPrefix[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpcAddressPrefixes(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.address_prefixes;
    }

    /**
     * Returns all results by invoking listVpcAddressPrefixes() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.AddressPrefix[]>}
     */
    public async getAll(): Promise<VpcV1.AddressPrefix[]> {
      const results: AddressPrefix[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpcRoutesPager can be used to simplify the use of listVpcRoutes().
   */
  export class VpcRoutesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpcRoutesParams;

    /**
     * Construct a VpcRoutesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpcRoutes()
     * @param {Object} params - The parameters to be passed to listVpcRoutes()
     * @constructor
     * @returns {VpcRoutesPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListVpcRoutesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpcRoutes().
     * @returns {Promise<VpcV1.RouteCollectionVPCContextRoutesItem[]>}
     */
    public async getNext(): Promise<VpcV1.RouteCollectionVPCContextRoutesItem[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpcRoutes(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.routes;
    }

    /**
     * Returns all results by invoking listVpcRoutes() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.RouteCollectionVPCContextRoutesItem[]>}
     */
    public async getAll(): Promise<VpcV1.RouteCollectionVPCContextRoutesItem[]> {
      const results: RouteCollectionVPCContextRoutesItem[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpcRoutingTablesPager can be used to simplify the use of listVpcRoutingTables().
   */
  export class VpcRoutingTablesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpcRoutingTablesParams;

    /**
     * Construct a VpcRoutingTablesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpcRoutingTables()
     * @param {Object} params - The parameters to be passed to listVpcRoutingTables()
     * @constructor
     * @returns {VpcRoutingTablesPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListVpcRoutingTablesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpcRoutingTables().
     * @returns {Promise<VpcV1.RoutingTable[]>}
     */
    public async getNext(): Promise<VpcV1.RoutingTable[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpcRoutingTables(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.routing_tables;
    }

    /**
     * Returns all results by invoking listVpcRoutingTables() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.RoutingTable[]>}
     */
    public async getAll(): Promise<VpcV1.RoutingTable[]> {
      const results: RoutingTable[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpcRoutingTableRoutesPager can be used to simplify the use of listVpcRoutingTableRoutes().
   */
  export class VpcRoutingTableRoutesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpcRoutingTableRoutesParams;

    /**
     * Construct a VpcRoutingTableRoutesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpcRoutingTableRoutes()
     * @param {Object} params - The parameters to be passed to listVpcRoutingTableRoutes()
     * @constructor
     * @returns {VpcRoutingTableRoutesPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListVpcRoutingTableRoutesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpcRoutingTableRoutes().
     * @returns {Promise<VpcV1.Route[]>}
     */
    public async getNext(): Promise<VpcV1.Route[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpcRoutingTableRoutes(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.routes;
    }

    /**
     * Returns all results by invoking listVpcRoutingTableRoutes() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Route[]>}
     */
    public async getAll(): Promise<VpcV1.Route[]> {
      const results: Route[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SubnetsPager can be used to simplify the use of listSubnets().
   */
  export class SubnetsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSubnetsParams;

    /**
     * Construct a SubnetsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listSubnets()
     * @param {Object} [params] - The parameters to be passed to listSubnets()
     * @constructor
     * @returns {SubnetsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListSubnetsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSubnets().
     * @returns {Promise<VpcV1.Subnet[]>}
     */
    public async getNext(): Promise<VpcV1.Subnet[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listSubnets(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.subnets;
    }

    /**
     * Returns all results by invoking listSubnets() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Subnet[]>}
     */
    public async getAll(): Promise<VpcV1.Subnet[]> {
      const results: Subnet[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SubnetReservedIpsPager can be used to simplify the use of listSubnetReservedIps().
   */
  export class SubnetReservedIpsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSubnetReservedIpsParams;

    /**
     * Construct a SubnetReservedIpsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listSubnetReservedIps()
     * @param {Object} params - The parameters to be passed to listSubnetReservedIps()
     * @constructor
     * @returns {SubnetReservedIpsPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListSubnetReservedIpsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSubnetReservedIps().
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getNext(): Promise<VpcV1.ReservedIP[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listSubnetReservedIps(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.reserved_ips;
    }

    /**
     * Returns all results by invoking listSubnetReservedIps() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getAll(): Promise<VpcV1.ReservedIP[]> {
      const results: ReservedIP[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ImagesPager can be used to simplify the use of listImages().
   */
  export class ImagesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListImagesParams;

    /**
     * Construct a ImagesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listImages()
     * @param {Object} [params] - The parameters to be passed to listImages()
     * @constructor
     * @returns {ImagesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListImagesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listImages().
     * @returns {Promise<VpcV1.Image[]>}
     */
    public async getNext(): Promise<VpcV1.Image[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listImages(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.images;
    }

    /**
     * Returns all results by invoking listImages() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Image[]>}
     */
    public async getAll(): Promise<VpcV1.Image[]> {
      const results: Image[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * OperatingSystemsPager can be used to simplify the use of listOperatingSystems().
   */
  export class OperatingSystemsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListOperatingSystemsParams;

    /**
     * Construct a OperatingSystemsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listOperatingSystems()
     * @param {Object} [params] - The parameters to be passed to listOperatingSystems()
     * @constructor
     * @returns {OperatingSystemsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListOperatingSystemsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listOperatingSystems().
     * @returns {Promise<VpcV1.OperatingSystem[]>}
     */
    public async getNext(): Promise<VpcV1.OperatingSystem[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listOperatingSystems(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.operating_systems;
    }

    /**
     * Returns all results by invoking listOperatingSystems() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.OperatingSystem[]>}
     */
    public async getAll(): Promise<VpcV1.OperatingSystem[]> {
      const results: OperatingSystem[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * KeysPager can be used to simplify the use of listKeys().
   */
  export class KeysPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListKeysParams;

    /**
     * Construct a KeysPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listKeys()
     * @param {Object} [params] - The parameters to be passed to listKeys()
     * @constructor
     * @returns {KeysPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListKeysParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listKeys().
     * @returns {Promise<VpcV1.Key[]>}
     */
    public async getNext(): Promise<VpcV1.Key[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listKeys(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.keys;
    }

    /**
     * Returns all results by invoking listKeys() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Key[]>}
     */
    public async getAll(): Promise<VpcV1.Key[]> {
      const results: Key[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstancesPager can be used to simplify the use of listInstances().
   */
  export class InstancesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstancesParams;

    /**
     * Construct a InstancesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstances()
     * @param {Object} [params] - The parameters to be passed to listInstances()
     * @constructor
     * @returns {InstancesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListInstancesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstances().
     * @returns {Promise<VpcV1.Instance[]>}
     */
    public async getNext(): Promise<VpcV1.Instance[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstances(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.instances;
    }

    /**
     * Returns all results by invoking listInstances() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Instance[]>}
     */
    public async getAll(): Promise<VpcV1.Instance[]> {
      const results: Instance[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceNetworkInterfaceIpsPager can be used to simplify the use of listInstanceNetworkInterfaceIps().
   */
  export class InstanceNetworkInterfaceIpsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceNetworkInterfaceIpsParams;

    /**
     * Construct a InstanceNetworkInterfaceIpsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceNetworkInterfaceIps()
     * @param {Object} params - The parameters to be passed to listInstanceNetworkInterfaceIps()
     * @constructor
     * @returns {InstanceNetworkInterfaceIpsPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListInstanceNetworkInterfaceIpsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceNetworkInterfaceIps().
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getNext(): Promise<VpcV1.ReservedIP[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceNetworkInterfaceIps(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.ips;
    }

    /**
     * Returns all results by invoking listInstanceNetworkInterfaceIps() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getAll(): Promise<VpcV1.ReservedIP[]> {
      const results: ReservedIP[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceGroupsPager can be used to simplify the use of listInstanceGroups().
   */
  export class InstanceGroupsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceGroupsParams;

    /**
     * Construct a InstanceGroupsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceGroups()
     * @param {Object} [params] - The parameters to be passed to listInstanceGroups()
     * @constructor
     * @returns {InstanceGroupsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListInstanceGroupsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceGroups().
     * @returns {Promise<VpcV1.InstanceGroup[]>}
     */
    public async getNext(): Promise<VpcV1.InstanceGroup[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceGroups(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.instance_groups;
    }

    /**
     * Returns all results by invoking listInstanceGroups() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.InstanceGroup[]>}
     */
    public async getAll(): Promise<VpcV1.InstanceGroup[]> {
      const results: InstanceGroup[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceGroupManagersPager can be used to simplify the use of listInstanceGroupManagers().
   */
  export class InstanceGroupManagersPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceGroupManagersParams;

    /**
     * Construct a InstanceGroupManagersPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceGroupManagers()
     * @param {Object} params - The parameters to be passed to listInstanceGroupManagers()
     * @constructor
     * @returns {InstanceGroupManagersPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListInstanceGroupManagersParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceGroupManagers().
     * @returns {Promise<VpcV1.InstanceGroupManager[]>}
     */
    public async getNext(): Promise<VpcV1.InstanceGroupManager[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceGroupManagers(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.managers;
    }

    /**
     * Returns all results by invoking listInstanceGroupManagers() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.InstanceGroupManager[]>}
     */
    public async getAll(): Promise<VpcV1.InstanceGroupManager[]> {
      const results: InstanceGroupManager[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceGroupManagerActionsPager can be used to simplify the use of listInstanceGroupManagerActions().
   */
  export class InstanceGroupManagerActionsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceGroupManagerActionsParams;

    /**
     * Construct a InstanceGroupManagerActionsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceGroupManagerActions()
     * @param {Object} params - The parameters to be passed to listInstanceGroupManagerActions()
     * @constructor
     * @returns {InstanceGroupManagerActionsPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListInstanceGroupManagerActionsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceGroupManagerActions().
     * @returns {Promise<VpcV1.InstanceGroupManagerAction[]>}
     */
    public async getNext(): Promise<VpcV1.InstanceGroupManagerAction[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceGroupManagerActions(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.actions;
    }

    /**
     * Returns all results by invoking listInstanceGroupManagerActions() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.InstanceGroupManagerAction[]>}
     */
    public async getAll(): Promise<VpcV1.InstanceGroupManagerAction[]> {
      const results: InstanceGroupManagerAction[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceGroupManagerPoliciesPager can be used to simplify the use of listInstanceGroupManagerPolicies().
   */
  export class InstanceGroupManagerPoliciesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceGroupManagerPoliciesParams;

    /**
     * Construct a InstanceGroupManagerPoliciesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceGroupManagerPolicies()
     * @param {Object} params - The parameters to be passed to listInstanceGroupManagerPolicies()
     * @constructor
     * @returns {InstanceGroupManagerPoliciesPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListInstanceGroupManagerPoliciesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceGroupManagerPolicies().
     * @returns {Promise<VpcV1.InstanceGroupManagerPolicy[]>}
     */
    public async getNext(): Promise<VpcV1.InstanceGroupManagerPolicy[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceGroupManagerPolicies(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.policies;
    }

    /**
     * Returns all results by invoking listInstanceGroupManagerPolicies() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.InstanceGroupManagerPolicy[]>}
     */
    public async getAll(): Promise<VpcV1.InstanceGroupManagerPolicy[]> {
      const results: InstanceGroupManagerPolicy[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceGroupMembershipsPager can be used to simplify the use of listInstanceGroupMemberships().
   */
  export class InstanceGroupMembershipsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceGroupMembershipsParams;

    /**
     * Construct a InstanceGroupMembershipsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceGroupMemberships()
     * @param {Object} params - The parameters to be passed to listInstanceGroupMemberships()
     * @constructor
     * @returns {InstanceGroupMembershipsPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListInstanceGroupMembershipsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceGroupMemberships().
     * @returns {Promise<VpcV1.InstanceGroupMembership[]>}
     */
    public async getNext(): Promise<VpcV1.InstanceGroupMembership[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceGroupMemberships(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.memberships;
    }

    /**
     * Returns all results by invoking listInstanceGroupMemberships() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.InstanceGroupMembership[]>}
     */
    public async getAll(): Promise<VpcV1.InstanceGroupMembership[]> {
      const results: InstanceGroupMembership[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * DedicatedHostGroupsPager can be used to simplify the use of listDedicatedHostGroups().
   */
  export class DedicatedHostGroupsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListDedicatedHostGroupsParams;

    /**
     * Construct a DedicatedHostGroupsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listDedicatedHostGroups()
     * @param {Object} [params] - The parameters to be passed to listDedicatedHostGroups()
     * @constructor
     * @returns {DedicatedHostGroupsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListDedicatedHostGroupsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listDedicatedHostGroups().
     * @returns {Promise<VpcV1.DedicatedHostGroup[]>}
     */
    public async getNext(): Promise<VpcV1.DedicatedHostGroup[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listDedicatedHostGroups(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.groups;
    }

    /**
     * Returns all results by invoking listDedicatedHostGroups() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.DedicatedHostGroup[]>}
     */
    public async getAll(): Promise<VpcV1.DedicatedHostGroup[]> {
      const results: DedicatedHostGroup[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * DedicatedHostProfilesPager can be used to simplify the use of listDedicatedHostProfiles().
   */
  export class DedicatedHostProfilesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListDedicatedHostProfilesParams;

    /**
     * Construct a DedicatedHostProfilesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listDedicatedHostProfiles()
     * @param {Object} [params] - The parameters to be passed to listDedicatedHostProfiles()
     * @constructor
     * @returns {DedicatedHostProfilesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListDedicatedHostProfilesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listDedicatedHostProfiles().
     * @returns {Promise<VpcV1.DedicatedHostProfile[]>}
     */
    public async getNext(): Promise<VpcV1.DedicatedHostProfile[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listDedicatedHostProfiles(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.profiles;
    }

    /**
     * Returns all results by invoking listDedicatedHostProfiles() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.DedicatedHostProfile[]>}
     */
    public async getAll(): Promise<VpcV1.DedicatedHostProfile[]> {
      const results: DedicatedHostProfile[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * DedicatedHostsPager can be used to simplify the use of listDedicatedHosts().
   */
  export class DedicatedHostsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListDedicatedHostsParams;

    /**
     * Construct a DedicatedHostsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listDedicatedHosts()
     * @param {Object} [params] - The parameters to be passed to listDedicatedHosts()
     * @constructor
     * @returns {DedicatedHostsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListDedicatedHostsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listDedicatedHosts().
     * @returns {Promise<VpcV1.DedicatedHost[]>}
     */
    public async getNext(): Promise<VpcV1.DedicatedHost[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listDedicatedHosts(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.dedicated_hosts;
    }

    /**
     * Returns all results by invoking listDedicatedHosts() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.DedicatedHost[]>}
     */
    public async getAll(): Promise<VpcV1.DedicatedHost[]> {
      const results: DedicatedHost[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * BackupPoliciesPager can be used to simplify the use of listBackupPolicies().
   */
  export class BackupPoliciesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListBackupPoliciesParams;

    /**
     * Construct a BackupPoliciesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listBackupPolicies()
     * @param {Object} [params] - The parameters to be passed to listBackupPolicies()
     * @constructor
     * @returns {BackupPoliciesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListBackupPoliciesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listBackupPolicies().
     * @returns {Promise<VpcV1.BackupPolicy[]>}
     */
    public async getNext(): Promise<VpcV1.BackupPolicy[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listBackupPolicies(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.backup_policies;
    }

    /**
     * Returns all results by invoking listBackupPolicies() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.BackupPolicy[]>}
     */
    public async getAll(): Promise<VpcV1.BackupPolicy[]> {
      const results: BackupPolicy[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * BackupPolicyJobsPager can be used to simplify the use of listBackupPolicyJobs().
   */
  export class BackupPolicyJobsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListBackupPolicyJobsParams;

    /**
     * Construct a BackupPolicyJobsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listBackupPolicyJobs()
     * @param {Object} params - The parameters to be passed to listBackupPolicyJobs()
     * @constructor
     * @returns {BackupPolicyJobsPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListBackupPolicyJobsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listBackupPolicyJobs().
     * @returns {Promise<VpcV1.BackupPolicyJob[]>}
     */
    public async getNext(): Promise<VpcV1.BackupPolicyJob[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listBackupPolicyJobs(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.jobs;
    }

    /**
     * Returns all results by invoking listBackupPolicyJobs() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.BackupPolicyJob[]>}
     */
    public async getAll(): Promise<VpcV1.BackupPolicyJob[]> {
      const results: BackupPolicyJob[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * PlacementGroupsPager can be used to simplify the use of listPlacementGroups().
   */
  export class PlacementGroupsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListPlacementGroupsParams;

    /**
     * Construct a PlacementGroupsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listPlacementGroups()
     * @param {Object} [params] - The parameters to be passed to listPlacementGroups()
     * @constructor
     * @returns {PlacementGroupsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListPlacementGroupsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listPlacementGroups().
     * @returns {Promise<VpcV1.PlacementGroup[]>}
     */
    public async getNext(): Promise<VpcV1.PlacementGroup[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listPlacementGroups(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.placement_groups;
    }

    /**
     * Returns all results by invoking listPlacementGroups() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.PlacementGroup[]>}
     */
    public async getAll(): Promise<VpcV1.PlacementGroup[]> {
      const results: PlacementGroup[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * BareMetalServerProfilesPager can be used to simplify the use of listBareMetalServerProfiles().
   */
  export class BareMetalServerProfilesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListBareMetalServerProfilesParams;

    /**
     * Construct a BareMetalServerProfilesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listBareMetalServerProfiles()
     * @param {Object} [params] - The parameters to be passed to listBareMetalServerProfiles()
     * @constructor
     * @returns {BareMetalServerProfilesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListBareMetalServerProfilesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listBareMetalServerProfiles().
     * @returns {Promise<VpcV1.BareMetalServerProfile[]>}
     */
    public async getNext(): Promise<VpcV1.BareMetalServerProfile[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listBareMetalServerProfiles(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.profiles;
    }

    /**
     * Returns all results by invoking listBareMetalServerProfiles() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.BareMetalServerProfile[]>}
     */
    public async getAll(): Promise<VpcV1.BareMetalServerProfile[]> {
      const results: BareMetalServerProfile[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * BareMetalServersPager can be used to simplify the use of listBareMetalServers().
   */
  export class BareMetalServersPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListBareMetalServersParams;

    /**
     * Construct a BareMetalServersPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listBareMetalServers()
     * @param {Object} [params] - The parameters to be passed to listBareMetalServers()
     * @constructor
     * @returns {BareMetalServersPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListBareMetalServersParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listBareMetalServers().
     * @returns {Promise<VpcV1.BareMetalServer[]>}
     */
    public async getNext(): Promise<VpcV1.BareMetalServer[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listBareMetalServers(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.bare_metal_servers;
    }

    /**
     * Returns all results by invoking listBareMetalServers() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.BareMetalServer[]>}
     */
    public async getAll(): Promise<VpcV1.BareMetalServer[]> {
      const results: BareMetalServer[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * BareMetalServerNetworkInterfacesPager can be used to simplify the use of listBareMetalServerNetworkInterfaces().
   */
  export class BareMetalServerNetworkInterfacesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListBareMetalServerNetworkInterfacesParams;

    /**
     * Construct a BareMetalServerNetworkInterfacesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listBareMetalServerNetworkInterfaces()
     * @param {Object} params - The parameters to be passed to listBareMetalServerNetworkInterfaces()
     * @constructor
     * @returns {BareMetalServerNetworkInterfacesPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListBareMetalServerNetworkInterfacesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listBareMetalServerNetworkInterfaces().
     * @returns {Promise<VpcV1.BareMetalServerNetworkInterface[]>}
     */
    public async getNext(): Promise<VpcV1.BareMetalServerNetworkInterface[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listBareMetalServerNetworkInterfaces(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.network_interfaces;
    }

    /**
     * Returns all results by invoking listBareMetalServerNetworkInterfaces() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.BareMetalServerNetworkInterface[]>}
     */
    public async getAll(): Promise<VpcV1.BareMetalServerNetworkInterface[]> {
      const results: BareMetalServerNetworkInterface[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VolumeProfilesPager can be used to simplify the use of listVolumeProfiles().
   */
  export class VolumeProfilesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVolumeProfilesParams;

    /**
     * Construct a VolumeProfilesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVolumeProfiles()
     * @param {Object} [params] - The parameters to be passed to listVolumeProfiles()
     * @constructor
     * @returns {VolumeProfilesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListVolumeProfilesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVolumeProfiles().
     * @returns {Promise<VpcV1.VolumeProfile[]>}
     */
    public async getNext(): Promise<VpcV1.VolumeProfile[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVolumeProfiles(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.profiles;
    }

    /**
     * Returns all results by invoking listVolumeProfiles() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VolumeProfile[]>}
     */
    public async getAll(): Promise<VpcV1.VolumeProfile[]> {
      const results: VolumeProfile[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VolumesPager can be used to simplify the use of listVolumes().
   */
  export class VolumesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVolumesParams;

    /**
     * Construct a VolumesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVolumes()
     * @param {Object} [params] - The parameters to be passed to listVolumes()
     * @constructor
     * @returns {VolumesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListVolumesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVolumes().
     * @returns {Promise<VpcV1.Volume[]>}
     */
    public async getNext(): Promise<VpcV1.Volume[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVolumes(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.volumes;
    }

    /**
     * Returns all results by invoking listVolumes() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Volume[]>}
     */
    public async getAll(): Promise<VpcV1.Volume[]> {
      const results: Volume[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SnapshotsPager can be used to simplify the use of listSnapshots().
   */
  export class SnapshotsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSnapshotsParams;

    /**
     * Construct a SnapshotsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listSnapshots()
     * @param {Object} [params] - The parameters to be passed to listSnapshots()
     * @constructor
     * @returns {SnapshotsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListSnapshotsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSnapshots().
     * @returns {Promise<VpcV1.Snapshot[]>}
     */
    public async getNext(): Promise<VpcV1.Snapshot[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listSnapshots(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.snapshots;
    }

    /**
     * Returns all results by invoking listSnapshots() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Snapshot[]>}
     */
    public async getAll(): Promise<VpcV1.Snapshot[]> {
      const results: Snapshot[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ShareProfilesPager can be used to simplify the use of listShareProfiles().
   */
  export class ShareProfilesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListShareProfilesParams;

    /**
     * Construct a ShareProfilesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listShareProfiles()
     * @param {Object} [params] - The parameters to be passed to listShareProfiles()
     * @constructor
     * @returns {ShareProfilesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListShareProfilesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listShareProfiles().
     * @returns {Promise<VpcV1.ShareProfile[]>}
     */
    public async getNext(): Promise<VpcV1.ShareProfile[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listShareProfiles(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.profiles;
    }

    /**
     * Returns all results by invoking listShareProfiles() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ShareProfile[]>}
     */
    public async getAll(): Promise<VpcV1.ShareProfile[]> {
      const results: ShareProfile[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SharesPager can be used to simplify the use of listShares().
   */
  export class SharesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSharesParams;

    /**
     * Construct a SharesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listShares()
     * @param {Object} [params] - The parameters to be passed to listShares()
     * @constructor
     * @returns {SharesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListSharesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listShares().
     * @returns {Promise<VpcV1.Share[]>}
     */
    public async getNext(): Promise<VpcV1.Share[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listShares(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.shares;
    }

    /**
     * Returns all results by invoking listShares() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Share[]>}
     */
    public async getAll(): Promise<VpcV1.Share[]> {
      const results: Share[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ShareMountTargetsPager can be used to simplify the use of listShareMountTargets().
   */
  export class ShareMountTargetsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListShareMountTargetsParams;

    /**
     * Construct a ShareMountTargetsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listShareMountTargets()
     * @param {Object} params - The parameters to be passed to listShareMountTargets()
     * @constructor
     * @returns {ShareMountTargetsPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListShareMountTargetsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listShareMountTargets().
     * @returns {Promise<VpcV1.ShareMountTarget[]>}
     */
    public async getNext(): Promise<VpcV1.ShareMountTarget[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listShareMountTargets(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.mount_targets;
    }

    /**
     * Returns all results by invoking listShareMountTargets() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ShareMountTarget[]>}
     */
    public async getAll(): Promise<VpcV1.ShareMountTarget[]> {
      const results: ShareMountTarget[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VirtualNetworkInterfacesPager can be used to simplify the use of listVirtualNetworkInterfaces().
   */
  export class VirtualNetworkInterfacesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVirtualNetworkInterfacesParams;

    /**
     * Construct a VirtualNetworkInterfacesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVirtualNetworkInterfaces()
     * @param {Object} [params] - The parameters to be passed to listVirtualNetworkInterfaces()
     * @constructor
     * @returns {VirtualNetworkInterfacesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListVirtualNetworkInterfacesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVirtualNetworkInterfaces().
     * @returns {Promise<VpcV1.VirtualNetworkInterface[]>}
     */
    public async getNext(): Promise<VpcV1.VirtualNetworkInterface[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVirtualNetworkInterfaces(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.virtual_network_interfaces;
    }

    /**
     * Returns all results by invoking listVirtualNetworkInterfaces() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VirtualNetworkInterface[]>}
     */
    public async getAll(): Promise<VpcV1.VirtualNetworkInterface[]> {
      const results: VirtualNetworkInterface[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * PublicGatewaysPager can be used to simplify the use of listPublicGateways().
   */
  export class PublicGatewaysPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListPublicGatewaysParams;

    /**
     * Construct a PublicGatewaysPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listPublicGateways()
     * @param {Object} [params] - The parameters to be passed to listPublicGateways()
     * @constructor
     * @returns {PublicGatewaysPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListPublicGatewaysParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listPublicGateways().
     * @returns {Promise<VpcV1.PublicGateway[]>}
     */
    public async getNext(): Promise<VpcV1.PublicGateway[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listPublicGateways(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.public_gateways;
    }

    /**
     * Returns all results by invoking listPublicGateways() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.PublicGateway[]>}
     */
    public async getAll(): Promise<VpcV1.PublicGateway[]> {
      const results: PublicGateway[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * FloatingIpsPager can be used to simplify the use of listFloatingIps().
   */
  export class FloatingIpsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListFloatingIpsParams;

    /**
     * Construct a FloatingIpsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listFloatingIps()
     * @param {Object} [params] - The parameters to be passed to listFloatingIps()
     * @constructor
     * @returns {FloatingIpsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListFloatingIpsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listFloatingIps().
     * @returns {Promise<VpcV1.FloatingIP[]>}
     */
    public async getNext(): Promise<VpcV1.FloatingIP[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listFloatingIps(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.floating_ips;
    }

    /**
     * Returns all results by invoking listFloatingIps() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.FloatingIP[]>}
     */
    public async getAll(): Promise<VpcV1.FloatingIP[]> {
      const results: FloatingIP[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * NetworkAclsPager can be used to simplify the use of listNetworkAcls().
   */
  export class NetworkAclsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListNetworkAclsParams;

    /**
     * Construct a NetworkAclsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listNetworkAcls()
     * @param {Object} [params] - The parameters to be passed to listNetworkAcls()
     * @constructor
     * @returns {NetworkAclsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListNetworkAclsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listNetworkAcls().
     * @returns {Promise<VpcV1.NetworkACL[]>}
     */
    public async getNext(): Promise<VpcV1.NetworkACL[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listNetworkAcls(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.network_acls;
    }

    /**
     * Returns all results by invoking listNetworkAcls() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.NetworkACL[]>}
     */
    public async getAll(): Promise<VpcV1.NetworkACL[]> {
      const results: NetworkACL[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * NetworkAclRulesPager can be used to simplify the use of listNetworkAclRules().
   */
  export class NetworkAclRulesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListNetworkAclRulesParams;

    /**
     * Construct a NetworkAclRulesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listNetworkAclRules()
     * @param {Object} params - The parameters to be passed to listNetworkAclRules()
     * @constructor
     * @returns {NetworkAclRulesPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListNetworkAclRulesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listNetworkAclRules().
     * @returns {Promise<VpcV1.NetworkACLRuleItem[]>}
     */
    public async getNext(): Promise<VpcV1.NetworkACLRuleItem[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listNetworkAclRules(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.rules;
    }

    /**
     * Returns all results by invoking listNetworkAclRules() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.NetworkACLRuleItem[]>}
     */
    public async getAll(): Promise<VpcV1.NetworkACLRuleItem[]> {
      const results: NetworkACLRuleItem[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SecurityGroupsPager can be used to simplify the use of listSecurityGroups().
   */
  export class SecurityGroupsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSecurityGroupsParams;

    /**
     * Construct a SecurityGroupsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listSecurityGroups()
     * @param {Object} [params] - The parameters to be passed to listSecurityGroups()
     * @constructor
     * @returns {SecurityGroupsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListSecurityGroupsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSecurityGroups().
     * @returns {Promise<VpcV1.SecurityGroup[]>}
     */
    public async getNext(): Promise<VpcV1.SecurityGroup[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listSecurityGroups(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.security_groups;
    }

    /**
     * Returns all results by invoking listSecurityGroups() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.SecurityGroup[]>}
     */
    public async getAll(): Promise<VpcV1.SecurityGroup[]> {
      const results: SecurityGroup[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SecurityGroupTargetsPager can be used to simplify the use of listSecurityGroupTargets().
   */
  export class SecurityGroupTargetsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSecurityGroupTargetsParams;

    /**
     * Construct a SecurityGroupTargetsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listSecurityGroupTargets()
     * @param {Object} params - The parameters to be passed to listSecurityGroupTargets()
     * @constructor
     * @returns {SecurityGroupTargetsPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListSecurityGroupTargetsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSecurityGroupTargets().
     * @returns {Promise<VpcV1.SecurityGroupTargetReference[]>}
     */
    public async getNext(): Promise<VpcV1.SecurityGroupTargetReference[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listSecurityGroupTargets(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.targets;
    }

    /**
     * Returns all results by invoking listSecurityGroupTargets() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.SecurityGroupTargetReference[]>}
     */
    public async getAll(): Promise<VpcV1.SecurityGroupTargetReference[]> {
      const results: SecurityGroupTargetReference[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * IkePoliciesPager can be used to simplify the use of listIkePolicies().
   */
  export class IkePoliciesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListIkePoliciesParams;

    /**
     * Construct a IkePoliciesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listIkePolicies()
     * @param {Object} [params] - The parameters to be passed to listIkePolicies()
     * @constructor
     * @returns {IkePoliciesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListIkePoliciesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listIkePolicies().
     * @returns {Promise<VpcV1.IKEPolicy[]>}
     */
    public async getNext(): Promise<VpcV1.IKEPolicy[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listIkePolicies(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.ike_policies;
    }

    /**
     * Returns all results by invoking listIkePolicies() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.IKEPolicy[]>}
     */
    public async getAll(): Promise<VpcV1.IKEPolicy[]> {
      const results: IKEPolicy[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * IpsecPoliciesPager can be used to simplify the use of listIpsecPolicies().
   */
  export class IpsecPoliciesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListIpsecPoliciesParams;

    /**
     * Construct a IpsecPoliciesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listIpsecPolicies()
     * @param {Object} [params] - The parameters to be passed to listIpsecPolicies()
     * @constructor
     * @returns {IpsecPoliciesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListIpsecPoliciesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listIpsecPolicies().
     * @returns {Promise<VpcV1.IPsecPolicy[]>}
     */
    public async getNext(): Promise<VpcV1.IPsecPolicy[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listIpsecPolicies(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.ipsec_policies;
    }

    /**
     * Returns all results by invoking listIpsecPolicies() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.IPsecPolicy[]>}
     */
    public async getAll(): Promise<VpcV1.IPsecPolicy[]> {
      const results: IPsecPolicy[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpnGatewaysPager can be used to simplify the use of listVpnGateways().
   */
  export class VpnGatewaysPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpnGatewaysParams;

    /**
     * Construct a VpnGatewaysPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpnGateways()
     * @param {Object} [params] - The parameters to be passed to listVpnGateways()
     * @constructor
     * @returns {VpnGatewaysPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListVpnGatewaysParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpnGateways().
     * @returns {Promise<VpcV1.VPNGateway[]>}
     */
    public async getNext(): Promise<VpcV1.VPNGateway[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpnGateways(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.vpn_gateways;
    }

    /**
     * Returns all results by invoking listVpnGateways() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPNGateway[]>}
     */
    public async getAll(): Promise<VpcV1.VPNGateway[]> {
      const results: VPNGateway[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpnServersPager can be used to simplify the use of listVpnServers().
   */
  export class VpnServersPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpnServersParams;

    /**
     * Construct a VpnServersPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpnServers()
     * @param {Object} [params] - The parameters to be passed to listVpnServers()
     * @constructor
     * @returns {VpnServersPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListVpnServersParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpnServers().
     * @returns {Promise<VpcV1.VPNServer[]>}
     */
    public async getNext(): Promise<VpcV1.VPNServer[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpnServers(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.vpn_servers;
    }

    /**
     * Returns all results by invoking listVpnServers() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPNServer[]>}
     */
    public async getAll(): Promise<VpcV1.VPNServer[]> {
      const results: VPNServer[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpnServerClientsPager can be used to simplify the use of listVpnServerClients().
   */
  export class VpnServerClientsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpnServerClientsParams;

    /**
     * Construct a VpnServerClientsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpnServerClients()
     * @param {Object} params - The parameters to be passed to listVpnServerClients()
     * @constructor
     * @returns {VpnServerClientsPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListVpnServerClientsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpnServerClients().
     * @returns {Promise<VpcV1.VPNServerClient[]>}
     */
    public async getNext(): Promise<VpcV1.VPNServerClient[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpnServerClients(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.clients;
    }

    /**
     * Returns all results by invoking listVpnServerClients() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPNServerClient[]>}
     */
    public async getAll(): Promise<VpcV1.VPNServerClient[]> {
      const results: VPNServerClient[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpnServerRoutesPager can be used to simplify the use of listVpnServerRoutes().
   */
  export class VpnServerRoutesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpnServerRoutesParams;

    /**
     * Construct a VpnServerRoutesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpnServerRoutes()
     * @param {Object} params - The parameters to be passed to listVpnServerRoutes()
     * @constructor
     * @returns {VpnServerRoutesPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListVpnServerRoutesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpnServerRoutes().
     * @returns {Promise<VpcV1.VPNServerRoute[]>}
     */
    public async getNext(): Promise<VpcV1.VPNServerRoute[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpnServerRoutes(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.routes;
    }

    /**
     * Returns all results by invoking listVpnServerRoutes() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPNServerRoute[]>}
     */
    public async getAll(): Promise<VpcV1.VPNServerRoute[]> {
      const results: VPNServerRoute[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * LoadBalancerProfilesPager can be used to simplify the use of listLoadBalancerProfiles().
   */
  export class LoadBalancerProfilesPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListLoadBalancerProfilesParams;

    /**
     * Construct a LoadBalancerProfilesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listLoadBalancerProfiles()
     * @param {Object} [params] - The parameters to be passed to listLoadBalancerProfiles()
     * @constructor
     * @returns {LoadBalancerProfilesPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListLoadBalancerProfilesParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listLoadBalancerProfiles().
     * @returns {Promise<VpcV1.LoadBalancerProfile[]>}
     */
    public async getNext(): Promise<VpcV1.LoadBalancerProfile[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listLoadBalancerProfiles(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.profiles;
    }

    /**
     * Returns all results by invoking listLoadBalancerProfiles() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.LoadBalancerProfile[]>}
     */
    public async getAll(): Promise<VpcV1.LoadBalancerProfile[]> {
      const results: LoadBalancerProfile[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * LoadBalancersPager can be used to simplify the use of listLoadBalancers().
   */
  export class LoadBalancersPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListLoadBalancersParams;

    /**
     * Construct a LoadBalancersPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listLoadBalancers()
     * @param {Object} [params] - The parameters to be passed to listLoadBalancers()
     * @constructor
     * @returns {LoadBalancersPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListLoadBalancersParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listLoadBalancers().
     * @returns {Promise<VpcV1.LoadBalancer[]>}
     */
    public async getNext(): Promise<VpcV1.LoadBalancer[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listLoadBalancers(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.load_balancers;
    }

    /**
     * Returns all results by invoking listLoadBalancers() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.LoadBalancer[]>}
     */
    public async getAll(): Promise<VpcV1.LoadBalancer[]> {
      const results: LoadBalancer[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * EndpointGatewaysPager can be used to simplify the use of listEndpointGateways().
   */
  export class EndpointGatewaysPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListEndpointGatewaysParams;

    /**
     * Construct a EndpointGatewaysPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listEndpointGateways()
     * @param {Object} [params] - The parameters to be passed to listEndpointGateways()
     * @constructor
     * @returns {EndpointGatewaysPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListEndpointGatewaysParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listEndpointGateways().
     * @returns {Promise<VpcV1.EndpointGateway[]>}
     */
    public async getNext(): Promise<VpcV1.EndpointGateway[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listEndpointGateways(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.endpoint_gateways;
    }

    /**
     * Returns all results by invoking listEndpointGateways() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.EndpointGateway[]>}
     */
    public async getAll(): Promise<VpcV1.EndpointGateway[]> {
      const results: EndpointGateway[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * EndpointGatewayIpsPager can be used to simplify the use of listEndpointGatewayIps().
   */
  export class EndpointGatewayIpsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListEndpointGatewayIpsParams;

    /**
     * Construct a EndpointGatewayIpsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listEndpointGatewayIps()
     * @param {Object} params - The parameters to be passed to listEndpointGatewayIps()
     * @constructor
     * @returns {EndpointGatewayIpsPager}
     */
    constructor(
      client: VpcV1,
      params: VpcV1.ListEndpointGatewayIpsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listEndpointGatewayIps().
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getNext(): Promise<VpcV1.ReservedIP[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listEndpointGatewayIps(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.ips;
    }

    /**
     * Returns all results by invoking listEndpointGatewayIps() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getAll(): Promise<VpcV1.ReservedIP[]> {
      const results: ReservedIP[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * FlowLogCollectorsPager can be used to simplify the use of listFlowLogCollectors().
   */
  export class FlowLogCollectorsPager {
    protected _hasNext: boolean;
    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListFlowLogCollectorsParams;

    /**
     * Construct a FlowLogCollectorsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listFlowLogCollectors()
     * @param {Object} [params] - The parameters to be passed to listFlowLogCollectors()
     * @constructor
     * @returns {FlowLogCollectorsPager}
     */
    constructor(
      client: VpcV1,
      params?: VpcV1.ListFlowLogCollectorsParams
    ) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listFlowLogCollectors().
     * @returns {Promise<VpcV1.FlowLogCollector[]>}
     */
    public async getNext(): Promise<VpcV1.FlowLogCollector[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listFlowLogCollectors(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.flow_log_collectors;
    }

    /**
     * Returns all results by invoking listFlowLogCollectors() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.FlowLogCollector[]>}
     */
    public async getAll(): Promise<VpcV1.FlowLogCollector[]> {
      const results: FlowLogCollector[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }
}

export = VpcV1;
