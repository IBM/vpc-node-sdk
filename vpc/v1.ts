/**
 * (C) Copyright IBM Corp. 2023, 2024, 2025.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * IBM OpenAPI SDK Code Generator Version: 3.102.0-615ec964-20250307-203034
 */

/* eslint-disable max-classes-per-file */
/* eslint-disable no-await-in-loop */

import * as extend from 'extend';
import { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http';
import {
  AbortSignal,
  Authenticator,
  BaseService,
  SDKLogger,
  UserOptions,
  getAuthenticatorFromEnvironment,
  getNewLogger,
  getQueryParam,
  validateParams,
} from 'ibm-cloud-sdk-core';
import { getSdkHeaders } from '../lib/common';

/**
 * The IBM Cloud Virtual Private Cloud (VPC) API can be used to programmatically provision and manage virtual server
 * instances, along with subnets, volumes, load balancers, and more.
 *
 * API Version: 2025-04-22
 */

class VpcV1 extends BaseService {
  static _logger: SDKLogger = getNewLogger('VpcV1');

  static DEFAULT_SERVICE_URL: string = 'https://us-south.iaas.cloud.ibm.com/v1';

  static DEFAULT_SERVICE_NAME: string = 'vpc';

  private static _regionalEndpoints = new Map([
    ['au-syd', 'https://au-syd.iaas.cloud.ibm.com/v1'], // Australia (Sydney)
    ['br-sao', 'https://br-sao.iaas.cloud.ibm.com/v1'], // Brazil (Sao Paulo)
    ['ca-mon', 'https://ca-mon.iaas.cloud.ibm.com/v1'], // Canada (Montreal)
    ['ca-tor', 'https://ca-tor.iaas.cloud.ibm.com/v1'], // Canada (Toronto)
    ['eu-de', 'https://eu-de.iaas.cloud.ibm.com/v1'], // Germany (Frankfurt)
    ['eu-es', 'https://eu-es.iaas.cloud.ibm.com/v1'], // Spain (Madrid)
    ['eu-gb', 'https://eu-gb.iaas.cloud.ibm.com/v1'], // United Kingdom (London)
    ['jp-osa', 'https://jp-osa.iaas.cloud.ibm.com/v1'], // Japan (Osaka)
    ['jp-tok', 'https://jp-tok.iaas.cloud.ibm.com/v1'], // Japan (Tokyo)
    ['us-east', 'https://us-east.iaas.cloud.ibm.com/v1'], // US East (Washington DC)
    ['us-south', 'https://us-south.iaas.cloud.ibm.com/v1'], // US South (Dallas)
  ]);

  /**
   * Returns the service URL associated with the specified region.
   * @param region a string representing the region
   * @returns the service URL associated with the specified region or undefined
   * if no mapping for the region exists
   */
  public static getServiceUrlForRegion(region: string): string {
    return this._regionalEndpoints.get(region)
  }

  /*************************
   * Factory method
   ************************/

  /**
   * Constructs an instance of VpcV1 with passed in options and external configuration.
   *
   * @param {UserOptions} [options] - The parameters to send to the service.
   * @param {string} [options.serviceName] - The name of the service to configure
   * @param {Authenticator} [options.authenticator] - The Authenticator object used to authenticate requests to the service
   * @param {string} [options.serviceUrl] - The base URL for the service
   * @returns {VpcV1}
   */

  public static newInstance(options: UserOptions): VpcV1 {
    options = options || {};

    if (!options.serviceName) {
      options.serviceName = this.DEFAULT_SERVICE_NAME;
    }
    if (!options.authenticator) {
      options.authenticator = getAuthenticatorFromEnvironment(options.serviceName);
    }
    const service = new VpcV1(options);
    service.configureService(options.serviceName);
    if (options.serviceUrl) {
      service.setServiceUrl(options.serviceUrl);
    }
    return service;
  }

  /** The infrastructure generation. For the API behavior documented here, specify `2`. */
  generation?: number;

  /** The API version, in format `YYYY-MM-DD`. For the API behavior documented here, specify any date between
   *  `2025-04-08` and `2025-04-23`.
   */
  version: string;

  /**
   * Construct a VpcV1 object.
   *
   * @param {Object} options - Options for the service.
   * @param {number} [options.generation] - The infrastructure generation. For the API behavior documented here, specify
   * `2`.
   * @param {string} options.version - The API version, in format `YYYY-MM-DD`. For the API behavior documented here,
   * specify any date between `2025-04-08` and `2025-04-23`.
   * @param {string} [options.serviceUrl] - The base URL for the service
   * @param {OutgoingHttpHeaders} [options.headers] - Default headers that shall be included with every request to the service.
   * @param {Authenticator} options.authenticator - The Authenticator object used to authenticate requests to the service
   * @constructor
   * @returns {VpcV1}
   */
  constructor(options: UserOptions) {
    options = options || {};

    const _requiredParams = ['version'];
    const _validationErrors = validateParams(options, _requiredParams, null);
    if (_validationErrors) {
      throw _validationErrors;
    }
    super(options);
    if (options.serviceUrl) {
      this.setServiceUrl(options.serviceUrl);
    } else {
      this.setServiceUrl(VpcV1.DEFAULT_SERVICE_URL);
    }
    this.generation = options.generation;
    if (!('generation' in options)) {
      this.generation = 2;
    }
    this.version = options.version || '2025-04-22';
  }

  /*************************
   * vPCs
   ************************/

  /**
   * List VPCs.
   *
   * This request lists VPCs in the region. A VPC is a virtual network that belongs to an account and provides logical
   * isolation from other networks. A VPC is made up of resources in one or more zones. VPCs are regional, and each VPC
   * can contain resources in multiple zones in a region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {boolean} [params.classicAccess] - Filters the collection to VPCs with a `classic_access` property matching
   * the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPCCollection>>}
   */
  public listVpcs(
    params?: VpcV1.ListVpcsParams
  ): Promise<VpcV1.Response<VpcV1.VPCCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'classicAccess', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'classic_access': _params.classicAccess,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpcs');

    const parameters = {
      options: {
        url: '/vpcs',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a VPC.
   *
   * This request creates a new VPC from a VPC prototype object. The prototype object is structured in the same way as a
   * retrieved VPC, and contains the information necessary to create the new VPC.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.addressPrefixManagement] - Indicates whether a [default address
   * prefix](https://cloud.ibm.com/docs/vpc?topic=vpc-configuring-address-prefixes) will be automatically created for
   * each zone in this VPC. If `manual`, this VPC will be created with no default address prefixes.
   *
   * Since address prefixes are managed identically regardless of whether they were automatically created, the value is
   * not preserved as a VPC property.
   * @param {boolean} [params.classicAccess] - Deprecated: Indicates whether this VPC will be connected to Classic
   * Infrastructure. If true, this VPC's resources will have private network connectivity to the account's Classic
   * Infrastructure resources. Only one VPC, per region, may be connected in this way. This value is set at creation and
   * subsequently immutable.
   *
   * This property has been deprecated. Instead, use a [Transit Gateway](https://cloud.ibm.com/docs/transit-gateway) to
   * connect this VPC to Classic Infrastructure. For more information, see [upcoming
   * changes](https://cloud.ibm.com/docs/vpc?topic=vpc-api-change-log#upcoming-changes).
   * @param {VPCDNSPrototype} [params.dns] - The DNS configuration for this VPC.
   *
   * If unspecified, the system will assign DNS servers capable of resolving hosts and endpoint
   * gateways within this VPC, and hosts on the internet.
   * @param {string} [params.name] - The name for this VPC. The name must not be used by another VPC in the region. If
   * unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPC>>}
   */
  public createVpc(
    params?: VpcV1.CreateVpcParams
  ): Promise<VpcV1.Response<VpcV1.VPC>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['addressPrefixManagement', 'classicAccess', 'dns', 'name', 'resourceGroup', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'address_prefix_management': _params.addressPrefixManagement,
      'classic_access': _params.classicAccess,
      'dns': _params.dns,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVpc');

    const parameters = {
      options: {
        url: '/vpcs',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPC.
   *
   * This request deletes a VPC. This operation cannot be reversed.
   *
   * For this request to succeed:
   * - Instances, subnets, public gateways, endpoint gateways, and private path service
   *   gateways must not reside in this VPC
   * - The VPC must not be providing DNS resolution for any other VPCs
   * - If `dns.enable_hub` is `true`, `dns.resolution_binding_count` must be zero
   *
   * All security groups and network ACLs associated with the VPC are automatically deleted. All flow log collectors
   * with `auto_delete` set to `true` targeting the VPC or any resource in the VPC are automatically deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpc(
    params: VpcV1.DeleteVpcParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVpc');

    const parameters = {
      options: {
        url: '/vpcs/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC.
   *
   * This request retrieves a single VPC specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPC>>}
   */
  public getVpc(
    params: VpcV1.GetVpcParams
  ): Promise<VpcV1.Response<VpcV1.VPC>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpc');

    const parameters = {
      options: {
        url: '/vpcs/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPC.
   *
   * This request updates a VPC with the information provided in a VPC patch object. The patch object is structured in
   * the same way as a retrieved VPC and needs to contain only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {VPCDNSPatch} [params.dns] - The DNS configuration for this VPC.
   * @param {string} [params.name] - The name for this VPC. The name must not be used by another VPC in the region.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPC>>}
   */
  public updateVpc(
    params: VpcV1.UpdateVpcParams
  ): Promise<VpcV1.Response<VpcV1.VPC>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'dns', 'name', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'dns': _params.dns,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVpc');

    const parameters = {
      options: {
        url: '/vpcs/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC's default network ACL.
   *
   * This request retrieves the default network ACL for the VPC specified by the identifier in the URL. The default
   * network ACL is applied to any new subnets in the VPC which do not specify a network ACL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DefaultNetworkACL>>}
   */
  public getVpcDefaultNetworkAcl(
    params: VpcV1.GetVpcDefaultNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.DefaultNetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpcDefaultNetworkAcl');

    const parameters = {
      options: {
        url: '/vpcs/{id}/default_network_acl',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC's default routing table.
   *
   * This request retrieves the default routing table for the VPC specified by the identifier in the URL. The default
   * routing table is associated with any subnets in the VPC which have not been explicitly associated with another
   * routing table.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DefaultRoutingTable>>}
   */
  public getVpcDefaultRoutingTable(
    params: VpcV1.GetVpcDefaultRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.DefaultRoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpcDefaultRoutingTable');

    const parameters = {
      options: {
        url: '/vpcs/{id}/default_routing_table',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC's default security group.
   *
   * This request retrieves the default security group for the VPC specified by the identifier in the URL. Resources
   * created in this VPC that allow a security group to be optionally specified will use this security group by default.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPC identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DefaultSecurityGroup>>}
   */
  public getVpcDefaultSecurityGroup(
    params: VpcV1.GetVpcDefaultSecurityGroupParams
  ): Promise<VpcV1.Response<VpcV1.DefaultSecurityGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpcDefaultSecurityGroup');

    const parameters = {
      options: {
        url: '/vpcs/{id}/default_security_group',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List address prefixes for a VPC.
   *
   * This request lists address pool prefixes for a VPC.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.AddressPrefixCollection>>}
   */
  public listVpcAddressPrefixes(
    params: VpcV1.ListVpcAddressPrefixesParams
  ): Promise<VpcV1.Response<VpcV1.AddressPrefixCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId'];
    const _validParams = ['vpcId', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpcAddressPrefixes');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/address_prefixes',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an address prefix for a VPC.
   *
   * This request creates a new prefix from a prefix prototype object. The prototype object is structured in the same
   * way as a retrieved prefix, and contains the information necessary to create the new prefix.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.cidr - The IPv4 range of the address prefix, expressed in CIDR format. The range must not
   * overlap with any existing address prefixes in the VPC or any of the following reserved address ranges:
   *
   *   - `127.0.0.0/8` (IPv4 loopback addresses)
   *   - `161.26.0.0/16` (IBM services)
   *   - `166.8.0.0/14` (Cloud Service Endpoints)
   *   - `169.254.0.0/16` (IPv4 link-local addresses)
   *   - `224.0.0.0/4` (IPv4 multicast addresses)
   *
   * The prefix length of the address prefix's CIDR must be between `/9` (8,388,608 addresses) and `/29` (8 addresses).
   * @param {ZoneIdentity} params.zone - The zone this address prefix will reside in.
   * @param {boolean} [params.isDefault] - Indicates whether this will be the default address prefix for this zone in
   * this VPC. If `true`, the VPC must not have a default address prefix for this zone.
   * @param {string} [params.name] - The name for this address prefix. The name must not be used by another address
   * prefix for the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.AddressPrefix>>}
   */
  public createVpcAddressPrefix(
    params: VpcV1.CreateVpcAddressPrefixParams
  ): Promise<VpcV1.Response<VpcV1.AddressPrefix>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'cidr', 'zone'];
    const _validParams = ['vpcId', 'cidr', 'zone', 'isDefault', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'cidr': _params.cidr,
      'zone': _params.zone,
      'is_default': _params.isDefault,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVpcAddressPrefix');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/address_prefixes',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an address prefix.
   *
   * This request deletes a prefix. This operation cannot be reversed. The request will fail if any subnets use
   * addresses from this prefix.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The prefix identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpcAddressPrefix(
    params: VpcV1.DeleteVpcAddressPrefixParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVpcAddressPrefix');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/address_prefixes/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an address prefix.
   *
   * This request retrieves a single prefix specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The prefix identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.AddressPrefix>>}
   */
  public getVpcAddressPrefix(
    params: VpcV1.GetVpcAddressPrefixParams
  ): Promise<VpcV1.Response<VpcV1.AddressPrefix>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpcAddressPrefix');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/address_prefixes/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an address prefix.
   *
   * This request updates a prefix with the information in a provided prefix patch. The prefix patch object is
   * structured in the same way as a retrieved prefix and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The prefix identifier.
   * @param {boolean} [params.isDefault] - Indicates whether this is the default prefix for this zone in this VPC.
   * Updating to true makes this prefix the default prefix for this zone in this VPC, provided the VPC currently has no
   * default address prefix for this zone. Updating to false removes the default prefix for this zone in this VPC.
   * @param {string} [params.name] - The name for this address prefix. The name must not be used by another address
   * prefix for the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.AddressPrefix>>}
   */
  public updateVpcAddressPrefix(
    params: VpcV1.UpdateVpcAddressPrefixParams
  ): Promise<VpcV1.Response<VpcV1.AddressPrefix>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'isDefault', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'is_default': _params.isDefault,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVpcAddressPrefix');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/address_prefixes/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List DNS resolution bindings for a VPC.
   *
   * This request lists DNS resolution bindings for a VPC. A DNS resolution binding represents an association with
   * another VPC for centralizing DNS name resolution.
   *
   * If the VPC specified by the identifier in the URL is a DNS hub VPC (has `dns.enable_hub` set to `true`) then there
   * is one binding for each VPC bound to the hub VPC. The endpoint gateways in the bound VPCs can allow (using
   * `allow_dns_resolution_binding`) the hub VPC to centralize resolution of their DNS names.
   *
   * If the VPC specified by the identifier in the URL is not a DNS hub VPC, then there is at most one binding (to a hub
   * VPC). The endpoint gateways in the VPC specified by the identifier in the URL can allow (using
   * `allow_dns_resolution_binding`) its hub VPC to centralize resolution of their DNS names.
   *
   * To make use of centralized DNS resolution, a VPC bound to a DNS hub VPC must delegate DNS resolution to its hub VPC
   * by setting `dns.resolver.type` to `delegate`.
   *
   * The bindings will be sorted by their `created_at` property values, with newest bindings first. Bindings with
   * identical `created_at` property values will in turn be sorted by ascending `name` property values.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.vpcCrn] - Filters the collection to resources with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to resources with a `vpc.name` property matching the
   * exact specified name.
   * @param {string} [params.accountId] - Filters the collection to resources with a `vpc.remote.account.id` property
   * matching the specified account identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPCDNSResolutionBindingCollection>>}
   */
  public listVpcDnsResolutionBindings(
    params: VpcV1.ListVpcDnsResolutionBindingsParams
  ): Promise<VpcV1.Response<VpcV1.VPCDNSResolutionBindingCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId'];
    const _validParams = ['vpcId', 'sort', 'start', 'limit', 'name', 'vpcCrn', 'vpcName', 'accountId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'sort': _params.sort,
      'start': _params.start,
      'limit': _params.limit,
      'name': _params.name,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
      'account.id': _params.accountId,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpcDnsResolutionBindings');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/dns_resolution_bindings',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a DNS resolution binding.
   *
   * This request creates a new DNS resolution binding from a DNS resolution binding prototype object. The prototype
   * object is structured in the same way as a retrieved DNS resolution binding, and contains the information necessary
   * to create the new DNS resolution binding.
   *
   * For this request to succeed, `dns.enable_hub` must be `false` for the VPC specified by the identifier in the URL,
   * and the VPC must not already have a DNS resolution binding.
   *
   * See [About DNS sharing for VPE gateways](/docs/vpc?topic=vpc-vpe-dns-sharing) for more information.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {VPCIdentity} params.vpc - Another VPC to bind this VPC to for DNS resolution. The VPC must have
   * `dns.enable_hub` set to `true`, and may be in a different account (subject to
   * IAM policies).
   *
   * Additionally, the VPC specified in the URL (this VPC) must have `dns.enable_hub`
   * set to `false` and a `dns.resolution_binding_count` of zero.
   * @param {string} [params.name] - The name for this DNS resolution binding. The name must not be used by another DNS
   * resolution binding for the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPCDNSResolutionBinding>>}
   */
  public createVpcDnsResolutionBinding(
    params: VpcV1.CreateVpcDnsResolutionBindingParams
  ): Promise<VpcV1.Response<VpcV1.VPCDNSResolutionBinding>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'vpc'];
    const _validParams = ['vpcId', 'vpc', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'vpc': _params.vpc,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVpcDnsResolutionBinding');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/dns_resolution_bindings',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a DNS resolution binding.
   *
   * This request deletes a DNS resolution binding. This operation cannot be reversed.
   *
   * For this request to succeed, the VPC specified by the identifier in the URL must not have
   * `dns.resolver.type` set to `delegated`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The DNS resolution binding identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPCDNSResolutionBinding>>}
   */
  public deleteVpcDnsResolutionBinding(
    params: VpcV1.DeleteVpcDnsResolutionBindingParams
  ): Promise<VpcV1.Response<VpcV1.VPCDNSResolutionBinding>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVpcDnsResolutionBinding');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/dns_resolution_bindings/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a DNS resolution binding.
   *
   * This request retrieves a single DNS resolution binding specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The DNS resolution binding identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPCDNSResolutionBinding>>}
   */
  public getVpcDnsResolutionBinding(
    params: VpcV1.GetVpcDnsResolutionBindingParams
  ): Promise<VpcV1.Response<VpcV1.VPCDNSResolutionBinding>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpcDnsResolutionBinding');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/dns_resolution_bindings/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a DNS resolution binding.
   *
   * This request updates a DNS resolution binding with the information in a provided DNS resolution binding patch. The
   * DNS resolution binding patch object is structured in the same way as a retrieved DNS resolution binding and
   * contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The DNS resolution binding identifier.
   * @param {string} [params.name] - The name for this DNS resolution binding. The name must not be used by another DNS
   * resolution binding for the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPCDNSResolutionBinding>>}
   */
  public updateVpcDnsResolutionBinding(
    params: VpcV1.UpdateVpcDnsResolutionBindingParams
  ): Promise<VpcV1.Response<VpcV1.VPCDNSResolutionBinding>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVpcDnsResolutionBinding');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/dns_resolution_bindings/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List routes in a VPC's default routing table.
   *
   * This request lists routes in the VPC's default routing table. Each route is zone-specific and directs any packets
   * matching its destination CIDR block to a `next_hop` IP address. The most specific route matching a packet's
   * destination will be used. If multiple equally-specific routes exist, traffic will be distributed across them.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} [params.zoneName] - Filters the collection to resources with a `zone.name` property matching the
   * exact specified name.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RouteCollectionVPCContext>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public listVpcRoutes(
    params: VpcV1.ListVpcRoutesParams
  ): Promise<VpcV1.Response<VpcV1.RouteCollectionVPCContext>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: listVpcRoutes');
    const _params = { ...params };
    const _requiredParams = ['vpcId'];
    const _validParams = ['vpcId', 'zoneName', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'zone.name': _params.zoneName,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpcRoutes');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routes',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a route in a VPC's default routing table.
   *
   * This request creates a new route in the VPC's default routing table. The route prototype object is structured in
   * the same way as a retrieved route, and contains the information necessary to create the new route. The request will
   * fail if the new route will cause a loop.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.destination - The destination CIDR of the route. The host identifier in the CIDR must be
   * zero.
   *
   * At most two routes per `zone` in a table can have the same `destination` and
   * `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
   * @param {ZoneIdentity} params.zone - The zone to apply the route to.
   *
   * If subnets are attached to the route's routing table, egress traffic from those
   * subnets in this zone will be subject to this route. If this route's routing table
   * has any of `route_direct_link_ingress`, `route_internet_ingress`,
   * `route_transit_gateway_ingress` or `route_vpc_zone_ingress`  set to`true`, traffic
   * from those ingress sources arriving in this zone will be subject to this route.
   * @param {string} [params.action] - The action to perform with a packet matching the route:
   * - `delegate`: delegate to system-provided routes
   * - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
   * - `deliver`: deliver the packet to the specified `next_hop`
   * - `drop`: drop the packet.
   * @param {boolean} [params.advertise] - Indicates whether this route will be advertised to the ingress sources
   * specified by the `advertise_routes_to` routing table property.
   *
   * All routes in a routing table with the same `destination` and `zone` must have the same
   * `advertise` value.
   * @param {string} [params.name] - The name for this route. The name must not be used by another route in the routing
   * table. Names starting with `ibm-` are reserved for system-provided routes, and are not allowed. If unspecified, the
   * name will be a hyphenated list of randomly-selected words.
   * @param {RouteNextHopPrototype} [params.nextHop] - If `action` is `deliver`, the next hop that packets will be
   * delivered to (must not be
   * `0.0.0.0`). For other `action` values, it must be omitted or specified as `0.0.0.0`.
   *
   * At most two routes per `zone` in a table can have the same `destination` and `priority`,
   * and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
   * @param {number} [params.priority] - The priority of this route. Smaller values have higher priority.
   *
   * If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
   * priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
   * distributed between them.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public createVpcRoute(
    params: VpcV1.CreateVpcRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: createVpcRoute');
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'destination', 'zone'];
    const _validParams = ['vpcId', 'destination', 'zone', 'action', 'advertise', 'name', 'nextHop', 'priority', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'destination': _params.destination,
      'zone': _params.zone,
      'action': _params.action,
      'advertise': _params.advertise,
      'name': _params.name,
      'next_hop': _params.nextHop,
      'priority': _params.priority,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVpcRoute');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routes',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPC route.
   *
   * This request deletes a route. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public deleteVpcRoute(
    params: VpcV1.DeleteVpcRouteParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: deleteVpcRoute');
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVpcRoute');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routes/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC route.
   *
   * This request retrieves a single route specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public getVpcRoute(
    params: VpcV1.GetVpcRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: getVpcRoute');
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpcRoute');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routes/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPC route.
   *
   * This request updates a route with the information in a provided route patch. The route patch object is structured
   * in the same way as a retrieved route and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The route identifier.
   * @param {boolean} [params.advertise] - Indicates whether this route will be advertised to the ingress sources
   * specified by the `advertise_routes_to` routing table property.
   *
   * Since all routes in a routing table with the same `destination` and `zone` must have the same `advertise` value,
   * this property can only be changed for routes with a unique
   * `destination` and `zone` in the routing table. For more information, see [Advertising
   * routes](https://cloud.ibm.com/docs/vpc?topic=vpc-about-custom-routes#rt-advertising-routes).
   * @param {string} [params.name] - The name for this route. The name must not be used by another route in the routing
   * table. Names starting with `ibm-` are reserved for system-provided routes, and are not allowed.
   * @param {RouteNextHopPatch} [params.nextHop] - If `action` is `deliver`, the next hop that packets will be delivered
   * to (must not be
   * `0.0.0.0`). For other `action` values, specify `0.0.0.0` or remove it by specifying
   * `null`.
   *
   * At most two routes per `zone` in a table can have the same `destination` and `priority`,
   * and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
   * @param {number} [params.priority] - The priority of this route. Smaller values have higher priority.
   *
   * If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
   * priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
   * distributed between them.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public updateVpcRoute(
    params: VpcV1.UpdateVpcRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: updateVpcRoute');
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'advertise', 'name', 'nextHop', 'priority', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'advertise': _params.advertise,
      'name': _params.name,
      'next_hop': _params.nextHop,
      'priority': _params.priority,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVpcRoute');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routes/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List routing tables for a VPC.
   *
   * This request lists routing tables for a VPC. Each subnet in a VPC is associated with a routing table, which
   * controls delivery of packets sent on that subnet according to the action of the most specific matching route in the
   * table. If multiple equally-specific routes exist, traffic will be distributed across them. If no routes match,
   * delivery will be controlled by the system's built-in routes.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {boolean} [params.isDefault] - Filters the collection to routing tables with an `is_default` property
   * matching the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTableCollection>>}
   */
  public listVpcRoutingTables(
    params: VpcV1.ListVpcRoutingTablesParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTableCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId'];
    const _validParams = ['vpcId', 'start', 'limit', 'isDefault', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'is_default': _params.isDefault,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpcRoutingTables');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a routing table for a VPC.
   *
   * This request creates a routing table from a routing table prototype object. The prototype object is structured in
   * the same way as a retrieved routing table, and contains the information necessary to create the new routing table.
   *
   * At present, the routing table's `resource_group` will be inherited from its VPC, but may be specifiable in the
   * future.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {ResourceFilter[]} [params.acceptRoutesFrom] - The filters specifying the resources that may create routes
   * in this routing table.
   *
   * If specified, `resource_type` must be `vpn_gateway` or `vpn_server`.
   * @param {string[]} [params.advertiseRoutesTo] - The ingress sources to advertise routes to. Routes in the table with
   * `advertise` enabled will be advertised to these sources.
   * @param {string} [params.name] - The name for this routing table. The name must not be used by another routing table
   * in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {boolean} [params.routeDirectLinkIngress] - If set to `true`, this routing table will be used to route
   * traffic that originates from [Direct Link](https://cloud.ibm.com/docs/dl) to this VPC. The VPC must not already
   * have a routing table with this property set to `true`.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
   * able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
   * connection, the packet will be dropped.
   *
   * If [Classic Access](https://cloud.ibm.com/docs/vpc?topic=vpc-setting-up-access-to-classic-infrastructure) is
   * enabled for this VPC, and this property is set to `true`, its incoming traffic will also be routed according to
   * this routing table.
   * @param {boolean} [params.routeInternetIngress] - If set to `true`, this routing table will be used to route traffic
   * that originates from the internet. For this to succeed, the VPC must not already have a routing table with this
   * property set to `true`.
   *
   * Incoming traffic will be routed according to the routing table with two exceptions:
   * - Traffic destined for IP addresses associated with public gateways will not be
   *   subject to routes in this routing table.
   * - Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is
   *   an IP address in a subnet in the route's `zone` that is able to accept traffic.
   *   Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
   *   connection, the packet will be dropped.
   * @param {boolean} [params.routeTransitGatewayIngress] - If set to `true`, this routing table will be used to route
   * traffic that originates from [Transit Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC. The VPC
   * must not already have a routing table with this property set to `true`.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
   * able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
   * connection, the packet will be dropped.
   * @param {boolean} [params.routeVpcZoneIngress] - If set to `true`, this routing table will be used to route traffic
   * that originates from subnets in other zones in this VPC. The VPC must not already have a routing table with this
   * property set to `true`.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
   * able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
   * connection, the packet will be dropped.
   * @param {RoutePrototype[]} [params.routes] - The prototype objects for routes to create for this routing table. If
   * unspecified, the routing table will be created with no routes.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTable>>}
   */
  public createVpcRoutingTable(
    params: VpcV1.CreateVpcRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId'];
    const _validParams = ['vpcId', 'acceptRoutesFrom', 'advertiseRoutesTo', 'name', 'routeDirectLinkIngress', 'routeInternetIngress', 'routeTransitGatewayIngress', 'routeVpcZoneIngress', 'routes', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'accept_routes_from': _params.acceptRoutesFrom,
      'advertise_routes_to': _params.advertiseRoutesTo,
      'name': _params.name,
      'route_direct_link_ingress': _params.routeDirectLinkIngress,
      'route_internet_ingress': _params.routeInternetIngress,
      'route_transit_gateway_ingress': _params.routeTransitGatewayIngress,
      'route_vpc_zone_ingress': _params.routeVpcZoneIngress,
      'routes': _params.routes,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVpcRoutingTable');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPC routing table.
   *
   * This request deletes a routing table.  A routing table cannot be deleted if it is associated with any subnets in
   * the VPC. Additionally, a VPC's default routing table cannot be deleted. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The routing table identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpcRoutingTable(
    params: VpcV1.DeleteVpcRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVpcRoutingTable');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC routing table.
   *
   * This request retrieves a single routing table specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The routing table identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTable>>}
   */
  public getVpcRoutingTable(
    params: VpcV1.GetVpcRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpcRoutingTable');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPC routing table.
   *
   * This request updates a routing table with the information in a provided routing table patch. The patch object is
   * structured in the same way as a retrieved table and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.id - The routing table identifier.
   * @param {ResourceFilter[]} [params.acceptRoutesFrom] - The filters specifying the resources that may create routes
   * in this routing table
   * (replacing any existing filters). All routes created by resources that match a given filter will be removed when an
   * existing filter is removed. Therefore, if an empty array is specified, all filters will be removed, resulting in
   * all routes not directly created by the user being removed.
   *
   * If specified, `resource_type` must be `vpn_gateway` or `vpn_server`.
   * @param {string[]} [params.advertiseRoutesTo] - The ingress sources to advertise routes to, replacing any existing
   * sources to advertise to. Routes in the table with `advertise` enabled will be advertised to these sources.
   * @param {string} [params.name] - The name for this routing table. The name must not be used by another routing table
   * in the VPC.
   * @param {boolean} [params.routeDirectLinkIngress] - Indicates whether this routing table is used to route traffic
   * that originates from
   * [Direct Link](https://cloud.ibm.com/docs/dl/) to this VPC. Updating to `true` selects this routing table, provided
   * no other routing table in the VPC already has this property set to `true`, and no subnets are attached to this
   * routing table. Updating to
   * `false` deselects this routing table, provided `direct_link` is absent from
   * `advertise_routes_to`.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
   * able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
   * connection, the packet will be dropped.
   * @param {boolean} [params.routeInternetIngress] - Indicates whether this routing table is used to route traffic that
   * originates from the internet.  Updating to `true` selects this routing table, provided no other routing table in
   * the VPC already has this property set to `true`.  Updating to `false` deselects this routing table.
   *
   * Incoming traffic will be routed according to the routing table with two exceptions:
   * -  Traffic destined for IP addresses associated with public gateways will not be subject
   *    to routes in this routing table.
   * -  Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is an
   *    IP address in a subnet in the route's `zone` that is able to accept traffic.
   *    Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
   *    connection, the packet will be dropped.
   * @param {boolean} [params.routeTransitGatewayIngress] - Indicates whether this routing table is used to route
   * traffic that originates from
   * [Transit Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC. Updating to
   * `true` selects this routing table, provided no other routing table in the VPC already has this property set to
   * `true`, and no subnets are attached to this routing table. Updating to `false` deselects this routing table,
   * provided `transit_gateway` is absent from `advertise_routes_to`.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
   * able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
   * connection, the packet will be dropped.
   *
   * If [Classic Access](https://cloud.ibm.com/docs/vpc?topic=vpc-setting-up-access-to-classic-infrastructure) is
   * enabled for this VPC, and this property is set to `true`, its incoming traffic will also be routed according to
   * this routing table.
   * @param {boolean} [params.routeVpcZoneIngress] - Indicates whether this routing table is used to route traffic that
   * originates from subnets in other zones in this VPC. Updating to `true` selects this routing table, provided no
   * other routing table in the VPC already has this property set to `true`, and no subnets are attached to this routing
   * table. Updating to `false` deselects this routing table.
   *
   * Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
   * `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
   * able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
   * connection, the packet will be dropped.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTable>>}
   */
  public updateVpcRoutingTable(
    params: VpcV1.UpdateVpcRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'id'];
    const _validParams = ['vpcId', 'id', 'acceptRoutesFrom', 'advertiseRoutesTo', 'name', 'routeDirectLinkIngress', 'routeInternetIngress', 'routeTransitGatewayIngress', 'routeVpcZoneIngress', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'accept_routes_from': _params.acceptRoutesFrom,
      'advertise_routes_to': _params.advertiseRoutesTo,
      'name': _params.name,
      'route_direct_link_ingress': _params.routeDirectLinkIngress,
      'route_internet_ingress': _params.routeInternetIngress,
      'route_transit_gateway_ingress': _params.routeTransitGatewayIngress,
      'route_vpc_zone_ingress': _params.routeVpcZoneIngress,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVpcRoutingTable');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List routes in a VPC routing table.
   *
   * This request lists routes in a VPC routing table. If subnets are associated with this routing table, delivery of
   * packets sent on a subnet is performed according to the action of the most specific matching route in the table
   * (provided the subnet and route are in the same zone). If multiple equally-specific routes exist, the route with the
   * highest priority will be used. If two matching routes have the same destination and priority, traffic will be
   * distributed between them. If no routes match, delivery will be controlled by the system's built-in routes.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.routingTableId - The routing table identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RouteCollection>>}
   */
  public listVpcRoutingTableRoutes(
    params: VpcV1.ListVpcRoutingTableRoutesParams
  ): Promise<VpcV1.Response<VpcV1.RouteCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'routingTableId'];
    const _validParams = ['vpcId', 'routingTableId', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'routing_table_id': _params.routingTableId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpcRoutingTableRoutes');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a route in a VPC routing table.
   *
   * This request creates a new VPC route from a VPC route prototype object. The prototype object is structured in the
   * same way as a retrieved VPC route and contains the information necessary to create the route.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.routingTableId - The routing table identifier.
   * @param {string} params.destination - The destination CIDR of the route. The host identifier in the CIDR must be
   * zero.
   *
   * At most two routes per `zone` in a table can have the same `destination` and
   * `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
   * @param {ZoneIdentity} params.zone - The zone to apply the route to.
   *
   * If subnets are attached to the route's routing table, egress traffic from those
   * subnets in this zone will be subject to this route. If this route's routing table
   * has any of `route_direct_link_ingress`, `route_internet_ingress`,
   * `route_transit_gateway_ingress` or `route_vpc_zone_ingress`  set to`true`, traffic
   * from those ingress sources arriving in this zone will be subject to this route.
   * @param {string} [params.action] - The action to perform with a packet matching the route:
   * - `delegate`: delegate to system-provided routes
   * - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
   * - `deliver`: deliver the packet to the specified `next_hop`
   * - `drop`: drop the packet.
   * @param {boolean} [params.advertise] - Indicates whether this route will be advertised to the ingress sources
   * specified by the `advertise_routes_to` routing table property.
   *
   * All routes in a routing table with the same `destination` and `zone` must have the same
   * `advertise` value.
   * @param {string} [params.name] - The name for this route. The name must not be used by another route in the routing
   * table. Names starting with `ibm-` are reserved for system-provided routes, and are not allowed. If unspecified, the
   * name will be a hyphenated list of randomly-selected words.
   * @param {RouteNextHopPrototype} [params.nextHop] - If `action` is `deliver`, the next hop that packets will be
   * delivered to (must not be
   * `0.0.0.0`). For other `action` values, it must be omitted or specified as `0.0.0.0`.
   *
   * At most two routes per `zone` in a table can have the same `destination` and `priority`,
   * and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
   * @param {number} [params.priority] - The priority of this route. Smaller values have higher priority.
   *
   * If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
   * priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
   * distributed between them.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   */
  public createVpcRoutingTableRoute(
    params: VpcV1.CreateVpcRoutingTableRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'routingTableId', 'destination', 'zone'];
    const _validParams = ['vpcId', 'routingTableId', 'destination', 'zone', 'action', 'advertise', 'name', 'nextHop', 'priority', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'destination': _params.destination,
      'zone': _params.zone,
      'action': _params.action,
      'advertise': _params.advertise,
      'name': _params.name,
      'next_hop': _params.nextHop,
      'priority': _params.priority,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'routing_table_id': _params.routingTableId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVpcRoutingTableRoute');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPC routing table route.
   *
   * This request deletes a VPC route. This operation cannot be reversed. Only VPC routes with an `origin` of `user` are
   * allowed to be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.routingTableId - The routing table identifier.
   * @param {string} params.id - The VPC routing table route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpcRoutingTableRoute(
    params: VpcV1.DeleteVpcRoutingTableRouteParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'routingTableId', 'id'];
    const _validParams = ['vpcId', 'routingTableId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'routing_table_id': _params.routingTableId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVpcRoutingTableRoute');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPC routing table route.
   *
   * This request retrieves a single VPC route specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.routingTableId - The routing table identifier.
   * @param {string} params.id - The VPC routing table route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   */
  public getVpcRoutingTableRoute(
    params: VpcV1.GetVpcRoutingTableRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'routingTableId', 'id'];
    const _validParams = ['vpcId', 'routingTableId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'routing_table_id': _params.routingTableId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpcRoutingTableRoute');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPC routing table route.
   *
   * This request updates a VPC route with the information provided in a route patch object. The patch object is
   * structured in the same way as a retrieved VPC route and needs to contain only the information to be updated. Only
   * VPC routes with an `origin` of `user` are allowed to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpcId - The VPC identifier.
   * @param {string} params.routingTableId - The routing table identifier.
   * @param {string} params.id - The VPC routing table route identifier.
   * @param {boolean} [params.advertise] - Indicates whether this route will be advertised to the ingress sources
   * specified by the `advertise_routes_to` routing table property.
   *
   * Since all routes in a routing table with the same `destination` and `zone` must have the same `advertise` value,
   * this property can only be changed for routes with a unique
   * `destination` and `zone` in the routing table. For more information, see [Advertising
   * routes](https://cloud.ibm.com/docs/vpc?topic=vpc-about-custom-routes#rt-advertising-routes).
   * @param {string} [params.name] - The name for this route. The name must not be used by another route in the routing
   * table. Names starting with `ibm-` are reserved for system-provided routes, and are not allowed.
   * @param {RouteNextHopPatch} [params.nextHop] - If `action` is `deliver`, the next hop that packets will be delivered
   * to (must not be
   * `0.0.0.0`). For other `action` values, specify `0.0.0.0` or remove it by specifying
   * `null`.
   *
   * At most two routes per `zone` in a table can have the same `destination` and `priority`,
   * and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
   * @param {number} [params.priority] - The priority of this route. Smaller values have higher priority.
   *
   * If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
   * priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
   * distributed between them.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Route>>}
   */
  public updateVpcRoutingTableRoute(
    params: VpcV1.UpdateVpcRoutingTableRouteParams
  ): Promise<VpcV1.Response<VpcV1.Route>> {
    const _params = { ...params };
    const _requiredParams = ['vpcId', 'routingTableId', 'id'];
    const _validParams = ['vpcId', 'routingTableId', 'id', 'advertise', 'name', 'nextHop', 'priority', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'advertise': _params.advertise,
      'name': _params.name,
      'next_hop': _params.nextHop,
      'priority': _params.priority,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpc_id': _params.vpcId,
      'routing_table_id': _params.routingTableId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVpcRoutingTableRoute');

    const parameters = {
      options: {
        url: '/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * subnets
   ************************/

  /**
   * List subnets.
   *
   * This request lists subnets in the region. Subnets are contiguous ranges of IP addresses specified in CIDR block
   * notation. Each subnet is within a particular zone and cannot span multiple zones or regions.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.zoneName] - Filters the collection to resources with a `zone.name` property matching the
   * exact specified name.
   * @param {string} [params.vpcId] - Filters the collection to resources with a `vpc.id` property matching the
   * specified identifier.
   * @param {string} [params.vpcCrn] - Filters the collection to resources with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to resources with a `vpc.name` property matching the
   * exact specified name.
   * @param {string} [params.routingTableId] - Filters the collection to subnets with a `routing_table.id` property
   * matching the specified identifier.
   * @param {string} [params.routingTableName] - Filters the collection to subnets with a `routing_table.name` property
   * matching the exact specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SubnetCollection>>}
   */
  public listSubnets(
    params?: VpcV1.ListSubnetsParams
  ): Promise<VpcV1.Response<VpcV1.SubnetCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'zoneName', 'vpcId', 'vpcCrn', 'vpcName', 'routingTableId', 'routingTableName', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'zone.name': _params.zoneName,
      'vpc.id': _params.vpcId,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
      'routing_table.id': _params.routingTableId,
      'routing_table.name': _params.routingTableName,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listSubnets');

    const parameters = {
      options: {
        url: '/subnets',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a subnet.
   *
   * This request creates a new subnet from a subnet prototype object. The prototype object is structured in the same
   * way as a retrieved subnet, and contains the information necessary to create the new subnet. For this request to
   * succeed, the prototype's CIDR block must not overlap with an existing subnet in the VPC.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {SubnetPrototype} params.subnetPrototype - The subnet prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Subnet>>}
   */
  public createSubnet(
    params: VpcV1.CreateSubnetParams
  ): Promise<VpcV1.Response<VpcV1.Subnet>> {
    const _params = { ...params };
    const _requiredParams = ['subnetPrototype'];
    const _validParams = ['subnetPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.subnetPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createSubnet');

    const parameters = {
      options: {
        url: '/subnets',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a subnet.
   *
   * This request deletes a subnet. This operation cannot be reversed. For this request to succeed, the subnet must not
   * be referenced by any bare metal server network interfaces, instance network interfaces, virtual network interfaces,
   * VPN gateways, or load balancers. A delete operation automatically detaches the subnet from any network ACLs, public
   * gateways, or endpoint gateways. All flow log collectors with `auto_delete` set to `true` targeting the subnet or
   * any resource in the subnet are automatically deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSubnet(
    params: VpcV1.DeleteSubnetParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteSubnet');

    const parameters = {
      options: {
        url: '/subnets/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a subnet.
   *
   * This request retrieves a single subnet specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Subnet>>}
   */
  public getSubnet(
    params: VpcV1.GetSubnetParams
  ): Promise<VpcV1.Response<VpcV1.Subnet>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getSubnet');

    const parameters = {
      options: {
        url: '/subnets/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a subnet.
   *
   * This request updates a subnet with the information in a provided subnet patch. The subnet patch object is
   * structured in the same way as a retrieved subnet and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {string} [params.name] - The name for this subnet. The name must not be used by another subnet in the VPC.
   * @param {NetworkACLIdentity} [params.networkAcl] - The network ACL to use for this subnet.
   * @param {SubnetPublicGatewayPatch} [params.publicGateway] - The public gateway to use for internet-bound traffic for
   * this subnet.
   * @param {RoutingTableIdentity} [params.routingTable] - The routing table to use for this subnet.  The routing table
   * properties
   * `route_direct_link_ingress`, `route_internet_ingress`,
   * `route_transit_gateway_ingress`, and `route_vpc_zone_ingress` must be `false`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Subnet>>}
   */
  public updateSubnet(
    params: VpcV1.UpdateSubnetParams
  ): Promise<VpcV1.Response<VpcV1.Subnet>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'networkAcl', 'publicGateway', 'routingTable', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'network_acl': _params.networkAcl,
      'public_gateway': _params.publicGateway,
      'routing_table': _params.routingTable,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateSubnet');

    const parameters = {
      options: {
        url: '/subnets/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a subnet's attached network ACL.
   *
   * This request retrieves the network ACL attached to the subnet specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACL>>}
   */
  public getSubnetNetworkAcl(
    params: VpcV1.GetSubnetNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getSubnetNetworkAcl');

    const parameters = {
      options: {
        url: '/subnets/{id}/network_acl',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Replace the network ACL for a subnet.
   *
   * This request replaces the existing network ACL for a subnet with the network ACL specified in the request body.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {NetworkACLIdentity} params.networkAclIdentity - The network ACL identity.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACL>>}
   */
  public replaceSubnetNetworkAcl(
    params: VpcV1.ReplaceSubnetNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'networkAclIdentity'];
    const _validParams = ['id', 'networkAclIdentity', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.networkAclIdentity;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'replaceSubnetNetworkAcl');

    const parameters = {
      options: {
        url: '/subnets/{id}/network_acl',
        method: 'PUT',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Detach a public gateway from a subnet.
   *
   * This request detaches the public gateway from the subnet specified by the subnet identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public unsetSubnetPublicGateway(
    params: VpcV1.UnsetSubnetPublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'unsetSubnetPublicGateway');

    const parameters = {
      options: {
        url: '/subnets/{id}/public_gateway',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a subnet's attached public gateway.
   *
   * This request retrieves the public gateway attached to the subnet specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGateway>>}
   */
  public getSubnetPublicGateway(
    params: VpcV1.GetSubnetPublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PublicGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getSubnetPublicGateway');

    const parameters = {
      options: {
        url: '/subnets/{id}/public_gateway',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Attach a public gateway to a subnet.
   *
   * This request attaches the public gateway, specified in the request body, to the subnet specified by the subnet
   * identifier in the URL. The public gateway must have the same VPC and zone as the subnet.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {PublicGatewayIdentity} params.publicGatewayIdentity - The public gateway identity.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGateway>>}
   */
  public setSubnetPublicGateway(
    params: VpcV1.SetSubnetPublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PublicGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'publicGatewayIdentity'];
    const _validParams = ['id', 'publicGatewayIdentity', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.publicGatewayIdentity;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'setSubnetPublicGateway');

    const parameters = {
      options: {
        url: '/subnets/{id}/public_gateway',
        method: 'PUT',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a subnet's attached routing table.
   *
   * This request retrieves the routing table attached to the subnet specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTable>>}
   */
  public getSubnetRoutingTable(
    params: VpcV1.GetSubnetRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getSubnetRoutingTable');

    const parameters = {
      options: {
        url: '/subnets/{id}/routing_table',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Replace the routing table for a subnet.
   *
   * This request replaces the existing routing table for a subnet with the routing table specified in the request body.
   *
   * For this request to succeed, the routing table `route_direct_link_ingress`,
   * `route_internet_ingress`, `route_transit_gateway_ingress`, and `route_vpc_zone_ingress` properties must be `false`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The subnet identifier.
   * @param {RoutingTableIdentity} params.routingTableIdentity - The routing table identity.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RoutingTable>>}
   */
  public replaceSubnetRoutingTable(
    params: VpcV1.ReplaceSubnetRoutingTableParams
  ): Promise<VpcV1.Response<VpcV1.RoutingTable>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'routingTableIdentity'];
    const _validParams = ['id', 'routingTableIdentity', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.routingTableIdentity;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'replaceSubnetRoutingTable');

    const parameters = {
      options: {
        url: '/subnets/{id}/routing_table',
        method: 'PUT',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List reserved IPs in a subnet.
   *
   * This request lists reserved IPs in a subnet. A reserved IP resource will exist for every address in the subnet
   * which is not available for use.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.subnetId - The subnet identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.targetId] - Filters the collection to resources with a `target.id` property matching the
   * specified identifier.
   * @param {string} [params.targetCrn] - Filters the collection to resources with a `target.crn` property matching the
   * specified CRN.
   * @param {string} [params.targetName] - Filters the collection to resources with a `target.name` property matching
   * the exact specified name.
   * @param {string} [params.targetResourceType] - Filters the collection to resources with a `target.resource_type`
   * property matching the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIPCollection>>}
   */
  public listSubnetReservedIps(
    params: VpcV1.ListSubnetReservedIpsParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIPCollection>> {
    const _params = { ...params };
    const _requiredParams = ['subnetId'];
    const _validParams = ['subnetId', 'start', 'limit', 'sort', 'targetId', 'targetCrn', 'targetName', 'targetResourceType', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
      'target.id': _params.targetId,
      'target.crn': _params.targetCrn,
      'target.name': _params.targetName,
      'target.resource_type': _params.targetResourceType,
    };

    const path = {
      'subnet_id': _params.subnetId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listSubnetReservedIps');

    const parameters = {
      options: {
        url: '/subnets/{subnet_id}/reserved_ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Reserve an IP in a subnet.
   *
   * This request reserves an IP address in a subnet. If the provided prototype object includes an `address`, the
   * address must not already be reserved.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.subnetId - The subnet identifier.
   * @param {string} [params.address] - The IP address to reserve, which must not already be reserved on the subnet.
   *
   * If unspecified, an available address on the subnet will automatically be selected.
   * @param {boolean} [params.autoDelete] - Indicates whether this reserved IP member will be automatically deleted when
   * either
   * `target` is deleted, or the reserved IP is unbound. Must be `false` if the reserved IP is unbound.
   * @param {string} [params.name] - The name for this reserved IP. The name must not be used by another reserved IP in
   * the subnet. Names starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If
   * unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ReservedIPTargetPrototype} [params.target] - The target to bind this reserved IP to.  The target must be in
   * the same VPC.
   *
   * The following targets are supported:
   * - An endpoint gateway not already bound to a reserved IP in the subnet's zone.
   * - A virtual network interface.
   *
   * If unspecified, the reserved IP will be created unbound.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public createSubnetReservedIp(
    params: VpcV1.CreateSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['subnetId'];
    const _validParams = ['subnetId', 'address', 'autoDelete', 'name', 'target', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'address': _params.address,
      'auto_delete': _params.autoDelete,
      'name': _params.name,
      'target': _params.target,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'subnet_id': _params.subnetId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createSubnetReservedIp');

    const parameters = {
      options: {
        url: '/subnets/{subnet_id}/reserved_ips',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a reserved IP.
   *
   * This request releases a reserved IP. This operation cannot be reversed.
   *
   * For this request to succeed, the reserved IP must not be required by another resource, such as a bare metal server
   * network interface, instance network interface or virtual network interface for which it is the primary IP. A
   * provider-owned reserved IP is not allowed to be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.subnetId - The subnet identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSubnetReservedIp(
    params: VpcV1.DeleteSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['subnetId', 'id'];
    const _validParams = ['subnetId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'subnet_id': _params.subnetId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteSubnetReservedIp');

    const parameters = {
      options: {
        url: '/subnets/{subnet_id}/reserved_ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a reserved IP.
   *
   * This request retrieves a single reserved IP specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.subnetId - The subnet identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public getSubnetReservedIp(
    params: VpcV1.GetSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['subnetId', 'id'];
    const _validParams = ['subnetId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'subnet_id': _params.subnetId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getSubnetReservedIp');

    const parameters = {
      options: {
        url: '/subnets/{subnet_id}/reserved_ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a reserved IP.
   *
   * This request updates a reserved IP with the information in a provided reserved IP patch. The reserved IP patch
   * object is structured in the same way as a retrieved reserved IP and contains only the information to be updated.
   *
   * A provider-owned reserved IP is not allowed to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.subnetId - The subnet identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {boolean} [params.autoDelete] - Indicates whether this reserved IP member will be automatically deleted when
   * either
   * `target` is deleted, or the reserved IP is unbound. Must be `false` if the reserved IP is unbound.
   * @param {string} [params.name] - The name for this reserved IP. The name must not be used by another reserved IP in
   * the subnet. Names starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public updateSubnetReservedIp(
    params: VpcV1.UpdateSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['subnetId', 'id'];
    const _validParams = ['subnetId', 'id', 'autoDelete', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'auto_delete': _params.autoDelete,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'subnet_id': _params.subnetId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateSubnetReservedIp');

    const parameters = {
      options: {
        url: '/subnets/{subnet_id}/reserved_ips/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * images
   ************************/

  /**
   * List images.
   *
   * This request lists images available in the region. An image provides source data for a volume. Images are either
   * system-provided, or created from another source, such as importing from Cloud Object Storage.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string[]} [params.status] - Filters the collection to images with a `status` property matching one of the
   * specified comma-separated values.
   * @param {string} [params.visibility] - Filters the collection to images with a `visibility` property matching the
   * specified value.
   * @param {string[]} [params.userDataFormat] - Filters the collection to images with a `user_data_format` property
   * matching one of the specified comma-separated values.
   * @param {string} [params.ownerType] - Filters the collection to images with an `owner_type` property matching the
   * specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ImageCollection>>}
   */
  public listImages(
    params?: VpcV1.ListImagesParams
  ): Promise<VpcV1.Response<VpcV1.ImageCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'status', 'visibility', 'userDataFormat', 'ownerType', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'status': _params.status,
      'visibility': _params.visibility,
      'user_data_format': _params.userDataFormat,
      'owner_type': _params.ownerType,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listImages');

    const parameters = {
      options: {
        url: '/images',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an image.
   *
   * This request creates a new image from an image prototype object. The prototype object is structured in the same way
   * as a retrieved image, and contains the information necessary to create the new image. If an image is being
   * imported, a URL to the image file on object storage must be specified. If an image is being created from an
   * existing volume, that volume must be specified.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {ImagePrototype} params.imagePrototype - The image prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Image>>}
   */
  public createImage(
    params: VpcV1.CreateImageParams
  ): Promise<VpcV1.Response<VpcV1.Image>> {
    const _params = { ...params };
    const _requiredParams = ['imagePrototype'];
    const _validParams = ['imagePrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.imagePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createImage');

    const parameters = {
      options: {
        url: '/images',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an image.
   *
   * This request deletes an image. Any active image export jobs will be completed first. This operation cannot be
   * reversed. A system-provided image is not allowed to be deleted. Additionally, an image cannot be deleted if it:
   * - has a `status` of `deleting`
   * - has a `status` of `pending` with a `status_reasons` code of `image_request_in_progress`
   * - has `catalog_offering.managed` set to `true`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The image identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteImage(
    params: VpcV1.DeleteImageParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteImage');

    const parameters = {
      options: {
        url: '/images/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an image.
   *
   * This request retrieves a single image specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The image identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Image>>}
   */
  public getImage(
    params: VpcV1.GetImageParams
  ): Promise<VpcV1.Response<VpcV1.Image>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getImage');

    const parameters = {
      options: {
        url: '/images/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an image.
   *
   * This request updates an image with the information in a provided image patch. The image patch object is structured
   * in the same way as a retrieved image and contains only the information to be updated. A system-provided image is
   * not allowed to be updated. An image with a `status` of `deleting` cannot be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The image identifier.
   * @param {string} [params.deprecationAt] - The deprecation date and time to set for this image.
   *
   * This cannot be set if the image has a `status` of `failed` or `deleting`, or if
   * `catalog_offering.managed` is `true`.
   *
   * The date and time must not be in the past, and must be earlier than `obsolescence_at`
   * (if `obsolescence_at` is set). Additionally, if the image status is currently
   * `deprecated`, the value cannot be changed (but may be removed).
   *
   * Specify `null` to remove an existing deprecation date and time. If the image status is currently `deprecated`, it
   * will become `available`.
   *
   * If the deprecation date and time is reached while the image has a status of `pending`, the image's status will
   * transition to `deprecated` upon its successful creation (or
   * `obsolete` if the obsolescence date and time was also reached).
   * @param {string} [params.name] - The name for this image. The name must not be used by another image in the region.
   * Names starting with `ibm-` are reserved for system-provided images, and are not allowed.
   * @param {string} [params.obsolescenceAt] - The obsolescence date and time to set for this image.
   *
   * This cannot be set if the image has a `status` of `failed` or `deleting`, or if
   * `catalog_offering.managed` is `true`.
   *
   * The date and time must not be in the past, and must be later than `deprecation_at` (if
   * `deprecation_at` is set). Additionally, if the image status is currently `obsolete`, the value cannot be changed
   * (but may be removed).
   *
   * Specify `null` to remove an existing obsolescence date and time. If the image status is currently `obsolete`, it
   * will become `deprecated` if `deprecation_at` is in the past. Otherwise, it will become `available`.
   *
   * If the obsolescence date and time is reached while the image has a status of `pending`, the image's status will
   * transition to `obsolete` upon its successful creation.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Image>>}
   */
  public updateImage(
    params: VpcV1.UpdateImageParams
  ): Promise<VpcV1.Response<VpcV1.Image>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'deprecationAt', 'name', 'obsolescenceAt', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'deprecation_at': _params.deprecationAt,
      'name': _params.name,
      'obsolescence_at': _params.obsolescenceAt,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateImage');

    const parameters = {
      options: {
        url: '/images/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Deprecate an image.
   *
   * This request deprecates an image, resulting in its `status` becoming `deprecated` and
   * `deprecation_at` being set to the current date and time.
   *
   * The image must:
   * - have a `status` of `available`
   * - have `catalog_offering.managed` set to `false`
   * - not have `deprecation_at` set
   *
   * The image must not have `deprecation_at` set, must have `catalog_offering.managed` set to
   * `false`, and must have a `status` of `available`.
   *
   * A system-provided image is not allowed to be deprecated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The image identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deprecateImage(
    params: VpcV1.DeprecateImageParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deprecateImage');

    const parameters = {
      options: {
        url: '/images/{id}/deprecate',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Obsolete an image.
   *
   * This request obsoletes an image, resulting in its `status` becoming `obsolete` and
   * `obsolescence_at` being set to the current date and time.
   *
   * The image must:
   * - have a `status` of `available` or `deprecated`
   * - have `catalog_offering.managed` set to `false`
   * - not have `deprecation_at` set in the future
   * - not have `obsolescence_at` set
   *
   * A system-provided image is not allowed to be obsoleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The image identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public obsoleteImage(
    params: VpcV1.ObsoleteImageParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'obsoleteImage');

    const parameters = {
      options: {
        url: '/images/{id}/obsolete',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List export jobs for an image.
   *
   * This request lists export jobs for an image. Each job tracks the exporting of the image to another location, such
   * as a bucket within cloud object storage.
   *
   * The jobs will be sorted by their `created_at` property values, with newest jobs first. Jobs with identical
   * `created_at` property values will in turn be sorted by ascending
   * `name` property values.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.imageId - The image identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ImageExportJobUnpaginatedCollection>>}
   */
  public listImageExportJobs(
    params: VpcV1.ListImageExportJobsParams
  ): Promise<VpcV1.Response<VpcV1.ImageExportJobUnpaginatedCollection>> {
    const _params = { ...params };
    const _requiredParams = ['imageId'];
    const _validParams = ['imageId', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'name': _params.name,
    };

    const path = {
      'image_id': _params.imageId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listImageExportJobs');

    const parameters = {
      options: {
        url: '/images/{image_id}/export_jobs',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an export job for an image.
   *
   * This request creates and queues a new export job for the image specified in the URL using the image export job
   * prototype object. The image must be owned by the account and be in the `available`, `deprecated`, `obsolete`, or
   * `unusable` state. The prototype object is structured in the same way as a retrieved image export job, and contains
   * the information necessary to create and queue the new image export job.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.imageId - The image identifier.
   * @param {CloudObjectStorageBucketIdentity} params.storageBucket - The Cloud Object Storage bucket to export the
   * image to. The bucket must exist and an IAM
   * service authorization must grant `Image Service for VPC` of
   * `VPC Infrastructure Services` writer access to the bucket.
   * @param {string} [params.format] - The format to use for the exported image. If the image is encrypted, only `qcow2`
   * is supported.
   * @param {string} [params.name] - The name for this image export job. The name must not be used by another export job
   * for the image. If unspecified, the name will be a hyphenated list of randomly-selected words prefixed with the
   * first 16 characters of the parent image name.
   *
   * The exported image object name in Cloud Object Storage (`storage_object.name` in the response) will be based on
   * this name. The object name will be unique within the bucket.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ImageExportJob>>}
   */
  public createImageExportJob(
    params: VpcV1.CreateImageExportJobParams
  ): Promise<VpcV1.Response<VpcV1.ImageExportJob>> {
    const _params = { ...params };
    const _requiredParams = ['imageId', 'storageBucket'];
    const _validParams = ['imageId', 'storageBucket', 'format', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'storage_bucket': _params.storageBucket,
      'format': _params.format,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'image_id': _params.imageId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createImageExportJob');

    const parameters = {
      options: {
        url: '/images/{image_id}/export_jobs',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an image export job.
   *
   * This request deletes an image export job. This operation cannot be reversed. If the job has not completed, the job
   * will be canceled, and the incomplete exported image object deleted. If the job has completed, the exported image
   * object will not be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.imageId - The image identifier.
   * @param {string} params.id - The image export job identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteImageExportJob(
    params: VpcV1.DeleteImageExportJobParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['imageId', 'id'];
    const _validParams = ['imageId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'image_id': _params.imageId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteImageExportJob');

    const parameters = {
      options: {
        url: '/images/{image_id}/export_jobs/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an image export job.
   *
   * This request retrieves a single image export job specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.imageId - The image identifier.
   * @param {string} params.id - The image export job identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ImageExportJob>>}
   */
  public getImageExportJob(
    params: VpcV1.GetImageExportJobParams
  ): Promise<VpcV1.Response<VpcV1.ImageExportJob>> {
    const _params = { ...params };
    const _requiredParams = ['imageId', 'id'];
    const _validParams = ['imageId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'image_id': _params.imageId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getImageExportJob');

    const parameters = {
      options: {
        url: '/images/{image_id}/export_jobs/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an image export job.
   *
   * This request updates an image export job with the information in a provided image export job patch. The image
   * export job patch object is structured in the same way as a retrieved image export job and contains only the
   * information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.imageId - The image identifier.
   * @param {string} params.id - The image export job identifier.
   * @param {string} [params.name] - The name for this image export job. The name must not be used by another export job
   * for the image. Changing the name will not affect the exported image name,
   * `storage_object.name`, or `storage_href` values.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ImageExportJob>>}
   */
  public updateImageExportJob(
    params: VpcV1.UpdateImageExportJobParams
  ): Promise<VpcV1.Response<VpcV1.ImageExportJob>> {
    const _params = { ...params };
    const _requiredParams = ['imageId', 'id'];
    const _validParams = ['imageId', 'id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'image_id': _params.imageId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateImageExportJob');

    const parameters = {
      options: {
        url: '/images/{image_id}/export_jobs/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List operating systems.
   *
   * This request lists operating systems in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.OperatingSystemCollection>>}
   */
  public listOperatingSystems(
    params?: VpcV1.ListOperatingSystemsParams
  ): Promise<VpcV1.Response<VpcV1.OperatingSystemCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listOperatingSystems');

    const parameters = {
      options: {
        url: '/operating_systems',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an operating system.
   *
   * This request retrieves a single operating system specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The operating system name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.OperatingSystem>>}
   */
  public getOperatingSystem(
    params: VpcV1.GetOperatingSystemParams
  ): Promise<VpcV1.Response<VpcV1.OperatingSystem>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getOperatingSystem');

    const parameters = {
      options: {
        url: '/operating_systems/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * keys
   ************************/

  /**
   * List keys.
   *
   * This request lists keys in the region. A key contains a public SSH key which may be installed on instances when
   * they are created. Private keys are not stored.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.KeyCollection>>}
   */
  public listKeys(
    params?: VpcV1.ListKeysParams
  ): Promise<VpcV1.Response<VpcV1.KeyCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listKeys');

    const parameters = {
      options: {
        url: '/keys',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a key.
   *
   * This request creates a new SSH key from an key prototype object. The prototype object is structured in the same way
   * as a retrieved key, and contains the information necessary to create the new key. The public key value must be
   * provided.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.publicKey - The public SSH key to use, in OpenSSH format (consisting of three
   * space-separated fields: the algorithm name, base64-encoded key value, and a comment). The algorithm and comment
   * fields may be omitted, as only the key field is used.
   *
   * The key field must not match another key in the region.
   *
   * Keys of type `rsa` must be 2048 or 4096 bits in length (4096 is recommended). Keys of type `ed25519` must be 256
   * bits in length.
   * @param {string} [params.name] - The name for this key. The name must not be used by another key in the region. If
   * unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {string} [params.type] - The crypto-system for this key.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Key>>}
   */
  public createKey(
    params: VpcV1.CreateKeyParams
  ): Promise<VpcV1.Response<VpcV1.Key>> {
    const _params = { ...params };
    const _requiredParams = ['publicKey'];
    const _validParams = ['publicKey', 'name', 'resourceGroup', 'type', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'public_key': _params.publicKey,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
      'type': _params.type,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createKey');

    const parameters = {
      options: {
        url: '/keys',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a key.
   *
   * This request deletes a key. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The key identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteKey(
    params: VpcV1.DeleteKeyParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteKey');

    const parameters = {
      options: {
        url: '/keys/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a key.
   *
   * This request retrieves a single key specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The key identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Key>>}
   */
  public getKey(
    params: VpcV1.GetKeyParams
  ): Promise<VpcV1.Response<VpcV1.Key>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getKey');

    const parameters = {
      options: {
        url: '/keys/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a key.
   *
   * This request updates a key's name.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The key identifier.
   * @param {string} [params.name] - The name for this key. The name must not be used by another key in the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Key>>}
   */
  public updateKey(
    params: VpcV1.UpdateKeyParams
  ): Promise<VpcV1.Response<VpcV1.Key>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateKey');

    const parameters = {
      options: {
        url: '/keys/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * instances
   ************************/

  /**
   * List instance profiles.
   *
   * This request lists provisionable [instance profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) in the
   * region. An instance profile specifies the performance characteristics and pricing model for an instance.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceProfileCollection>>}
   */
  public listInstanceProfiles(
    params?: VpcV1.ListInstanceProfilesParams
  ): Promise<VpcV1.Response<VpcV1.InstanceProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceProfiles');

    const parameters = {
      options: {
        url: '/instance/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance profile.
   *
   * This request retrieves a single instance profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The instance profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceProfile>>}
   */
  public getInstanceProfile(
    params: VpcV1.GetInstanceProfileParams
  ): Promise<VpcV1.Response<VpcV1.InstanceProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceProfile');

    const parameters = {
      options: {
        url: '/instance/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List instance templates.
   *
   * This request lists instance templates in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceTemplateCollection>>}
   */
  public listInstanceTemplates(
    params?: VpcV1.ListInstanceTemplatesParams
  ): Promise<VpcV1.Response<VpcV1.InstanceTemplateCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceTemplates');

    const parameters = {
      options: {
        url: '/instance/templates',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an instance template.
   *
   * This request creates a new instance template. The prototype object is structured in the same way as a retrieved
   * instance template, and contains the information necessary to provision a new instance from the template.
   *
   * If a `source_template` is specified in the prototype object, its contents are copied into the new template prior to
   * copying any other properties provided in the prototype object.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {InstanceTemplatePrototype} params.instanceTemplatePrototype - The instance template prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceTemplate>>}
   */
  public createInstanceTemplate(
    params: VpcV1.CreateInstanceTemplateParams
  ): Promise<VpcV1.Response<VpcV1.InstanceTemplate>> {
    const _params = { ...params };
    const _requiredParams = ['instanceTemplatePrototype'];
    const _validParams = ['instanceTemplatePrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.instanceTemplatePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createInstanceTemplate');

    const parameters = {
      options: {
        url: '/instance/templates',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance template.
   *
   * This request deletes the instance template. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance template identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceTemplate(
    params: VpcV1.DeleteInstanceTemplateParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceTemplate');

    const parameters = {
      options: {
        url: '/instance/templates/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance template.
   *
   * This request retrieves a single instance template specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance template identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceTemplate>>}
   */
  public getInstanceTemplate(
    params: VpcV1.GetInstanceTemplateParams
  ): Promise<VpcV1.Response<VpcV1.InstanceTemplate>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceTemplate');

    const parameters = {
      options: {
        url: '/instance/templates/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance template.
   *
   * This request updates an instance template with the information provided in the instance template patch. The
   * instance template patch object is structured in the same way as a retrieved instance template and contains only the
   * information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance template identifier.
   * @param {string} [params.name] - The name for this instance template. The name must not be used by another instance
   * template in the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceTemplate>>}
   */
  public updateInstanceTemplate(
    params: VpcV1.UpdateInstanceTemplateParams
  ): Promise<VpcV1.Response<VpcV1.InstanceTemplate>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstanceTemplate');

    const parameters = {
      options: {
        url: '/instance/templates/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List instances.
   *
   * This request lists instances in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.clusterNetworkId] - Filters the collection to instances with a `cluster_network.id`
   * property matching the specified identifier.
   * @param {string} [params.clusterNetworkCrn] - Filters the collection to instances with a `cluster_network.crn`
   * property matching the specified CRN.
   * @param {string} [params.clusterNetworkName] - Filters the collection to resources with a `cluster_network.name`
   * property matching the exact specified name.
   * @param {string} [params.dedicatedHostId] - Filters the collection to resources with a `dedicated_host.id` property
   * matching the specified identifier.
   * @param {string} [params.dedicatedHostCrn] - Filters the collection to resources with a `dedicated_host.crn`
   * property matching the specified CRN.
   * @param {string} [params.dedicatedHostName] - Filters the collection to resources with a `dedicated_host.name`
   * property matching the exact specified name.
   * @param {string} [params.placementGroupId] - Filters the collection to resources with a `placement_target.id`
   * property matching the specified placement group identifier.
   * @param {string} [params.placementGroupCrn] - Filters the collection to resources with a `placement_target.crn`
   * property matching the specified placement group CRN.
   * @param {string} [params.placementGroupName] - Filters the collection to resources with a `placement_target.name`
   * property matching the exact specified placement group name.
   * @param {string} [params.reservationAffinityPolicy] - Filters the collection to instances with a
   * `reservation_affinity.policy` property matching the specified value.
   * @param {string} [params.reservationId] - Filters the collection to resources with a `reservation.id` property
   * matching the specified identifier.
   * @param {string} [params.reservationCrn] - Filters the collection to resources with a `reservation.crn` property
   * matching the specified identifier.
   * @param {string} [params.reservationName] - Filters the collection to resources with a `reservation.name` property
   * matching the specified identifier.
   * @param {string} [params.vpcId] - Filters the collection to resources with a `vpc.id` property matching the
   * specified identifier.
   * @param {string} [params.vpcCrn] - Filters the collection to resources with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to resources with a `vpc.name` property matching the
   * exact specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceCollection>>}
   */
  public listInstances(
    params?: VpcV1.ListInstancesParams
  ): Promise<VpcV1.Response<VpcV1.InstanceCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'clusterNetworkId', 'clusterNetworkCrn', 'clusterNetworkName', 'dedicatedHostId', 'dedicatedHostCrn', 'dedicatedHostName', 'placementGroupId', 'placementGroupCrn', 'placementGroupName', 'reservationAffinityPolicy', 'reservationId', 'reservationCrn', 'reservationName', 'vpcId', 'vpcCrn', 'vpcName', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'cluster_network.id': _params.clusterNetworkId,
      'cluster_network.crn': _params.clusterNetworkCrn,
      'cluster_network.name': _params.clusterNetworkName,
      'dedicated_host.id': _params.dedicatedHostId,
      'dedicated_host.crn': _params.dedicatedHostCrn,
      'dedicated_host.name': _params.dedicatedHostName,
      'placement_group.id': _params.placementGroupId,
      'placement_group.crn': _params.placementGroupCrn,
      'placement_group.name': _params.placementGroupName,
      'reservation_affinity.policy': _params.reservationAffinityPolicy,
      'reservation.id': _params.reservationId,
      'reservation.crn': _params.reservationCrn,
      'reservation.name': _params.reservationName,
      'vpc.id': _params.vpcId,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstances');

    const parameters = {
      options: {
        url: '/instances',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an instance.
   *
   * This request provisions a new instance from an instance prototype object. The prototype object is structured in the
   * same way as a retrieved instance, and contains the information necessary to provision the new instance. The
   * instance is automatically started.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {InstancePrototype} params.instancePrototype - The instance prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Instance>>}
   */
  public createInstance(
    params: VpcV1.CreateInstanceParams
  ): Promise<VpcV1.Response<VpcV1.Instance>> {
    const _params = { ...params };
    const _requiredParams = ['instancePrototype'];
    const _validParams = ['instancePrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.instancePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createInstance');

    const parameters = {
      options: {
        url: '/instances',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance.
   *
   * This request deletes an instance. This operation cannot be reversed. Any floating IPs associated with instance
   * network interfaces are implicitly disassociated. All virtual network interfaces with `auto_delete` set to `true`
   * targeting instance network attachments on the instance are automatically deleted. All flow log collectors with
   * `auto_delete` set to `true` targeting the instance, the instance network attachments, the instance network
   * interfaces, or the automatically deleted virtual network interfaces are automatically deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The virtual server instance identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstance(
    params: VpcV1.DeleteInstanceParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstance');

    const parameters = {
      options: {
        url: '/instances/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance.
   *
   * This request retrieves a single instance specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The virtual server instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Instance>>}
   */
  public getInstance(
    params: VpcV1.GetInstanceParams
  ): Promise<VpcV1.Response<VpcV1.Instance>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstance');

    const parameters = {
      options: {
        url: '/instances/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance.
   *
   * This request updates an instance with the information in a provided instance patch. The instance patch object is
   * structured in the same way as a retrieved instance and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The virtual server instance identifier.
   * @param {InstanceAvailabilityPolicyPatch} [params.availabilityPolicy] - The availability policy for this virtual
   * server instance.
   * @param {string} [params.confidentialComputeMode] - The confidential compute mode to use for this virtual server
   * instance.
   *
   * For this property to be changed, the virtual server instance `status` must be
   * `stopping` or `stopped`.
   * @param {boolean} [params.enableSecureBoot] - Indicates whether secure boot is enabled for this virtual server
   * instance.
   *
   * For this property to be changed, the virtual server instance `status` must be
   * `stopping` or `stopped`.
   * @param {InstanceMetadataServicePatch} [params.metadataService] - The metadata service configuration.
   * @param {string} [params.name] - The name for this virtual server instance. The name must not be used by another
   * virtual server instance in the region. Changing the name will not affect the system hostname.
   * @param {InstancePlacementTargetPatch} [params.placementTarget] - The placement restrictions to use for the virtual
   * server instance. For the placement restrictions to be changed, the instance `status` must be `stopping` or
   * `stopped`.
   * If set, `reservation_affinity.policy` must be `disabled`.
   * @param {InstancePatchProfile} [params.profile] - The profile to use for this virtual server instance. Any disks
   * associated with the
   * current profile will be deleted, and any disks associated with the requested profile
   * will be created.
   *
   * For the profile to be changed, the instance `status` must be `stopping` or `stopped`.
   * In addition, the requested profile must:
   * - Be compatible with any `placement_target` constraints. For example, if the
   *   instance is placed on a dedicated host, the requested profile `family` must be
   *   the same as the dedicated host `family`.
   * - Have the same `vcpu.architecture`.
   * - Support the number of network attachments or network interfaces the instance
   *   currently has.
   * @param {InstanceReservationAffinityPatch} [params.reservationAffinity] -
   * @param {number} [params.totalVolumeBandwidth] - The amount of bandwidth (in megabits per second) allocated
   * exclusively to instance storage volumes. An increase in this value will result in a corresponding decrease to
   * `total_network_bandwidth`.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Instance>>}
   */
  public updateInstance(
    params: VpcV1.UpdateInstanceParams
  ): Promise<VpcV1.Response<VpcV1.Instance>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'availabilityPolicy', 'confidentialComputeMode', 'enableSecureBoot', 'metadataService', 'name', 'placementTarget', 'profile', 'reservationAffinity', 'totalVolumeBandwidth', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'availability_policy': _params.availabilityPolicy,
      'confidential_compute_mode': _params.confidentialComputeMode,
      'enable_secure_boot': _params.enableSecureBoot,
      'metadata_service': _params.metadataService,
      'name': _params.name,
      'placement_target': _params.placementTarget,
      'profile': _params.profile,
      'reservation_affinity': _params.reservationAffinity,
      'total_volume_bandwidth': _params.totalVolumeBandwidth,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstance');

    const parameters = {
      options: {
        url: '/instances/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve initialization configuration for an instance.
   *
   * This request retrieves configuration used to initialize the instance, such as SSH keys and the Windows
   * administrator password. These can subsequently be changed on the instance and therefore may not be current.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceInitialization>>}
   */
  public getInstanceInitialization(
    params: VpcV1.GetInstanceInitializationParams
  ): Promise<VpcV1.Response<VpcV1.InstanceInitialization>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceInitialization');

    const parameters = {
      options: {
        url: '/instances/{id}/initialization',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an instance action.
   *
   * This request creates a new action which will be queued up to run as soon as any pending or running actions have
   * completed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.type - The type of action.
   * @param {boolean} [params.force] - If set to true, the action will be forced immediately, and all queued actions
   * deleted. Ignored for the start action.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceAction>>}
   */
  public createInstanceAction(
    params: VpcV1.CreateInstanceActionParams
  ): Promise<VpcV1.Response<VpcV1.InstanceAction>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'type'];
    const _validParams = ['instanceId', 'type', 'force', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'type': _params.type,
      'force': _params.force,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createInstanceAction');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/actions',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List cluster network attachments on an instance.
   *
   * This request lists cluster network attachments on an instance. A cluster network attachment represents a device on
   * the instance to which a cluster network interface is attached.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceClusterNetworkAttachmentCollection>>}
   */
  public listInstanceClusterNetworkAttachments(
    params: VpcV1.ListInstanceClusterNetworkAttachmentsParams
  ): Promise<VpcV1.Response<VpcV1.InstanceClusterNetworkAttachmentCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceClusterNetworkAttachments');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/cluster_network_attachments',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a cluster network attachment.
   *
   * This request creates a cluster network attachment from an instance cluster network attachment prototype object. A
   * cluster network attachment will attach the instance to a cluster network. The cluster network attachment prototype
   * must specify a cluster network interface identity or a cluster network interface prototype.
   *
   * The instance must be in a `stopped` or `stopping` state to create an instance cluster network attachment.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterface} params.clusterNetworkInterface - A
   * cluster network interface for the instance cluster network attachment. This can be
   * specified using an existing cluster network interface that does not already have a `target`,
   * or a prototype object for a new cluster network interface.
   *
   * This instance must reside in the same VPC as the specified cluster network interface. The
   * cluster network interface must reside in the same cluster network as the
   * `cluster_network_interface` of any other `cluster_network_attachments` for this instance.
   * @param {InstanceClusterNetworkAttachmentBeforePrototype} [params.before] - The instance cluster network attachment
   * to insert this instance cluster network attachment
   * immediately before.
   *
   * If unspecified, this instance cluster network attachment will be inserted after all
   * existing instance cluster network attachments.
   * @param {string} [params.name] - The name for this cluster network attachment. Names must be unique within the
   * instance the cluster network attachment resides in. If unspecified, the name will be a hyphenated list of
   * randomly-selected words. Names starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceClusterNetworkAttachment>>}
   */
  public createClusterNetworkAttachment(
    params: VpcV1.CreateClusterNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.InstanceClusterNetworkAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'clusterNetworkInterface'];
    const _validParams = ['instanceId', 'clusterNetworkInterface', 'before', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'cluster_network_interface': _params.clusterNetworkInterface,
      'before': _params.before,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createClusterNetworkAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/cluster_network_attachments',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance cluster network attachment.
   *
   * This request deletes an instance cluster network attachment. The instance must be in a
   * `stopped` or `stopping` state to delete an instance cluster network attachment.
   *
   * This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance cluster network attachment identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceClusterNetworkAttachment>>}
   */
  public deleteInstanceClusterNetworkAttachment(
    params: VpcV1.DeleteInstanceClusterNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.InstanceClusterNetworkAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceClusterNetworkAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/cluster_network_attachments/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance cluster network attachment.
   *
   * This request retrieves a single instance cluster network attachment specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance cluster network attachment identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceClusterNetworkAttachment>>}
   */
  public getInstanceClusterNetworkAttachment(
    params: VpcV1.GetInstanceClusterNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.InstanceClusterNetworkAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceClusterNetworkAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/cluster_network_attachments/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance cluster network attachment.
   *
   * This request updates an instance cluster network attachment with the information provided in an instance network
   * interface patch object. The instance cluster network attachment patch object is structured in the same way as a
   * retrieved instance cluster network attachment and needs to contain only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance cluster network attachment identifier.
   * @param {string} [params.name] - The name for this network attachment. The name must not be used by another network
   * attachment for the instance. Names starting with `ibm-` are reserved for provider-owned resources, and are not
   * allowed.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceClusterNetworkAttachment>>}
   */
  public updateInstanceClusterNetworkAttachment(
    params: VpcV1.UpdateInstanceClusterNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.InstanceClusterNetworkAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstanceClusterNetworkAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/cluster_network_attachments/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a console access token for an instance.
   *
   * This request creates a new single-use console access token for an instance. All console configuration is provided
   * at token create time, and the token is subsequently used in the `access_token` query parameter for the WebSocket
   * request.  The access token is only valid for a short period of time, and a maximum of one token is valid for a
   * given instance at a time.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.consoleType - The instance console type for which this token may be used.
   * @param {boolean} [params.force] - Indicates whether to disconnect an existing serial console session as the serial
   * console cannot be shared.  This has no effect on VNC consoles.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceConsoleAccessToken>>}
   */
  public createInstanceConsoleAccessToken(
    params: VpcV1.CreateInstanceConsoleAccessTokenParams
  ): Promise<VpcV1.Response<VpcV1.InstanceConsoleAccessToken>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'consoleType'];
    const _validParams = ['instanceId', 'consoleType', 'force', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'console_type': _params.consoleType,
      'force': _params.force,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createInstanceConsoleAccessToken');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/console_access_token',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List disks on an instance.
   *
   * This request lists disks on an instance.  A disk is a block device that is locally attached to the instance's
   * physical host and is also referred to as instance storage. By default, the listed disks are sorted by their
   * `created_at` property values, with the newest disk first.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceDiskCollection>>}
   */
  public listInstanceDisks(
    params: VpcV1.ListInstanceDisksParams
  ): Promise<VpcV1.Response<VpcV1.InstanceDiskCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceDisks');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/disks',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance disk.
   *
   * This request retrieves a single instance disk specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance disk identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceDisk>>}
   */
  public getInstanceDisk(
    params: VpcV1.GetInstanceDiskParams
  ): Promise<VpcV1.Response<VpcV1.InstanceDisk>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceDisk');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/disks/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance disk.
   *
   * This request updates the instance disk with the information in a provided patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance disk identifier.
   * @param {string} [params.name] - The name for this instance disk. The name must not be used by another disk on the
   * instance.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceDisk>>}
   */
  public updateInstanceDisk(
    params: VpcV1.UpdateInstanceDiskParams
  ): Promise<VpcV1.Response<VpcV1.InstanceDisk>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstanceDisk');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/disks/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List network attachments on an instance.
   *
   * This request lists network attachments on an instance. A network attachment represents a device on the instance to
   * which a virtual network interface is attached.
   *
   * The network attachments will be sorted by their `created_at` property values, with newest network attachments
   * first. Network attachments with identical `created_at` property values will in turn be sorted by ascending `name`
   * property values.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceNetworkAttachmentCollection>>}
   */
  public listInstanceNetworkAttachments(
    params: VpcV1.ListInstanceNetworkAttachmentsParams
  ): Promise<VpcV1.Response<VpcV1.InstanceNetworkAttachmentCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceNetworkAttachments');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_attachments',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a network attachment on an instance.
   *
   * This request creates a new instance network attachment from an instance network attachment prototype object. The
   * prototype object is structured in the same way as a retrieved instance network attachment, and contains the
   * information necessary to create the new instance network attachment.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {InstanceNetworkAttachmentPrototypeVirtualNetworkInterface} params.virtualNetworkInterface - A virtual
   * network interface for the instance network attachment. This can be specified
   * using an existing virtual network interface, or a prototype object for a new virtual
   * network interface.
   *
   * If an existing virtual network interface is specified, `enable_infrastructure_nat` must be
   * `true`.
   * @param {string} [params.name] - The name for this network attachment. Names must be unique within the instance the
   * network attachment resides in. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceNetworkAttachment>>}
   */
  public createInstanceNetworkAttachment(
    params: VpcV1.CreateInstanceNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.InstanceNetworkAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'virtualNetworkInterface'];
    const _validParams = ['instanceId', 'virtualNetworkInterface', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'virtual_network_interface': _params.virtualNetworkInterface,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createInstanceNetworkAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_attachments',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance network attachment.
   *
   * This request deletes an instance network attachment. This operation cannot be reversed. Any floating IPs associated
   * with the instance network attachment are implicitly disassociated. All flow log collectors with `auto_delete` set
   * to `true` targeting the instance network attachment are automatically deleted. The primary instance network
   * attachment is not allowed to be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance network attachment identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceNetworkAttachment(
    params: VpcV1.DeleteInstanceNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceNetworkAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_attachments/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance network attachment.
   *
   * This request retrieves a single instance network attachment specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance network attachment identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceNetworkAttachment>>}
   */
  public getInstanceNetworkAttachment(
    params: VpcV1.GetInstanceNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.InstanceNetworkAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceNetworkAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_attachments/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance network attachment.
   *
   * This request updates an instance network attachment with the information provided in an instance network interface
   * patch object. The instance network attachment patch object is structured in the same way as a retrieved instance
   * network attachment and needs to contain only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance network attachment identifier.
   * @param {string} [params.name] - The name for this network attachment. The name must not be used by another network
   * attachment for the instance.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceNetworkAttachment>>}
   */
  public updateInstanceNetworkAttachment(
    params: VpcV1.UpdateInstanceNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.InstanceNetworkAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstanceNetworkAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_attachments/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List network interfaces on an instance.
   *
   * This request lists network interfaces on an instance. An instance network interface is an abstract representation
   * of a network device and attaches an instance to a single subnet. Each network interface on an instance can attach
   * to any subnet in the zone, including subnets that are already attached to the instance. Multiple network interfaces
   * on the instance may also attach to the same subnet.
   *
   * If this instance has network attachments, each returned network interface is a [read-only
   * representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding
   * network attachment and its attached virtual network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkInterfaceUnpaginatedCollection>>}
   */
  public listInstanceNetworkInterfaces(
    params: VpcV1.ListInstanceNetworkInterfacesParams
  ): Promise<VpcV1.Response<VpcV1.NetworkInterfaceUnpaginatedCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceNetworkInterfaces');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a network interface on an instance.
   *
   * This request creates a new instance network interface from an instance network interface prototype object. The
   * prototype object is structured in the same way as a retrieved instance network interface, and contains the
   * information necessary to create the new instance network interface. Any subnet in the instance's VPC may be
   * specified. Addresses on the instance network interface must be within the specified subnet's CIDR blocks.
   *
   * If this instance has network attachments, each network interface is a [read-only
   * representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding
   * network attachment and its attached virtual network interface, and new network interfaces are not allowed to be
   * created.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {SubnetIdentity} params.subnet - The associated subnet.
   * @param {boolean} [params.allowIpSpoofing] - Indicates whether source IP spoofing is allowed on this instance
   * network interface.
   *
   * If this instance has network attachments, this network interface is a
   * [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
   * corresponding network attachment and its attached virtual network interface, and source IP spoofing is managed on
   * the attached virtual network interface.
   * @param {string} [params.name] - The name for the instance network interface. The name must not be used by another
   * network interface on the virtual server instance. If unspecified, the name will be a hyphenated list of
   * randomly-selected words.
   * @param {NetworkInterfaceIPPrototype} [params.primaryIp] - The primary IP address to bind to the instance network
   * interface. This can be
   * specified using an existing reserved IP, or a prototype object for a new reserved IP.
   *
   * If an existing reserved IP or a prototype object with an address is specified, it must
   * be available on the instance network interface's subnet. Otherwise, an
   * available address on the subnet will be automatically selected and reserved.
   * @param {SecurityGroupIdentity[]} [params.securityGroups] - The security groups to use for this instance network
   * interface. If unspecified, the VPC's default security group is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkInterface>>}
   */
  public createInstanceNetworkInterface(
    params: VpcV1.CreateInstanceNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.NetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'subnet'];
    const _validParams = ['instanceId', 'subnet', 'allowIpSpoofing', 'name', 'primaryIp', 'securityGroups', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'subnet': _params.subnet,
      'allow_ip_spoofing': _params.allowIpSpoofing,
      'name': _params.name,
      'primary_ip': _params.primaryIp,
      'security_groups': _params.securityGroups,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createInstanceNetworkInterface');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance network interface.
   *
   * This request deletes an instance network interface. This operation cannot be reversed. Any floating IPs associated
   * with the instance network interface are implicitly disassociated. All flow log collectors with `auto_delete` set to
   * `true` targeting the instance network interface are automatically deleted. The primary instance network interface
   * is not allowed to be deleted.
   *
   * If this instance has network attachments, this network interface is a [read-only
   * representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding
   * network attachment and its attached virtual network interface, and is not allowed to be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceNetworkInterface(
    params: VpcV1.DeleteInstanceNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceNetworkInterface');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance network interface.
   *
   * This request retrieves a single instance network interface specified by the identifier in the URL.
   *
   * If this instance has network attachments, the retrieved network interface is a
   * [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
   * corresponding network attachment and its attached virtual network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkInterface>>}
   */
  public getInstanceNetworkInterface(
    params: VpcV1.GetInstanceNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.NetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceNetworkInterface');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance network interface.
   *
   * This request updates an instance network interface with the information provided in an instance network interface
   * patch object. The instance network interface patch object is structured in the same way as a retrieved instance
   * network interface and needs to contain only the information to be updated.
   *
   * If this instance has network attachments, this network interface is a [read-only
   * representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding
   * network attachment and its attached virtual network interface, and is not allowed to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The instance network interface identifier.
   * @param {boolean} [params.allowIpSpoofing] - Indicates whether source IP spoofing is allowed on this instance
   * network interface.
   *
   * If this instance has network attachments, this network interface is a
   * [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
   * corresponding network attachment and its attached virtual network interface, and source IP spoofing is managed on
   * the attached virtual network interface.
   * @param {string} [params.name] - The name for the instance network interface. The name must not be used by another
   * network interface on the virtual server instance.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkInterface>>}
   */
  public updateInstanceNetworkInterface(
    params: VpcV1.UpdateInstanceNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.NetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'allowIpSpoofing', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'allow_ip_spoofing': _params.allowIpSpoofing,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstanceNetworkInterface');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List floating IPs associated with an instance network interface.
   *
   * This request lists floating IPs associated with an instance network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIPUnpaginatedCollection>>}
   */
  public listInstanceNetworkInterfaceFloatingIps(
    params: VpcV1.ListInstanceNetworkInterfaceFloatingIpsParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIPUnpaginatedCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceNetworkInterfaceFloatingIps');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Disassociate a floating IP from an instance network interface.
   *
   * This request disassociates the specified floating IP from the specified instance network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeInstanceNetworkInterfaceFloatingIp(
    params: VpcV1.RemoveInstanceNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId', 'id'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'removeInstanceNetworkInterfaceFloatingIp');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve associated floating IP.
   *
   * This request retrieves a specified floating IP address if it is associated with the instance network interface and
   * instance specified in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public getInstanceNetworkInterfaceFloatingIp(
    params: VpcV1.GetInstanceNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId', 'id'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceNetworkInterfaceFloatingIp');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Associate a floating IP with an instance network interface.
   *
   * This request associates the specified floating IP with the specified instance network interface, replacing any
   * existing association.
   *
   * The existing floating IP must:
   * - not be required by another resource, such as a public gateway
   * - be in the same `zone` as the instance
   *
   * A request body is not required, and if provided, is ignored.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public addInstanceNetworkInterfaceFloatingIp(
    params: VpcV1.AddInstanceNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId', 'id'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'addInstanceNetworkInterfaceFloatingIp');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List the primary reserved IP for an instance network interface.
   *
   * This request lists the primary reserved IP for an instance network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIPCollectionInstanceNetworkInterfaceContext>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public listInstanceNetworkInterfaceIps(
    params: VpcV1.ListInstanceNetworkInterfaceIpsParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIPCollectionInstanceNetworkInterfaceContext>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: listInstanceNetworkInterfaceIps');
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceNetworkInterfaceIps');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve the primary reserved IP.
   *
   * This request retrieves the primary reserved IP for an instance network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.networkInterfaceId - The instance network interface identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public getInstanceNetworkInterfaceIp(
    params: VpcV1.GetInstanceNetworkInterfaceIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: getInstanceNetworkInterfaceIp');
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'networkInterfaceId', 'id'];
    const _validParams = ['instanceId', 'networkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceNetworkInterfaceIp');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/network_interfaces/{network_interface_id}/ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List volumes attachments on an instance.
   *
   * This request lists volume attachments on an instance. A volume attachment connects a volume to an instance. Each
   * instance may have many volume attachments but each volume attachment connects exactly one instance to exactly one
   * volume.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeAttachmentCollection>>}
   */
  public listInstanceVolumeAttachments(
    params: VpcV1.ListInstanceVolumeAttachmentsParams
  ): Promise<VpcV1.Response<VpcV1.VolumeAttachmentCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceVolumeAttachments');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/volume_attachments',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a volume attachment on an instance.
   *
   * This request creates a new volume attachment from a volume attachment prototype object, connecting a volume to an
   * instance. For this request to succeed, the specified volume must not be busy. The prototype object is structured in
   * the same way as a retrieved volume attachment, and contains the information necessary to create the new volume
   * attachment.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {VolumeAttachmentPrototypeVolume} params.volume - The volume to use for this attachment. This can be
   * specified as an existing unattached
   * volume, or a prototype object for a new volume.
   * @param {boolean} [params.deleteVolumeOnInstanceDelete] - Indicates whether deleting the instance will also delete
   * the attached volume.
   * @param {string} [params.name] - The name for this volume attachment. The name must not be used by another volume
   * attachment on the instance. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeAttachment>>}
   */
  public createInstanceVolumeAttachment(
    params: VpcV1.CreateInstanceVolumeAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.VolumeAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'volume'];
    const _validParams = ['instanceId', 'volume', 'deleteVolumeOnInstanceDelete', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'volume': _params.volume,
      'delete_volume_on_instance_delete': _params.deleteVolumeOnInstanceDelete,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createInstanceVolumeAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/volume_attachments',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a volume attachment.
   *
   * This request deletes a volume attachment. This operation cannot be reversed, but a new volume attachment may
   * subsequently be created for the volume.  For this request to succeed, the volume must not be busy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The volume attachment identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceVolumeAttachment(
    params: VpcV1.DeleteInstanceVolumeAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceVolumeAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/volume_attachments/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a volume attachment.
   *
   * This request retrieves a single volume attachment specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The volume attachment identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeAttachment>>}
   */
  public getInstanceVolumeAttachment(
    params: VpcV1.GetInstanceVolumeAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.VolumeAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceVolumeAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/volume_attachments/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a volume attachment.
   *
   * This request updates a volume attachment with the information provided in a volume attachment patch object. The
   * volume attachment patch object is structured in the same way as a retrieved volume attachment and needs to contain
   * only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - The virtual server instance identifier.
   * @param {string} params.id - The volume attachment identifier.
   * @param {boolean} [params.deleteVolumeOnInstanceDelete] - Indicates whether deleting the instance will also delete
   * the attached volume.
   * @param {string} [params.name] - The name for this volume attachment. The name must not be used by another volume
   * attachment on the instance.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeAttachment>>}
   */
  public updateInstanceVolumeAttachment(
    params: VpcV1.UpdateInstanceVolumeAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.VolumeAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'deleteVolumeOnInstanceDelete', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'delete_volume_on_instance_delete': _params.deleteVolumeOnInstanceDelete,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstanceVolumeAttachment');

    const parameters = {
      options: {
        url: '/instances/{instance_id}/volume_attachments/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * instanceGroups
   ************************/

  /**
   * List instance groups.
   *
   * This request lists instance groups in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupCollection>>}
   */
  public listInstanceGroups(
    params?: VpcV1.ListInstanceGroupsParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceGroups');

    const parameters = {
      options: {
        url: '/instance_groups',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an instance group.
   *
   * This request creates a new instance group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {InstanceTemplateIdentity} params.instanceTemplate - Instance template to use when creating new instances.
   *
   * Instance groups are not compatible with instance templates that specify `true` for
   * `default_trusted_profile.auto_link`.
   * @param {SubnetIdentity[]} params.subnets - The subnets to use when creating new instances.
   * @param {number} [params.applicationPort] - The port to use for new load balancer pool members created by this
   * instance group. The load balancer pool member will receive load balancer traffic on this port, unless the load
   * balancer listener is using a port range. (Traffic received on a listener using a port range will be sent to members
   * using the same port the listener received it on.)
   *
   * This port will also be used for health checks unless the port property of
   * `health_monitor` property is specified.
   *
   * This property must be specified if and only if `load_balancer_pool` has been specified.
   * @param {LoadBalancerIdentity} [params.loadBalancer] - The load balancer associated with the specified load balancer
   * pool.
   * Required if `load_balancer_pool` is specified. The load balancer must have
   * `instance_groups_supported` set to `true`.
   * @param {LoadBalancerPoolIdentity} [params.loadBalancerPool] - If specified, this instance group will manage the
   * load balancer pool. A pool member
   * will be created for each instance created by this group.  The specified load
   * balancer pool must not be used by another instance group in the VPC.
   *
   * If specified, `load_balancer` and `application_port` must also be specified.
   * @param {number} [params.membershipCount] - The number of instances in the instance group.
   * @param {string} [params.name] - The name for this instance group. The name must not be used by another instance
   * group in the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroup>>}
   */
  public createInstanceGroup(
    params: VpcV1.CreateInstanceGroupParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroup>> {
    const _params = { ...params };
    const _requiredParams = ['instanceTemplate', 'subnets'];
    const _validParams = ['instanceTemplate', 'subnets', 'applicationPort', 'loadBalancer', 'loadBalancerPool', 'membershipCount', 'name', 'resourceGroup', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'instance_template': _params.instanceTemplate,
      'subnets': _params.subnets,
      'application_port': _params.applicationPort,
      'load_balancer': _params.loadBalancer,
      'load_balancer_pool': _params.loadBalancerPool,
      'membership_count': _params.membershipCount,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createInstanceGroup');

    const parameters = {
      options: {
        url: '/instance_groups',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance group.
   *
   * This request deletes an instance group. This operation cannot be reversed. Any instances associated with the group
   * will be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroup(
    params: VpcV1.DeleteInstanceGroupParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceGroup');

    const parameters = {
      options: {
        url: '/instance_groups/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance group.
   *
   * This request retrieves a single instance group specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroup>>}
   */
  public getInstanceGroup(
    params: VpcV1.GetInstanceGroupParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceGroup');

    const parameters = {
      options: {
        url: '/instance_groups/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance group.
   *
   * This request updates an instance group with the information provided instance group patch. The instance group patch
   * object is structured in the same way as a retrieved instance group and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The instance group identifier.
   * @param {number} [params.applicationPort] - The port to use for new load balancer pool members created by this
   * instance group.
   *
   * This property must be set if and only if `load_balancer_pool` has been set.
   * @param {InstanceTemplateIdentity} [params.instanceTemplate] - Instance template to use when creating new instances.
   *
   * Instance groups are not compatible with instance templates that specify `true` for
   * `default_trusted_profile.auto_link`.
   * @param {LoadBalancerIdentity} [params.loadBalancer] - The load balancer associated with `load_balancer_pool`.
   * The load balancer must have `instance_groups_supported` set to `true`.
   *
   * This property must be set if and only if `load_balancer_pool` has been set.
   * @param {LoadBalancerPoolIdentity} [params.loadBalancerPool] - If specified, this instance group will manage the
   * load balancer pool. A pool member
   * will be created for each instance created by this group.  The specified load
   * balancer pool must not be used by another instance group in the VPC.
   *
   * If set, `load_balancer` and `application_port` must also be set.
   * @param {number} [params.membershipCount] - The number of instances in the instance group.
   * @param {string} [params.name] - The name for this instance group. The name must not be used by another instance
   * group in the region.
   * @param {SubnetIdentity[]} [params.subnets] - The subnets to use when creating new instances.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroup>>}
   */
  public updateInstanceGroup(
    params: VpcV1.UpdateInstanceGroupParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'applicationPort', 'instanceTemplate', 'loadBalancer', 'loadBalancerPool', 'membershipCount', 'name', 'subnets', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'application_port': _params.applicationPort,
      'instance_template': _params.instanceTemplate,
      'load_balancer': _params.loadBalancer,
      'load_balancer_pool': _params.loadBalancerPool,
      'membership_count': _params.membershipCount,
      'name': _params.name,
      'subnets': _params.subnets,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstanceGroup');

    const parameters = {
      options: {
        url: '/instance_groups/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance group load balancer.
   *
   * This request unbinds the instance group from the load balancer pool, and deletes the load balancer pool members.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupLoadBalancer(
    params: VpcV1.DeleteInstanceGroupLoadBalancerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId'];
    const _validParams = ['instanceGroupId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceGroupLoadBalancer');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/load_balancer',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List managers for an instance group.
   *
   * This request lists managers for an instance group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerCollection>>}
   */
  public listInstanceGroupManagers(
    params: VpcV1.ListInstanceGroupManagersParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId'];
    const _validParams = ['instanceGroupId', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceGroupManagers');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a manager for an instance group.
   *
   * This request creates a new instance group manager.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {InstanceGroupManagerPrototype} params.instanceGroupManagerPrototype - The instance group manager prototype
   * object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManager>>}
   */
  public createInstanceGroupManager(
    params: VpcV1.CreateInstanceGroupManagerParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManager>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerPrototype'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.instanceGroupManagerPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createInstanceGroupManager');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance group manager.
   *
   * This request deletes an instance group manager. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group manager identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupManager(
    params: VpcV1.DeleteInstanceGroupManagerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceGroupManager');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance group manager.
   *
   * This request retrieves a single instance group manager specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group manager identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManager>>}
   */
  public getInstanceGroupManager(
    params: VpcV1.GetInstanceGroupManagerParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManager>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceGroupManager');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance group manager.
   *
   * This request updates an instance group manager with the information provided instance group manager patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group manager identifier.
   * @param {number} [params.aggregationWindow] - The time window in seconds to aggregate metrics prior to evaluation.
   * @param {number} [params.cooldown] - The duration of time in seconds to pause further scale actions after scaling
   * has taken place.
   * @param {boolean} [params.managementEnabled] - Indicates whether this manager will control the instance group.
   * @param {number} [params.maxMembershipCount] - The maximum number of members in a managed instance group.
   * @param {number} [params.minMembershipCount] - The minimum number of members in a managed instance group.
   * @param {string} [params.name] - The name for this instance group manager. The name must not be used by another
   * manager for the instance group.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManager>>}
   */
  public updateInstanceGroupManager(
    params: VpcV1.UpdateInstanceGroupManagerParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManager>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'aggregationWindow', 'cooldown', 'managementEnabled', 'maxMembershipCount', 'minMembershipCount', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'aggregation_window': _params.aggregationWindow,
      'cooldown': _params.cooldown,
      'management_enabled': _params.managementEnabled,
      'max_membership_count': _params.maxMembershipCount,
      'min_membership_count': _params.minMembershipCount,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstanceGroupManager');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List actions for an instance group manager.
   *
   * This request lists instance group actions for an instance group manager.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerActionsCollection>>}
   */
  public listInstanceGroupManagerActions(
    params: VpcV1.ListInstanceGroupManagerActionsParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerActionsCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceGroupManagerActions');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an instance group manager action.
   *
   * This request creates a new instance group manager action.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {InstanceGroupManagerActionPrototype} params.instanceGroupManagerActionPrototype - The instance group
   * manager action prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>>}
   */
  public createInstanceGroupManagerAction(
    params: VpcV1.CreateInstanceGroupManagerActionParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'instanceGroupManagerActionPrototype'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'instanceGroupManagerActionPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.instanceGroupManagerActionPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createInstanceGroupManagerAction');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete specified instance group manager action.
   *
   * This request deletes an instance group manager action. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager action identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupManagerAction(
    params: VpcV1.DeleteInstanceGroupManagerActionParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceGroupManagerAction');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve specified instance group manager action.
   *
   * This request retrieves a single instance group manager action specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager action identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>>}
   */
  public getInstanceGroupManagerAction(
    params: VpcV1.GetInstanceGroupManagerActionParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceGroupManagerAction');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update specified instance group manager action.
   *
   * This request updates an instance group manager action.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager action identifier.
   * @param {boolean} [params.autoDelete] - Indicates whether this scheduled action will be automatically deleted after
   * it has completed and `auto_delete_timeout` hours have passed.
   * @param {number} [params.autoDeleteTimeout] - If `auto_delete` is `true`, and this scheduled action has finished,
   * the hours after which it will be automatically deleted. If the value is `0`, the action will be deleted once it has
   * finished.
   * @param {string} [params.cronSpec] - The cron specification for a recurring scheduled action. Actions can be applied
   * a maximum of one time within a 5 min period.
   * @param {InstanceGroupManagerActionGroupPatch} [params.group] -
   * @param {InstanceGroupManagerActionManagerPatch} [params.manager] -
   * @param {string} [params.name] - The name for this instance group manager action. The name must not be used by
   * another action for the instance group manager.
   * @param {string} [params.runAt] - The date and time the scheduled action will run.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>>}
   */
  public updateInstanceGroupManagerAction(
    params: VpcV1.UpdateInstanceGroupManagerActionParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerAction>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'autoDelete', 'autoDeleteTimeout', 'cronSpec', 'group', 'manager', 'name', 'runAt', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'auto_delete': _params.autoDelete,
      'auto_delete_timeout': _params.autoDeleteTimeout,
      'cron_spec': _params.cronSpec,
      'group': _params.group,
      'manager': _params.manager,
      'name': _params.name,
      'run_at': _params.runAt,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstanceGroupManagerAction');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List policies for an instance group manager.
   *
   * This request lists policies for an instance group manager.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicyCollection>>}
   */
  public listInstanceGroupManagerPolicies(
    params: VpcV1.ListInstanceGroupManagerPoliciesParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicyCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceGroupManagerPolicies');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a policy for an instance group manager.
   *
   * This request creates a new instance group manager policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {InstanceGroupManagerPolicyPrototype} params.instanceGroupManagerPolicyPrototype - The instance group
   * manager policy prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>>}
   */
  public createInstanceGroupManagerPolicy(
    params: VpcV1.CreateInstanceGroupManagerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'instanceGroupManagerPolicyPrototype'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'instanceGroupManagerPolicyPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.instanceGroupManagerPolicyPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createInstanceGroupManagerPolicy');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance group manager policy.
   *
   * This request deletes an instance group manager policy. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupManagerPolicy(
    params: VpcV1.DeleteInstanceGroupManagerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceGroupManagerPolicy');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance group manager policy.
   *
   * This request retrieves a single instance group manager policy specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>>}
   */
  public getInstanceGroupManagerPolicy(
    params: VpcV1.GetInstanceGroupManagerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceGroupManagerPolicy');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance group manager policy.
   *
   * This request updates an instance group manager policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.instanceGroupManagerId - The instance group manager identifier.
   * @param {string} params.id - The instance group manager policy identifier.
   * @param {string} [params.metricType] - The type of metric to be evaluated.
   * @param {number} [params.metricValue] - The metric value to be evaluated.
   * @param {string} [params.name] - The name for this instance group manager policy. The name must not be used by
   * another policy for the instance group manager.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>>}
   */
  public updateInstanceGroupManagerPolicy(
    params: VpcV1.UpdateInstanceGroupManagerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupManagerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'instanceGroupManagerId', 'id'];
    const _validParams = ['instanceGroupId', 'instanceGroupManagerId', 'id', 'metricType', 'metricValue', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'metric_type': _params.metricType,
      'metric_value': _params.metricValue,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'instance_group_manager_id': _params.instanceGroupManagerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstanceGroupManagerPolicy');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete memberships from an instance group.
   *
   * This request deletes memberships of an instance group. This operation cannot be reversed. Memberships that have
   * `delete_instance_on_membership_delete` set to `true` will also have their instances deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupMemberships(
    params: VpcV1.DeleteInstanceGroupMembershipsParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId'];
    const _validParams = ['instanceGroupId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceGroupMemberships');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/memberships',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List memberships for an instance group.
   *
   * This request lists instance group memberships for an instance group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupMembershipCollection>>}
   */
  public listInstanceGroupMemberships(
    params: VpcV1.ListInstanceGroupMembershipsParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupMembershipCollection>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId'];
    const _validParams = ['instanceGroupId', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceGroupMemberships');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/memberships',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an instance group membership.
   *
   * This request deletes a memberships of an instance group. This operation cannot be reversed. reversed. If the
   * membership has `delete_instance_on_membership_delete` set to `true`, the instance will also be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group membership identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteInstanceGroupMembership(
    params: VpcV1.DeleteInstanceGroupMembershipParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteInstanceGroupMembership');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/memberships/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an instance group membership.
   *
   * This request retrieves a single instance group membership specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group membership identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupMembership>>}
   */
  public getInstanceGroupMembership(
    params: VpcV1.GetInstanceGroupMembershipParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupMembership>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getInstanceGroupMembership');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/memberships/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an instance group membership.
   *
   * This request updates an instance group membership with the information provided instance group membership patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceGroupId - The instance group identifier.
   * @param {string} params.id - The instance group membership identifier.
   * @param {boolean} [params.deleteInstanceOnMembershipDelete] - If set to true, when deleting the membership the
   * instance will also be deleted.
   * @param {string} [params.name] - The name for this instance group membership. The name must not be used by another
   * membership for the instance group manager.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.InstanceGroupMembership>>}
   */
  public updateInstanceGroupMembership(
    params: VpcV1.UpdateInstanceGroupMembershipParams
  ): Promise<VpcV1.Response<VpcV1.InstanceGroupMembership>> {
    const _params = { ...params };
    const _requiredParams = ['instanceGroupId', 'id'];
    const _validParams = ['instanceGroupId', 'id', 'deleteInstanceOnMembershipDelete', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'delete_instance_on_membership_delete': _params.deleteInstanceOnMembershipDelete,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'instance_group_id': _params.instanceGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateInstanceGroupMembership');

    const parameters = {
      options: {
        url: '/instance_groups/{instance_group_id}/memberships/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * reservations
   ************************/

  /**
   * List reservations.
   *
   * This request lists reservations in the region. A reservation provides reserved capacity for a specified profile in
   * a specified zone. A reservation can also include a long-term committed use discount.
   *
   * The reservations will be sorted by their `created_at` property values, with newest reservations first. Reservations
   * with identical `created_at` property values will in turn be sorted by ascending `name` property values.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.profileResourceType] - Filters the collection of resources with a `profile.resource_type`
   * property matching the specified value.
   * @param {string} [params.affinityPolicy] - Filters the collection to reservations with an `affinity_policy` property
   * matching the specified value.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.zoneName] - Filters the collection to resources with a `zone.name` property matching the
   * exact specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservationCollection>>}
   */
  public listReservations(
    params?: VpcV1.ListReservationsParams
  ): Promise<VpcV1.Response<VpcV1.ReservationCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'name', 'profileResourceType', 'affinityPolicy', 'resourceGroupId', 'zoneName', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'name': _params.name,
      'profile.resource_type': _params.profileResourceType,
      'affinity_policy': _params.affinityPolicy,
      'resource_group.id': _params.resourceGroupId,
      'zone.name': _params.zoneName,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listReservations');

    const parameters = {
      options: {
        url: '/reservations',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a reservation.
   *
   * This request creates a new reservation from a reservation prototype object. The prototype object is structured in
   * the same way as a retrieved reservation, and contains the information necessary to create the new reservation.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {ReservationCapacityPrototype} params.capacity - The capacity reservation configuration to use.
   * @param {ReservationCommittedUsePrototype} params.committedUse - The committed use configuration to use for this
   * reservation.
   * @param {ReservationProfilePrototype} params.profile - The [instance
   * profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) or
   * [bare metal server
   * profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
   * to use for this reservation.
   * @param {ZoneIdentity} params.zone - The zone to use for this reservation.
   * @param {string} [params.affinityPolicy] - The affinity policy to use for this reservation:
   * - `automatic`: The reservation will be automatically selected
   * - `restricted`: The reservation must be manually requested.
   * @param {string} [params.name] - The name for this reservation. The name must not be used by another reservation in
   * the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Reservation>>}
   */
  public createReservation(
    params: VpcV1.CreateReservationParams
  ): Promise<VpcV1.Response<VpcV1.Reservation>> {
    const _params = { ...params };
    const _requiredParams = ['capacity', 'committedUse', 'profile', 'zone'];
    const _validParams = ['capacity', 'committedUse', 'profile', 'zone', 'affinityPolicy', 'name', 'resourceGroup', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'capacity': _params.capacity,
      'committed_use': _params.committedUse,
      'profile': _params.profile,
      'zone': _params.zone,
      'affinity_policy': _params.affinityPolicy,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createReservation');

    const parameters = {
      options: {
        url: '/reservations',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a reservation.
   *
   * This request deletes a reservation. This operation cannot be reversed. Reservations with a `status` of `active` are
   * not allowed to be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The reservation identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Reservation>>}
   */
  public deleteReservation(
    params: VpcV1.DeleteReservationParams
  ): Promise<VpcV1.Response<VpcV1.Reservation>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteReservation');

    const parameters = {
      options: {
        url: '/reservations/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a reservation.
   *
   * This request retrieves a single reservation specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The reservation identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Reservation>>}
   */
  public getReservation(
    params: VpcV1.GetReservationParams
  ): Promise<VpcV1.Response<VpcV1.Reservation>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getReservation');

    const parameters = {
      options: {
        url: '/reservations/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a reservation.
   *
   * This request updates a reservation with the information provided in a reservation patch object. The patch object is
   * structured in the same way as a retrieved reservation and needs to contain only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The reservation identifier.
   * @param {string} [params.affinityPolicy] - The affinity policy to use for this reservation:
   * - `automatic`: The reservation will be automatically selected
   * - `restricted`: The reservation must be manually requested
   *
   * The affinity policy can only be changed for a reservation with a `status` of `inactive`.
   * @param {ReservationCapacityPatch} [params.capacity] - The capacity reservation configuration to use.
   *
   * The configuration can only be changed for reservations with a `status` of `inactive`.
   * @param {ReservationCommittedUsePatch} [params.committedUse] - The committed use configuration to use for this
   * reservation.
   * @param {string} [params.name] - The name for this reservation. The name must not be used by another reservation in
   * the region.
   * @param {ReservationProfilePatch} [params.profile] - The [instance
   * profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) or
   * [bare metal server
   * profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
   * to use for this reservation.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Reservation>>}
   */
  public updateReservation(
    params: VpcV1.UpdateReservationParams
  ): Promise<VpcV1.Response<VpcV1.Reservation>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'affinityPolicy', 'capacity', 'committedUse', 'name', 'profile', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'affinity_policy': _params.affinityPolicy,
      'capacity': _params.capacity,
      'committed_use': _params.committedUse,
      'name': _params.name,
      'profile': _params.profile,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateReservation');

    const parameters = {
      options: {
        url: '/reservations/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Activate a reservation.
   *
   * This request activates a reservation. For this request to succeed, the reservation status must be `inactive`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The reservation identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public activateReservation(
    params: VpcV1.ActivateReservationParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'activateReservation');

    const parameters = {
      options: {
        url: '/reservations/{id}/activate',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * dedicatedHosts
   ************************/

  /**
   * List dedicated host groups.
   *
   * This request lists dedicated host groups in the region. Each dedicated host must belong to exactly one group, which
   * controls placement of instances. Dedicated host groups do not span zones.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.zoneName] - Filters the collection to resources with a `zone.name` property matching the
   * exact specified name.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostGroupCollection>>}
   */
  public listDedicatedHostGroups(
    params?: VpcV1.ListDedicatedHostGroupsParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostGroupCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'zoneName', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'zone.name': _params.zoneName,
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listDedicatedHostGroups');

    const parameters = {
      options: {
        url: '/dedicated_host/groups',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a dedicated host group.
   *
   * This request creates a new dedicated host group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params._class - The dedicated host profile class for hosts in this group.
   * @param {string} params.family - The dedicated host profile family for hosts in this group.
   * @param {ZoneIdentity} params.zone - The zone this dedicated host group will reside in.
   * @param {string} [params.name] - The name for this dedicated host group. The name must not be used by another
   * dedicated host group in the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>>}
   */
  public createDedicatedHostGroup(
    params: VpcV1.CreateDedicatedHostGroupParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>> {
    const _params = { ...params };
    const _requiredParams = ['_class', 'family', 'zone'];
    const _validParams = ['_class', 'family', 'zone', 'name', 'resourceGroup', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'class': _params._class,
      'family': _params.family,
      'zone': _params.zone,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createDedicatedHostGroup');

    const parameters = {
      options: {
        url: '/dedicated_host/groups',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a dedicated host group.
   *
   * This request deletes a dedicated host group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteDedicatedHostGroup(
    params: VpcV1.DeleteDedicatedHostGroupParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteDedicatedHostGroup');

    const parameters = {
      options: {
        url: '/dedicated_host/groups/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a dedicated host group.
   *
   * This request retrieves a single dedicated host group specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>>}
   */
  public getDedicatedHostGroup(
    params: VpcV1.GetDedicatedHostGroupParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getDedicatedHostGroup');

    const parameters = {
      options: {
        url: '/dedicated_host/groups/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a dedicated host group.
   *
   * This request updates a dedicated host group with the information in a provided dedicated host group patch. The
   * dedicated host group patch object is structured in the same way as a retrieved dedicated host group and contains
   * only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host group identifier.
   * @param {string} [params.name] - The name for this dedicated host group. The name must not be used by another
   * dedicated host group in the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>>}
   */
  public updateDedicatedHostGroup(
    params: VpcV1.UpdateDedicatedHostGroupParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateDedicatedHostGroup');

    const parameters = {
      options: {
        url: '/dedicated_host/groups/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List dedicated host profiles.
   *
   * This request lists provisionable [dedicated host profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles) in
   * the region. A dedicated host profile specifies the hardware characteristics for a dedicated host.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostProfileCollection>>}
   */
  public listDedicatedHostProfiles(
    params?: VpcV1.ListDedicatedHostProfilesParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listDedicatedHostProfiles');

    const parameters = {
      options: {
        url: '/dedicated_host/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a dedicated host profile.
   *
   * This request retrieves a single dedicated host profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The dedicated host profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostProfile>>}
   */
  public getDedicatedHostProfile(
    params: VpcV1.GetDedicatedHostProfileParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getDedicatedHostProfile');

    const parameters = {
      options: {
        url: '/dedicated_host/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List dedicated hosts.
   *
   * This request lists dedicated hosts in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.dedicatedHostGroupId] - Filters the collection to dedicated hosts with a `group.id`
   * property matching the specified identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.zoneName] - Filters the collection to resources with a `zone.name` property matching the
   * exact specified name.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostCollection>>}
   */
  public listDedicatedHosts(
    params?: VpcV1.ListDedicatedHostsParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['dedicatedHostGroupId', 'start', 'limit', 'resourceGroupId', 'zoneName', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'dedicated_host_group.id': _params.dedicatedHostGroupId,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'zone.name': _params.zoneName,
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listDedicatedHosts');

    const parameters = {
      options: {
        url: '/dedicated_hosts',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a dedicated host.
   *
   * This request creates a new dedicated host.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {DedicatedHostPrototype} params.dedicatedHostPrototype - The dedicated host prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHost>>}
   */
  public createDedicatedHost(
    params: VpcV1.CreateDedicatedHostParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHost>> {
    const _params = { ...params };
    const _requiredParams = ['dedicatedHostPrototype'];
    const _validParams = ['dedicatedHostPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.dedicatedHostPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createDedicatedHost');

    const parameters = {
      options: {
        url: '/dedicated_hosts',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List disks on a dedicated host.
   *
   * This request lists disks on a dedicated host.  A disk is a physical device that is locally attached to the compute
   * node. By default, the listed disks are sorted by their
   * `created_at` property values, with the newest disk first.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.dedicatedHostId - The dedicated host identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostDiskCollection>>}
   */
  public listDedicatedHostDisks(
    params: VpcV1.ListDedicatedHostDisksParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostDiskCollection>> {
    const _params = { ...params };
    const _requiredParams = ['dedicatedHostId'];
    const _validParams = ['dedicatedHostId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'dedicated_host_id': _params.dedicatedHostId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listDedicatedHostDisks');

    const parameters = {
      options: {
        url: '/dedicated_hosts/{dedicated_host_id}/disks',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a dedicated host disk.
   *
   * This request retrieves a single dedicated host disk specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.dedicatedHostId - The dedicated host identifier.
   * @param {string} params.id - The dedicated host disk identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostDisk>>}
   */
  public getDedicatedHostDisk(
    params: VpcV1.GetDedicatedHostDiskParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostDisk>> {
    const _params = { ...params };
    const _requiredParams = ['dedicatedHostId', 'id'];
    const _validParams = ['dedicatedHostId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'dedicated_host_id': _params.dedicatedHostId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getDedicatedHostDisk');

    const parameters = {
      options: {
        url: '/dedicated_hosts/{dedicated_host_id}/disks/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a dedicated host disk.
   *
   * This request updates the dedicated host disk with the information in a provided patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.dedicatedHostId - The dedicated host identifier.
   * @param {string} params.id - The dedicated host disk identifier.
   * @param {string} [params.name] - The name for this dedicated host disk. The name must not be used by another disk on
   * the dedicated host.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHostDisk>>}
   */
  public updateDedicatedHostDisk(
    params: VpcV1.UpdateDedicatedHostDiskParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHostDisk>> {
    const _params = { ...params };
    const _requiredParams = ['dedicatedHostId', 'id'];
    const _validParams = ['dedicatedHostId', 'id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'dedicated_host_id': _params.dedicatedHostId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateDedicatedHostDisk');

    const parameters = {
      options: {
        url: '/dedicated_hosts/{dedicated_host_id}/disks/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a dedicated host.
   *
   * This request deletes a dedicated host. This operation cannot be reversed. For this request to succeed, `instances`
   * must be empty and `instance_placement_enabled` must be `false`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteDedicatedHost(
    params: VpcV1.DeleteDedicatedHostParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteDedicatedHost');

    const parameters = {
      options: {
        url: '/dedicated_hosts/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a dedicated host.
   *
   * This request retrieves a single dedicated host specified by the identifiers in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHost>>}
   */
  public getDedicatedHost(
    params: VpcV1.GetDedicatedHostParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHost>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getDedicatedHost');

    const parameters = {
      options: {
        url: '/dedicated_hosts/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a dedicated host.
   *
   * This request updates a dedicated host with the information in a provided dedicated host patch. The dedicated host
   * patch object is structured in the same way as a retrieved dedicated host and contains only the information to be
   * updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The dedicated host identifier.
   * @param {boolean} [params.instancePlacementEnabled] - If set to true, instances can be placed on this dedicated
   * host.
   * @param {string} [params.name] - The name for this dedicated host. The name must not be used by another dedicated
   * host in the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.DedicatedHost>>}
   */
  public updateDedicatedHost(
    params: VpcV1.UpdateDedicatedHostParams
  ): Promise<VpcV1.Response<VpcV1.DedicatedHost>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'instancePlacementEnabled', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'instance_placement_enabled': _params.instancePlacementEnabled,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateDedicatedHost');

    const parameters = {
      options: {
        url: '/dedicated_hosts/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * placementGroups
   ************************/

  /**
   * List placement groups.
   *
   * This request lists placement groups in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PlacementGroupCollection>>}
   */
  public listPlacementGroups(
    params?: VpcV1.ListPlacementGroupsParams
  ): Promise<VpcV1.Response<VpcV1.PlacementGroupCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listPlacementGroups');

    const parameters = {
      options: {
        url: '/placement_groups',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a placement group.
   *
   * This request creates a new placement group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.strategy - The strategy for this placement group:
   * - `host_spread`: place on different compute hosts
   * - `power_spread`: place on compute hosts that use different power sources.
   * @param {string} [params.name] - The name for this placement group. The name must not be used by another placement
   * group in the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PlacementGroup>>}
   */
  public createPlacementGroup(
    params: VpcV1.CreatePlacementGroupParams
  ): Promise<VpcV1.Response<VpcV1.PlacementGroup>> {
    const _params = { ...params };
    const _requiredParams = ['strategy'];
    const _validParams = ['strategy', 'name', 'resourceGroup', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'strategy': _params.strategy,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createPlacementGroup');

    const parameters = {
      options: {
        url: '/placement_groups',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a placement group.
   *
   * This request deletes a placement group. This operation cannot be reversed. For this request to succeed, the
   * placement group must not be associated with an instance.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The placement group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deletePlacementGroup(
    params: VpcV1.DeletePlacementGroupParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deletePlacementGroup');

    const parameters = {
      options: {
        url: '/placement_groups/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a placement group.
   *
   * This request retrieves a single placement group specified by identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The placement group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PlacementGroup>>}
   */
  public getPlacementGroup(
    params: VpcV1.GetPlacementGroupParams
  ): Promise<VpcV1.Response<VpcV1.PlacementGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getPlacementGroup');

    const parameters = {
      options: {
        url: '/placement_groups/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a placement group.
   *
   * This request updates a placement group with the information provided placement group patch. The placement group
   * patch object is structured in the same way as a retrieved placement group and contains only the information to be
   * updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The placement group identifier.
   * @param {string} [params.name] - The name for this placement group. The name must not be used by another placement
   * group in the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PlacementGroup>>}
   */
  public updatePlacementGroup(
    params: VpcV1.UpdatePlacementGroupParams
  ): Promise<VpcV1.Response<VpcV1.PlacementGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updatePlacementGroup');

    const parameters = {
      options: {
        url: '/placement_groups/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * bareMetalServers
   ************************/

  /**
   * List bare metal server profiles.
   *
   * This request lists [bare metal server
   * profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile) available in the region. A bare
   * metal server profile specifies the performance characteristics and pricing model for a bare metal server.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerProfileCollection>>}
   */
  public listBareMetalServerProfiles(
    params?: VpcV1.ListBareMetalServerProfilesParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listBareMetalServerProfiles');

    const parameters = {
      options: {
        url: '/bare_metal_server/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a bare metal server profile.
   *
   * This request retrieves a single bare metal server profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The bare metal server profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerProfile>>}
   */
  public getBareMetalServerProfile(
    params: VpcV1.GetBareMetalServerProfileParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getBareMetalServerProfile');

    const parameters = {
      options: {
        url: '/bare_metal_server/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List bare metal servers.
   *
   * This request lists bare metal servers in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.reservationId] - Filters the collection to resources with a `reservation.id` property
   * matching the specified identifier.
   * @param {string} [params.reservationCrn] - Filters the collection to resources with a `reservation.crn` property
   * matching the specified identifier.
   * @param {string} [params.reservationName] - Filters the collection to resources with a `reservation.name` property
   * matching the specified identifier.
   * @param {string} [params.vpcId] - Filters the collection to resources with a `vpc.id` property matching the
   * specified identifier.
   * @param {string} [params.vpcCrn] - Filters the collection to resources with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to resources with a `vpc.name` property matching the
   * exact specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerCollection>>}
   */
  public listBareMetalServers(
    params?: VpcV1.ListBareMetalServersParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'reservationId', 'reservationCrn', 'reservationName', 'vpcId', 'vpcCrn', 'vpcName', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'reservation.id': _params.reservationId,
      'reservation.crn': _params.reservationCrn,
      'reservation.name': _params.reservationName,
      'vpc.id': _params.vpcId,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listBareMetalServers');

    const parameters = {
      options: {
        url: '/bare_metal_servers',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a bare metal server.
   *
   * This request provisions a new bare metal server from a prototype object. The prototype object is structured in the
   * same way as a retrieved bare metal server, and contains the information necessary to provision the new bare metal
   * server. The bare metal server is automatically started.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {BareMetalServerPrototype} params.bareMetalServerPrototype - The bare metal server prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServer>>}
   */
  public createBareMetalServer(
    params: VpcV1.CreateBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServer>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerPrototype'];
    const _validParams = ['bareMetalServerPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.bareMetalServerPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createBareMetalServer');

    const parameters = {
      options: {
        url: '/bare_metal_servers',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a console access token for a bare metal server.
   *
   * This request creates a new single-use console access token for a bare metal server. All console configuration is
   * provided at token create time, and the token is subsequently used in the `access_token` query parameter for the
   * WebSocket request.  The access token is only valid for a short period of time, and a maximum of one token is valid
   * for a given bare metal server at a time.  For this request to succeed, the server must have a `status` of
   * `stopped`, `starting`, or `running`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.consoleType - The bare metal server console type for which this token may be used
   *
   * Must be `serial` for bare metal servers with a `cpu.architecture` of `s390x`.
   * @param {boolean} [params.force] - Indicates whether to disconnect an existing serial console session as the serial
   * console cannot be shared.  This has no effect on VNC consoles.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerConsoleAccessToken>>}
   */
  public createBareMetalServerConsoleAccessToken(
    params: VpcV1.CreateBareMetalServerConsoleAccessTokenParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerConsoleAccessToken>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'consoleType'];
    const _validParams = ['bareMetalServerId', 'consoleType', 'force', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'console_type': _params.consoleType,
      'force': _params.force,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createBareMetalServerConsoleAccessToken');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/console_access_token',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List disks on a bare metal server.
   *
   * This request lists  disks on a bare metal server.  A disk is a block device that is locally attached to the
   * physical server.  By default, the listed disks are sorted by their `created_at` property values, with the newest
   * disk first.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerDiskCollection>>}
   */
  public listBareMetalServerDisks(
    params: VpcV1.ListBareMetalServerDisksParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerDiskCollection>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId'];
    const _validParams = ['bareMetalServerId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listBareMetalServerDisks');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/disks',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a bare metal server disk.
   *
   * This request retrieves a single disk specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server disk identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerDisk>>}
   */
  public getBareMetalServerDisk(
    params: VpcV1.GetBareMetalServerDiskParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerDisk>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getBareMetalServerDisk');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/disks/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a bare metal server disk.
   *
   * This request updates the bare metal server disk with the information in a provided patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server disk identifier.
   * @param {string} [params.name] - The name for this bare metal server disk. The name must not be used by another disk
   * on the bare metal server.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerDisk>>}
   */
  public updateBareMetalServerDisk(
    params: VpcV1.UpdateBareMetalServerDiskParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerDisk>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateBareMetalServerDisk');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/disks/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List network attachments on a bare metal server.
   *
   * This request lists network attachments on a bare metal server. A bare metal server network attachment is an
   * abstract representation of a network device and attaches a bare metal server to a single subnet. Each network
   * interface on a bare metal server can attach to any subnet in the zone, including subnets that are already attached
   * to the bare metal server.
   *
   * The network attachments will be sorted by their `created_at` property values, with newest network attachments
   * first. Network attachments with identical `created_at` property values will in turn be sorted by ascending `name`
   * property values.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkAttachmentCollection>>}
   */
  public listBareMetalServerNetworkAttachments(
    params: VpcV1.ListBareMetalServerNetworkAttachmentsParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkAttachmentCollection>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId'];
    const _validParams = ['bareMetalServerId', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listBareMetalServerNetworkAttachments');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_attachments',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a network attachment on a bare metal server.
   *
   * This request creates a new bare metal server network attachment from a bare metal server network attachment
   * prototype object. The prototype object is structured in the same way as a retrieved bare metal server network
   * attachment, and contains the information necessary to create the new bare metal server network attachment.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {BareMetalServerNetworkAttachmentPrototype} params.bareMetalServerNetworkAttachmentPrototype - The bare
   * metal server network attachment prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkAttachment>>}
   */
  public createBareMetalServerNetworkAttachment(
    params: VpcV1.CreateBareMetalServerNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'bareMetalServerNetworkAttachmentPrototype'];
    const _validParams = ['bareMetalServerId', 'bareMetalServerNetworkAttachmentPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.bareMetalServerNetworkAttachmentPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createBareMetalServerNetworkAttachment');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_attachments',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a bare metal server network attachment.
   *
   * This request deletes a bare metal server network attachment. This operation cannot be reversed. Any floating IPs
   * associated with the bare metal server network attachment are implicitly disassociated.
   *
   * The bare metal server's primary network attachment cannot be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server network attachment identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteBareMetalServerNetworkAttachment(
    params: VpcV1.DeleteBareMetalServerNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteBareMetalServerNetworkAttachment');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_attachments/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a bare metal server network attachment.
   *
   * This request retrieves a single bare metal server network attachment specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server network attachment identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkAttachment>>}
   */
  public getBareMetalServerNetworkAttachment(
    params: VpcV1.GetBareMetalServerNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getBareMetalServerNetworkAttachment');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_attachments/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a bare metal server network attachment.
   *
   * This request updates a bare metal server network attachment with the information provided in a bare metal server
   * network attachment patch object. The bare metal server network attachment patch object is structured in the same
   * way as a retrieved bare metal server network attachment and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server network attachment identifier.
   * @param {number[]} [params.allowedVlans] - The VLAN IDs to allow for `vlan` attachments using this PCI attachment,
   * replacing any existing VLAN IDs. The specified values must include IDs for all `vlan` attachments currently using
   * this PCI attachment.
   * @param {string} [params.name] - The name for this network attachment. The name must not be used by another network
   * attachment for the bare metal server.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkAttachment>>}
   */
  public updateBareMetalServerNetworkAttachment(
    params: VpcV1.UpdateBareMetalServerNetworkAttachmentParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkAttachment>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'allowedVlans', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'allowed_vlans': _params.allowedVlans,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateBareMetalServerNetworkAttachment');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_attachments/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List network interfaces on a bare metal server.
   *
   * This request lists network interfaces on a bare metal server. A bare metal server network interface is an abstract
   * representation of a network device and attaches a bare metal server to a single subnet. Each network interface on a
   * bare metal server can attach to any subnet in the zone, including subnets that are already attached to the bare
   * metal server.
   *
   * If this bare metal server has network attachments, each returned network interface is a [read-only
   * representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding
   * network attachment and its attached virtual network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterfaceCollection>>}
   */
  public listBareMetalServerNetworkInterfaces(
    params: VpcV1.ListBareMetalServerNetworkInterfacesParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterfaceCollection>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId'];
    const _validParams = ['bareMetalServerId', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listBareMetalServerNetworkInterfaces');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a network interface on a bare metal server.
   *
   * This request creates a new bare metal server network interface from a bare metal server network interface prototype
   * object. The prototype object is structured in the same way as a retrieved bare metal server network interface, and
   * contains the information necessary to create the new bare metal server network interface. Any subnet in the bare
   * metal server's VPC may be specified, even if it is already attached to another bare metal server network interface.
   * Addresses on the bare metal server network interface must be within the specified subnet's CIDR blocks.
   *
   * If this bare metal server has network attachments, each network interface is a [read-only
   * representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding
   * network attachment and its attached virtual network interface, and new network interfaces are not allowed to be
   * created.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {BareMetalServerNetworkInterfacePrototype} params.bareMetalServerNetworkInterfacePrototype - The bare metal
   * server network interface prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>>}
   */
  public createBareMetalServerNetworkInterface(
    params: VpcV1.CreateBareMetalServerNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'bareMetalServerNetworkInterfacePrototype'];
    const _validParams = ['bareMetalServerId', 'bareMetalServerNetworkInterfacePrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.bareMetalServerNetworkInterfacePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createBareMetalServerNetworkInterface');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a bare metal server network interface.
   *
   * This request deletes a bare metal server network interface. This operation cannot be reversed. Any floating IPs
   * associated with the bare metal server network interface are implicitly disassociated.  The primary bare metal
   * server network interface is not allowed to be deleted.
   *
   * If this bare metal server has network attachments, this network interface is a [read-only
   * representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding
   * network attachment and its attached virtual network interface, and is not allowed to be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteBareMetalServerNetworkInterface(
    params: VpcV1.DeleteBareMetalServerNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteBareMetalServerNetworkInterface');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a bare metal server network interface.
   *
   * This request retrieves a single bare metal server network interface specified by the identifier in the URL.
   *
   * If this bare metal server has network attachments, the retrieved network interface is a [read-only
   * representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding
   * network attachment and its attached virtual network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>>}
   */
  public getBareMetalServerNetworkInterface(
    params: VpcV1.GetBareMetalServerNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getBareMetalServerNetworkInterface');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a bare metal server network interface.
   *
   * This request updates a bare metal server network interface with the information provided in a bare metal server
   * network interface patch object. The bare metal server network interface patch object is structured in the same way
   * as a retrieved bare metal server network interface and needs to contain only the information to be updated.
   *
   * If this bare metal server has network attachments, this network interface is a [read-only
   * representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding
   * network attachment and its attached virtual network interface, and is not allowed to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.id - The bare metal server network interface identifier.
   * @param {boolean} [params.allowIpSpoofing] - Indicates whether source IP spoofing is allowed on this bare metal
   * server network interface.
   *
   * If this bare metal server has network attachments, this network interface is a
   * [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
   * corresponding network attachment and its attached virtual network interface, and source IP spoofing is managed on
   * the attached virtual network interface.
   * @param {number[]} [params.allowedVlans] - The VLAN IDs to allow for `vlan` interfaces using this PCI interface,
   * replacing any existing VLAN IDs. The specified values must include IDs for all `vlan` interfaces currently using
   * this PCI interface.
   * @param {boolean} [params.enableInfrastructureNat] - If `true`:
   * - The VPC infrastructure performs any needed NAT operations.
   * - `floating_ips` must not have more than one floating IP.
   *
   * If `false`:
   * - Packets are passed unchanged to/from the bare metal server network interface,
   *   allowing the workload to perform any needed NAT operations.
   * - `allow_ip_spoofing` must be `false`.
   * - `interface_type` must not be `hipersocket`.
   *
   * If this bare metal server has network attachments, this network interface is a
   * [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
   * corresponding network attachment and its attached virtual network interface, and infrastructure NAT is managed on
   * the attached virtual network interface.
   * @param {string} [params.name] - The name for this bare metal server network interface. The name must not be used by
   * another network interface on the bare metal server.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>>}
   */
  public updateBareMetalServerNetworkInterface(
    params: VpcV1.UpdateBareMetalServerNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'id'];
    const _validParams = ['bareMetalServerId', 'id', 'allowIpSpoofing', 'allowedVlans', 'enableInfrastructureNat', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'allow_ip_spoofing': _params.allowIpSpoofing,
      'allowed_vlans': _params.allowedVlans,
      'enable_infrastructure_nat': _params.enableInfrastructureNat,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateBareMetalServerNetworkInterface');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List floating IPs associated with a bare metal server network interface.
   *
   * This request lists floating IPs associated with a bare metal server network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIPUnpaginatedCollection>>}
   */
  public listBareMetalServerNetworkInterfaceFloatingIps(
    params: VpcV1.ListBareMetalServerNetworkInterfaceFloatingIpsParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIPUnpaginatedCollection>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listBareMetalServerNetworkInterfaceFloatingIps');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Disassociate a floating IP from a bare metal server network interface.
   *
   * This request disassociates the specified floating IP from the specified bare metal server network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeBareMetalServerNetworkInterfaceFloatingIp(
    params: VpcV1.RemoveBareMetalServerNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId', 'id'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'removeBareMetalServerNetworkInterfaceFloatingIp');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve associated floating IP.
   *
   * This request retrieves a specified floating IP if it is associated with the bare metal server network interface
   * specified in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public getBareMetalServerNetworkInterfaceFloatingIp(
    params: VpcV1.GetBareMetalServerNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId', 'id'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getBareMetalServerNetworkInterfaceFloatingIp');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Associate a floating IP with a bare metal server network interface.
   *
   * This request associates the specified floating IP with the specified bare metal server network interface. If
   * `enable_infrastructure_nat` is `false`, this adds the IP to any existing associations. If
   * `enable_infrastructure_nat` is `true`, this replaces any existing association.
   *
   * The existing floating IP must:
   * - not be required by another resource, such as a public gateway
   * - be in the same `zone` as the bare metal server
   *
   * A request body is not required, and if provided, is ignored.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public addBareMetalServerNetworkInterfaceFloatingIp(
    params: VpcV1.AddBareMetalServerNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId', 'id'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'addBareMetalServerNetworkInterfaceFloatingIp');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips/{id}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List the primary reserved IP for a bare metal server network interface.
   *
   * This request lists the primary reserved IP for a bare metal server network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIPCollectionBareMetalServerNetworkInterfaceContext>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public listBareMetalServerNetworkInterfaceIps(
    params: VpcV1.ListBareMetalServerNetworkInterfaceIpsParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIPCollectionBareMetalServerNetworkInterfaceContext>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: listBareMetalServerNetworkInterfaceIps');
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listBareMetalServerNetworkInterfaceIps');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve the primary reserved IP.
   *
   * This request retrieves the primary reserved IP for a bare metal server network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.bareMetalServerId - The bare metal server identifier.
   * @param {string} params.networkInterfaceId - The bare metal server network interface identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   * @deprecated this method is deprecated and may be removed in a future release
   */
  public getBareMetalServerNetworkInterfaceIp(
    params: VpcV1.GetBareMetalServerNetworkInterfaceIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    VpcV1._logger.warn('A deprecated operation has been invoked: getBareMetalServerNetworkInterfaceIp');
    const _params = { ...params };
    const _requiredParams = ['bareMetalServerId', 'networkInterfaceId', 'id'];
    const _validParams = ['bareMetalServerId', 'networkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'bare_metal_server_id': _params.bareMetalServerId,
      'network_interface_id': _params.networkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getBareMetalServerNetworkInterfaceIp');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a bare metal server.
   *
   * This request deletes a bare metal server. This operation cannot be reversed. Any floating IPs associated with the
   * bare metal server network interfaces are implicitly disassociated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteBareMetalServer(
    params: VpcV1.DeleteBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteBareMetalServer');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a bare metal server.
   *
   * This request retrieves a single bare metal server specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServer>>}
   */
  public getBareMetalServer(
    params: VpcV1.GetBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getBareMetalServer');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a bare metal server.
   *
   * This request updates a bare metal server with the information in a provided patch. The bare metal server patch
   * object is structured in the same way as a retrieved bare metal server and contains only the information to be
   * updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {number} [params.bandwidth] - The total bandwidth (in megabits per second) shared across the bare metal
   * server's network interfaces. The specified value must match one of the bandwidth values in the bare metal server's
   * profile.
   * @param {boolean} [params.enableSecureBoot] - Indicates whether secure boot is enabled. If enabled, the image must
   * support secure boot or the bare metal server will fail to boot.
   *
   * For `enable_secure_boot` to be changed, the bare metal server `status` must be
   * `stopped`.
   * @param {string} [params.name] - The name for this bare metal server. The name must not be used by another bare
   * metal server in the region. Changing the name will not affect the system hostname.
   * @param {BareMetalServerReservationAffinityPatch} [params.reservationAffinity] -
   * @param {BareMetalServerTrustedPlatformModulePatch} [params.trustedPlatformModule] -
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServer>>}
   */
  public updateBareMetalServer(
    params: VpcV1.UpdateBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'bandwidth', 'enableSecureBoot', 'name', 'reservationAffinity', 'trustedPlatformModule', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'bandwidth': _params.bandwidth,
      'enable_secure_boot': _params.enableSecureBoot,
      'name': _params.name,
      'reservation_affinity': _params.reservationAffinity,
      'trusted_platform_module': _params.trustedPlatformModule,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateBareMetalServer');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update firmware for a bare metal server.
   *
   * This request updates a bare metal server to the latest available firmware. The server must be stopped.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {boolean} [params.autoStart] - Indicates whether to automatically start the bare metal server after the
   * firmware update is successfully completed.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public updateFirmwareForBareMetalServer(
    params: VpcV1.UpdateFirmwareForBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'autoStart', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'auto_start': _params.autoStart,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateFirmwareForBareMetalServer');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}/firmware/update',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve initialization configuration for a bare metal server.
   *
   * This request retrieves configuration used to initialize the bare metal server, such as the image used, SSH keys,
   * and any configured usernames and passwords. These can subsequently be changed on the server and therefore may not
   * be current.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerInitialization>>}
   */
  public getBareMetalServerInitialization(
    params: VpcV1.GetBareMetalServerInitializationParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerInitialization>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getBareMetalServerInitialization');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}/initialization',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Reinitialize a bare metal server.
   *
   * This request reinitializes a bare metal server with the specified image and SSH keys. The server must be stopped.
   * Upon successful reinitiatilization, the bare metal server will be started automatically.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {ImageIdentity} params.image - The image to be used when provisioning the bare metal server.
   * @param {KeyIdentity[]} params.keys - The public SSH keys to install on the bare metal server. Keys will be made
   * available to the bare metal server as cloud-init vendor data. For cloud-init enabled images, these keys will also
   * be added as SSH authorized keys for the [default
   * user](https://cloud.ibm.com/docs/vpc?topic=vpc-vsi_is_connecting_linux#determining-default-user-account).
   *
   * For Windows images, at least one key must be specified, and one will be selected to encrypt the administrator
   * password. Keys are optional for other images, but if no keys are specified, the bare metal server will be
   * inaccessible unless the specified image provides another means of access.
   * @param {string} [params.userData] - User data to be made available when initializing the bare metal server.
   *
   * If unspecified, no user data will be made available.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BareMetalServerInitialization>>}
   */
  public replaceBareMetalServerInitialization(
    params: VpcV1.ReplaceBareMetalServerInitializationParams
  ): Promise<VpcV1.Response<VpcV1.BareMetalServerInitialization>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'image', 'keys'];
    const _validParams = ['id', 'image', 'keys', 'userData', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'image': _params.image,
      'keys': _params.keys,
      'user_data': _params.userData,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'replaceBareMetalServerInitialization');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}/initialization',
        method: 'PUT',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Restart a bare metal server.
   *
   * This request immediately restarts a bare metal server.  For this request to succeed, the server must have a
   * `status` of `running`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public restartBareMetalServer(
    params: VpcV1.RestartBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'restartBareMetalServer');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}/restart',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Start a bare metal server.
   *
   * This request starts a bare metal server.  It will run immediately provided the server is stopped.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public startBareMetalServer(
    params: VpcV1.StartBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'startBareMetalServer');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}/start',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Stop a bare metal server.
   *
   * This request stops a bare metal server. It will run immediately provided the server is running. Note: A soft stop
   * may not complete as it relies on the operating system to perform the operation.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The bare metal server identifier.
   * @param {string} params.type - The type of stop operation:
   * - `soft`: signal running operating system to quiesce and shutdown cleanly
   * - `hard`: immediately stop the server.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public stopBareMetalServer(
    params: VpcV1.StopBareMetalServerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'type'];
    const _validParams = ['id', 'type', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'type': _params.type,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'stopBareMetalServer');

    const parameters = {
      options: {
        url: '/bare_metal_servers/{id}/stop',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * volumes
   ************************/

  /**
   * List volume profiles.
   *
   * This request lists [volume profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) available in
   * the region. A volume profile specifies the performance characteristics and pricing model for a volume.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeProfileCollection>>}
   */
  public listVolumeProfiles(
    params?: VpcV1.ListVolumeProfilesParams
  ): Promise<VpcV1.Response<VpcV1.VolumeProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVolumeProfiles');

    const parameters = {
      options: {
        url: '/volume/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a volume profile.
   *
   * This request retrieves a single volume profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The volume profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeProfile>>}
   */
  public getVolumeProfile(
    params: VpcV1.GetVolumeProfileParams
  ): Promise<VpcV1.Response<VpcV1.VolumeProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVolumeProfile');

    const parameters = {
      options: {
        url: '/volume/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List volumes.
   *
   * This request lists volumes in the region. Volumes are network-connected block storage devices that may be attached
   * to one or more instances in the same region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.attachmentState] - Filters the collection to volumes with an `attachment_state` property
   * matching the specified value.
   * @param {string} [params.encryption] - Filters the collection to resources with an `encryption` property matching
   * the specified value.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.operatingSystemFamily] - Filters the collection to resources with an
   * `operating_system.family` property matching the specified operating system family.
   *
   * This parameter also supports the values `null` and `not:null` which filter the collection to resources which have
   * no operating system or any operating system, respectively.
   * @param {string} [params.operatingSystemArchitecture] - Filters the collection to resources with an
   * `operating_system.architecture` property matching the specified operating system architecture.
   *
   * This parameter also supports the values `null` and `not:null` which filter the collection to resources which have
   * no operating system or any operating system, respectively.
   * @param {string} [params.tag] - Filters the collection to resources with an item in the `tags` property matching the
   * exact specified tag.
   * @param {string} [params.zoneName] - Filters the collection to resources with a `zone.name` property matching the
   * exact specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VolumeCollection>>}
   */
  public listVolumes(
    params?: VpcV1.ListVolumesParams
  ): Promise<VpcV1.Response<VpcV1.VolumeCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'attachmentState', 'encryption', 'name', 'operatingSystemFamily', 'operatingSystemArchitecture', 'tag', 'zoneName', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'attachment_state': _params.attachmentState,
      'encryption': _params.encryption,
      'name': _params.name,
      'operating_system.family': _params.operatingSystemFamily,
      'operating_system.architecture': _params.operatingSystemArchitecture,
      'tag': _params.tag,
      'zone.name': _params.zoneName,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVolumes');

    const parameters = {
      options: {
        url: '/volumes',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a volume.
   *
   * This request creates a new volume from a volume prototype object. The prototype object is structured in the same
   * way as a retrieved volume, and contains the information necessary to create the new volume.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {VolumePrototype} params.volumePrototype - The volume prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Volume>>}
   */
  public createVolume(
    params: VpcV1.CreateVolumeParams
  ): Promise<VpcV1.Response<VpcV1.Volume>> {
    const _params = { ...params };
    const _requiredParams = ['volumePrototype'];
    const _validParams = ['volumePrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.volumePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVolume');

    const parameters = {
      options: {
        url: '/volumes',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a volume.
   *
   * This request deletes a volume. This operation cannot be reversed. For this request to succeed, the volume must not
   * be attached to any instances.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The volume identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVolume(
    params: VpcV1.DeleteVolumeParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVolume');

    const parameters = {
      options: {
        url: '/volumes/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a volume.
   *
   * This request retrieves a single volume specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The volume identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Volume>>}
   */
  public getVolume(
    params: VpcV1.GetVolumeParams
  ): Promise<VpcV1.Response<VpcV1.Volume>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVolume');

    const parameters = {
      options: {
        url: '/volumes/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a volume.
   *
   * This request updates a volume with the information in a provided volume patch. The volume patch object is
   * structured in the same way as a retrieved volume and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The volume identifier.
   * @param {number} [params.bandwidth] - The maximum bandwidth (in megabits per second) for the volume.
   *
   * If specified, the volume profile must not have a `bandwidth.type` of `dependent`.
   * @param {number} [params.capacity] - The capacity to use for the volume (in gigabytes). For the capacity to be
   * changed the volume's current `attachment_state` must be one of the values included in
   * `adjustable_capacity_states`. If `adjustable_capacity_states` is empty, then the volume capacity cannot be changed.
   *  Additionally:
   * - The specified value must not be less than the current capacity.
   * - If the volume is attached as a boot volume, the specified value must not exceed
   *   the `boot_capacity.max` of the volume profile.
   * - If the volume is attached as a data volume, the specified value must not exceed
   *   the `capacity.max` of the volume profile.
   * @param {number} [params.iops] - The maximum I/O operations per second (IOPS) to use for this volume.  For the IOPS
   * to be changed the volume's current `attachment_state` must be one of the values included in
   * `adjustable_iops_states`. If `adjustable_iops_states` is empty, then the IOPS cannot be changed.
   * @param {string} [params.name] - The name for this volume. The name must not be used by another volume in the
   * region.
   * @param {VolumeProfileIdentity} [params.profile] - The profile to use for this volume. The requested profile must
   * have the same
   * `family` and `storage_generation` values as the current profile. Additionally:
   * - If the volume is a boot volume then the value specified for `capacity` property
   * must not be less than the `boot_capacity.min` and must not exceed the
   * `boot_capacity.max` of the specified volume profile.
   * - If the volume is a data volume then the value specified for `capacity` property
   * must not be less than the `capacity.min` and must not exceed the `capacity.max`
   * of the specified volume profile.
   * @param {string[]} [params.userTags] - The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags)
   * associated with this volume (replacing any existing tags).
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Volume>>}
   */
  public updateVolume(
    params: VpcV1.UpdateVolumeParams
  ): Promise<VpcV1.Response<VpcV1.Volume>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'bandwidth', 'capacity', 'iops', 'name', 'profile', 'userTags', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'bandwidth': _params.bandwidth,
      'capacity': _params.capacity,
      'iops': _params.iops,
      'name': _params.name,
      'profile': _params.profile,
      'user_tags': _params.userTags,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVolume');

    const parameters = {
      options: {
        url: '/volumes/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * snapshots
   ************************/

  /**
   * List snapshot consistency groups.
   *
   * This request lists snapshot consistency groups in the region. A snapshot consistency group is a collection of
   * individual snapshots taken at the same time.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.backupPolicyPlanId] - Filters the collection to backup policy jobs with a
   * `backup_policy_plan.id` property matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotConsistencyGroupCollection>>}
   */
  public listSnapshotConsistencyGroups(
    params?: VpcV1.ListSnapshotConsistencyGroupsParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotConsistencyGroupCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'sort', 'backupPolicyPlanId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'sort': _params.sort,
      'backup_policy_plan.id': _params.backupPolicyPlanId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listSnapshotConsistencyGroups');

    const parameters = {
      options: {
        url: '/snapshot_consistency_groups',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a snapshot consistency group.
   *
   * This request creates a new snapshot consistency group from a snapshot consistency group object.  The prototype
   * object is structured in the same way as a retrieved consistency group, and contains the information necessary to
   * provision the new snapshot consistency group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {SnapshotConsistencyGroupPrototype} params.snapshotConsistencyGroupPrototype - The snapshot consistency
   * group prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotConsistencyGroup>>}
   */
  public createSnapshotConsistencyGroup(
    params: VpcV1.CreateSnapshotConsistencyGroupParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotConsistencyGroup>> {
    const _params = { ...params };
    const _requiredParams = ['snapshotConsistencyGroupPrototype'];
    const _validParams = ['snapshotConsistencyGroupPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.snapshotConsistencyGroupPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createSnapshotConsistencyGroup');

    const parameters = {
      options: {
        url: '/snapshot_consistency_groups',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a snapshot consistency group.
   *
   * This request deletes snapshot consistency group. This operation cannot be reversed. If the
   * `delete_snapshots_on_delete` property is `true`, all snapshots in the consistency group will also be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot consistency group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotConsistencyGroup>>}
   */
  public deleteSnapshotConsistencyGroup(
    params: VpcV1.DeleteSnapshotConsistencyGroupParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotConsistencyGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteSnapshotConsistencyGroup');

    const parameters = {
      options: {
        url: '/snapshot_consistency_groups/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a snapshot consistency group.
   *
   * This request retrieves a single snapshot consistency group specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot consistency group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotConsistencyGroup>>}
   */
  public getSnapshotConsistencyGroup(
    params: VpcV1.GetSnapshotConsistencyGroupParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotConsistencyGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getSnapshotConsistencyGroup');

    const parameters = {
      options: {
        url: '/snapshot_consistency_groups/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a snapshot consistency group.
   *
   * This request updates a snapshot consistency group with the information in a provided snapshot consistency group
   * patch. The snapshot consistency group patch object is structured in the same way as a retrieved snapshot
   * consistency group and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot consistency group identifier.
   * @param {boolean} [params.deleteSnapshotsOnDelete] - Indicates whether deleting the snapshot consistency group will
   * also delete the snapshots in the group.
   * @param {string} [params.name] - The name for this snapshot consistency group. The name must not be used by another
   * snapshot consistency groups in the region.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotConsistencyGroup>>}
   */
  public updateSnapshotConsistencyGroup(
    params: VpcV1.UpdateSnapshotConsistencyGroupParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotConsistencyGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'deleteSnapshotsOnDelete', 'name', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'delete_snapshots_on_delete': _params.deleteSnapshotsOnDelete,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateSnapshotConsistencyGroup');

    const parameters = {
      options: {
        url: '/snapshot_consistency_groups/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a filtered collection of snapshots.
   *
   * This request deletes snapshots that match the specified filter. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.sourceVolumeId - Filters the collection to resources with a `source_volume.id` property
   * matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSnapshots(
    params: VpcV1.DeleteSnapshotsParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['sourceVolumeId'];
    const _validParams = ['sourceVolumeId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'source_volume.id': _params.sourceVolumeId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteSnapshots');

    const parameters = {
      options: {
        url: '/snapshots',
        method: 'DELETE',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List snapshots.
   *
   * This request lists snapshots in the region. A snapshot preserves the data of a volume at the time the snapshot is
   * created.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.tag] - Filters the collection to resources with an item in the `tags` property matching the
   * exact specified tag.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.sourceVolumeId] - Filters the collection to resources with a `source_volume.id` property
   * matching the specified identifier.
   * @param {string} [params.sourceVolumeCrn] - Filters the collection to resources with a `source_volume.crn` property
   * matching the specified CRN.
   * @param {string} [params.sourceImageId] - Filters the collection to resources with a `source_image.id` property
   * matching the specified identifier.
   *
   * This parameter also supports the values `null` and `not:null` which filter the collection to resources which have
   * no source image or any existent source image, respectively.
   * @param {string} [params.sourceImageCrn] - Filters the collection to resources with a `source_image.crn` property
   * matching the specified CRN.
   *
   * This parameter also supports the values `null` and `not:null` which filter the collection to resources which have
   * no source image or any existent source image, respectively.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.backupPolicyPlanId] - Filters the collection to backup policy jobs with a
   * `backup_policy_plan.id` property matching the specified identifier.
   * @param {string} [params.copiesId] - Filters the collection to snapshots with an item in the `copies` property with
   * an `id` property matching the specified identifier.
   * @param {string} [params.copiesName] - Filters the collection to snapshots with an item in the `copies` property
   * with a `name` property matching the exact specified name.
   * @param {string} [params.copiesCrn] - Filters the collection to snapshots with an item in the `copies` property with
   * a `crn` property matching the specified CRN.
   * @param {string} [params.copiesRemoteRegionName] - Filters the collection to snapshots with an item in the `copies`
   * property with a
   * `remote.region.name` property matching the exact specified name.
   * @param {string} [params.sourceSnapshotId] - Filters the collection to resources with a `source_snapshot.id`
   * property matching the specified identifier.
   * @param {string} [params.sourceSnapshotRemoteRegionName] - Filters the collection to resources with a
   * `source_snapshot.remote.region.name` property matching the exact specified name.
   * @param {string} [params.sourceVolumeRemoteRegionName] - Filters the collection to resources with a
   * `source_volume.remote.region.name` property matching the exact specified name.
   * @param {string} [params.sourceImageRemoteRegionName] - Filters the collection to resources with a
   * `source_image.remote.region.name` property matching the exact specified name.
   * @param {string} [params.clonesZoneName] - Filters the collection to snapshots with an item in the `clones` property
   * with a `zone.name` property matching the exact specified name.
   * @param {string} [params.snapshotConsistencyGroupId] - Filters the collection to resources with a
   * `snapshot_consistency_group.id` property matching the specified identifier.
   * @param {string} [params.snapshotConsistencyGroupCrn] - Filters the collection to resources with a
   * `snapshot_consistency_group.crn` property matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotCollection>>}
   */
  public listSnapshots(
    params?: VpcV1.ListSnapshotsParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'tag', 'resourceGroupId', 'name', 'sourceVolumeId', 'sourceVolumeCrn', 'sourceImageId', 'sourceImageCrn', 'sort', 'backupPolicyPlanId', 'copiesId', 'copiesName', 'copiesCrn', 'copiesRemoteRegionName', 'sourceSnapshotId', 'sourceSnapshotRemoteRegionName', 'sourceVolumeRemoteRegionName', 'sourceImageRemoteRegionName', 'clonesZoneName', 'snapshotConsistencyGroupId', 'snapshotConsistencyGroupCrn', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'tag': _params.tag,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'source_volume.id': _params.sourceVolumeId,
      'source_volume.crn': _params.sourceVolumeCrn,
      'source_image.id': _params.sourceImageId,
      'source_image.crn': _params.sourceImageCrn,
      'sort': _params.sort,
      'backup_policy_plan.id': _params.backupPolicyPlanId,
      'copies[].id': _params.copiesId,
      'copies[].name': _params.copiesName,
      'copies[].crn': _params.copiesCrn,
      'copies[].remote.region.name': _params.copiesRemoteRegionName,
      'source_snapshot.id': _params.sourceSnapshotId,
      'source_snapshot.remote.region.name': _params.sourceSnapshotRemoteRegionName,
      'source_volume.remote.region.name': _params.sourceVolumeRemoteRegionName,
      'source_image.remote.region.name': _params.sourceImageRemoteRegionName,
      'clones[].zone.name': _params.clonesZoneName,
      'snapshot_consistency_group.id': _params.snapshotConsistencyGroupId,
      'snapshot_consistency_group.crn': _params.snapshotConsistencyGroupCrn,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listSnapshots');

    const parameters = {
      options: {
        url: '/snapshots',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a snapshot.
   *
   * This request creates a new snapshot from a snapshot prototype object.  The prototype object is structured in the
   * same way as a retrieved snapshot, and contains the information necessary to provision the new snapshot.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {SnapshotPrototype} params.snapshotPrototype - The snapshot prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Snapshot>>}
   */
  public createSnapshot(
    params: VpcV1.CreateSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.Snapshot>> {
    const _params = { ...params };
    const _requiredParams = ['snapshotPrototype'];
    const _validParams = ['snapshotPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.snapshotPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createSnapshot');

    const parameters = {
      options: {
        url: '/snapshots',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a snapshot.
   *
   * This request deletes a snapshot. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSnapshot(
    params: VpcV1.DeleteSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteSnapshot');

    const parameters = {
      options: {
        url: '/snapshots/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a snapshot.
   *
   * This request retrieves a single snapshot specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Snapshot>>}
   */
  public getSnapshot(
    params: VpcV1.GetSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.Snapshot>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getSnapshot');

    const parameters = {
      options: {
        url: '/snapshots/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a snapshot.
   *
   * This request updates a snapshot with the information in a provided snapshot patch. The snapshot consistency group
   * patch object is structured in the same way as a retrieved snapshot and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {string} [params.name] - The name for this snapshot. The name must not be used by another snapshot in the
   * region.
   * @param {string[]} [params.userTags] - The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags)
   * associated with this snapshot.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Snapshot>>}
   */
  public updateSnapshot(
    params: VpcV1.UpdateSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.Snapshot>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'userTags', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'user_tags': _params.userTags,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateSnapshot');

    const parameters = {
      options: {
        url: '/snapshots/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List clones for a snapshot.
   *
   * This request lists clones for a snapshot. Use a clone to quickly restore a snapshot within the clone's zone.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotCloneCollection>>}
   */
  public listSnapshotClones(
    params: VpcV1.ListSnapshotClonesParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotCloneCollection>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listSnapshotClones');

    const parameters = {
      options: {
        url: '/snapshots/{id}/clones',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a snapshot clone.
   *
   * This request deletes a snapshot clone. This operation cannot be reversed, but an equivalent clone may be recreated
   * from the snapshot.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {string} params.zoneName - The zone name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSnapshotClone(
    params: VpcV1.DeleteSnapshotCloneParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'zoneName'];
    const _validParams = ['id', 'zoneName', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
      'zone_name': _params.zoneName,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteSnapshotClone');

    const parameters = {
      options: {
        url: '/snapshots/{id}/clones/{zone_name}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a snapshot clone.
   *
   * This request retrieves a single clone specified by the snapshot identifier and zone name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {string} params.zoneName - The zone name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotClone>>}
   */
  public getSnapshotClone(
    params: VpcV1.GetSnapshotCloneParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotClone>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'zoneName'];
    const _validParams = ['id', 'zoneName', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
      'zone_name': _params.zoneName,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getSnapshotClone');

    const parameters = {
      options: {
        url: '/snapshots/{id}/clones/{zone_name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a clone for a snapshot.
   *
   * This request creates a new clone for a snapshot in the specified zone. A request body is not required, and if
   * provided, is ignored. If the snapshot already has a clone in the zone, it is returned.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The snapshot identifier.
   * @param {string} params.zoneName - The zone name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SnapshotClone>>}
   */
  public createSnapshotClone(
    params: VpcV1.CreateSnapshotCloneParams
  ): Promise<VpcV1.Response<VpcV1.SnapshotClone>> {
    const _params = { ...params };
    const _requiredParams = ['id', 'zoneName'];
    const _validParams = ['id', 'zoneName', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
      'zone_name': _params.zoneName,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createSnapshotClone');

    const parameters = {
      options: {
        url: '/snapshots/{id}/clones/{zone_name}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * shares
   ************************/

  /**
   * List file share profiles.
   *
   * This request lists [file share profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) available
   * in the region. A file share profile specifies the performance characteristics and pricing model for a file share.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareProfileCollection>>}
   */
  public listShareProfiles(
    params?: VpcV1.ListShareProfilesParams
  ): Promise<VpcV1.Response<VpcV1.ShareProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'sort', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listShareProfiles');

    const parameters = {
      options: {
        url: '/share/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a file share profile.
   *
   * This request retrieves a single file share profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The file share profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareProfile>>}
   */
  public getShareProfile(
    params: VpcV1.GetShareProfileParams
  ): Promise<VpcV1.Response<VpcV1.ShareProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getShareProfile');

    const parameters = {
      options: {
        url: '/share/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List file shares.
   *
   * This request lists file shares in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.replicationRole] - Filters the collection to file shares with a `replication_role` property
   * matching the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareCollection>>}
   */
  public listShares(
    params?: VpcV1.ListSharesParams
  ): Promise<VpcV1.Response<VpcV1.ShareCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'sort', 'replicationRole', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'sort': _params.sort,
      'replication_role': _params.replicationRole,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listShares');

    const parameters = {
      options: {
        url: '/shares',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a file share.
   *
   * This request provisions new file shares from a share prototype object. The new file shares can be a standalone
   * share, a replica share, or both a source and replica share.
   *
   * The prototype object is structured in the same way as a retrieved share, and contains the information necessary to
   * provision the new file shares.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {SharePrototype} params.sharePrototype - The file share prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Share>>}
   */
  public createShare(
    params: VpcV1.CreateShareParams
  ): Promise<VpcV1.Response<VpcV1.Share>> {
    const _params = { ...params };
    const _requiredParams = ['sharePrototype'];
    const _validParams = ['sharePrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.sharePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createShare');

    const parameters = {
      options: {
        url: '/shares',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a file share.
   *
   * This request deletes a share. This operation cannot be reversed. A share cannot be deleted if it:
   * - has share mount targets
   * - has a `lifecycle_state` of `updating`
   * - has a replication operation in progress
   *
   * If the request is accepted, the share `lifecycle_state` will be set to `deleting`. Once deletion processing
   * completes, it will no longer be retrievable.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The file share identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Share>>}
   */
  public deleteShare(
    params: VpcV1.DeleteShareParams
  ): Promise<VpcV1.Response<VpcV1.Share>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteShare');

    const parameters = {
      options: {
        url: '/shares/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a file share.
   *
   * This request retrieves a single file share specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The file share identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Share>>}
   */
  public getShare(
    params: VpcV1.GetShareParams
  ): Promise<VpcV1.Response<VpcV1.Share>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getShare');

    const parameters = {
      options: {
        url: '/shares/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a file share.
   *
   * This request updates a share with the information in a provided share patch. The share patch object is structured
   * in the same way as a retrieved share and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The file share identifier.
   * @param {string} [params.accessControlMode] - The access control mode for the share:
   *
   * - `security_group`: The security groups on the virtual network interface for a
   *   mount target control access to the mount target.
   * - `vpc`: All clients in the VPC for a mount target have access to the mount target.
   *
   * For this property to be changed, the share must have no mount targets,
   * `replication_role` must be `none` and `accessor_binding_role` must not be `accessor`.
   * @param {string[]} [params.allowedTransitEncryptionModes] - The transit encryption modes to allow for this share
   * (replacing the existing allowed transit encryption modes). The specified transit encryption modes must contain all
   * transit_encryption modes specified by existing mount targets.
   *
   * For this property to be updated, the `accessor_binding_role` must be `none`.
   * @param {number} [params.iops] - The maximum input/output operations per second (IOPS) for the file share.
   *
   * The maximum IOPS for a share may increase in the future. For this property to be changed, the share
   * `accessor_binding_role` must not be `accessor`, the share profile must not have an `iops.type` of `dependent` or
   * `fixed`, and the specified value must be within the `iops` range of the share's profile supported by the share's
   * size.
   * @param {string} [params.name] - The name for this share. The name must not be used by another share in the region.
   * @param {ShareProfileIdentity} [params.profile] - The profile to use for this file share.
   *
   * The requested profile must be in the same `family`.
   * @param {string} [params.replicationCronSpec] - The cron specification for the file share replication schedule.
   *
   * Replication of a share can be scheduled to occur at most once every 15 minutes.
   *
   * For this property to be changed, the share `replication_role` must be `replica`.
   * @param {number} [params.size] - The size of the file share (in gigabytes), excluding share snapshots. The value
   * must not be less than the share's current size, and must not exceed the maximum supported by the share's profile
   * and IOPS.
   *
   * For this property to be changed:
   * - The share `lifecycle_state` must be `stable`
   * - The share `replication_role` must not be `replica`
   * - The share `accessor_binding_role` must not be `accessor`.
   * @param {string[]} [params.userTags] - Tags for this resource.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Share>>}
   */
  public updateShare(
    params: VpcV1.UpdateShareParams
  ): Promise<VpcV1.Response<VpcV1.Share>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'accessControlMode', 'allowedTransitEncryptionModes', 'iops', 'name', 'profile', 'replicationCronSpec', 'size', 'userTags', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'access_control_mode': _params.accessControlMode,
      'allowed_transit_encryption_modes': _params.allowedTransitEncryptionModes,
      'iops': _params.iops,
      'name': _params.name,
      'profile': _params.profile,
      'replication_cron_spec': _params.replicationCronSpec,
      'size': _params.size,
      'user_tags': _params.userTags,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateShare');

    const parameters = {
      options: {
        url: '/shares/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List accessor bindings for a file share.
   *
   * This request lists accessor bindings for a share. Each accessor binding identifies a resource (possibly in another
   * account) with access to this file share including its snapshots.
   *
   * The share accessor bindings will be sorted by their `created_at` property values, with newest bindings first.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The file share identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareAccessorBindingCollection>>}
   */
  public listShareAccessorBindings(
    params: VpcV1.ListShareAccessorBindingsParams
  ): Promise<VpcV1.Response<VpcV1.ShareAccessorBindingCollection>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listShareAccessorBindings');

    const parameters = {
      options: {
        url: '/shares/{id}/accessor_bindings',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a file share accessor binding.
   *
   * This request deletes a share accessor binding. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} params.id - The file share accessor binding identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteShareAccessorBinding(
    params: VpcV1.DeleteShareAccessorBindingParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'id'];
    const _validParams = ['shareId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteShareAccessorBinding');

    const parameters = {
      options: {
        url: '/shares/{share_id}/accessor_bindings/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a file share accessor binding.
   *
   * This request retrieves a single accessor binding specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} params.id - The file share accessor binding identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareAccessorBinding>>}
   */
  public getShareAccessorBinding(
    params: VpcV1.GetShareAccessorBindingParams
  ): Promise<VpcV1.Response<VpcV1.ShareAccessorBinding>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'id'];
    const _validParams = ['shareId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getShareAccessorBinding');

    const parameters = {
      options: {
        url: '/shares/{share_id}/accessor_bindings/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Failover to replica file share.
   *
   * This request triggers a failover to the replica file share specified by the identifier in the URL. The failover
   * cannot be started if a source share or the replica share has a `lifecycle_state` of `updating`, or has a
   * replication operation in progress.
   *
   * If `fallback_policy` is specified as `split`, and the request is accepted but the failover operation cannot be
   * performed, a split will be triggered.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} [params.fallbackPolicy] - The action to take if the failover request is accepted but cannot be
   * performed or times out:
   * - `fail`: Fail the operation, resulting in the replication relationship being unchanged.
   * - `split`: Split the replica from its source, resulting in two individual read-write
   *     file shares. Because the final sync was not completed, the replica may be
   *     out-of-date. This occurs in disaster recovery scenarios where the source is known to
   *     be unreachable.
   * @param {number} [params.timeout] - The failover timeout in seconds.
   *
   * If the timeout is reached, the `fallback_policy` will be triggered.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public failoverShare(
    params: VpcV1.FailoverShareParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['shareId'];
    const _validParams = ['shareId', 'fallbackPolicy', 'timeout', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'fallback_policy': _params.fallbackPolicy,
      'timeout': _params.timeout,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'failoverShare');

    const parameters = {
      options: {
        url: '/shares/{share_id}/failover',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List mount targets for a file share.
   *
   * This request lists mount targets for a file share. A mount target is a network endpoint at which a file share may
   * be mounted. The file share can be mounted by clients in the same VPC and zone after creating share mount targets.
   *
   * The share mount targets will be sorted by their `created_at` property values, with newest targets first.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareMountTargetCollection>>}
   */
  public listShareMountTargets(
    params: VpcV1.ListShareMountTargetsParams
  ): Promise<VpcV1.Response<VpcV1.ShareMountTargetCollection>> {
    const _params = { ...params };
    const _requiredParams = ['shareId'];
    const _validParams = ['shareId', 'name', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'name': _params.name,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listShareMountTargets');

    const parameters = {
      options: {
        url: '/shares/{share_id}/mount_targets',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a mount target for a file share.
   *
   * This request creates a new share mount target from a share mount target prototype object.
   *
   * The prototype object is structured in the same way as a retrieved share mount target, and contains the information
   * necessary to provision the new file share mount target.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {ShareMountTargetPrototype} params.shareMountTargetPrototype - The share mount target prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareMountTarget>>}
   */
  public createShareMountTarget(
    params: VpcV1.CreateShareMountTargetParams
  ): Promise<VpcV1.Response<VpcV1.ShareMountTarget>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'shareMountTargetPrototype'];
    const _validParams = ['shareId', 'shareMountTargetPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.shareMountTargetPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createShareMountTarget');

    const parameters = {
      options: {
        url: '/shares/{share_id}/mount_targets',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a file share mount target.
   *
   * This request deletes a share mount target. This operation cannot be reversed.
   *
   * If the request is accepted, the share mount target `lifecycle_state` will be set to
   * `deleting`. Once deletion processing completes, it will no longer be retrievable.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} params.id - The file share mount target identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareMountTarget>>}
   */
  public deleteShareMountTarget(
    params: VpcV1.DeleteShareMountTargetParams
  ): Promise<VpcV1.Response<VpcV1.ShareMountTarget>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'id'];
    const _validParams = ['shareId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteShareMountTarget');

    const parameters = {
      options: {
        url: '/shares/{share_id}/mount_targets/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a file share mount target.
   *
   * This request retrieves a single share mount target specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} params.id - The file share mount target identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareMountTarget>>}
   */
  public getShareMountTarget(
    params: VpcV1.GetShareMountTargetParams
  ): Promise<VpcV1.Response<VpcV1.ShareMountTarget>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'id'];
    const _validParams = ['shareId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getShareMountTarget');

    const parameters = {
      options: {
        url: '/shares/{share_id}/mount_targets/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a file share mount target.
   *
   * This request updates a share mount target with the information provided in a share mount target patch object. The
   * share mount target patch object is structured in the same way as a retrieved share mount target and needs to
   * contain only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} params.id - The file share mount target identifier.
   * @param {string} [params.name] - The name for this share mount target. The name must not be used by another mount
   * target for the file share.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareMountTarget>>}
   */
  public updateShareMountTarget(
    params: VpcV1.UpdateShareMountTargetParams
  ): Promise<VpcV1.Response<VpcV1.ShareMountTarget>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'id'];
    const _validParams = ['shareId', 'id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateShareMountTarget');

    const parameters = {
      options: {
        url: '/shares/{share_id}/mount_targets/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List file share snapshots.
   *
   * This request lists snapshots for the specified file share, or across all accessible file shares. A snapshot
   * preserves the data of a share at the time the snapshot was captured.
   *
   * If the file share is a replica, the list will contain snapshots corresponding to snapshots on the source.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier, or `-` to wildcard all accessible file shares.
   * @param {string} [params.backupPolicyPlanId] - Filters the collection to backup policy jobs with a
   * `backup_policy_plan.id` property matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareSnapshotCollection>>}
   */
  public listShareSnapshots(
    params: VpcV1.ListShareSnapshotsParams
  ): Promise<VpcV1.Response<VpcV1.ShareSnapshotCollection>> {
    const _params = { ...params };
    const _requiredParams = ['shareId'];
    const _validParams = ['shareId', 'backupPolicyPlanId', 'name', 'start', 'limit', 'sort', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'backup_policy_plan.id': _params.backupPolicyPlanId,
      'name': _params.name,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listShareSnapshots');

    const parameters = {
      options: {
        url: '/shares/{share_id}/snapshots',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a snapshot for a file share.
   *
   * This request creates a new share snapshot from a share snapshot prototype object. The prototype object is
   * structured in the same way as a retrieved share snapshot, and contains the information necessary to create the new
   * share snapshot.
   *
   * The share must have an `access_control_mode` of `security_group` and a `replication_role` of `source` or `none`.
   *
   * The snapshot will inherit its `resource_group` and encryption settings from the share.
   *
   * If the share has a `replication_role` of `source`, a corresponding snapshot on the replica share will be created
   * with a `status` of `pending`. It will remain in
   * `pending` until the data is synchronized per the replication schedule determined by the replica share's
   * `replication_cron_spec`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} [params.name] - The name for this share snapshot. The name must not be used by another snapshot for
   * the file share. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {string[]} [params.userTags] - The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags)
   * associated with this share snapshot.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareSnapshot>>}
   */
  public createShareSnapshot(
    params: VpcV1.CreateShareSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.ShareSnapshot>> {
    const _params = { ...params };
    const _requiredParams = ['shareId'];
    const _validParams = ['shareId', 'name', 'userTags', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'user_tags': _params.userTags,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createShareSnapshot');

    const parameters = {
      options: {
        url: '/shares/{share_id}/snapshots',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a share snapshot.
   *
   * This request deletes a share snapshot. This operation cannot be reversed. For this request to succeed, the share
   * must have a `replication_role` of `source` or `none`.
   *
   * If the request is accepted, the share snapshot `lifecycle_state` will be set to
   * `deleting`. Once deletion processing completes, the share snapshot will no longer be retrievable.
   *
   * Deleting a share snapshot will not affect any previously-accepted requests to create a share from it.
   *
   * If the share has a `replication_role` of `source`, the corresponding snapshot on the replica share will be
   * subsequently moved to a `lifecycle_state` of `deleting`. If the data for the corresponding snapshot has already
   * been synchronized via the replication schedule determined by `replication_cron_spec`, the snapshot will remain
   * available in the replica share's `.snapshot` directory until the next replication sync.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} params.id - The share snapshot identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareSnapshot>>}
   */
  public deleteShareSnapshot(
    params: VpcV1.DeleteShareSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.ShareSnapshot>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'id'];
    const _validParams = ['shareId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteShareSnapshot');

    const parameters = {
      options: {
        url: '/shares/{share_id}/snapshots/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a share snapshot.
   *
   * This request retrieves a single share snapshot specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} params.id - The share snapshot identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareSnapshot>>}
   */
  public getShareSnapshot(
    params: VpcV1.GetShareSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.ShareSnapshot>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'id'];
    const _validParams = ['shareId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getShareSnapshot');

    const parameters = {
      options: {
        url: '/shares/{share_id}/snapshots/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a share snapshot.
   *
   * This request updates a share snapshot with the information provided in a share snapshot patch object. The share
   * snapshot patch object is structured in the same way as a retrieved share snapshot and needs to contain only the
   * information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {string} params.id - The share snapshot identifier.
   * @param {string[]} [params.userTags] - The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags)
   * associated with this share snapshot.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareSnapshot>>}
   */
  public updateShareSnapshot(
    params: VpcV1.UpdateShareSnapshotParams
  ): Promise<VpcV1.Response<VpcV1.ShareSnapshot>> {
    const _params = { ...params };
    const _requiredParams = ['shareId', 'id'];
    const _validParams = ['shareId', 'id', 'userTags', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'user_tags': _params.userTags,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateShareSnapshot');

    const parameters = {
      options: {
        url: '/shares/{share_id}/snapshots/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Split the source file share from a replica file share.
   *
   * This request removes the replication relationship between a source share and the replica share specified by the
   * identifier in the URL. The replication relationship cannot be removed if a source share or the replica share has a
   * `lifecycle_state` of `updating`, or has a replication operation in progress.
   *
   * This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteShareSource(
    params: VpcV1.DeleteShareSourceParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['shareId'];
    const _validParams = ['shareId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteShareSource');

    const parameters = {
      options: {
        url: '/shares/{share_id}/source',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve the source file share for a replica file share.
   *
   * This request retrieves the source file share associated with the replica file share specified by the identifier in
   * the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.shareId - The file share identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ShareReference>>}
   */
  public getShareSource(
    params: VpcV1.GetShareSourceParams
  ): Promise<VpcV1.Response<VpcV1.ShareReference>> {
    const _params = { ...params };
    const _requiredParams = ['shareId'];
    const _validParams = ['shareId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'share_id': _params.shareId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getShareSource');

    const parameters = {
      options: {
        url: '/shares/{share_id}/source',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * backupPolicies
   ************************/

  /**
   * List backup policies.
   *
   * This request lists backup policies in the region. Backup policies control which sources are selected for backup and
   * include a set of backup policy plans that provide the backup schedules and deletion triggers.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.tag] - Filters the collection to resources with an item in the `tags` property matching the
   * exact specified tag.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyCollection>>}
   */
  public listBackupPolicies(
    params?: VpcV1.ListBackupPoliciesParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'tag', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'tag': _params.tag,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listBackupPolicies');

    const parameters = {
      options: {
        url: '/backup_policies',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a backup policy.
   *
   * This request creates a new backup policy from a backup policy prototype object. The prototype object is structured
   * in the same way as a retrieved backup policy, and contains the information necessary to create the new backup
   * policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {BackupPolicyPrototype} params.backupPolicyPrototype - The backup policy prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicy>>}
   */
  public createBackupPolicy(
    params: VpcV1.CreateBackupPolicyParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyPrototype'];
    const _validParams = ['backupPolicyPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.backupPolicyPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createBackupPolicy');

    const parameters = {
      options: {
        url: '/backup_policies',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List jobs for a backup policy.
   *
   * This request retrieves jobs for a backup policy. A backup job represents the execution of a backup policy plan for
   * a resource matching the policy's criteria.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} [params.status] - Filters the collection to backup policy jobs with a `status` property matching
   * the specified value.
   * @param {string} [params.backupPolicyPlanId] - Filters the collection to backup policy jobs with a
   * `backup_policy_plan.id` property matching the specified identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.sourceId] - Filters the collection to backup policy jobs with a `source.id` property
   * matching the specified identifier.
   * @param {string} [params.targetSnapshotsId] - Filters the collection to backup policy jobs with an item in the
   * `target_snapshots` property with an `id` property matching the specified identifier.
   * @param {string} [params.targetSnapshotsCrn] - Filters the collection to backup policy jobs with an item in the
   * `target_snapshots` property with a `crn` property matching the specified CRN.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyJobCollection>>}
   */
  public listBackupPolicyJobs(
    params: VpcV1.ListBackupPolicyJobsParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyJobCollection>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId'];
    const _validParams = ['backupPolicyId', 'status', 'backupPolicyPlanId', 'start', 'limit', 'sort', 'sourceId', 'targetSnapshotsId', 'targetSnapshotsCrn', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'status': _params.status,
      'backup_policy_plan.id': _params.backupPolicyPlanId,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
      'source.id': _params.sourceId,
      'target_snapshots[].id': _params.targetSnapshotsId,
      'target_snapshots[].crn': _params.targetSnapshotsCrn,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listBackupPolicyJobs');

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/jobs',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a backup policy job.
   *
   * This request retrieves a single backup policy job specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} params.id - The backup policy job identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyJob>>}
   */
  public getBackupPolicyJob(
    params: VpcV1.GetBackupPolicyJobParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyJob>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId', 'id'];
    const _validParams = ['backupPolicyId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getBackupPolicyJob');

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/jobs/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List plans for a backup policy.
   *
   * This request retrieves plans for a backup policy. Backup plans provide the backup schedule and deletion triggers.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyPlanCollection>>}
   */
  public listBackupPolicyPlans(
    params: VpcV1.ListBackupPolicyPlansParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyPlanCollection>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId'];
    const _validParams = ['backupPolicyId', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'name': _params.name,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listBackupPolicyPlans');

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/plans',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a plan for a backup policy.
   *
   * This request creates a new backup policy plan from a backup policy plan prototype object. The prototype object is
   * structured in the same way as a retrieved backup policy plan, and contains the information necessary to create the
   * new backup policy plan.
   *
   * Backups created by this plan will use the resource group of the source being backed up.
   *
   * Backups created by this plan will use the plan's name truncated to 46 characters, followed by a unique 16-character
   * suffix.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} params.cronSpec - The cron specification for the backup schedule. The backup policy jobs
   * (which create and delete backups for this plan) will not start until this time, and may start for up to 90 minutes
   * after this time.
   *
   * All backup schedules for plans in the same policy must be at least an hour apart.
   * @param {boolean} [params.active] - Indicates whether the plan is active.
   * @param {string[]} [params.attachUserTags] - User tags to attach to each backup (snapshot) created by this plan. If
   * unspecified, no user tags will be attached.
   * @param {BackupPolicyPlanClonePolicyPrototype} [params.clonePolicy] -
   * @param {boolean} [params.copyUserTags] - Indicates whether to copy the source's user tags to the created backups
   * (snapshots).
   * @param {BackupPolicyPlanDeletionTriggerPrototype} [params.deletionTrigger] -
   * @param {string} [params.name] - The name for this backup policy plan. The name must not be used by another plan for
   * the backup policy. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {BackupPolicyPlanRemoteRegionPolicyPrototype[]} [params.remoteRegionPolicies] - The policies for additional
   * backups in remote regions.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>>}
   */
  public createBackupPolicyPlan(
    params: VpcV1.CreateBackupPolicyPlanParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId', 'cronSpec'];
    const _validParams = ['backupPolicyId', 'cronSpec', 'active', 'attachUserTags', 'clonePolicy', 'copyUserTags', 'deletionTrigger', 'name', 'remoteRegionPolicies', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'cron_spec': _params.cronSpec,
      'active': _params.active,
      'attach_user_tags': _params.attachUserTags,
      'clone_policy': _params.clonePolicy,
      'copy_user_tags': _params.copyUserTags,
      'deletion_trigger': _params.deletionTrigger,
      'name': _params.name,
      'remote_region_policies': _params.remoteRegionPolicies,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createBackupPolicyPlan');

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/plans',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a backup policy plan.
   *
   * This request deletes a backup policy plan. This operation cannot be reversed. Any backups that have been created by
   * the plan will remain but will no longer be subject to the plan's deletion trigger. Any running jobs associated with
   * the plan will run to completion before the plan is deleted.
   *
   * If the request is accepted, the backup policy plan `status` will be set to `deleting`. Once deletion processing
   * completes, the backup policy plan will no longer be retrievable.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} params.id - The backup policy plan identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>>}
   */
  public deleteBackupPolicyPlan(
    params: VpcV1.DeleteBackupPolicyPlanParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId', 'id'];
    const _validParams = ['backupPolicyId', 'id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteBackupPolicyPlan');

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/plans/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a backup policy plan.
   *
   * This request retrieves a single backup policy plan specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} params.id - The backup policy plan identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>>}
   */
  public getBackupPolicyPlan(
    params: VpcV1.GetBackupPolicyPlanParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId', 'id'];
    const _validParams = ['backupPolicyId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getBackupPolicyPlan');

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/plans/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a backup policy plan.
   *
   * This request updates a backup policy plan with the information in a provided plan patch. The plan patch object is
   * structured in the same way as a retrieved backup policy plan and can contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.backupPolicyId - The backup policy identifier.
   * @param {string} params.id - The backup policy plan identifier.
   * @param {boolean} [params.active] - Indicates whether the plan is active.
   * @param {string[]} [params.attachUserTags] - The user tags to attach to backups (snapshots) created by this plan.
   * Updating this value does not change the user tags for backups that have already been created by this plan.
   * @param {BackupPolicyPlanClonePolicyPatch} [params.clonePolicy] -
   * @param {boolean} [params.copyUserTags] - Indicates whether to copy the source's user tags to the created backups
   * (snapshots).
   * @param {string} [params.cronSpec] - The cron specification for the backup schedule. The backup policy jobs
   * (which create and delete backups for this plan) will not start until this time, and may start for up to 90 minutes
   * after this time.
   *
   * All backup schedules for plans in the same policy must be at least an hour apart.
   * @param {BackupPolicyPlanDeletionTriggerPatch} [params.deletionTrigger] -
   * @param {string} [params.name] - The name for this backup policy plan. The name must not be used by another plan for
   * the backup policy.
   * @param {BackupPolicyPlanRemoteRegionPolicyPrototype[]} [params.remoteRegionPolicies] - The policies for additional
   * backups in remote regions (replacing any existing policies).
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>>}
   */
  public updateBackupPolicyPlan(
    params: VpcV1.UpdateBackupPolicyPlanParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicyPlan>> {
    const _params = { ...params };
    const _requiredParams = ['backupPolicyId', 'id'];
    const _validParams = ['backupPolicyId', 'id', 'active', 'attachUserTags', 'clonePolicy', 'copyUserTags', 'cronSpec', 'deletionTrigger', 'name', 'remoteRegionPolicies', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'active': _params.active,
      'attach_user_tags': _params.attachUserTags,
      'clone_policy': _params.clonePolicy,
      'copy_user_tags': _params.copyUserTags,
      'cron_spec': _params.cronSpec,
      'deletion_trigger': _params.deletionTrigger,
      'name': _params.name,
      'remote_region_policies': _params.remoteRegionPolicies,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'backup_policy_id': _params.backupPolicyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateBackupPolicyPlan');

    const parameters = {
      options: {
        url: '/backup_policies/{backup_policy_id}/plans/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a backup policy.
   *
   * This request deletes a backup policy. This operation cannot be reversed.
   *
   * If the request is accepted, the backup policy `status` will be set to `deleting`. Once deletion processing
   * completes, the backup policy will no longer be retrievable.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The backup policy identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicy>>}
   */
  public deleteBackupPolicy(
    params: VpcV1.DeleteBackupPolicyParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteBackupPolicy');

    const parameters = {
      options: {
        url: '/backup_policies/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a backup policy.
   *
   * This request retrieves a single backup policy specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The backup policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicy>>}
   */
  public getBackupPolicy(
    params: VpcV1.GetBackupPolicyParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getBackupPolicy');

    const parameters = {
      options: {
        url: '/backup_policies/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a backup policy.
   *
   * This request updates a backup policy with the information in a provided backup policy patch. The backup policy
   * patch object is structured in the same way as a retrieved backup policy and contains only the information to be
   * updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The backup policy identifier.
   * @param {string[]} [params.includedContent] - The included content for backups created using this policy:
   * - `boot_volume`: Include the instance's boot volume.
   * - `data_volumes`: Include the instance's data volumes.
   * @param {string[]} [params.matchUserTags] - The user tags this backup policy will apply to (replacing any existing
   * tags). Resources that have both a matching user tag and a matching type will be subject to the backup policy.
   * @param {string} [params.name] - The name for this backup policy. The name must not be used by another backup policy
   * in the region.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.BackupPolicy>>}
   */
  public updateBackupPolicy(
    params: VpcV1.UpdateBackupPolicyParams
  ): Promise<VpcV1.Response<VpcV1.BackupPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'includedContent', 'matchUserTags', 'name', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'included_content': _params.includedContent,
      'match_user_tags': _params.matchUserTags,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateBackupPolicy');

    const parameters = {
      options: {
        url: '/backup_policies/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * geography
   ************************/

  /**
   * List regions.
   *
   * This request lists regions. Each region is a separate geographic area that contains multiple isolated zones.
   * Resources can be provisioned into one or more zones in a region. Each zone is isolated, but connected to other
   * zones in the same region with low-latency and high-bandwidth links. Regions represent the top-level of fault
   * isolation available. Resources deployed within a single region also benefit from the low latency afforded by
   * geographic proximity.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.RegionCollection>>}
   */
  public listRegions(
    params?: VpcV1.ListRegionsParams
  ): Promise<VpcV1.Response<VpcV1.RegionCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listRegions');

    const parameters = {
      options: {
        url: '/regions',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a region.
   *
   * This request retrieves a single region specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The region name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Region>>}
   */
  public getRegion(
    params: VpcV1.GetRegionParams
  ): Promise<VpcV1.Response<VpcV1.Region>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getRegion');

    const parameters = {
      options: {
        url: '/regions/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List zones in a region.
   *
   * This request lists zones in a region. Zones represent logically-isolated data centers with high-bandwidth and
   * low-latency interconnects to other zones in the same region. Faults in a zone do not affect other zones.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.regionName - The region name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ZoneCollection>>}
   */
  public listRegionZones(
    params: VpcV1.ListRegionZonesParams
  ): Promise<VpcV1.Response<VpcV1.ZoneCollection>> {
    const _params = { ...params };
    const _requiredParams = ['regionName'];
    const _validParams = ['regionName', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'region_name': _params.regionName,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listRegionZones');

    const parameters = {
      options: {
        url: '/regions/{region_name}/zones',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a zone.
   *
   * This request retrieves a single zone specified by the region and zone names in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.regionName - The region name.
   * @param {string} params.name - The zone name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.Zone>>}
   */
  public getRegionZone(
    params: VpcV1.GetRegionZoneParams
  ): Promise<VpcV1.Response<VpcV1.Zone>> {
    const _params = { ...params };
    const _requiredParams = ['regionName', 'name'];
    const _validParams = ['regionName', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'region_name': _params.regionName,
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getRegionZone');

    const parameters = {
      options: {
        url: '/regions/{region_name}/zones/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * virtualNetworkInterfaces
   ************************/

  /**
   * List virtual network interfaces.
   *
   * This request lists virtual network interfaces in the region. A virtual network interface is a logical abstraction
   * of a virtual network interface in a subnet, and may be attached to a target resource.
   *
   * The virtual network interfaces will be sorted by their `created_at` property values, with newest virtual network
   * interfaces first. Virtual network interfaces with identical
   * `created_at` property values will in turn be sorted by ascending `name` property values.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VirtualNetworkInterfaceCollection>>}
   */
  public listVirtualNetworkInterfaces(
    params?: VpcV1.ListVirtualNetworkInterfacesParams
  ): Promise<VpcV1.Response<VpcV1.VirtualNetworkInterfaceCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVirtualNetworkInterfaces');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a virtual network interface.
   *
   * This request creates a new virtual network interface from a virtual network interface prototype object. The
   * prototype object is structured in the same way as a retrieved virtual network interface, and contains the
   * information necessary to create the new virtual network interface.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {boolean} [params.allowIpSpoofing] - Indicates whether source IP spoofing is allowed on this interface. If
   * `false`, source IP spoofing is prevented on this interface. If `true`, source IP spoofing is allowed on this
   * interface.
   * @param {boolean} [params.autoDelete] - Indicates whether this virtual network interface will be automatically
   * deleted when
   * `target` is deleted. Must be `false` if the virtual network interface is unbound.
   * @param {boolean} [params.enableInfrastructureNat] - If `true`:
   * - The VPC infrastructure performs any needed NAT operations.
   * - `floating_ips` must not have more than one floating IP.
   *
   * If `false`:
   * - Packets are passed unchanged to/from the virtual network interface,
   *   allowing the workload to perform any needed NAT operations.
   * - `allow_ip_spoofing` must be `false`.
   * - Can only be attached to a `target` with a `resource_type` of
   *   `bare_metal_server_network_attachment`.
   * @param {VirtualNetworkInterfaceIPPrototype[]} [params.ips] - Additional IP addresses to bind to the virtual network
   * interface. Each item may be either a reserved IP identity, or a reserved IP prototype object which will be used to
   * create a new reserved IP. All IP addresses must be in the primary IP's subnet.
   *
   * If reserved IP identities are provided, the specified reserved IPs must be unbound.
   *
   * If reserved IP prototype objects with addresses are provided, the addresses must be available on the virtual
   * network interface's subnet. For any prototype objects that do not specify an address, an available address on the
   * subnet will be automatically selected and reserved.
   * @param {string} [params.name] - The name for this virtual network interface. The name must not be used by another
   * virtual network interface in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected
   * words. Names beginning with `ibm-` are reserved for provider-owned resources, and are not allowed.
   * @param {VirtualNetworkInterfacePrimaryIPPrototype} [params.primaryIp] - The primary IP address to bind to the
   * virtual network interface. May be either a
   * reserved IP identity, or a reserved IP prototype object which will be used to create a
   * new reserved IP.
   *
   * If a reserved IP identity is provided, the specified reserved IP must be unbound.
   *
   * If a reserved IP prototype object with an address is provided, the address must be
   * available on the virtual network interface's subnet. If no address is specified,
   * an available address on the subnet will be automatically selected and reserved.
   * @param {string} [params.protocolStateFilteringMode] - The protocol state filtering mode to use for this virtual
   * network interface. If
   * `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target`
   * resource type:
   *
   * - `bare_metal_server_network_attachment`: disabled
   * - `instance_network_attachment`: enabled
   * - `share_mount_target`: enabled
   *
   * Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops
   * any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering
   * mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {SecurityGroupIdentity[]} [params.securityGroups] - The security groups to use for this virtual network
   * interface. If unspecified, the default security group of the VPC for the subnet is used.
   * @param {SubnetIdentity} [params.subnet] - The associated subnet. Required if `primary_ip` does not specify a
   * reserved IP
   * identity.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>>}
   */
  public createVirtualNetworkInterface(
    params?: VpcV1.CreateVirtualNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['allowIpSpoofing', 'autoDelete', 'enableInfrastructureNat', 'ips', 'name', 'primaryIp', 'protocolStateFilteringMode', 'resourceGroup', 'securityGroups', 'subnet', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'allow_ip_spoofing': _params.allowIpSpoofing,
      'auto_delete': _params.autoDelete,
      'enable_infrastructure_nat': _params.enableInfrastructureNat,
      'ips': _params.ips,
      'name': _params.name,
      'primary_ip': _params.primaryIp,
      'protocol_state_filtering_mode': _params.protocolStateFilteringMode,
      'resource_group': _params.resourceGroup,
      'security_groups': _params.securityGroups,
      'subnet': _params.subnet,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVirtualNetworkInterface');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a virtual network interface.
   *
   * This request deletes a virtual network interface. This operation cannot be reversed. For this request to succeed,
   * the virtual network interface must not be required by another resource, such as the primary network attachment for
   * an instance.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The virtual network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>>}
   */
  public deleteVirtualNetworkInterfaces(
    params: VpcV1.DeleteVirtualNetworkInterfacesParams
  ): Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVirtualNetworkInterfaces');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a virtual network interface.
   *
   * This request retrieves a single virtual network interface specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The virtual network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>>}
   */
  public getVirtualNetworkInterface(
    params: VpcV1.GetVirtualNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVirtualNetworkInterface');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a virtual network interface.
   *
   * This request updates a virtual network interface with the information in a provided virtual network interface
   * patch. The virtual network interface patch object is structured in the same way as a retrieved virtual network
   * interface and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The virtual network interface identifier.
   * @param {boolean} [params.allowIpSpoofing] - Indicates whether source IP spoofing is allowed on this interface.
   *
   * Must be `false` if `target` is a file share mount target.
   * @param {boolean} [params.autoDelete] - Indicates whether this virtual network interface will be automatically
   * deleted when
   * `target` is deleted. Must be `false` if the virtual network interface is unbound.
   * @param {boolean} [params.enableInfrastructureNat] - If `true`:
   * - The VPC infrastructure performs any needed NAT operations.
   * - `floating_ips` must not have more than one floating IP.
   *
   * If `false`:
   * - Packets are passed unchanged to/from the virtual network interface,
   *   allowing the workload to perform any needed NAT operations.
   * - `allow_ip_spoofing` must be `false`.
   * - Can only be attached to a `target` with a `resource_type` of
   *   `bare_metal_server_network_attachment`.
   * @param {string} [params.name] - The name for this virtual network interface. The name must not be used by another
   * virtual network interface in the region. Names beginning with `ibm-` are reserved for provider-owned resources, and
   * are not allowed.
   * @param {string} [params.protocolStateFilteringMode] - The protocol state filtering mode to use for this virtual
   * network interface. If
   * `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target`
   * resource type:
   *
   * - `bare_metal_server_network_attachment`: disabled
   * - `instance_network_attachment`: enabled
   * - `share_mount_target`: enabled
   *
   * Must not be `disabled` if the virtual network interface's `target` resource type is
   * `share_mount_target`.
   *
   * Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops
   * any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering
   * mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>>}
   */
  public updateVirtualNetworkInterface(
    params: VpcV1.UpdateVirtualNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.VirtualNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'allowIpSpoofing', 'autoDelete', 'enableInfrastructureNat', 'name', 'protocolStateFilteringMode', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'allow_ip_spoofing': _params.allowIpSpoofing,
      'auto_delete': _params.autoDelete,
      'enable_infrastructure_nat': _params.enableInfrastructureNat,
      'name': _params.name,
      'protocol_state_filtering_mode': _params.protocolStateFilteringMode,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVirtualNetworkInterface');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List floating IPs associated with a virtual network interface.
   *
   * This request lists floating IPs associated with a virtual network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.virtualNetworkInterfaceId - The virtual network interface identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value
   * `-name` sorts the collection by the `name` property in descending order, and the value `name` sorts it by the
   * `name` property in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIPCollectionVirtualNetworkInterfaceContext>>}
   */
  public listNetworkInterfaceFloatingIps(
    params: VpcV1.ListNetworkInterfaceFloatingIpsParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIPCollectionVirtualNetworkInterfaceContext>> {
    const _params = { ...params };
    const _requiredParams = ['virtualNetworkInterfaceId'];
    const _validParams = ['virtualNetworkInterfaceId', 'start', 'limit', 'sort', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const path = {
      'virtual_network_interface_id': _params.virtualNetworkInterfaceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listNetworkInterfaceFloatingIps');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{virtual_network_interface_id}/floating_ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Disassociate a floating IP from a virtual network interface.
   *
   * This request disassociates the specified floating IP from the specified virtual network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.virtualNetworkInterfaceId - The virtual network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeNetworkInterfaceFloatingIp(
    params: VpcV1.RemoveNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['virtualNetworkInterfaceId', 'id'];
    const _validParams = ['virtualNetworkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'virtual_network_interface_id': _params.virtualNetworkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'removeNetworkInterfaceFloatingIp');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{virtual_network_interface_id}/floating_ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve associated floating IP.
   *
   * This request retrieves a specified floating IP if it is associated with the virtual network interface specified in
   * the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.virtualNetworkInterfaceId - The virtual network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIPReference>>}
   */
  public getNetworkInterfaceFloatingIp(
    params: VpcV1.GetNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIPReference>> {
    const _params = { ...params };
    const _requiredParams = ['virtualNetworkInterfaceId', 'id'];
    const _validParams = ['virtualNetworkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'virtual_network_interface_id': _params.virtualNetworkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getNetworkInterfaceFloatingIp');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{virtual_network_interface_id}/floating_ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Add an association between a floating IP and a virtual network interface.
   *
   * This request adds an association between the specified floating IP and the specified virtual network interface.
   *
   * If the virtual network interface has `enable_infrastructure_nat` set to `true`, no more than one floating IP can be
   * associated, and network address translation is performed between the floating IP address and the virtual network
   * interface's `primary_ip` address.
   *
   * If the virtual network interface has `enable_infrastructure_nat` set to `false`, packets are passed unchanged
   * to/from the virtual network interface.
   *
   * The floating IP must:
   * - be in the same `zone` as the virtual network interface
   * - not currently be associated with another resource
   *
   * The virtual network interface's `target` must not currently be a file share mount target.
   *
   * A request body is not required, and if provided, is ignored.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.virtualNetworkInterfaceId - The virtual network interface identifier.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIPReference>>}
   */
  public addNetworkInterfaceFloatingIp(
    params: VpcV1.AddNetworkInterfaceFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIPReference>> {
    const _params = { ...params };
    const _requiredParams = ['virtualNetworkInterfaceId', 'id'];
    const _validParams = ['virtualNetworkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'virtual_network_interface_id': _params.virtualNetworkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'addNetworkInterfaceFloatingIp');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{virtual_network_interface_id}/floating_ips/{id}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List reserved IPs bound to a virtual network interface.
   *
   * This request lists reserved IPs bound to a virtual network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.virtualNetworkInterfaceId - The virtual network interface identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value
   * `-name` sorts the collection by the `name` property in descending order, and the value `name` sorts it by the
   * `name` property in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIPCollectionVirtualNetworkInterfaceContext>>}
   */
  public listVirtualNetworkInterfaceIps(
    params: VpcV1.ListVirtualNetworkInterfaceIpsParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIPCollectionVirtualNetworkInterfaceContext>> {
    const _params = { ...params };
    const _requiredParams = ['virtualNetworkInterfaceId'];
    const _validParams = ['virtualNetworkInterfaceId', 'start', 'limit', 'sort', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const path = {
      'virtual_network_interface_id': _params.virtualNetworkInterfaceId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVirtualNetworkInterfaceIps');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{virtual_network_interface_id}/ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Unbind a reserved IP from a virtual network interface.
   *
   * This request unbinds the specified reserved IP from the specified virtual network interface. If the reserved IP has
   * `auto_delete` set to `true`, the reserved IP will be deleted.
   *
   * The reserved IP for the `primary_ip` cannot be unbound.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.virtualNetworkInterfaceId - The virtual network interface identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeVirtualNetworkInterfaceIp(
    params: VpcV1.RemoveVirtualNetworkInterfaceIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['virtualNetworkInterfaceId', 'id'];
    const _validParams = ['virtualNetworkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'virtual_network_interface_id': _params.virtualNetworkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'removeVirtualNetworkInterfaceIp');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{virtual_network_interface_id}/ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve bound reserved IP.
   *
   * This request retrieves the specified reserved IP address if it is bound to the virtual network interface specified
   * in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.virtualNetworkInterfaceId - The virtual network interface identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIPReference>>}
   */
  public getVirtualNetworkInterfaceIp(
    params: VpcV1.GetVirtualNetworkInterfaceIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIPReference>> {
    const _params = { ...params };
    const _requiredParams = ['virtualNetworkInterfaceId', 'id'];
    const _validParams = ['virtualNetworkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'virtual_network_interface_id': _params.virtualNetworkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVirtualNetworkInterfaceIp');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{virtual_network_interface_id}/ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Bind a reserved IP to a virtual network interface.
   *
   * This request binds the specified reserved IP to the specified virtual network interface.
   *
   * The reserved IP must currently be unbound and in the primary IP's subnet. The virtual network interface's `target`
   * must not currently be a file share mount target.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.virtualNetworkInterfaceId - The virtual network interface identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIPReference>>}
   */
  public addVirtualNetworkInterfaceIp(
    params: VpcV1.AddVirtualNetworkInterfaceIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIPReference>> {
    const _params = { ...params };
    const _requiredParams = ['virtualNetworkInterfaceId', 'id'];
    const _validParams = ['virtualNetworkInterfaceId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'virtual_network_interface_id': _params.virtualNetworkInterfaceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'addVirtualNetworkInterfaceIp');

    const parameters = {
      options: {
        url: '/virtual_network_interfaces/{virtual_network_interface_id}/ips/{id}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * clusterNetworks
   ************************/

  /**
   * List cluster network profiles.
   *
   * This request lists cluster network profiles available in the region. A cluster network profile specifies the
   * performance characteristics and capabilities for a cluster network.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkProfileCollection>>}
   */
  public listClusterNetworkProfiles(
    params?: VpcV1.ListClusterNetworkProfilesParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listClusterNetworkProfiles');

    const parameters = {
      options: {
        url: '/cluster_network/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a cluster network profile.
   *
   * This request retrieves a single cluster network profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The cluster network profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkProfile>>}
   */
  public getClusterNetworkProfile(
    params: VpcV1.GetClusterNetworkProfileParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getClusterNetworkProfile');

    const parameters = {
      options: {
        url: '/cluster_network/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List cluster networks.
   *
   * This request lists [cluster networks](https://cloud.ibm.com/docs/vpc?topic=vpc-about-cluster-network) in the
   * region. A cluster network is a grouping of resources in a separate networking space for high performance computing
   * and networking.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.vpcId] - Filters the collection to cluster networks with a `vpc.id` property matching the
   * specified id.
   * @param {string} [params.vpcCrn] - Filters the collection to cluster networks with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to cluster networks with a `vpc.name` property matching
   * the specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkCollection>>}
   */
  public listClusterNetworks(
    params?: VpcV1.ListClusterNetworksParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'sort', 'vpcId', 'vpcCrn', 'vpcName', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'sort': _params.sort,
      'vpc.id': _params.vpcId,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listClusterNetworks');

    const parameters = {
      options: {
        url: '/cluster_networks',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a cluster network.
   *
   * This request creates a new cluster network from a cluster network prototype object. The prototype object is
   * structured in the same way as a retrieved cluster network, and contains the information necessary to create the new
   * cluster network.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {ClusterNetworkProfileIdentity} params.profile - The profile to use for this cluster network.
   * @param {VPCIdentity} params.vpc - The VPC this cluster network will reside in.
   * @param {ZoneIdentity} params.zone - The zone this cluster network will reside in. The zone must be listed
   * as supported on the specified cluster network profile.
   * @param {string} [params.name] - The name for this cluster network. The name must not be used by another cluster
   * network in the region. Names starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
   * If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {ClusterNetworkSubnetPrefixPrototype[]} [params.subnetPrefixes] -
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetwork>>}
   */
  public createClusterNetwork(
    params: VpcV1.CreateClusterNetworkParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetwork>> {
    const _params = { ...params };
    const _requiredParams = ['profile', 'vpc', 'zone'];
    const _validParams = ['profile', 'vpc', 'zone', 'name', 'resourceGroup', 'subnetPrefixes', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'profile': _params.profile,
      'vpc': _params.vpc,
      'zone': _params.zone,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
      'subnet_prefixes': _params.subnetPrefixes,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createClusterNetwork');

    const parameters = {
      options: {
        url: '/cluster_networks',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List cluster network interfaces.
   *
   * This request lists cluster network interfaces in the region. A cluster network interface is a logical abstraction
   * of a cluster network interface in a subnet, and may be attached to a target resource.
   *
   * The cluster network interfaces will be sorted by their `created_at` property values, with newest cluster network
   * interfaces first. Cluster network interfaces with identical
   * `created_at` property values will in turn be sorted by ascending `name` property values.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkInterfaceCollection>>}
   */
  public listClusterNetworkInterfaces(
    params: VpcV1.ListClusterNetworkInterfacesParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkInterfaceCollection>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId'];
    const _validParams = ['clusterNetworkId', 'start', 'limit', 'name', 'sort', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'name': _params.name,
      'sort': _params.sort,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listClusterNetworkInterfaces');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/interfaces',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a cluster network interface.
   *
   * This request creates a new cluster network interface from a cluster network interface prototype object. The
   * prototype object is structured in the same way as a retrieved cluster network interface, and contains the
   * information necessary to create the new cluster network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} [params.name] - The name for this cluster network interface. The name must not be used by another
   * interface in the cluster network. Names beginning with `ibm-` are reserved for provider-owned resources, and are
   * not allowed. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ClusterNetworkInterfacePrimaryIPPrototype} [params.primaryIp] - The primary IP address to bind to the
   * cluster network interface. May be either
   * a cluster network subnet reserved IP identity, or a cluster network subnet reserved IP
   * prototype object which will be used to create a new cluster network subnet reserved IP.
   *
   * If a cluster network subnet reserved IP identity is provided, the specified cluster
   * network subnet reserved IP must be unbound.
   *
   * If a cluster network subnet reserved IP prototype object with an address is provided,
   * the address must be available on the cluster network interface's cluster network
   * subnet. If no address is specified, an available address on the cluster network subnet
   * will be automatically selected and reserved.
   * @param {ClusterNetworkSubnetIdentity} [params.subnet] - The associated cluster network subnet. Required if
   * `primary_ip` does not specify a cluster
   * network subnet reserved IP identity.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkInterface>>}
   */
  public createClusterNetworkInterface(
    params: VpcV1.CreateClusterNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId'];
    const _validParams = ['clusterNetworkId', 'name', 'primaryIp', 'subnet', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'primary_ip': _params.primaryIp,
      'subnet': _params.subnet,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createClusterNetworkInterface');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/interfaces',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a cluster network interface.
   *
   * This request deletes a cluster network interface. This operation cannot be reversed. For this request to succeed,
   * the cluster network interface must not be required by another resource, such as a cluster network attachment for a
   * virtual server instance.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} params.id - The cluster network interface identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkInterface>>}
   */
  public deleteClusterNetworkInterface(
    params: VpcV1.DeleteClusterNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'id'];
    const _validParams = ['clusterNetworkId', 'id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteClusterNetworkInterface');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/interfaces/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a cluster network interface.
   *
   * This request retrieves a single cluster network interface specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} params.id - The cluster network interface identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkInterface>>}
   */
  public getClusterNetworkInterface(
    params: VpcV1.GetClusterNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'id'];
    const _validParams = ['clusterNetworkId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getClusterNetworkInterface');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/interfaces/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a cluster network interface.
   *
   * This request updates a cluster network interface with the information provided in a cluster network interface patch
   * object. The patch object is structured in the same way as a retrieved cluster network interface and needs to
   * contain only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} params.id - The cluster network interface identifier.
   * @param {boolean} [params.autoDelete] - Indicates whether this cluster network interface will be automatically
   * deleted when `target` is deleted. Must be `false` if the cluster network interface is unbound.
   * @param {string} [params.name] - The name for this cluster network interface. The name must not be used by another
   * interface in the cluster network. Names beginning with `ibm-` are reserved for provider-owned resources, and are
   * not allowed.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkInterface>>}
   */
  public updateClusterNetworkInterface(
    params: VpcV1.UpdateClusterNetworkInterfaceParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkInterface>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'id'];
    const _validParams = ['clusterNetworkId', 'id', 'autoDelete', 'name', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'auto_delete': _params.autoDelete,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateClusterNetworkInterface');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/interfaces/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List cluster network subnets.
   *
   * This request lists cluster network subnets in the cluster network. A cluster network subnet provides network
   * routing between other cluster network subnets within a cluster network.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetCollection>>}
   */
  public listClusterNetworkSubnets(
    params: VpcV1.ListClusterNetworkSubnetsParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetCollection>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId'];
    const _validParams = ['clusterNetworkId', 'start', 'limit', 'name', 'sort', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'name': _params.name,
      'sort': _params.sort,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listClusterNetworkSubnets');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/subnets',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a cluster network subnet.
   *
   * This request creates a new cluster network subnet from a cluster network subnet prototype object. The prototype
   * object is structured in the same way as a retrieved cluster network subnet, and contains the information necessary
   * to create the new cluster network subnet.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {ClusterNetworkSubnetPrototype} params.clusterNetworkSubnetPrototype - The cluster network subnet prototype
   * object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnet>>}
   */
  public createClusterNetworkSubnet(
    params: VpcV1.CreateClusterNetworkSubnetParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnet>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'clusterNetworkSubnetPrototype'];
    const _validParams = ['clusterNetworkId', 'clusterNetworkSubnetPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.clusterNetworkSubnetPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createClusterNetworkSubnet');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/subnets',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List cluster network subnet reserved IPs.
   *
   * This request lists cluster network subnet reserved IPs in the cluster network.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} params.clusterNetworkSubnetId - The cluster network subnet identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetReservedIPCollection>>}
   */
  public listClusterNetworkSubnetReservedIps(
    params: VpcV1.ListClusterNetworkSubnetReservedIpsParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetReservedIPCollection>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'clusterNetworkSubnetId'];
    const _validParams = ['clusterNetworkId', 'clusterNetworkSubnetId', 'start', 'limit', 'name', 'sort', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'name': _params.name,
      'sort': _params.sort,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
      'cluster_network_subnet_id': _params.clusterNetworkSubnetId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listClusterNetworkSubnetReservedIps');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/subnets/{cluster_network_subnet_id}/reserved_ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a cluster network subnet reserved IP.
   *
   * This request creates a new cluster network subnet reserved IP from a cluster network subnet reserved IP prototype
   * object. The prototype object is structured in the same way as a retrieved cluster network subnet reserved IP, and
   * contains the information necessary to create the new cluster network subnet reserved IP.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} params.clusterNetworkSubnetId - The cluster network subnet identifier.
   * @param {string} [params.address] - The IP address to reserve, which must not already be reserved on the subnet.
   *
   * If unspecified, an available address on the subnet will automatically be selected.
   * @param {string} [params.name] - The name for this cluster network subnet reserved IP. The name must not be used by
   * another reserved IP in the cluster network subnet. Names starting with `ibm-` are reserved for provider-owned
   * resources, and are not allowed. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetReservedIP>>}
   */
  public createClusterNetworkSubnetReservedIp(
    params: VpcV1.CreateClusterNetworkSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'clusterNetworkSubnetId'];
    const _validParams = ['clusterNetworkId', 'clusterNetworkSubnetId', 'address', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'address': _params.address,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
      'cluster_network_subnet_id': _params.clusterNetworkSubnetId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createClusterNetworkSubnetReservedIp');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/subnets/{cluster_network_subnet_id}/reserved_ips',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a cluster network subnet reserved IP.
   *
   * This request deletes a cluster network subnet reserved IP. This operation cannot be reversed.
   *
   * For this request to succeed, the reserved IP must be unbound. A provider-owned reserved IP is not allowed to be
   * deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} params.clusterNetworkSubnetId - The cluster network subnet identifier.
   * @param {string} params.id - The cluster network subnet reserved IP identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetReservedIP>>}
   */
  public deleteClusterNetworkSubnetReservedIp(
    params: VpcV1.DeleteClusterNetworkSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'clusterNetworkSubnetId', 'id'];
    const _validParams = ['clusterNetworkId', 'clusterNetworkSubnetId', 'id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
      'cluster_network_subnet_id': _params.clusterNetworkSubnetId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteClusterNetworkSubnetReservedIp');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/subnets/{cluster_network_subnet_id}/reserved_ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a cluster network subnet reserved IP.
   *
   * This request retrieves a single cluster network subnet reserved IP specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} params.clusterNetworkSubnetId - The cluster network subnet identifier.
   * @param {string} params.id - The cluster network subnet reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetReservedIP>>}
   */
  public getClusterNetworkSubnetReservedIp(
    params: VpcV1.GetClusterNetworkSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'clusterNetworkSubnetId', 'id'];
    const _validParams = ['clusterNetworkId', 'clusterNetworkSubnetId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
      'cluster_network_subnet_id': _params.clusterNetworkSubnetId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getClusterNetworkSubnetReservedIp');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/subnets/{cluster_network_subnet_id}/reserved_ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a cluster network subnet reserved IP.
   *
   * This request updates a cluster network subnet reserved IP with the information provided in a cluster network subnet
   * reserved IP patch object. The patch object is structured in the same way as a retrieved cluster network subnet
   * reserved IP and needs to contain only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} params.clusterNetworkSubnetId - The cluster network subnet identifier.
   * @param {string} params.id - The cluster network subnet reserved IP identifier.
   * @param {boolean} [params.autoDelete] - Indicates whether this cluster network subnet reserved IP member will be
   * automatically deleted when either `target` is deleted, or the cluster network subnet reserved IP is unbound. Must
   * be `false` if the cluster network subnet reserved IP is unbound.
   * @param {string} [params.name] - The name for this cluster network subnet reserved IP. The name must not be used by
   * another reserved IP in the cluster network subnet. Names starting with `ibm-` are reserved for provider-owned
   * resources, and are not allowed.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetReservedIP>>}
   */
  public updateClusterNetworkSubnetReservedIp(
    params: VpcV1.UpdateClusterNetworkSubnetReservedIpParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnetReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'clusterNetworkSubnetId', 'id'];
    const _validParams = ['clusterNetworkId', 'clusterNetworkSubnetId', 'id', 'autoDelete', 'name', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'auto_delete': _params.autoDelete,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
      'cluster_network_subnet_id': _params.clusterNetworkSubnetId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateClusterNetworkSubnetReservedIp');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/subnets/{cluster_network_subnet_id}/reserved_ips/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a cluster network subnet.
   *
   * This request deletes a cluster network subnet. This operation cannot be reversed.
   *
   * For this request to succeed, this cluster subnet must not be attached to a cluster network interface.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} params.id - The cluster network subnet identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnet>>}
   */
  public deleteClusterNetworkSubnet(
    params: VpcV1.DeleteClusterNetworkSubnetParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnet>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'id'];
    const _validParams = ['clusterNetworkId', 'id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteClusterNetworkSubnet');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/subnets/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a cluster network subnet.
   *
   * This request retrieves a single cluster network subnet specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} params.id - The cluster network subnet identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnet>>}
   */
  public getClusterNetworkSubnet(
    params: VpcV1.GetClusterNetworkSubnetParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnet>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'id'];
    const _validParams = ['clusterNetworkId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getClusterNetworkSubnet');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/subnets/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a cluster network subnet.
   *
   * This request updates a cluster network subnet with the information provided in a cluster network subnet patch
   * object. The patch object is structured in the same way as a retrieved cluster network subnet and needs to contain
   * only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.clusterNetworkId - The cluster network identifier.
   * @param {string} params.id - The cluster network subnet identifier.
   * @param {string} [params.name] - The name for this cluster network subnet. The name must not be used by another
   * cluster network subnet in the cluster network. Names starting with `ibm-` are reserved for provider-owned
   * resources, and are not allowed.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnet>>}
   */
  public updateClusterNetworkSubnet(
    params: VpcV1.UpdateClusterNetworkSubnetParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetworkSubnet>> {
    const _params = { ...params };
    const _requiredParams = ['clusterNetworkId', 'id'];
    const _validParams = ['clusterNetworkId', 'id', 'name', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'cluster_network_id': _params.clusterNetworkId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateClusterNetworkSubnet');

    const parameters = {
      options: {
        url: '/cluster_networks/{cluster_network_id}/subnets/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a cluster network.
   *
   * This request deletes a cluster network. This operation cannot be reversed.
   *
   * For this request to succeed, virtual server instances must not reside in this cluster network.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The cluster network identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetwork>>}
   */
  public deleteClusterNetwork(
    params: VpcV1.DeleteClusterNetworkParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetwork>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteClusterNetwork');

    const parameters = {
      options: {
        url: '/cluster_networks/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a cluster network.
   *
   * This request retrieves a single cluster network specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The cluster network identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetwork>>}
   */
  public getClusterNetwork(
    params: VpcV1.GetClusterNetworkParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetwork>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getClusterNetwork');

    const parameters = {
      options: {
        url: '/cluster_networks/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a cluster.
   *
   * This request updates a cluster network with the information provided in a cluster network patch object. The patch
   * object is structured in the same way as a retrieved cluster network and needs to contain only the information to be
   * updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The cluster network identifier.
   * @param {string} [params.name] - The name for this cluster network. The name must not be used by another cluster
   * network in the region. Names starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ClusterNetwork>>}
   */
  public updateClusterNetwork(
    params: VpcV1.UpdateClusterNetworkParams
  ): Promise<VpcV1.Response<VpcV1.ClusterNetwork>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateClusterNetwork');

    const parameters = {
      options: {
        url: '/cluster_networks/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * publicGateways
   ************************/

  /**
   * List public gateways.
   *
   * This request lists public gateways in the region. A public gateway is a virtual network device associated with a
   * VPC, which allows access to the Internet. A public gateway resides in a zone and can be connected to subnets in the
   * same zone only.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGatewayCollection>>}
   */
  public listPublicGateways(
    params?: VpcV1.ListPublicGatewaysParams
  ): Promise<VpcV1.Response<VpcV1.PublicGatewayCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listPublicGateways');

    const parameters = {
      options: {
        url: '/public_gateways',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a public gateway.
   *
   * This request creates a new public gateway from a public gateway prototype object. For this to succeed, the VPC must
   * not already have a public gateway in the specified zone.
   *
   * If a floating IP is provided, it must be unbound. If a floating IP is not provided, one will be created and bound
   * to the public gateway. Once a public gateway has been created, its floating IP cannot be unbound. A public gateway
   * must be explicitly attached to each subnet it will provide connectivity for.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {VPCIdentity} params.vpc - The VPC this public gateway will reside in.
   * @param {ZoneIdentity} params.zone - The zone this public gateway will reside in.
   * @param {PublicGatewayFloatingIPPrototype} [params.floatingIp] -
   * @param {string} [params.name] - The name for this public gateway. The name must not be used by another public
   * gateway in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGateway>>}
   */
  public createPublicGateway(
    params: VpcV1.CreatePublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PublicGateway>> {
    const _params = { ...params };
    const _requiredParams = ['vpc', 'zone'];
    const _validParams = ['vpc', 'zone', 'floatingIp', 'name', 'resourceGroup', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'vpc': _params.vpc,
      'zone': _params.zone,
      'floating_ip': _params.floatingIp,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createPublicGateway');

    const parameters = {
      options: {
        url: '/public_gateways',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a public gateway.
   *
   * This request deletes a public gateway. This operation cannot be reversed. For this request to succeed, the public
   * gateway must not be attached to any subnets. The public gateway's floating IP will be automatically unbound. If the
   * floating IP was created when the public gateway was created, it will be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The public gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deletePublicGateway(
    params: VpcV1.DeletePublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deletePublicGateway');

    const parameters = {
      options: {
        url: '/public_gateways/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a public gateway.
   *
   * This request retrieves a single public gateway specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The public gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGateway>>}
   */
  public getPublicGateway(
    params: VpcV1.GetPublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PublicGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getPublicGateway');

    const parameters = {
      options: {
        url: '/public_gateways/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a public gateway.
   *
   * This request updates a public gateway's name.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The public gateway identifier.
   * @param {string} [params.name] - The name for this public gateway. The name must not be used by another public
   * gateway in the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PublicGateway>>}
   */
  public updatePublicGateway(
    params: VpcV1.UpdatePublicGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PublicGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updatePublicGateway');

    const parameters = {
      options: {
        url: '/public_gateways/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * floatingIPs
   ************************/

  /**
   * List floating IPs.
   *
   * This request lists floating IPs in the region. Floating IPs allow inbound and outbound traffic from the Internet to
   * an instance.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.targetId] - Filters the collection to resources with a `target.id` property matching the
   * specified identifier.
   * @param {string} [params.targetCrn] - Filters the collection to resources with a `target.crn` property matching the
   * specified CRN.
   * @param {string} [params.targetName] - Filters the collection to resources with a `target.name` property matching
   * the exact specified name.
   * @param {string} [params.targetResourceType] - Filters the collection to resources with a `target.resource_type`
   * property matching the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIPCollection>>}
   */
  public listFloatingIps(
    params?: VpcV1.ListFloatingIpsParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIPCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'sort', 'targetId', 'targetCrn', 'targetName', 'targetResourceType', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'sort': _params.sort,
      'target.id': _params.targetId,
      'target.crn': _params.targetCrn,
      'target.name': _params.targetName,
      'target.resource_type': _params.targetResourceType,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listFloatingIps');

    const parameters = {
      options: {
        url: '/floating_ips',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Reserve a floating IP.
   *
   * This request reserves a new floating IP.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {FloatingIPPrototype} params.floatingIpPrototype - The floating IP prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public createFloatingIp(
    params: VpcV1.CreateFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['floatingIpPrototype'];
    const _validParams = ['floatingIpPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.floatingIpPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createFloatingIp');

    const parameters = {
      options: {
        url: '/floating_ips',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a floating IP.
   *
   * This request disassociates (if associated) and releases a floating IP. This operation cannot be reversed. For this
   * request to succeed, the floating IP must not be required by another resource, such as a public gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteFloatingIp(
    params: VpcV1.DeleteFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteFloatingIp');

    const parameters = {
      options: {
        url: '/floating_ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a floating IP.
   *
   * This request retrieves a single floating IP specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The floating IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public getFloatingIp(
    params: VpcV1.GetFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getFloatingIp');

    const parameters = {
      options: {
        url: '/floating_ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a floating IP.
   *
   * This request updates a floating IP's name and/or target.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The floating IP identifier.
   * @param {string} [params.name] - The name for this floating IP. The name must not be used by another floating IP in
   * the region.
   * @param {FloatingIPTargetPatch} [params.target] - The target resource to bind this floating IP to, replacing any
   * existing binding.
   * The floating IP must not be required by another resource, such as a public gateway.
   *
   * The target resource must not already have a floating IP bound to it if the target
   * resource is:
   *
   * - an instance network interface
   * - a bare metal server network interface with `enable_infrastructure_nat` set to `true`
   * - a virtual network interface with `enable_infrastructure_nat` set to `true`
   *
   * Specify `null` to remove an existing binding.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FloatingIP>>}
   */
  public updateFloatingIp(
    params: VpcV1.UpdateFloatingIpParams
  ): Promise<VpcV1.Response<VpcV1.FloatingIP>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'target', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'target': _params.target,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateFloatingIp');

    const parameters = {
      options: {
        url: '/floating_ips/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * networkACLs
   ************************/

  /**
   * List network ACLs.
   *
   * This request lists network ACLs in the region. A network ACL defines a set of packet filtering rules for traffic in
   * and out of the subnets the network ACL is attached to. No traffic is allowed by default. Both allow and deny rules
   * can be defined, and rules are stateless so that reverse traffic in response to allowed traffic is not automatically
   * allowed.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACLCollection>>}
   */
  public listNetworkAcls(
    params?: VpcV1.ListNetworkAclsParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACLCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listNetworkAcls');

    const parameters = {
      options: {
        url: '/network_acls',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a network ACL.
   *
   * This request creates a new stateless network ACL from a network ACL prototype object. The prototype object is
   * structured in the same way as a retrieved network ACL, and contains the information necessary to create the new
   * network ACL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {NetworkACLPrototype} params.networkAclPrototype - The network ACL prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACL>>}
   */
  public createNetworkAcl(
    params: VpcV1.CreateNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclPrototype'];
    const _validParams = ['networkAclPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.networkAclPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createNetworkAcl');

    const parameters = {
      options: {
        url: '/network_acls',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a network ACL.
   *
   * This request deletes a network ACL. This operation cannot be reversed. For this request to succeed, the network ACL
   * must not be the default network ACL for any VPCs, and the network ACL must not be attached to any subnets.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The network ACL identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteNetworkAcl(
    params: VpcV1.DeleteNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteNetworkAcl');

    const parameters = {
      options: {
        url: '/network_acls/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a network ACL.
   *
   * This request retrieves a single network ACL specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The network ACL identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACL>>}
   */
  public getNetworkAcl(
    params: VpcV1.GetNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getNetworkAcl');

    const parameters = {
      options: {
        url: '/network_acls/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a network ACL.
   *
   * This request updates a network ACL's name.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The network ACL identifier.
   * @param {string} [params.name] - The name for this network ACL. The name must not be used by another network ACL for
   * the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACL>>}
   */
  public updateNetworkAcl(
    params: VpcV1.UpdateNetworkAclParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACL>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateNetworkAcl');

    const parameters = {
      options: {
        url: '/network_acls/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List rules for a network ACL.
   *
   * This request lists rules for a network ACL. These rules can allow or deny traffic between a source CIDR block and a
   * destination CIDR block over a particular protocol and port range.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.networkAclId - The network ACL identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.direction] - Filters the collection to rules with a `direction` property matching the
   * specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACLRuleCollection>>}
   */
  public listNetworkAclRules(
    params: VpcV1.ListNetworkAclRulesParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACLRuleCollection>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclId'];
    const _validParams = ['networkAclId', 'start', 'limit', 'direction', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'direction': _params.direction,
    };

    const path = {
      'network_acl_id': _params.networkAclId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listNetworkAclRules');

    const parameters = {
      options: {
        url: '/network_acls/{network_acl_id}/rules',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a rule for a network ACL.
   *
   * This request creates a new rule from a network ACL rule prototype object. The prototype object is structured in the
   * same way as a retrieved rule, and contains the information necessary to create the new rule.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.networkAclId - The network ACL identifier.
   * @param {NetworkACLRulePrototype} params.networkAclRulePrototype - The network ACL rule prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACLRule>>}
   */
  public createNetworkAclRule(
    params: VpcV1.CreateNetworkAclRuleParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACLRule>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclId', 'networkAclRulePrototype'];
    const _validParams = ['networkAclId', 'networkAclRulePrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.networkAclRulePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'network_acl_id': _params.networkAclId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createNetworkAclRule');

    const parameters = {
      options: {
        url: '/network_acls/{network_acl_id}/rules',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a network ACL rule.
   *
   * This request deletes a rule. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.networkAclId - The network ACL identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteNetworkAclRule(
    params: VpcV1.DeleteNetworkAclRuleParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclId', 'id'];
    const _validParams = ['networkAclId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'network_acl_id': _params.networkAclId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteNetworkAclRule');

    const parameters = {
      options: {
        url: '/network_acls/{network_acl_id}/rules/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a network ACL rule.
   *
   * This request retrieves a single rule specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.networkAclId - The network ACL identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACLRule>>}
   */
  public getNetworkAclRule(
    params: VpcV1.GetNetworkAclRuleParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACLRule>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclId', 'id'];
    const _validParams = ['networkAclId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'network_acl_id': _params.networkAclId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getNetworkAclRule');

    const parameters = {
      options: {
        url: '/network_acls/{network_acl_id}/rules/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a network ACL rule.
   *
   * This request updates a rule with the information in a provided rule patch. The rule patch object contains only the
   * information to be updated. The request will fail if the provided patch includes properties that are not used by the
   * rule's protocol.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.networkAclId - The network ACL identifier.
   * @param {string} params.id - The rule identifier.
   * @param {string} [params.action] - The action to perform for a packet matching the rule.
   * @param {NetworkACLRuleBeforePatch} [params.before] - The rule to move this rule immediately before.
   *
   * Specify `null` to move this rule after all existing rules.
   * @param {number} [params.code] - The ICMP traffic code to match. If set, `type` must also be set.
   *
   * Specify `null` to remove an existing ICMP traffic code.
   * @param {string} [params.destination] - The destination IP address or CIDR block to match. The CIDR block
   * `0.0.0.0/0` matches all destination addresses.
   * @param {number} [params.destinationPortMax] - The inclusive upper bound of the TCP or UDP destination port range.
   *
   * Must be larger than or equal to `destination_port_min`.
   * @param {number} [params.destinationPortMin] - The inclusive lower bound of the TCP or UDP destination port range.
   *
   * Must be smaller than or equal to `destination_port_max`.
   * @param {string} [params.direction] - The direction of traffic to match.
   * @param {string} [params.name] - The name for this network ACL rule. The name must not be used by another rule for
   * the network ACL.
   * @param {string} [params.source] - The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches
   * all source addresses.
   * @param {number} [params.sourcePortMax] - The inclusive upper bound of the TCP or UDP source port range.
   *
   * Must be larger than or equal to `source_port_min`.
   * @param {number} [params.sourcePortMin] - The inclusive lower bound of the TCP or UDP source port range.
   *
   * Must be smaller than or equal to `source_port_max`.
   * @param {number} [params.type] - The ICMP traffic type to match.
   *
   * Specify `null` to remove an existing ICMP traffic type value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.NetworkACLRule>>}
   */
  public updateNetworkAclRule(
    params: VpcV1.UpdateNetworkAclRuleParams
  ): Promise<VpcV1.Response<VpcV1.NetworkACLRule>> {
    const _params = { ...params };
    const _requiredParams = ['networkAclId', 'id'];
    const _validParams = ['networkAclId', 'id', 'action', 'before', 'code', 'destination', 'destinationPortMax', 'destinationPortMin', 'direction', 'name', 'source', 'sourcePortMax', 'sourcePortMin', 'type', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'action': _params.action,
      'before': _params.before,
      'code': _params.code,
      'destination': _params.destination,
      'destination_port_max': _params.destinationPortMax,
      'destination_port_min': _params.destinationPortMin,
      'direction': _params.direction,
      'name': _params.name,
      'source': _params.source,
      'source_port_max': _params.sourcePortMax,
      'source_port_min': _params.sourcePortMin,
      'type': _params.type,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'network_acl_id': _params.networkAclId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateNetworkAclRule');

    const parameters = {
      options: {
        url: '/network_acls/{network_acl_id}/rules/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * securityGroups
   ************************/

  /**
   * List security groups.
   *
   * This request lists security groups in the region. A security group defines a set of packet filtering rules to allow
   * traffic in and out of the resources targeted by the security group. No traffic is allowed by default. Security
   * group rules are stateful so that reverse traffic in response to allowed traffic is automatically allowed.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.vpcId] - Filters the collection to resources with a `vpc.id` property matching the
   * specified identifier.
   * @param {string} [params.vpcCrn] - Filters the collection to resources with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to resources with a `vpc.name` property matching the
   * exact specified name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupCollection>>}
   */
  public listSecurityGroups(
    params?: VpcV1.ListSecurityGroupsParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'vpcId', 'vpcCrn', 'vpcName', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'vpc.id': _params.vpcId,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listSecurityGroups');

    const parameters = {
      options: {
        url: '/security_groups',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a security group.
   *
   * This request creates a new security group from a security group prototype object. The prototype object is
   * structured in the same way as a retrieved security group, and contains the information necessary to create the new
   * security group. If security group rules are included in the prototype object, those rules will be added to the
   * security group. Each security group is scoped to one VPC. Only resources in that VPC can be added to the security
   * group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {VPCIdentity} params.vpc - The VPC this security group will reside in.
   * @param {string} [params.name] - The name for this security group. The name must not be used by another security
   * group for the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {SecurityGroupRulePrototype[]} [params.rules] - The prototype objects for rules to be created for this
   * security group. If unspecified, no rules will be created, resulting in no traffic being allowed.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroup>>}
   */
  public createSecurityGroup(
    params: VpcV1.CreateSecurityGroupParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroup>> {
    const _params = { ...params };
    const _requiredParams = ['vpc'];
    const _validParams = ['vpc', 'name', 'resourceGroup', 'rules', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'vpc': _params.vpc,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
      'rules': _params.rules,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createSecurityGroup');

    const parameters = {
      options: {
        url: '/security_groups',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a security group.
   *
   * This request deletes a security group. A security group cannot be deleted if it is referenced by any security group
   * targets or rules. Additionally, a VPC's default security group cannot be deleted. This operation cannot be
   * reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The security group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSecurityGroup(
    params: VpcV1.DeleteSecurityGroupParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteSecurityGroup');

    const parameters = {
      options: {
        url: '/security_groups/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a security group.
   *
   * This request retrieves a single security group specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The security group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroup>>}
   */
  public getSecurityGroup(
    params: VpcV1.GetSecurityGroupParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getSecurityGroup');

    const parameters = {
      options: {
        url: '/security_groups/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a security group.
   *
   * This request updates a security group with the information provided in a security group patch object. The security
   * group patch object is structured in the same way as a retrieved security group and contains only the information to
   * be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The security group identifier.
   * @param {string} [params.name] - The name for this security group. The name must not be used by another security
   * group for the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroup>>}
   */
  public updateSecurityGroup(
    params: VpcV1.UpdateSecurityGroupParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroup>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateSecurityGroup');

    const parameters = {
      options: {
        url: '/security_groups/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List rules in a security group.
   *
   * This request lists rules in a security group. These rules define what traffic the security group permits. Security
   * group rules are stateful, such that reverse traffic in response to allowed traffic is automatically permitted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupRuleCollection>>}
   */
  public listSecurityGroupRules(
    params: VpcV1.ListSecurityGroupRulesParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupRuleCollection>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId'];
    const _validParams = ['securityGroupId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listSecurityGroupRules');

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/rules',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a rule for a security group.
   *
   * This request creates a new security group rule from a security group rule prototype object. The prototype object is
   * structured in the same way as a retrieved security group rule and contains the information necessary to create the
   * rule. As part of creating a new rule in a security group, the rule is applied to all the networking interfaces in
   * the security group. Rules specify which IP traffic a security group will allow. Security group rules are stateful,
   * such that reverse traffic in response to allowed traffic is automatically permitted. A rule allowing inbound TCP
   * traffic on port 80 also allows outbound TCP traffic on port 80 without the need for an additional rule.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {SecurityGroupRulePrototype} params.securityGroupRulePrototype - The properties of the security group rule
   * to be created.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupRule>>}
   */
  public createSecurityGroupRule(
    params: VpcV1.CreateSecurityGroupRuleParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupRule>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'securityGroupRulePrototype'];
    const _validParams = ['securityGroupId', 'securityGroupRulePrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.securityGroupRulePrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createSecurityGroupRule');

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/rules',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a security group rule.
   *
   * This request deletes a security group rule. This operation cannot be reversed. Removing a security group rule will
   * not end existing connections allowed by that rule.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSecurityGroupRule(
    params: VpcV1.DeleteSecurityGroupRuleParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteSecurityGroupRule');

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/rules/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a security group rule.
   *
   * This request retrieves a single security group rule specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupRule>>}
   */
  public getSecurityGroupRule(
    params: VpcV1.GetSecurityGroupRuleParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupRule>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getSecurityGroupRule');

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/rules/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a security group rule.
   *
   * This request updates a security group rule with the information in a provided rule patch object. The rule patch
   * object contains only the information to be updated. The request will fail if the provided patch includes properties
   * that are not used by the rule's protocol.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The rule identifier.
   * @param {number} [params.code] - The ICMP traffic code to allow. If set, `type` must also be set.
   *
   * Specify `null` to remove an existing ICMP traffic code.
   * @param {string} [params.direction] - The direction of traffic to allow.
   * @param {string} [params.ipVersion] - The IP version to allow. The format of `local.address`, `remote.address`,
   * `local.cidr_block` or `remote.cidr_block` must match this property, if they are used.
   *
   * If `remote` references a security group, then this rule only applies to IP addresses in that group matching this IP
   * version.
   * @param {SecurityGroupRuleLocalPatch} [params.local] - The local IP address or range of local IP addresses to which
   * this rule will allow inbound
   * traffic (or from which, for outbound traffic). Can be specified as an IP address or a CIDR
   * block.
   *
   * Specify a CIDR block of `0.0.0.0/0` to allow traffic to all local IP addresses (or from all
   * local IP addresses, for outbound rules).
   * @param {number} [params.portMax] - The inclusive upper bound of the protocol destination port range. If set,
   * `port_min` must also be set, and must not be larger.
   *
   * Specify `null` to remove an existing upper bound.
   * @param {number} [params.portMin] - The inclusive lower bound of the protocol destination port range. If set,
   * `port_max` must also be set, and must not be smaller.
   *
   * Specify `null` to remove an existing lower bound.
   * @param {SecurityGroupRuleRemotePatch} [params.remote] - The remote IP addresses or security groups from which this
   * rule will allow traffic (or to
   * which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
   * security group. A CIDR block of `0.0.0.0/0` will allow traffic from any source (or to
   * any destination, for outbound rules).
   * @param {number} [params.type] - The ICMP traffic type to allow.
   *
   * Specify `null` to remove an existing ICMP traffic type value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupRule>>}
   */
  public updateSecurityGroupRule(
    params: VpcV1.UpdateSecurityGroupRuleParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupRule>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'code', 'direction', 'ipVersion', 'local', 'portMax', 'portMin', 'remote', 'type', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'code': _params.code,
      'direction': _params.direction,
      'ip_version': _params.ipVersion,
      'local': _params.local,
      'port_max': _params.portMax,
      'port_min': _params.portMin,
      'remote': _params.remote,
      'type': _params.type,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateSecurityGroupRule');

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/rules/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List targets associated with a security group.
   *
   * This request lists targets associated with a security group, to which the rules in the security group are applied.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupTargetCollection>>}
   */
  public listSecurityGroupTargets(
    params: VpcV1.ListSecurityGroupTargetsParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupTargetCollection>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId'];
    const _validParams = ['securityGroupId', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listSecurityGroupTargets');

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/targets',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Remove a target from a security group.
   *
   * This request removes a target from a security group. For this request to succeed, the target must be attached to at
   * least one other security group.  The specified target identifier can be:
   *
   * - A bare metal server network interface identifier
   * - A virtual network interface identifier
   * - A VPN server identifier
   * - A load balancer identifier
   * - An endpoint gateway identifier
   * - An instance network interface identifier
   *
   * Security groups are stateful, so any changes to a target's security groups are applied to new connections. Existing
   * connections are not affected.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The security group target identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteSecurityGroupTargetBinding(
    params: VpcV1.DeleteSecurityGroupTargetBindingParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteSecurityGroupTargetBinding');

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/targets/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a security group target.
   *
   * This request retrieves a single target specified by the identifier in the URL path. The target must be an existing
   * target of the security group.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The security group target identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupTargetReference>>}
   */
  public getSecurityGroupTarget(
    params: VpcV1.GetSecurityGroupTargetParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupTargetReference>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getSecurityGroupTarget');

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/targets/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Add a target to a security group.
   *
   * This request adds a resource to an existing security group. The specified target identifier can be:
   *
   * - A bare metal server network interface identifier
   * - A virtual network interface identifier
   * - A VPN server identifier
   * - A load balancer identifier
   * - An endpoint gateway identifier
   * - An instance network interface identifier
   *
   * When a target is added to a security group, the security group rules are applied to the target. A request body is
   * not required, and if provided, is ignored.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.securityGroupId - The security group identifier.
   * @param {string} params.id - The security group target identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.SecurityGroupTargetReference>>}
   */
  public createSecurityGroupTargetBinding(
    params: VpcV1.CreateSecurityGroupTargetBindingParams
  ): Promise<VpcV1.Response<VpcV1.SecurityGroupTargetReference>> {
    const _params = { ...params };
    const _requiredParams = ['securityGroupId', 'id'];
    const _validParams = ['securityGroupId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'security_group_id': _params.securityGroupId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createSecurityGroupTargetBinding');

    const parameters = {
      options: {
        url: '/security_groups/{security_group_id}/targets/{id}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * vPNGateways
   ************************/

  /**
   * List IKE policies.
   *
   * This request lists IKE policies in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IKEPolicyCollection>>}
   */
  public listIkePolicies(
    params?: VpcV1.ListIkePoliciesParams
  ): Promise<VpcV1.Response<VpcV1.IKEPolicyCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listIkePolicies');

    const parameters = {
      options: {
        url: '/ike_policies',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an IKE policy.
   *
   * This request creates a new IKE policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.authenticationAlgorithm - The authentication algorithm.
   * @param {number} params.dhGroup - The Diffie-Hellman group.
   * @param {string} params.encryptionAlgorithm - The encryption algorithm.
   * @param {number} params.ikeVersion - The IKE protocol version.
   * @param {number} [params.keyLifetime] - The key lifetime in seconds.
   * @param {string} [params.name] - The name for this IKE policy. The name must not be used by another IKE policies in
   * the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IKEPolicy>>}
   */
  public createIkePolicy(
    params: VpcV1.CreateIkePolicyParams
  ): Promise<VpcV1.Response<VpcV1.IKEPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['authenticationAlgorithm', 'dhGroup', 'encryptionAlgorithm', 'ikeVersion'];
    const _validParams = ['authenticationAlgorithm', 'dhGroup', 'encryptionAlgorithm', 'ikeVersion', 'keyLifetime', 'name', 'resourceGroup', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'authentication_algorithm': _params.authenticationAlgorithm,
      'dh_group': _params.dhGroup,
      'encryption_algorithm': _params.encryptionAlgorithm,
      'ike_version': _params.ikeVersion,
      'key_lifetime': _params.keyLifetime,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createIkePolicy');

    const parameters = {
      options: {
        url: '/ike_policies',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an IKE policy.
   *
   * This request deletes an IKE policy. This operation cannot be reversed. For this request to succeed, there must not
   * be any VPN gateway connections using this policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IKE policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteIkePolicy(
    params: VpcV1.DeleteIkePolicyParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteIkePolicy');

    const parameters = {
      options: {
        url: '/ike_policies/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an IKE policy.
   *
   * This request retrieves a single IKE policy specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IKE policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IKEPolicy>>}
   */
  public getIkePolicy(
    params: VpcV1.GetIkePolicyParams
  ): Promise<VpcV1.Response<VpcV1.IKEPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getIkePolicy');

    const parameters = {
      options: {
        url: '/ike_policies/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an IKE policy.
   *
   * This request updates the properties of an existing IKE policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IKE policy identifier.
   * @param {string} [params.authenticationAlgorithm] - The authentication algorithm.
   * @param {number} [params.dhGroup] - The Diffie-Hellman group.
   * @param {string} [params.encryptionAlgorithm] - The encryption algorithm.
   * @param {number} [params.ikeVersion] - The IKE protocol version.
   * @param {number} [params.keyLifetime] - The key lifetime in seconds.
   * @param {string} [params.name] - The name for this IKE policy. The name must not be used by another IKE policy in
   * the region.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IKEPolicy>>}
   */
  public updateIkePolicy(
    params: VpcV1.UpdateIkePolicyParams
  ): Promise<VpcV1.Response<VpcV1.IKEPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'authenticationAlgorithm', 'dhGroup', 'encryptionAlgorithm', 'ikeVersion', 'keyLifetime', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'authentication_algorithm': _params.authenticationAlgorithm,
      'dh_group': _params.dhGroup,
      'encryption_algorithm': _params.encryptionAlgorithm,
      'ike_version': _params.ikeVersion,
      'key_lifetime': _params.keyLifetime,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateIkePolicy');

    const parameters = {
      options: {
        url: '/ike_policies/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List VPN gateway connections that use a specified IKE policy.
   *
   * This request lists VPN gateway connections that use an IKE policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IKE policy identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IKEPolicyConnectionCollection>>}
   */
  public listIkePolicyConnections(
    params: VpcV1.ListIkePolicyConnectionsParams
  ): Promise<VpcV1.Response<VpcV1.IKEPolicyConnectionCollection>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listIkePolicyConnections');

    const parameters = {
      options: {
        url: '/ike_policies/{id}/connections',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List IPsec policies.
   *
   * This request lists IPsec policies in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IPsecPolicyCollection>>}
   */
  public listIpsecPolicies(
    params?: VpcV1.ListIpsecPoliciesParams
  ): Promise<VpcV1.Response<VpcV1.IPsecPolicyCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listIpsecPolicies');

    const parameters = {
      options: {
        url: '/ipsec_policies',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an IPsec policy.
   *
   * This request creates a new IPsec policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.authenticationAlgorithm - The authentication algorithm
   *
   * Must be `disabled` if and only if the `encryption_algorithm` is `aes128gcm16`,
   * `aes192gcm16`, or `aes256gcm16`
   *
   * The `md5` and `sha1` algorithms have been deprecated.
   * @param {string} params.encryptionAlgorithm - The encryption algorithm
   *
   * The `authentication_algorithm` must be `disabled` if and only if
   * `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`
   *
   * The `triple_des` algorithm has been deprecated.
   * @param {string} params.pfs - The Perfect Forward Secrecy group.
   *
   * Groups `group_2` and `group_5` have been deprecated.
   * @param {number} [params.keyLifetime] - The key lifetime in seconds.
   * @param {string} [params.name] - The name for this IPsec policy. The name must not be used by another IPsec policies
   * in the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IPsecPolicy>>}
   */
  public createIpsecPolicy(
    params: VpcV1.CreateIpsecPolicyParams
  ): Promise<VpcV1.Response<VpcV1.IPsecPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['authenticationAlgorithm', 'encryptionAlgorithm', 'pfs'];
    const _validParams = ['authenticationAlgorithm', 'encryptionAlgorithm', 'pfs', 'keyLifetime', 'name', 'resourceGroup', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'authentication_algorithm': _params.authenticationAlgorithm,
      'encryption_algorithm': _params.encryptionAlgorithm,
      'pfs': _params.pfs,
      'key_lifetime': _params.keyLifetime,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createIpsecPolicy');

    const parameters = {
      options: {
        url: '/ipsec_policies',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an IPsec policy.
   *
   * This request deletes an IPsec policy. This operation cannot be reversed. For this request to succeed, there must
   * not be any VPN gateway connections using this policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IPsec policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteIpsecPolicy(
    params: VpcV1.DeleteIpsecPolicyParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteIpsecPolicy');

    const parameters = {
      options: {
        url: '/ipsec_policies/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an IPsec policy.
   *
   * This request retrieves a single IPsec policy specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IPsec policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IPsecPolicy>>}
   */
  public getIpsecPolicy(
    params: VpcV1.GetIpsecPolicyParams
  ): Promise<VpcV1.Response<VpcV1.IPsecPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getIpsecPolicy');

    const parameters = {
      options: {
        url: '/ipsec_policies/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an IPsec policy.
   *
   * This request updates the properties of an existing IPsec policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IPsec policy identifier.
   * @param {string} [params.authenticationAlgorithm] - The authentication algorithm
   *
   * Must be `disabled` if and only if the `encryption_algorithm` is `aes128gcm16`,
   * `aes192gcm16`, or `aes256gcm16`
   *
   * The `md5` and `sha1` algorithms have been deprecated.
   * @param {string} [params.encryptionAlgorithm] - The encryption algorithm
   *
   * The `authentication_algorithm` must be `disabled` if and only if
   * `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`
   *
   * The `triple_des` algorithm has been deprecated.
   * @param {number} [params.keyLifetime] - The key lifetime in seconds.
   * @param {string} [params.name] - The name for this IPsec policy. The name must not be used by another IPsec policy
   * in the region.
   * @param {string} [params.pfs] - The Perfect Forward Secrecy group.
   *
   * Groups `group_2` and `group_5` have been deprecated.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IPsecPolicy>>}
   */
  public updateIpsecPolicy(
    params: VpcV1.UpdateIpsecPolicyParams
  ): Promise<VpcV1.Response<VpcV1.IPsecPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'authenticationAlgorithm', 'encryptionAlgorithm', 'keyLifetime', 'name', 'pfs', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'authentication_algorithm': _params.authenticationAlgorithm,
      'encryption_algorithm': _params.encryptionAlgorithm,
      'key_lifetime': _params.keyLifetime,
      'name': _params.name,
      'pfs': _params.pfs,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateIpsecPolicy');

    const parameters = {
      options: {
        url: '/ipsec_policies/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List VPN gateway connections that use a specified IPsec policy.
   *
   * This request lists VPN gateway connections that use an IPsec policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The IPsec policy identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.IPsecPolicyConnectionCollection>>}
   */
  public listIpsecPolicyConnections(
    params: VpcV1.ListIpsecPolicyConnectionsParams
  ): Promise<VpcV1.Response<VpcV1.IPsecPolicyConnectionCollection>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listIpsecPolicyConnections');

    const parameters = {
      options: {
        url: '/ipsec_policies/{id}/connections',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List VPN gateways.
   *
   * This request lists VPN gateways in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {string} [params.mode] - Filters the collection to VPN gateways with a `mode` property matching the
   * specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayCollection>>}
   */
  public listVpnGateways(
    params?: VpcV1.ListVpnGatewaysParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'sort', 'mode', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'sort': _params.sort,
      'mode': _params.mode,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpnGateways');

    const parameters = {
      options: {
        url: '/vpn_gateways',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a VPN gateway.
   *
   * This request creates a new VPN gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {VPNGatewayPrototype} params.vpnGatewayPrototype - The VPN gateway prototype object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGateway>>}
   */
  public createVpnGateway(
    params: VpcV1.CreateVpnGatewayParams
  ): Promise<VpcV1.Response<VpcV1.VPNGateway>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayPrototype'];
    const _validParams = ['vpnGatewayPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.vpnGatewayPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVpnGateway');

    const parameters = {
      options: {
        url: '/vpn_gateways',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPN gateway.
   *
   * This request deletes a VPN gateway. This operation cannot be reversed. For this request to succeed, the VPN gateway
   * must not have a `status` of `pending`, and there must not be any VPC routes using the VPN gateway's connections as
   * a next hop.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpnGateway(
    params: VpcV1.DeleteVpnGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVpnGateway');

    const parameters = {
      options: {
        url: '/vpn_gateways/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPN gateway.
   *
   * This request retrieves a single VPN gateway specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGateway>>}
   */
  public getVpnGateway(
    params: VpcV1.GetVpnGatewayParams
  ): Promise<VpcV1.Response<VpcV1.VPNGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpnGateway');

    const parameters = {
      options: {
        url: '/vpn_gateways/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPN gateway.
   *
   * This request updates the properties of an existing VPN gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN gateway identifier.
   * @param {string} [params.name] - The name for this VPN gateway. The name must not be used by another VPN gateway in
   * the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGateway>>}
   */
  public updateVpnGateway(
    params: VpcV1.UpdateVpnGatewayParams
  ): Promise<VpcV1.Response<VpcV1.VPNGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVpnGateway');

    const parameters = {
      options: {
        url: '/vpn_gateways/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List connections of a VPN gateway.
   *
   * This request lists connections of a VPN gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.status] - Filters the collection to VPN gateway connections with a `status` property
   * matching the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCollection>>}
   */
  public listVpnGatewayConnections(
    params: VpcV1.ListVpnGatewayConnectionsParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId'];
    const _validParams = ['vpnGatewayId', 'start', 'limit', 'status', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'status': _params.status,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpnGatewayConnections');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a connection for a VPN gateway.
   *
   * This request creates a new VPN gateway connection.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {VPNGatewayConnectionPrototype} params.vpnGatewayConnectionPrototype - The VPN gateway connection prototype
   * object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>>}
   */
  public createVpnGatewayConnection(
    params: VpcV1.CreateVpnGatewayConnectionParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'vpnGatewayConnectionPrototype'];
    const _validParams = ['vpnGatewayId', 'vpnGatewayConnectionPrototype', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.vpnGatewayConnectionPrototype;
    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVpnGatewayConnection');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPN gateway connection.
   *
   * This request deletes a VPN gateway connection. This operation cannot be reversed. For this request to succeed,
   * there must not be VPC routes using this VPN connection as a next hop.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpnGatewayConnection(
    params: VpcV1.DeleteVpnGatewayConnectionParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id'];
    const _validParams = ['vpnGatewayId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVpnGatewayConnection');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPN gateway connection.
   *
   * This request retrieves a single VPN gateway connection specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>>}
   */
  public getVpnGatewayConnection(
    params: VpcV1.GetVpnGatewayConnectionParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id'];
    const _validParams = ['vpnGatewayId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpnGatewayConnection');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPN gateway connection.
   *
   * This request updates the properties of an existing VPN gateway connection.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {boolean} [params.adminStateUp] - If set to false, the VPN gateway connection is shut down.
   * @param {VPNGatewayConnectionDPDPatch} [params.deadPeerDetection] - The Dead Peer Detection settings.
   * @param {boolean} [params.distributeTraffic] - Indicates whether the traffic is distributed between the `up` tunnels
   * of the VPN gateway connection when the VPC route's next hop is a VPN connection. If `false`, the traffic is only
   * routed through the `up` tunnel with the lower `public_ip` address. Before enabling it on VPN connections to on-prem
   * private networks, review
   * [distributing traffic
   * restrictions](https://cloud.ibm.com/docs/vpc?topic=vpc-vpn-limitations#distributing-traffic-restrictions).
   *
   * If specified, `mode` must be `route`.
   * @param {string} [params.establishMode] - The establish mode of the VPN gateway connection:
   * - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol
   *    negotiations or rekeying processes.
   * - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway
   *    connection. Additionally, the peer is responsible for initiating the rekeying process
   *    after the connection is established. If rekeying does not occur, the VPN gateway
   *    connection will be brought down after its lifetime expires.
   * @param {VPNGatewayConnectionIKEPolicyPatch} [params.ikePolicy] - The IKE policy to use. Specify `null` to remove
   * any existing policy, [resulting in
   * auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
   * @param {VPNGatewayConnectionIPsecPolicyPatch} [params.ipsecPolicy] - The IPsec policy to use. Specify `null` to
   * remove any existing policy, [resulting in
   * auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
   * @param {string} [params.name] - The name for this VPN gateway connection. The name must not be used by another
   * connection for the VPN gateway.
   * @param {VPNGatewayConnectionPeerPatch} [params.peer] -
   * @param {string} [params.psk] - The pre-shared key.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>>}
   */
  public updateVpnGatewayConnection(
    params: VpcV1.UpdateVpnGatewayConnectionParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id'];
    const _validParams = ['vpnGatewayId', 'id', 'adminStateUp', 'deadPeerDetection', 'distributeTraffic', 'establishMode', 'ikePolicy', 'ipsecPolicy', 'name', 'peer', 'psk', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'admin_state_up': _params.adminStateUp,
      'dead_peer_detection': _params.deadPeerDetection,
      'distribute_traffic': _params.distributeTraffic,
      'establish_mode': _params.establishMode,
      'ike_policy': _params.ikePolicy,
      'ipsec_policy': _params.ipsecPolicy,
      'name': _params.name,
      'peer': _params.peer,
      'psk': _params.psk,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVpnGatewayConnection');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List local CIDRs for a VPN gateway connection.
   *
   * This request lists local CIDRs for a VPN gateway connection.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCIDRs>>}
   */
  public listVpnGatewayConnectionsLocalCidrs(
    params: VpcV1.ListVpnGatewayConnectionsLocalCidrsParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCIDRs>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id'];
    const _validParams = ['vpnGatewayId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpnGatewayConnectionsLocalCidrs');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/local/cidrs',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Remove a local CIDR from a VPN gateway connection.
   *
   * This request removes a CIDR from a VPN gateway connection.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidr - The IP address range in CIDR block notation.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeVpnGatewayConnectionsLocalCidr(
    params: VpcV1.RemoveVpnGatewayConnectionsLocalCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidr'];
    const _validParams = ['vpnGatewayId', 'id', 'cidr', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr': _params.cidr,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'removeVpnGatewayConnectionsLocalCidr');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/local/cidrs/{cidr}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Check if the specified local CIDR exists on a VPN gateway connection.
   *
   * This request succeeds if a CIDR exists on the specified VPN gateway connection, and fails otherwise.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidr - The IP address range in CIDR block notation.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public checkVpnGatewayConnectionsLocalCidr(
    params: VpcV1.CheckVpnGatewayConnectionsLocalCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidr'];
    const _validParams = ['vpnGatewayId', 'id', 'cidr', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr': _params.cidr,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'checkVpnGatewayConnectionsLocalCidr');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/local/cidrs/{cidr}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Set a local CIDR on a VPN gateway connection.
   *
   * This request adds the specified CIDR to the specified VPN gateway connection. This request succeeds if the
   * specified CIDR already exists. A request body is not required, and if provided, is ignored.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidr - The IP address range in CIDR block notation.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public addVpnGatewayConnectionsLocalCidr(
    params: VpcV1.AddVpnGatewayConnectionsLocalCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidr'];
    const _validParams = ['vpnGatewayId', 'id', 'cidr', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr': _params.cidr,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'addVpnGatewayConnectionsLocalCidr');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/local/cidrs/{cidr}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List peer CIDRs for a VPN gateway connection.
   *
   * This request lists peer CIDRs for a VPN gateway connection.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCIDRs>>}
   */
  public listVpnGatewayConnectionsPeerCidrs(
    params: VpcV1.ListVpnGatewayConnectionsPeerCidrsParams
  ): Promise<VpcV1.Response<VpcV1.VPNGatewayConnectionCIDRs>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id'];
    const _validParams = ['vpnGatewayId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpnGatewayConnectionsPeerCidrs');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer/cidrs',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Remove a peer CIDR from a VPN gateway connection.
   *
   * This request removes a CIDR from a VPN gateway connection.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidr - The IP address range in CIDR block notation.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeVpnGatewayConnectionsPeerCidr(
    params: VpcV1.RemoveVpnGatewayConnectionsPeerCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidr'];
    const _validParams = ['vpnGatewayId', 'id', 'cidr', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr': _params.cidr,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'removeVpnGatewayConnectionsPeerCidr');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer/cidrs/{cidr}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Check if the specified peer CIDR exists on a VPN gateway connection.
   *
   * This request succeeds if a CIDR exists on the specified VPN gateway connection, and fails otherwise.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidr - The IP address range in CIDR block notation.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public checkVpnGatewayConnectionsPeerCidr(
    params: VpcV1.CheckVpnGatewayConnectionsPeerCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidr'];
    const _validParams = ['vpnGatewayId', 'id', 'cidr', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr': _params.cidr,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'checkVpnGatewayConnectionsPeerCidr');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer/cidrs/{cidr}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Set a peer CIDR on a VPN gateway connection.
   *
   * This request adds the specified CIDR to the specified VPN gateway connection. This request succeeds if the
   * specified CIDR already exists. A request body is not required, and if provided, is ignored.
   *
   * This request is only supported for policy mode VPN gateways.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnGatewayId - The VPN gateway identifier.
   * @param {string} params.id - The VPN gateway connection identifier.
   * @param {string} params.cidr - The IP address range in CIDR block notation.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public addVpnGatewayConnectionsPeerCidr(
    params: VpcV1.AddVpnGatewayConnectionsPeerCidrParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnGatewayId', 'id', 'cidr'];
    const _validParams = ['vpnGatewayId', 'id', 'cidr', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_gateway_id': _params.vpnGatewayId,
      'id': _params.id,
      'cidr': _params.cidr,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'addVpnGatewayConnectionsPeerCidr');

    const parameters = {
      options: {
        url: '/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer/cidrs/{cidr}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * vPNServers
   ************************/

  /**
   * List VPN servers.
   *
   * This request lists VPN servers.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerCollection>>}
   */
  public listVpnServers(
    params?: VpcV1.ListVpnServersParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['name', 'start', 'limit', 'resourceGroupId', 'sort', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'name': _params.name,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'sort': _params.sort,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpnServers');

    const parameters = {
      options: {
        url: '/vpn_servers',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a VPN server.
   *
   * This request creates a new VPN server.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {CertificateInstanceIdentity} params.certificate - The certificate instance for this VPN server.
   * @param {VPNServerAuthenticationPrototype[]} params.clientAuthentication - The methods used to authenticate VPN
   * clients to this VPN server. VPN clients must authenticate against all specified methods.
   * @param {string} params.clientIpPool - The VPN client IPv4 address pool, expressed in CIDR format. The request must
   * not overlap with any existing address prefixes in the VPC or any of the following reserved address ranges:
   *   - `127.0.0.0/8` (IPv4 loopback addresses)
   *   - `161.26.0.0/16` (IBM services)
   *   - `166.8.0.0/14` (Cloud Service Endpoints)
   *   - `169.254.0.0/16` (IPv4 link-local addresses)
   *   - `224.0.0.0/4` (IPv4 multicast addresses)
   *
   * The prefix length of the client IP address pool's CIDR must be between
   * `/9` (8,388,608 addresses) and `/22` (1024 addresses). A CIDR block that contains twice the number of IP addresses
   * that are required to enable the maximum number of concurrent connections is recommended.
   * @param {SubnetIdentity[]} params.subnets - The subnets to provision this VPN server in.  Use subnets in different
   * zones for high availability.
   * @param {IP[]} [params.clientDnsServerIps] - The DNS server addresses that will be provided to VPN clients connected
   * to this VPN server.
   * @param {number} [params.clientIdleTimeout] - The seconds a VPN client can be idle before this VPN server will
   * disconnect it.   Specify `0` to prevent the server from disconnecting idle clients.
   * @param {boolean} [params.enableSplitTunneling] - Indicates whether the split tunneling is enabled on this VPN
   * server.
   * @param {string} [params.name] - The name for this VPN server. The name must not be used by another VPN server in
   * the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {number} [params.port] - The port number to use for this VPN server.
   * @param {string} [params.protocol] - The transport protocol to use for this VPN server.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {SecurityGroupIdentity[]} [params.securityGroups] - The security groups to use for this VPN server. If
   * unspecified, the VPC's default security group is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServer>>}
   */
  public createVpnServer(
    params: VpcV1.CreateVpnServerParams
  ): Promise<VpcV1.Response<VpcV1.VPNServer>> {
    const _params = { ...params };
    const _requiredParams = ['certificate', 'clientAuthentication', 'clientIpPool', 'subnets'];
    const _validParams = ['certificate', 'clientAuthentication', 'clientIpPool', 'subnets', 'clientDnsServerIps', 'clientIdleTimeout', 'enableSplitTunneling', 'name', 'port', 'protocol', 'resourceGroup', 'securityGroups', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'certificate': _params.certificate,
      'client_authentication': _params.clientAuthentication,
      'client_ip_pool': _params.clientIpPool,
      'subnets': _params.subnets,
      'client_dns_server_ips': _params.clientDnsServerIps,
      'client_idle_timeout': _params.clientIdleTimeout,
      'enable_split_tunneling': _params.enableSplitTunneling,
      'name': _params.name,
      'port': _params.port,
      'protocol': _params.protocol,
      'resource_group': _params.resourceGroup,
      'security_groups': _params.securityGroups,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVpnServer');

    const parameters = {
      options: {
        url: '/vpn_servers',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPN server.
   *
   * This request deletes a VPN server. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN server identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpnServer(
    params: VpcV1.DeleteVpnServerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVpnServer');

    const parameters = {
      options: {
        url: '/vpn_servers/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPN server.
   *
   * This request retrieves a single VPN server specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServer>>}
   */
  public getVpnServer(
    params: VpcV1.GetVpnServerParams
  ): Promise<VpcV1.Response<VpcV1.VPNServer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpnServer');

    const parameters = {
      options: {
        url: '/vpn_servers/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPN server.
   *
   * This request updates the properties of an existing VPN server. Any updates other than to `name` will cause all
   * connected VPN clients to be disconnected.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN server identifier.
   * @param {CertificateInstanceIdentity} [params.certificate] - The certificate instance for this VPN server.
   * @param {VPNServerAuthenticationPrototype[]} [params.clientAuthentication] - The authentication methods to use to
   * authenticate VPN client on this VPN server
   * (replacing any existing methods).
   * @param {IP[]} [params.clientDnsServerIps] - The DNS server addresses that will be provided to VPN clients connected
   * to this VPN server (replacing any existing addresses).
   * @param {number} [params.clientIdleTimeout] - The seconds a VPN client can be idle before this VPN server will
   * disconnect it.  If `0`, the server will not disconnect idle clients.
   * @param {string} [params.clientIpPool] - The VPN client IPv4 address pool, expressed in CIDR format. The request
   * must not overlap with any existing address prefixes in the VPC or any of the following reserved address ranges:
   *   - `127.0.0.0/8` (IPv4 loopback addresses)
   *   - `161.26.0.0/16` (IBM services)
   *   - `166.8.0.0/14` (Cloud Service Endpoints)
   *   - `169.254.0.0/16` (IPv4 link-local addresses)
   *   - `224.0.0.0/4` (IPv4 multicast addresses)
   *
   * The prefix length of the client IP address pool's CIDR must be between
   * `/9` (8,388,608 addresses) and `/22` (1024 addresses). A CIDR block that contains twice the number of IP addresses
   * that are required to enable the maximum number of concurrent connections is recommended.
   * @param {boolean} [params.enableSplitTunneling] - Indicates whether the split tunneling is enabled on this VPN
   * server.
   * @param {string} [params.name] - The name for this VPN server. The name must not be used by another VPN server in
   * the VPC.
   * @param {number} [params.port] - The port number used by this VPN server.
   * @param {string} [params.protocol] - The transport protocol to use for this VPN server.
   * @param {SubnetIdentity[]} [params.subnets] - The subnets to provision this VPN server in (replacing the existing
   * subnets).
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServer>>}
   */
  public updateVpnServer(
    params: VpcV1.UpdateVpnServerParams
  ): Promise<VpcV1.Response<VpcV1.VPNServer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'certificate', 'clientAuthentication', 'clientDnsServerIps', 'clientIdleTimeout', 'clientIpPool', 'enableSplitTunneling', 'name', 'port', 'protocol', 'subnets', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'certificate': _params.certificate,
      'client_authentication': _params.clientAuthentication,
      'client_dns_server_ips': _params.clientDnsServerIps,
      'client_idle_timeout': _params.clientIdleTimeout,
      'client_ip_pool': _params.clientIpPool,
      'enable_split_tunneling': _params.enableSplitTunneling,
      'name': _params.name,
      'port': _params.port,
      'protocol': _params.protocol,
      'subnets': _params.subnets,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVpnServer');

    const parameters = {
      options: {
        url: '/vpn_servers/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve client configuration.
   *
   * This request retrieves OpenVPN client configuration on a single VPN server specified by the identifier in the URL.
   * This configuration includes directives compatible with OpenVPN releases 2.4 and 2.5.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The VPN server identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<string>>}
   */
  public getVpnServerClientConfiguration(
    params: VpcV1.GetVpnServerClientConfigurationParams
  ): Promise<VpcV1.Response<string>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpnServerClientConfiguration');

    const parameters = {
      options: {
        url: '/vpn_servers/{id}/client_configuration',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'text/plain',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List VPN clients for a VPN server.
   *
   * This request retrieves connected VPN clients, and any disconnected VPN clients that the VPN server has not yet
   * deleted based on its auto-deletion policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerClientCollection>>}
   */
  public listVpnServerClients(
    params: VpcV1.ListVpnServerClientsParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerClientCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId'];
    const _validParams = ['vpnServerId', 'start', 'limit', 'sort', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpnServerClients');

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/clients',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPN client.
   *
   * This request disconnects and deletes the VPN client from the VPN server. The VPN client may reconnect unless its
   * authentication permissions for the configured authentication methods (such as its client certificate) have been
   * revoked.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN client identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpnServerClient(
    params: VpcV1.DeleteVpnServerClientParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVpnServerClient');

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/clients/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPN client.
   *
   * This request retrieves a single VPN client specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN client identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerClient>>}
   */
  public getVpnServerClient(
    params: VpcV1.GetVpnServerClientParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerClient>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpnServerClient');

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/clients/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Disconnect a VPN client.
   *
   * This request disconnects the specified VPN client, and deletes the client according to the VPN server's
   * auto-deletion policy. The VPN client may reconnect unless its authentication permissions for the configured
   * authentication methods (such as its client certificate) have been revoked.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN client identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public disconnectVpnClient(
    params: VpcV1.DisconnectVpnClientParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'disconnectVpnClient');

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/clients/{id}/disconnect',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List VPN routes for a VPN server.
   *
   * This request lists VPN routes in a VPN server. All VPN routes are provided to the VPN client when the connection is
   * established.  Packets received from the VPN client will be dropped by the VPN server if there is no VPN route
   * matching their specified destinations. All VPN routes must be unique within the VPN server.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerRouteCollection>>}
   */
  public listVpnServerRoutes(
    params: VpcV1.ListVpnServerRoutesParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerRouteCollection>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId'];
    const _validParams = ['vpnServerId', 'start', 'limit', 'sort', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listVpnServerRoutes');

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/routes',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a VPN route for a VPN server.
   *
   * This request creates a new VPN route in the VPN server. All VPN routes are provided to the VPN client when the
   * connection is established. Packets received from the VPN client will be dropped by the VPN server if there is no
   * VPN route matching their specified destinations. All VPN routes must be unique within the VPN server.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.destination - The destination to use for this VPN route in the VPN server. Must be unique
   * within the VPN server. If an incoming packet does not match any destination, it will be dropped.
   * @param {string} [params.action] - The action to perform with a packet matching the VPN route:
   * - `translate`: translate the source IP address to one of the private IP addresses of
   *   the VPN server, then deliver the packet to target.
   * - `deliver`: deliver the packet to the target.
   * - `drop`: drop the packet.
   * @param {string} [params.name] - The name for this VPN server route. The name must not be used by another route for
   * the VPN server. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerRoute>>}
   */
  public createVpnServerRoute(
    params: VpcV1.CreateVpnServerRouteParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerRoute>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'destination'];
    const _validParams = ['vpnServerId', 'destination', 'action', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'destination': _params.destination,
      'action': _params.action,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createVpnServerRoute');

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/routes',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a VPN route.
   *
   * This request deletes a VPN route. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteVpnServerRoute(
    params: VpcV1.DeleteVpnServerRouteParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteVpnServerRoute');

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/routes/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a VPN route.
   *
   * This request retrieves a single VPN route specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN route identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerRoute>>}
   */
  public getVpnServerRoute(
    params: VpcV1.GetVpnServerRouteParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerRoute>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getVpnServerRoute');

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/routes/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a VPN route.
   *
   * This request updates a VPN route with the information in a provided VPN route patch. The VPN route patch object is
   * structured in the same way as a retrieved VPN route and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.vpnServerId - The VPN server identifier.
   * @param {string} params.id - The VPN route identifier.
   * @param {string} [params.name] - The name for this VPN server route. The name must not be used by another route for
   * the VPN server.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.VPNServerRoute>>}
   */
  public updateVpnServerRoute(
    params: VpcV1.UpdateVpnServerRouteParams
  ): Promise<VpcV1.Response<VpcV1.VPNServerRoute>> {
    const _params = { ...params };
    const _requiredParams = ['vpnServerId', 'id'];
    const _validParams = ['vpnServerId', 'id', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'vpn_server_id': _params.vpnServerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateVpnServerRoute');

    const parameters = {
      options: {
        url: '/vpn_servers/{vpn_server_id}/routes/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * loadBalancers
   ************************/

  /**
   * List load balancer profiles.
   *
   * This request lists load balancer profiles available in the region. A load balancer profile specifies the
   * performance characteristics and pricing model for a load balancer.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerProfileCollection>>}
   */
  public listLoadBalancerProfiles(
    params?: VpcV1.ListLoadBalancerProfilesParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerProfileCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listLoadBalancerProfiles');

    const parameters = {
      options: {
        url: '/load_balancer/profiles',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer profile.
   *
   * This request retrieves a load balancer profile specified by the name in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.name - The load balancer profile name.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerProfile>>}
   */
  public getLoadBalancerProfile(
    params: VpcV1.GetLoadBalancerProfileParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerProfile>> {
    const _params = { ...params };
    const _requiredParams = ['name'];
    const _validParams = ['name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'name': _params.name,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getLoadBalancerProfile');

    const parameters = {
      options: {
        url: '/load_balancer/profiles/{name}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List load balancers.
   *
   * This request lists load balancers in the region.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerCollection>>}
   */
  public listLoadBalancers(
    params?: VpcV1.ListLoadBalancersParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listLoadBalancers');

    const parameters = {
      options: {
        url: '/load_balancers',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a load balancer.
   *
   * This request creates and provisions a new load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {boolean} params.isPublic - Indicates whether this load balancer is public.
   *
   * At present,
   * - If `route_mode` is set to `true`, the load balancer must be private.
   * - If `is_private_path` is specified, it must be set to `false`.
   * @param {SubnetIdentity[]} params.subnets - The subnets to provision this load balancer in.  The subnets must be in
   * the same VPC.
   * - If 'availability' is specified as `subnet` in the profile, the load balancer's availability will depend on the
   * availability of the zones that the subnets reside in.
   * - If 'availability' is specified as `region` in the profile, the load balancer remains available as long as any
   * zone in the region is available. Only members in healthy zones will be sent new connections.
   *
   * Load balancers in the `network` family allow only one subnet to be specified.
   * @param {LoadBalancerDNSPrototype} [params.dns] - The DNS configuration for this load balancer.
   *
   * If unspecified, DNS `A` records for this load balancer's `hostname` property will be added
   * to the public DNS zone `lb.appdomain.cloud`. Otherwise, those DNS `A` records will be
   * added to the specified `zone`.
   *
   * Not supported by private path load balancers.
   * @param {boolean} [params.isPrivatePath] - Indicates whether this is a private path load balancer.
   * @param {LoadBalancerListenerPrototypeLoadBalancerContext[]} [params.listeners] - The listeners of this load
   * balancer.
   * @param {LoadBalancerLoggingPrototype} [params.logging] - The logging configuration to use for this load balancer.
   * See [VPC Datapath
   * Logging](https://cloud.ibm.com/docs/vpc?topic=vpc-datapath-logging) on the logging
   * format, fields and permitted values. If unspecified, `datapath.active` will be `false`.
   *
   * To activate logging, the load balancer profile must support the specified logging type.
   * @param {string} [params.name] - The name for this load balancer. The name must not be used by another load balancer
   * in the VPC.  If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {LoadBalancerPoolPrototypeLoadBalancerContext[]} [params.pools] - The pools of this load balancer.
   * @param {LoadBalancerProfileIdentity} [params.profile] - The profile to use for this load balancer.
   *
   * If unspecified, `application` will be used.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {boolean} [params.routeMode] - Indicates whether [route
   * mode](https://cloud.ibm.com/docs/vpc?topic=vpc-nlb-vnf&interface=ui) is enabled for this load balancer.
   *
   * At present, public load balancers are not supported with route mode enabled.
   * @param {SecurityGroupIdentity[]} [params.securityGroups] - The security groups to use for this load balancer. If
   * unspecified, the VPC's default security group is used.
   *
   * The load balancer profile must support security groups.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancer>>}
   */
  public createLoadBalancer(
    params: VpcV1.CreateLoadBalancerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancer>> {
    const _params = { ...params };
    const _requiredParams = ['isPublic', 'subnets'];
    const _validParams = ['isPublic', 'subnets', 'dns', 'isPrivatePath', 'listeners', 'logging', 'name', 'pools', 'profile', 'resourceGroup', 'routeMode', 'securityGroups', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'is_public': _params.isPublic,
      'subnets': _params.subnets,
      'dns': _params.dns,
      'is_private_path': _params.isPrivatePath,
      'listeners': _params.listeners,
      'logging': _params.logging,
      'name': _params.name,
      'pools': _params.pools,
      'profile': _params.profile,
      'resource_group': _params.resourceGroup,
      'route_mode': _params.routeMode,
      'security_groups': _params.securityGroups,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createLoadBalancer');

    const parameters = {
      options: {
        url: '/load_balancers',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer.
   *
   * This request deletes a load balancer. This operation cannot be reversed. A load balancer cannot be deleted if its
   * `provisioning_status` is `delete_pending` or it is referenced by a resource.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The load balancer identifier.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancer(
    params: VpcV1.DeleteLoadBalancerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteLoadBalancer');

    const parameters = {
      options: {
        url: '/load_balancers/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer.
   *
   * This request retrieves a single load balancer specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The load balancer identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancer>>}
   */
  public getLoadBalancer(
    params: VpcV1.GetLoadBalancerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getLoadBalancer');

    const parameters = {
      options: {
        url: '/load_balancers/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer.
   *
   * This request updates a load balancer with the information in a provided load balancer patch. The load balancer
   * patch object is structured in the same way as a retrieved load balancer and contains only the information to be
   * updated. A load balancer can only be updated if its `provisioning_status` is `active`.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The load balancer identifier.
   * @param {LoadBalancerDNSPatch} [params.dns] - The DNS configuration for this load balancer.
   *
   * Specify `null` to remove the existing DNS configuration, which will remove all DNS `A`
   * records for this load balancer that had been added to `zone`, and add equivalent `A`
   * records to the public DNS zone `lb.appdomain.cloud`.
   *
   * Not supported by private path load balancers.
   * @param {LoadBalancerLoggingPatch} [params.logging] - The logging configuration to use for this load balancer.
   *
   * To activate logging, the load balancer profile must support the specified logging type.
   * @param {string} [params.name] - The name for this load balancer. The name must not be used by another load balancer
   * in the VPC.
   * @param {SubnetIdentity[]} [params.subnets] - The subnets to provision this load balancer in. The load balancer's
   * availability will depend on the availability of the zones that the subnets reside in.
   *
   * The specified subnets must be in the same VPC as the existing subnets, and will completely replace the existing
   * subnets.
   *
   * The load balancer must be in the `application` family.
   * @param {string} [params.ifMatch] - If present, the request will fail if the specified ETag value does not match the
   * resource's current ETag value. Required if the request body includes an array.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancer>>}
   */
  public updateLoadBalancer(
    params: VpcV1.UpdateLoadBalancerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancer>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'dns', 'logging', 'name', 'subnets', 'ifMatch', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'dns': _params.dns,
      'logging': _params.logging,
      'name': _params.name,
      'subnets': _params.subnets,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateLoadBalancer');

    const parameters = {
      options: {
        url: '/load_balancers/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
            'If-Match': _params.ifMatch,
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List statistics of a load balancer.
   *
   * This request lists statistics of a load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The load balancer identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerStatistics>>}
   */
  public getLoadBalancerStatistics(
    params: VpcV1.GetLoadBalancerStatisticsParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerStatistics>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getLoadBalancerStatistics');

    const parameters = {
      options: {
        url: '/load_balancers/{id}/statistics',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List listeners for a load balancer.
   *
   * This request lists listeners for a load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerCollection>>}
   */
  public listLoadBalancerListeners(
    params: VpcV1.ListLoadBalancerListenersParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId'];
    const _validParams = ['loadBalancerId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listLoadBalancerListeners');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a listener for a load balancer.
   *
   * This request creates a new listener for a load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.protocol - The listener protocol. Each listener in the load balancer must have a
   * non-overlapping port range and `protocol` combination.
   *
   * Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
   * the `application` family support `tcp`, `http` and
   * `https`.
   *
   * Additional restrictions:
   * - If `default_pool` is set, the pool's protocol must match, or be compatible with
   *   the listener's protocol. At present, the compatible protocols are `http` and
   *   `https`.
   * - If `https_redirect` is set, the protocol must be `http`.
   * @param {boolean} [params.acceptProxyProtocol] - If set to `true`, this listener will accept and forward PROXY
   * protocol information. Supported by load balancers in the `application` family (otherwise always `false`).
   * Additional restrictions:
   * - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
   *   match the `accept_proxy_protocol` value of the `https_redirect` listener.
   * - If this listener is the target of another listener's `https_redirect`, its
   *   `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
   * @param {CertificateInstanceIdentity} [params.certificateInstance] - The certificate instance to use for SSL
   * termination. The listener must have a
   * `protocol` of `https`.
   * @param {number} [params.connectionLimit] - The concurrent connection limit for the listener. If reached, incoming
   * connections may be queued or rejected.
   *
   * Supported for load balancers in the `application` family.
   *
   * If unspecified, the limit will be `15000` for load balancers in the `application` family.
   * @param {LoadBalancerPoolIdentity} [params.defaultPool] - The default pool for this listener. If `https_redirect` is
   * specified, the
   * default pool will not be used.
   * If specified, the pool must:
   *
   * - Belong to this load balancer.
   * - Have the same `protocol` as this listener, or have a compatible protocol.
   *   At present, the compatible protocols are `http` and `https`.
   * - Not already be the `default_pool` for another listener.
   *
   * If unspecified, this listener will be created with no default pool, but one may be
   * subsequently set.
   * @param {LoadBalancerListenerHTTPSRedirectPrototype} [params.httpsRedirect] - The target listener that requests will
   * be redirected to if none of the listener's
   * `policies` match.
   *
   * If specified, this listener must have a `protocol` of `http`, and the target
   * listener must have a `protocol` of `https`.
   * @param {number} [params.idleConnectionTimeout] - The idle connection timeout of the listener in seconds.
   *
   * Supported for load balancers in the `application` family.
   *
   * If unspecified, the timeout will be `50` for load balancers in the `application` family.
   * @param {LoadBalancerListenerPolicyPrototype[]} [params.policies] - The policy prototype objects for this listener.
   * The load balancer must be in the
   * `application` family.
   * @param {number} [params.port] - The listener port number. Each listener in the load balancer must have a
   * non-overlapping port range and `protocol` combination. Protocol values of `tcp`, `http` and `https` share the TCP
   * port space.
   *
   * If `port_min` is also specified, `port` must have the same value as `port_min`.
   * @param {number} [params.portMax] - The inclusive upper bound of the range of ports used by this listener. Must not
   * be less than `port_min`.
   *
   * Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
   * `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must be
   * `65535`.
   *
   * The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
   * same protocol. Protocol values of `tcp`, `http` and
   * `https` share the TCP port space.
   * @param {number} [params.portMin] - The inclusive lower bound of the range of ports used by this listener. Must not
   * be greater than `port_max`.
   *
   * If specified, `port_max` must also be specified, and must not be smaller. If unspecified, `port_max` must also be
   * unspecified.
   *
   * If `port` is also specified, `port_min` must have the same value as `port`.
   *
   * Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
   * `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must be
   * `1`.
   *
   * The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
   * same protocol. Protocol values of `tcp`, `http` and
   * `https` share the TCP port space.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListener>>}
   */
  public createLoadBalancerListener(
    params: VpcV1.CreateLoadBalancerListenerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListener>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'protocol'];
    const _validParams = ['loadBalancerId', 'protocol', 'acceptProxyProtocol', 'certificateInstance', 'connectionLimit', 'defaultPool', 'httpsRedirect', 'idleConnectionTimeout', 'policies', 'port', 'portMax', 'portMin', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'protocol': _params.protocol,
      'accept_proxy_protocol': _params.acceptProxyProtocol,
      'certificate_instance': _params.certificateInstance,
      'connection_limit': _params.connectionLimit,
      'default_pool': _params.defaultPool,
      'https_redirect': _params.httpsRedirect,
      'idle_connection_timeout': _params.idleConnectionTimeout,
      'policies': _params.policies,
      'port': _params.port,
      'port_max': _params.portMax,
      'port_min': _params.portMin,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createLoadBalancerListener');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer listener.
   *
   * This request deletes a load balancer listener. This operation cannot be reversed. For this operation to succeed,
   * the listener must not be the target of another load balancer listener.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The listener identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancerListener(
    params: VpcV1.DeleteLoadBalancerListenerParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteLoadBalancerListener');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer listener.
   *
   * This request retrieves a single listener specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The listener identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListener>>}
   */
  public getLoadBalancerListener(
    params: VpcV1.GetLoadBalancerListenerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListener>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getLoadBalancerListener');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer listener.
   *
   * This request updates a load balancer listener from a listener patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The listener identifier.
   * @param {boolean} [params.acceptProxyProtocol] - If set to `true`, this listener will accept and forward PROXY
   * protocol information. Supported by load balancers in the `application` family (otherwise always `false`).
   * Additional restrictions:
   * - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
   *   match the `accept_proxy_protocol` value of the `https_redirect` listener.
   * - If this listener is the target of another listener's `https_redirect`, its
   *   `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
   * @param {CertificateInstanceIdentity} [params.certificateInstance] - The certificate instance to use for SSL
   * termination. The listener must have a
   * `protocol` of `https`.
   * @param {number} [params.connectionLimit] - The concurrent connection limit for the listener. If reached, incoming
   * connections may be queued or rejected.
   *
   * Supported for load balancers in the `application` family.
   * @param {LoadBalancerListenerDefaultPoolPatch} [params.defaultPool] - The default pool for this listener. If
   * `https_redirect` is set, the default pool will not
   * be used. The specified pool must:
   *
   * - Belong to this load balancer
   * - Have the same `protocol` as this listener, or have a compatible protocol.
   *   At present, the compatible protocols are `http` and `https`.
   * - Not already be the `default_pool` for another listener
   *
   * Specify `null` to remove an existing default pool.
   * @param {LoadBalancerListenerHTTPSRedirectPatch} [params.httpsRedirect] - The target listener that requests will be
   * redirected to if none of the listener's
   * `policies` match.
   *
   * If specified, this listener must have a `protocol` of `http`, and the target listener
   * must have a `protocol` of `https`.
   *
   * Specify `null` to remove any existing https redirect.
   * @param {number} [params.idleConnectionTimeout] - The idle connection timeout of the listener in seconds.
   *
   * Supported for load balancers in the `application` family.
   * @param {number} [params.port] - The inclusive lower bound of the range of ports used by this listener. Must not be
   * greater than `port_max`. Updating `port` updates `port_min` to the same value.
   *
   * Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
   * `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must be
   * `1`.
   *
   * Each listener in the load balancer must have a non-overlapping port range and
   * `protocol` combination. Protocol values of `tcp`, `http` and `https` share the TCP port space.
   * @param {number} [params.portMax] - The inclusive upper bound of the range of ports used by this listener. Must not
   * be less than `port_min`.
   *
   * Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
   * `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must be
   * `65535`.
   *
   * The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
   * same protocol. Protocol values of `tcp`, `http` and
   * `https` share the TCP port space.
   * @param {number} [params.portMin] - The inclusive lower bound of the range of ports used by this listener. Must not
   * be greater than `port_max`. Updating `port_min` updates `port` to the same value.
   *
   * Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
   * `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must be
   * `1`.
   *
   * Each listener in the load balancer must have a non-overlapping port range and
   * `protocol` combination.
   * @param {string} [params.protocol] - The listener protocol. Each listener in the load balancer must have a
   * non-overlapping port range and `protocol` combination.
   *
   * Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
   * the `application` family support `tcp`, `http` and
   * `https`.
   *
   * Additional restrictions:
   * - If `default_pool` is set, the protocol cannot be changed.
   * - If `https_redirect` is set, the protocol must be `http`.
   * - If another listener's `https_redirect` targets this listener, the protocol must be
   * `https`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListener>>}
   */
  public updateLoadBalancerListener(
    params: VpcV1.UpdateLoadBalancerListenerParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListener>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'acceptProxyProtocol', 'certificateInstance', 'connectionLimit', 'defaultPool', 'httpsRedirect', 'idleConnectionTimeout', 'port', 'portMax', 'portMin', 'protocol', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'accept_proxy_protocol': _params.acceptProxyProtocol,
      'certificate_instance': _params.certificateInstance,
      'connection_limit': _params.connectionLimit,
      'default_pool': _params.defaultPool,
      'https_redirect': _params.httpsRedirect,
      'idle_connection_timeout': _params.idleConnectionTimeout,
      'port': _params.port,
      'port_max': _params.portMax,
      'port_min': _params.portMin,
      'protocol': _params.protocol,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateLoadBalancerListener');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List policies for a load balancer listener.
   *
   * This request lists policies for a load balancer listener. A policy consists of rules to match against each incoming
   * request, and an action to apply to the request if a rule matches.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyCollection>>}
   */
  public listLoadBalancerListenerPolicies(
    params: VpcV1.ListLoadBalancerListenerPoliciesParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId'];
    const _validParams = ['loadBalancerId', 'listenerId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listLoadBalancerListenerPolicies');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a policy for a load balancer listener.
   *
   * This request creates a new policy from a load balancer listener policy object. The prototype object is structured
   * in the same way as a retrieved policy, and contains the information necessary to create the new policy. For this
   * request to succeed, the load balancer must be in the `application` family.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.action - The policy action:
   * - `forward_to_listener`: Requests will be forwarded to the specified
   *   `target` listener.
   * - `forward_to_pool`: Requests will be forwarded to the specified `target` pool.
   * - `https_redirect`: Requests will be redirected to the specified `target.listener`.
   *    This listener must have a `protocol` of `http`, and the target listener must
   *    have a `protocol` of `https`.
   * - `redirect`: Requests will be redirected to the specified `target.url`
   * - `reject`: Requests will be rejected with a `403` status code.
   * @param {number} params.priority - Priority of the policy. The priority is unique across all policies for this load
   * balancer listener. Lower value indicates higher priority.
   * @param {string} [params.name] - The name for this policy. The name must not be used by another policy for the load
   * balancer listener. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {LoadBalancerListenerPolicyRulePrototype[]} [params.rules] - The rule prototype objects for this policy.
   * @param {LoadBalancerListenerPolicyTargetPrototype} [params.target] - - If `action` is `forward_to_listener`,
   * specify a `LoadBalancerListenerIdentity` in this
   *   load balancer to forward to.
   * - If `action` is `forward_to_pool`, use `LoadBalancerPoolIdentity` to specify a pool in
   *   this load balancer to forward to.
   * - If `action` is `https_redirect`, use
   *   `LoadBalancerListenerPolicyHTTPSRedirectPrototype` to specify a listener on this
   *   load balancer to redirect to.
   * - If `action` is `redirect`, use `LoadBalancerListenerPolicyRedirectURLPrototype`to
   *   specify a URL to redirect to.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>>}
   */
  public createLoadBalancerListenerPolicy(
    params: VpcV1.CreateLoadBalancerListenerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'action', 'priority'];
    const _validParams = ['loadBalancerId', 'listenerId', 'action', 'priority', 'name', 'rules', 'target', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'action': _params.action,
      'priority': _params.priority,
      'name': _params.name,
      'rules': _params.rules,
      'target': _params.target,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createLoadBalancerListenerPolicy');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer listener policy.
   *
   * Deletes a policy of the load balancer listener. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.id - The policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancerListenerPolicy(
    params: VpcV1.DeleteLoadBalancerListenerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteLoadBalancerListenerPolicy');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer listener policy.
   *
   * Retrieve a single policy specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.id - The policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>>}
   */
  public getLoadBalancerListenerPolicy(
    params: VpcV1.GetLoadBalancerListenerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getLoadBalancerListenerPolicy');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer listener policy.
   *
   * This request updates a load balancer listener policy with the information in a provided policy patch. The policy
   * patch object is structured in the same way as a retrieved policy and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.id - The policy identifier.
   * @param {string} [params.name] - The name for this policy. The name must not be used by another policy for the load
   * balancer listener.
   * @param {number} [params.priority] - Priority of the policy. The priority is unique across all policies for this
   * load balancer listener. Lower value indicates higher priority.
   * @param {LoadBalancerListenerPolicyTargetPatch} [params.target] - - If `action` is `forward_to_listener`, specify a
   * `LoadBalancerListenerIdentity` for a
   *   listener in this load balancer.
   * - If `action` is `forward_to_pool`, specify a `LoadBalancerPoolIdentity` for a pool in
   *   this load balancer.
   * - If `action` is `https_redirect`, specify a
   *   `LoadBalancerListenerPolicyHTTPSRedirectPatch` for a listener in this load balancer
   *   with a `protocol` of `https`.
   * - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPatch`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>>}
   */
  public updateLoadBalancerListenerPolicy(
    params: VpcV1.UpdateLoadBalancerListenerPolicyParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'id', 'name', 'priority', 'target', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'priority': _params.priority,
      'target': _params.target,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateLoadBalancerListenerPolicy');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List rules of a load balancer listener policy.
   *
   * This request lists rules of a load balancer listener policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.policyId - The policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRuleCollection>>}
   */
  public listLoadBalancerListenerPolicyRules(
    params: VpcV1.ListLoadBalancerListenerPolicyRulesParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRuleCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'policyId'];
    const _validParams = ['loadBalancerId', 'listenerId', 'policyId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'policy_id': _params.policyId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listLoadBalancerListenerPolicyRules');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a rule for a load balancer listener policy.
   *
   * Creates a new rule for the load balancer listener policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.policyId - The policy identifier.
   * @param {string} params.condition - The condition for the rule.
   * @param {string} params.type - The content the rule applies to:
   * - `body`: The UTF-8 form-encoded HTTP request body
   * - `header`: The HTTP header
   * - `hostname`: The fully-qualified domain name of the server specified in the Host
   *   HTTP request header
   * - `path`: The path of the HTTP request
   * - `query`: The query of the HTTP request URL
   * - `sni_hostname`: The fully-qualified domain name of the server provided in the
   *   "server name indicator" extension during TLS negotiation
   *
   * - For listeners with `protocol` `http` or `https`, any type may be specified.
   * - For listeners with `protocol` `tcp`, only type `sni_hostname` may be specified.
   * @param {string} params.value - The value to be matched for the rule condition.
   *
   * If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
   * @param {string} [params.field] - The field to match for this rule.
   * - If the `type` is `header`, this property must be specified.
   * - If the `type` is `body` or `query`, this property may be specified.
   * - For all other types, this property must not be specified.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>>}
   */
  public createLoadBalancerListenerPolicyRule(
    params: VpcV1.CreateLoadBalancerListenerPolicyRuleParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'policyId', 'condition', 'type', 'value'];
    const _validParams = ['loadBalancerId', 'listenerId', 'policyId', 'condition', 'type', 'value', 'field', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'condition': _params.condition,
      'type': _params.type,
      'value': _params.value,
      'field': _params.field,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'policy_id': _params.policyId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createLoadBalancerListenerPolicyRule');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer listener policy rule.
   *
   * Deletes a rule from the load balancer listener policy. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.policyId - The policy identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancerListenerPolicyRule(
    params: VpcV1.DeleteLoadBalancerListenerPolicyRuleParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'policyId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'policyId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'policy_id': _params.policyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteLoadBalancerListenerPolicyRule');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer listener policy rule.
   *
   * Retrieves a single rule specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.policyId - The policy identifier.
   * @param {string} params.id - The rule identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>>}
   */
  public getLoadBalancerListenerPolicyRule(
    params: VpcV1.GetLoadBalancerListenerPolicyRuleParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'policyId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'policyId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'policy_id': _params.policyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getLoadBalancerListenerPolicyRule');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer listener policy rule.
   *
   * Updates a rule of the load balancer listener policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.listenerId - The listener identifier.
   * @param {string} params.policyId - The policy identifier.
   * @param {string} params.id - The rule identifier.
   * @param {string} [params.condition] - The condition for the rule.
   * @param {string} [params.field] - The field to match for this rule.
   * - If the `type` is `header`, this property must be specified.
   * - If the `type` is `body` or `query`, this property may be specified.
   * - For all other types, this property must not be specified.
   * @param {string} [params.type] - The content the rule applies to:
   * - `body`: The UTF-8 form-encoded HTTP request body
   * - `header`: The HTTP header
   * - `hostname`: The fully-qualified domain name of the server specified in the Host
   *   HTTP request header
   * - `path`: The path of the HTTP request
   * - `query`: The query of the HTTP request URL
   * - `sni_hostname`: The fully-qualified domain name of the server provided in the
   *   "server name indicator" extension during TLS negotiation
   *
   * - For listeners with `protocol` `http` or `https`, any type may be specified.
   * - For listeners with `protocol` `tcp`, only type `sni_hostname` may be specified.
   * @param {string} [params.value] - The value to be matched for the rule condition.
   *
   * If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>>}
   */
  public updateLoadBalancerListenerPolicyRule(
    params: VpcV1.UpdateLoadBalancerListenerPolicyRuleParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerListenerPolicyRule>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'listenerId', 'policyId', 'id'];
    const _validParams = ['loadBalancerId', 'listenerId', 'policyId', 'id', 'condition', 'field', 'type', 'value', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'condition': _params.condition,
      'field': _params.field,
      'type': _params.type,
      'value': _params.value,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'listener_id': _params.listenerId,
      'policy_id': _params.policyId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateLoadBalancerListenerPolicyRule');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List pools of a load balancer.
   *
   * This request lists pools of a load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolCollection>>}
   */
  public listLoadBalancerPools(
    params: VpcV1.ListLoadBalancerPoolsParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId'];
    const _validParams = ['loadBalancerId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listLoadBalancerPools');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a load balancer pool.
   *
   * This request creates a new pool from a pool prototype object.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.algorithm - The load balancing algorithm. The `least_connections` algorithm is only
   * supported for load balancers that have `availability` with value `subnet` in the profile.
   * @param {LoadBalancerPoolHealthMonitorPrototype} params.healthMonitor - The health monitor of this pool.
   *
   * If this pool has a member targeting a load balancer then:
   *
   * - If the targeted load balancer has multiple subnets, this health monitor will be
   *   used to direct traffic to the available subnets.
   * - The health checks spawned by this health monitor will be handled as any other
   *   traffic (that is, subject to the configuration of listeners and pools on the target
   *   load balancer).
   * - This health monitor does not affect how pool member health is determined within the
   *   target load balancer.
   *
   * For more information, see [Private Path network load balancer frequently asked
   * questions](https://cloud.ibm.com/docs/vpc?topic=vpc-nlb-faqs#ppnlb-faqs).
   * @param {string} params.protocol - The protocol used for this load balancer pool. Load balancers in the `network`
   * family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the
   * `application` family support `tcp`, `http`, and `https`.
   * @param {LoadBalancerPoolFailsafePolicyPrototype} [params.failsafePolicy] - The failsafe policy to use for this
   * pool.
   *
   * If unspecified, the default failsafe policy action from the profile will be used.
   * @param {LoadBalancerPoolMemberPrototype[]} [params.members] - The members for this load balancer pool. For load
   * balancers in the `network` family, the same `port` and `target` tuple cannot be shared by a pool member of any
   * other load balancer in the same VPC.
   * @param {string} [params.name] - The name for this load balancer pool. The name must not be used by another pool for
   * the load balancer. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {string} [params.proxyProtocol] - The PROXY protocol setting for this pool:
   * - `v1`: Enabled with version 1 (human-readable header format)
   * - `v2`: Enabled with version 2 (binary header format)
   * - `disabled`: Disabled
   *
   * For load balancers in the `network` family, this property must be `disabled`.
   * @param {LoadBalancerPoolSessionPersistencePrototype} [params.sessionPersistence] - The session persistence of this
   * pool. If specified, the load balancer must have
   * `source_ip_session_persistence_supported` set to `true` in its profile.
   *
   * If unspecified, session persistence will be disabled, and traffic will be distributed
   * across members of the pool.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPool>>}
   */
  public createLoadBalancerPool(
    params: VpcV1.CreateLoadBalancerPoolParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPool>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'algorithm', 'healthMonitor', 'protocol'];
    const _validParams = ['loadBalancerId', 'algorithm', 'healthMonitor', 'protocol', 'failsafePolicy', 'members', 'name', 'proxyProtocol', 'sessionPersistence', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'algorithm': _params.algorithm,
      'health_monitor': _params.healthMonitor,
      'protocol': _params.protocol,
      'failsafe_policy': _params.failsafePolicy,
      'members': _params.members,
      'name': _params.name,
      'proxy_protocol': _params.proxyProtocol,
      'session_persistence': _params.sessionPersistence,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createLoadBalancerPool');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer pool.
   *
   * This request deletes a load balancer pool. This operation cannot be reversed. The pool must not currently be the
   * default pool for any listener in the load balancer, nor be the target pool in the failsafe policy for any other
   * pool.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The pool identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancerPool(
    params: VpcV1.DeleteLoadBalancerPoolParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteLoadBalancerPool');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer pool.
   *
   * This request retrieves a single pool specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The pool identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPool>>}
   */
  public getLoadBalancerPool(
    params: VpcV1.GetLoadBalancerPoolParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPool>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getLoadBalancerPool');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer pool.
   *
   * This request updates a load balancer pool from a pool patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.id - The pool identifier.
   * @param {string} [params.algorithm] - The load balancing algorithm. The `least_connections` algorithm is only
   * supported for load balancers that have `availability` with value `subnet` in the profile.
   * @param {LoadBalancerPoolFailsafePolicyPatch} [params.failsafePolicy] - The failsafe policy for this load balancer
   * pool.
   * @param {LoadBalancerPoolHealthMonitorPatch} [params.healthMonitor] - The health monitor of this pool.
   *
   * If this pool has a member targeting a load balancer then:
   *
   * - If the targeted load balancer has multiple subnets, this health monitor will be
   *   used to direct traffic to the available subnets.
   * - The health checks spawned by this health monitor will be handled as any other
   *   traffic (that is, subject to the configuration of listeners and pools on the
   *   target load balancer).
   * - This health monitor does not affect how pool member health is determined within
   *   the target load balancer.
   *
   * For more information, see [Private Path network load balancer frequently asked
   * questions](https://cloud.ibm.com/docs/vpc?topic=vpc-nlb-faqs#ppnlb-faqs).
   * @param {string} [params.name] - The name for this load balancer pool. The name must not be used by another pool for
   * the load balancer.
   * @param {string} [params.protocol] - The protocol for this load balancer pool.
   *
   * Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
   * the `application` family support `tcp`, `http` and
   * `https`.
   *
   * If this pool is associated with a load balancer listener or a load balancer failsafe target pool, the specified
   * protocol must match or be compatible with each other's protocol. At present, the compatible protocols are `http`
   * and `https`.
   * @param {string} [params.proxyProtocol] - The PROXY protocol setting for this pool:
   * - `v1`: Enabled with version 1 (human-readable header format)
   * - `v2`: Enabled with version 2 (binary header format)
   * - `disabled`: Disabled
   *
   * For load balancers in the `network` family, this property must be `disabled`.
   * @param {LoadBalancerPoolSessionPersistencePatch} [params.sessionPersistence] - The session persistence of this
   * pool.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPool>>}
   */
  public updateLoadBalancerPool(
    params: VpcV1.UpdateLoadBalancerPoolParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPool>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'id'];
    const _validParams = ['loadBalancerId', 'id', 'algorithm', 'failsafePolicy', 'healthMonitor', 'name', 'protocol', 'proxyProtocol', 'sessionPersistence', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'algorithm': _params.algorithm,
      'failsafe_policy': _params.failsafePolicy,
      'health_monitor': _params.healthMonitor,
      'name': _params.name,
      'protocol': _params.protocol,
      'proxy_protocol': _params.proxyProtocol,
      'session_persistence': _params.sessionPersistence,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateLoadBalancerPool');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List members of a load balancer pool.
   *
   * This request lists members of a load balancer pool.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMemberCollection>>}
   */
  public listLoadBalancerPoolMembers(
    params: VpcV1.ListLoadBalancerPoolMembersParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMemberCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId'];
    const _validParams = ['loadBalancerId', 'poolId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listLoadBalancerPoolMembers');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a member in a load balancer pool.
   *
   * This request creates a new member and adds the member to the pool.
   *
   * The pool must not already have a member targeting a load balancer.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {number} params.port - The port the member will receive load balancer traffic on. Applies only to load
   * balancer traffic received on a listener with a single port. (If the traffic is received on a listener with a port
   * range, the member will receive the traffic on the same port the listener received it on.)
   *
   * This port will also be used for health checks unless the `port` property of
   * `health_monitor` property is specified.
   *
   * The port must be unique across all members for all pools associated with this pool's listener.
   *
   * For load balancers in the `network` family, the same `port` and `target` tuple cannot be shared by a pool member of
   * any other load balancer in the same VPC.
   * @param {LoadBalancerPoolMemberTargetPrototype} params.target - The pool member target.
   *
   * If the load balancer has `route_mode` set to `true`, the member must be in a zone the load
   * balancer has a subnet in.
   *
   * For load balancers in the `network` family, the same `port` and `target` tuple cannot
   * be shared by a pool member of any other load balancer in the same VPC.
   * @param {number} [params.weight] - The weight of the server member.
   *
   * If specified, the pool algorithm must be `weighted_round_robin` and the load balancer must be in the `application`
   * family.
   *
   * If unspecified, the weight will be `50` for load balancers in the `application` family.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>>}
   */
  public createLoadBalancerPoolMember(
    params: VpcV1.CreateLoadBalancerPoolMemberParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId', 'port', 'target'];
    const _validParams = ['loadBalancerId', 'poolId', 'port', 'target', 'weight', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'port': _params.port,
      'target': _params.target,
      'weight': _params.weight,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createLoadBalancerPoolMember');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Replace load balancer pool members.
   *
   * This request replaces the existing members of the load balancer pool with new members created from the collection
   * of member prototype objects.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {LoadBalancerPoolMemberPrototype[]} params.members - The member prototype objects for this pool.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMemberCollection>>}
   */
  public replaceLoadBalancerPoolMembers(
    params: VpcV1.ReplaceLoadBalancerPoolMembersParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMemberCollection>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId', 'members'];
    const _validParams = ['loadBalancerId', 'poolId', 'members', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'members': _params.members,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'replaceLoadBalancerPoolMembers');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members',
        method: 'PUT',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a load balancer pool member.
   *
   * This request deletes a member from the pool. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {string} params.id - The member identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteLoadBalancerPoolMember(
    params: VpcV1.DeleteLoadBalancerPoolMemberParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId', 'id'];
    const _validParams = ['loadBalancerId', 'poolId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteLoadBalancerPoolMember');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a load balancer pool member.
   *
   * This request retrieves a single member specified by the identifier in the URL path.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {string} params.id - The member identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>>}
   */
  public getLoadBalancerPoolMember(
    params: VpcV1.GetLoadBalancerPoolMemberParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId', 'id'];
    const _validParams = ['loadBalancerId', 'poolId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getLoadBalancerPoolMember');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a load balancer pool member.
   *
   * This request updates an existing member from a member patch.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.loadBalancerId - The load balancer identifier.
   * @param {string} params.poolId - The pool identifier.
   * @param {string} params.id - The member identifier.
   * @param {number} [params.port] - The port the member will receive load balancer traffic on. Applies only to load
   * balancer traffic received on a listener with a single port. (If the traffic is received on a listener with a port
   * range, the member will receive the traffic on the same port the listener received it on.)
   *
   * This port will also be used for health checks unless the `port` property of
   * `health_monitor` property is specified.
   *
   * The port must be unique across all members for all pools associated with this pool's listener.
   *
   * For load balancers in the `network` family, the same `port` and `target` tuple cannot be shared by a pool member of
   * any other load balancer in the same VPC.
   * @param {LoadBalancerPoolMemberTargetPrototype} [params.target] - The pool member target.
   *
   * If the load balancer has `route_mode` set to `true`, the member must be in a zone the load
   * balancer has a subnet in.
   *
   * For load balancers in the `network` family, the same `port` and `target` tuple cannot
   * be shared by a pool member of any other load balancer in the same VPC.
   * @param {number} [params.weight] - The weight of the server member.
   *
   * If specified, the pool algorithm must be `weighted_round_robin`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>>}
   */
  public updateLoadBalancerPoolMember(
    params: VpcV1.UpdateLoadBalancerPoolMemberParams
  ): Promise<VpcV1.Response<VpcV1.LoadBalancerPoolMember>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancerId', 'poolId', 'id'];
    const _validParams = ['loadBalancerId', 'poolId', 'id', 'port', 'target', 'weight', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'port': _params.port,
      'target': _params.target,
      'weight': _params.weight,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'load_balancer_id': _params.loadBalancerId,
      'pool_id': _params.poolId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateLoadBalancerPoolMember');

    const parameters = {
      options: {
        url: '/load_balancers/{load_balancer_id}/pools/{pool_id}/members/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * endpointGateways
   ************************/

  /**
   * List endpoint gateways.
   *
   * This request lists endpoint gateways in the region. An endpoint gateway maps one or more reserved IPs in a VPC to a
   * target outside the VPC.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string[]} [params.lifecycleState] - Filters the collection to resources with a `lifecycle_state` property
   * matching one of the specified comma-separated values.
   * @param {string} [params.vpcId] - Filters the collection to resources with a `vpc.id` property matching the
   * specified identifier.
   * @param {string} [params.vpcCrn] - Filters the collection to resources with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to resources with a `vpc.name` property matching the
   * exact specified name.
   * @param {boolean} [params.allowDnsResolutionBinding] - Filters the collection to endpoint gateways with an
   * `allow_dns_resolution_binding` property matching the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EndpointGatewayCollection>>}
   */
  public listEndpointGateways(
    params?: VpcV1.ListEndpointGatewaysParams
  ): Promise<VpcV1.Response<VpcV1.EndpointGatewayCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['name', 'start', 'limit', 'resourceGroupId', 'lifecycleState', 'vpcId', 'vpcCrn', 'vpcName', 'allowDnsResolutionBinding', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'name': _params.name,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'lifecycle_state': _params.lifecycleState,
      'vpc.id': _params.vpcId,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
      'allow_dns_resolution_binding': _params.allowDnsResolutionBinding,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listEndpointGateways');

    const parameters = {
      options: {
        url: '/endpoint_gateways',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an endpoint gateway.
   *
   * This request creates a new endpoint gateway. An endpoint gateway maps one or more reserved IPs in a VPC to a target
   * outside the VPC.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {EndpointGatewayTargetPrototype} params.target - The target to use for this endpoint gateway. The target:
   * - Must not already be the target of another endpoint gateway in the VPC
   * - Must not have a service endpoint that duplicates or overlaps with any `service_endpoints`
   *   of another endpoint gateway in the VPC.
   * @param {VPCIdentity} params.vpc - The VPC this endpoint gateway will reside in.
   * @param {boolean} [params.allowDnsResolutionBinding] - Indicates whether to allow DNS resolution for this endpoint
   * gateway when the VPC this endpoint gateway resides in has a DNS resolution binding to a VPC with `dns.enable_hub`
   * set to `true`.
   *
   * Must be `true` if the VPC this endpoint gateway resides in has `dns.enable_hub` set to
   * `true`.
   * @param {EndpointGatewayReservedIP[]} [params.ips] - The reserved IPs to bind to this endpoint gateway. At most one
   * reserved IP per zone is allowed.
   * @param {string} [params.name] - The name for this endpoint gateway. The name must not be used by another endpoint
   * gateway in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {SecurityGroupIdentity[]} [params.securityGroups] - The security groups to use for this endpoint gateway. If
   * unspecified, the VPC's default security group is used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EndpointGateway>>}
   */
  public createEndpointGateway(
    params: VpcV1.CreateEndpointGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EndpointGateway>> {
    const _params = { ...params };
    const _requiredParams = ['target', 'vpc'];
    const _validParams = ['target', 'vpc', 'allowDnsResolutionBinding', 'ips', 'name', 'resourceGroup', 'securityGroups', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'target': _params.target,
      'vpc': _params.vpc,
      'allow_dns_resolution_binding': _params.allowDnsResolutionBinding,
      'ips': _params.ips,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
      'security_groups': _params.securityGroups,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createEndpointGateway');

    const parameters = {
      options: {
        url: '/endpoint_gateways',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List reserved IPs bound to an endpoint gateway.
   *
   * This request lists reserved IPs bound to an endpoint gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.endpointGatewayId - The endpoint gateway identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.sort] - Sorts the returned collection by the specified property name in ascending order. A
   * `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the
   * collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property
   * in ascending order.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIPCollectionEndpointGatewayContext>>}
   */
  public listEndpointGatewayIps(
    params: VpcV1.ListEndpointGatewayIpsParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIPCollectionEndpointGatewayContext>> {
    const _params = { ...params };
    const _requiredParams = ['endpointGatewayId'];
    const _validParams = ['endpointGatewayId', 'start', 'limit', 'sort', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'sort': _params.sort,
    };

    const path = {
      'endpoint_gateway_id': _params.endpointGatewayId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listEndpointGatewayIps');

    const parameters = {
      options: {
        url: '/endpoint_gateways/{endpoint_gateway_id}/ips',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Unbind a reserved IP from an endpoint gateway.
   *
   * This request unbinds the specified reserved IP from the specified endpoint gateway. If the reserved IP has
   * `auto_delete` set to `true`, the reserved IP will be deleted.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.endpointGatewayId - The endpoint gateway identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public removeEndpointGatewayIp(
    params: VpcV1.RemoveEndpointGatewayIpParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['endpointGatewayId', 'id'];
    const _validParams = ['endpointGatewayId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'endpoint_gateway_id': _params.endpointGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'removeEndpointGatewayIp');

    const parameters = {
      options: {
        url: '/endpoint_gateways/{endpoint_gateway_id}/ips/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a reserved IP bound to an endpoint gateway.
   *
   * This request retrieves the specified reserved IP address if it is bound to the endpoint gateway specified in the
   * URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.endpointGatewayId - The endpoint gateway identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public getEndpointGatewayIp(
    params: VpcV1.GetEndpointGatewayIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['endpointGatewayId', 'id'];
    const _validParams = ['endpointGatewayId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'endpoint_gateway_id': _params.endpointGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getEndpointGatewayIp');

    const parameters = {
      options: {
        url: '/endpoint_gateways/{endpoint_gateway_id}/ips/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Bind a reserved IP to an endpoint gateway.
   *
   * This request binds the specified reserved IP to the specified endpoint gateway. The reserved IP:
   *
   * - must currently be unbound, or not required by its target
   * - must not be in the same zone as any other reserved IP bound to the endpoint gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.endpointGatewayId - The endpoint gateway identifier.
   * @param {string} params.id - The reserved IP identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.ReservedIP>>}
   */
  public addEndpointGatewayIp(
    params: VpcV1.AddEndpointGatewayIpParams
  ): Promise<VpcV1.Response<VpcV1.ReservedIP>> {
    const _params = { ...params };
    const _requiredParams = ['endpointGatewayId', 'id'];
    const _validParams = ['endpointGatewayId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'endpoint_gateway_id': _params.endpointGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'addEndpointGatewayIp');

    const parameters = {
      options: {
        url: '/endpoint_gateways/{endpoint_gateway_id}/ips/{id}',
        method: 'PUT',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an endpoint gateway.
   *
   * This request deletes an endpoint gateway. This operation cannot be reversed.
   *
   * Reserved IPs that were bound to the endpoint gateway will be released if their
   * `auto_delete` property is set to true.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The endpoint gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteEndpointGateway(
    params: VpcV1.DeleteEndpointGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteEndpointGateway');

    const parameters = {
      options: {
        url: '/endpoint_gateways/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an endpoint gateway.
   *
   * This request retrieves a single endpoint gateway specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The endpoint gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EndpointGateway>>}
   */
  public getEndpointGateway(
    params: VpcV1.GetEndpointGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EndpointGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getEndpointGateway');

    const parameters = {
      options: {
        url: '/endpoint_gateways/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an endpoint gateway.
   *
   * This request updates an endpoint gateway's name.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The endpoint gateway identifier.
   * @param {boolean} [params.allowDnsResolutionBinding] - Indicates whether to allow DNS resolution for this endpoint
   * gateway when the VPC this endpoint gateway resides in has a DNS resolution binding to a VPC with `dns.enable_hub`
   * set to `true`.
   *
   * Must be `true` if the VPC this endpoint gateway resides in has `dns.enable_hub` set to
   * `true`.
   * @param {string} [params.name] - The name for this endpoint gateway. The name must not be used by another endpoint
   * gateway in the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EndpointGateway>>}
   */
  public updateEndpointGateway(
    params: VpcV1.UpdateEndpointGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EndpointGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'allowDnsResolutionBinding', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'allow_dns_resolution_binding': _params.allowDnsResolutionBinding,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateEndpointGateway');

    const parameters = {
      options: {
        url: '/endpoint_gateways/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * flowLogCollectors
   ************************/

  /**
   * List flow log collectors.
   *
   * This request lists flow log collectors in the region. A [flow log
   * collector](https://cloud.ibm.com/docs/vpc?topic=vpc-flow-logs) summarizes TCP and UDP data sent over the instance
   * network interfaces and instance network attachments contained within its target. The collected flow logs are
   * written to a cloud object storage bucket, where they can be
   * [viewed](https://cloud.ibm.com/docs/vpc?topic=vpc-fl-analyze).
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {string} [params.name] - Filters the collection to resources with a `name` property matching the exact
   * specified name.
   * @param {string} [params.vpcId] - Filters the collection to resources with a `vpc.id` property matching the
   * specified identifier.
   * @param {string} [params.vpcCrn] - Filters the collection to resources with a `vpc.crn` property matching the
   * specified CRN.
   * @param {string} [params.vpcName] - Filters the collection to resources with a `vpc.name` property matching the
   * exact specified name.
   * @param {string} [params.targetId] - Filters the collection to resources with a `target.id` property matching the
   * specified identifier.
   * @param {string} [params.targetResourceType] - Filters the collection to resources with a `target.resource_type`
   * property matching the specified value.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FlowLogCollectorCollection>>}
   */
  public listFlowLogCollectors(
    params?: VpcV1.ListFlowLogCollectorsParams
  ): Promise<VpcV1.Response<VpcV1.FlowLogCollectorCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'name', 'vpcId', 'vpcCrn', 'vpcName', 'targetId', 'targetResourceType', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
      'name': _params.name,
      'vpc.id': _params.vpcId,
      'vpc.crn': _params.vpcCrn,
      'vpc.name': _params.vpcName,
      'target.id': _params.targetId,
      'target.resource_type': _params.targetResourceType,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listFlowLogCollectors');

    const parameters = {
      options: {
        url: '/flow_log_collectors',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a flow log collector.
   *
   * This request creates and starts a new flow log collector from a flow log collector prototype object. The prototype
   * object is structured in the same way as a retrieved flow log collector, and contains the information necessary to
   * create and start the new flow log collector.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {LegacyCloudObjectStorageBucketIdentity} params.storageBucket - The Cloud Object Storage bucket where the
   * collected flows will be logged.
   * The bucket must exist and an IAM service authorization must grant
   * `IBM Cloud Flow Logs` resources of `VPC Infrastructure Services` writer
   * access to the bucket. For more information, see [Creating a flow log
   * collector](https://cloud.ibm.com/docs/vpc?topic=vpc-ordering-flow-log-collector).
   * @param {FlowLogCollectorTargetPrototype} params.target - The target this collector will collect flow logs for.
   *
   * If the target is an instance, subnet, or VPC, flow logs will not be collected for any
   * instance network attachments, virtual network interfaces or instance network interfaces
   * within the target that are themselves the target of a more specific flow log collector.
   *
   * The target must not be a virtual network interface that is attached to a bare metal server
   * network attachment or to a file share mount target.
   * @param {boolean} [params.active] - Indicates whether this collector will be active upon creation.
   * @param {string} [params.name] - The name for this flow log collector. The name must not be used by another flow log
   * collector in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FlowLogCollector>>}
   */
  public createFlowLogCollector(
    params: VpcV1.CreateFlowLogCollectorParams
  ): Promise<VpcV1.Response<VpcV1.FlowLogCollector>> {
    const _params = { ...params };
    const _requiredParams = ['storageBucket', 'target'];
    const _validParams = ['storageBucket', 'target', 'active', 'name', 'resourceGroup', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'storage_bucket': _params.storageBucket,
      'target': _params.target,
      'active': _params.active,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createFlowLogCollector');

    const parameters = {
      options: {
        url: '/flow_log_collectors',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a flow log collector.
   *
   * This request stops and deletes a flow log collector. This operation cannot be reversed.
   *
   * Collected flow logs remain available within the flow log collector's Cloud Object Storage bucket.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The flow log collector identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deleteFlowLogCollector(
    params: VpcV1.DeleteFlowLogCollectorParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteFlowLogCollector');

    const parameters = {
      options: {
        url: '/flow_log_collectors/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a flow log collector.
   *
   * This request retrieves a single flow log collector specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The flow log collector identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FlowLogCollector>>}
   */
  public getFlowLogCollector(
    params: VpcV1.GetFlowLogCollectorParams
  ): Promise<VpcV1.Response<VpcV1.FlowLogCollector>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getFlowLogCollector');

    const parameters = {
      options: {
        url: '/flow_log_collectors/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a flow log collector.
   *
   * This request updates a flow log collector with the information in a provided flow log collector patch. The flow log
   * collector patch object is structured in the same way as a retrieved flow log collector and contains only the
   * information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The flow log collector identifier.
   * @param {boolean} [params.active] - Indicates whether this collector is active. Updating to false deactivates the
   * collector and updating to true activates the collector.
   * @param {string} [params.name] - The name for this flow log collector. The name must not be used by another flow log
   * collector in the VPC.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.FlowLogCollector>>}
   */
  public updateFlowLogCollector(
    params: VpcV1.UpdateFlowLogCollectorParams
  ): Promise<VpcV1.Response<VpcV1.FlowLogCollector>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'active', 'name', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'active': _params.active,
      'name': _params.name,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updateFlowLogCollector');

    const parameters = {
      options: {
        url: '/flow_log_collectors/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * privatePathServiceGateways
   ************************/

  /**
   * List private path service gateways.
   *
   * This request lists private path service gateways in the region. Private path service gateways allow
   * [service
   * providers](https://cloud.ibm.com/docs/private-path?topic=private-path-private-path-service-architecture#private-path-service-components)
   * to make their services available using
   * [private path
   * connectivity](https://cloud.ibm.com/docs/private-path?topic=private-path-private-path-service-architecture#private-path-service-components).
   * Private path service gateways are used to facilitate and manage the private path connectivity between private path
   * network load balancers and their associated endpoint gateways.
   *
   * @param {Object} [params] - The parameters to send to the service.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.resourceGroupId] - Filters the collection to resources with a `resource_group.id` property
   * matching the specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayCollection>>}
   */
  public listPrivatePathServiceGateways(
    params?: VpcV1.ListPrivatePathServiceGatewaysParams
  ): Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayCollection>> {
    const _params = { ...params };
    const _requiredParams = [];
    const _validParams = ['start', 'limit', 'resourceGroupId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'resource_group.id': _params.resourceGroupId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listPrivatePathServiceGateways');

    const parameters = {
      options: {
        url: '/private_path_service_gateways',
        method: 'GET',
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a private path service gateway.
   *
   * This request creates a private path service gateway from a private path service gateway prototype object. The
   * prototype object is structured in the same way as a retrieved private path service gateway, and contains the
   * information necessary to create the new private path service gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {LoadBalancerIdentity} params.loadBalancer - The load balancer for this private path service gateway. The
   * load balancer must
   * have `is_private_path` set to `true`.
   *
   * The private path service gateway will reside in the same VPC as the specified load
   * balancer.
   * @param {string[]} params.serviceEndpoints - The fully qualified domain names for this private path service gateway.
   * Any uppercase letters will be converted to lowercase.
   * @param {string} [params.defaultAccessPolicy] - The policy to use for bindings from accounts without an explicit
   * account policy.
   * @param {string} [params.name] - The name for this private path service gateway. The name must not be used by
   * another private path service gateway in the VPC. If unspecified, the name will be a hyphenated list of
   * randomly-selected words.
   * @param {ResourceGroupIdentity} [params.resourceGroup] - The resource group to use. If unspecified, the account's
   * [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   * @param {boolean} [params.zonalAffinity] - Indicates whether this private path service gateway has zonal affinity.
   * - `true`:  Traffic to the service from a zone the service resides in will remain in
   *            that zone.
   * - `false`: Traffic to the service from a zone will be load balanced across all zones
   *            in the region the service resides in.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PrivatePathServiceGateway>>}
   */
  public createPrivatePathServiceGateway(
    params: VpcV1.CreatePrivatePathServiceGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PrivatePathServiceGateway>> {
    const _params = { ...params };
    const _requiredParams = ['loadBalancer', 'serviceEndpoints'];
    const _validParams = ['loadBalancer', 'serviceEndpoints', 'defaultAccessPolicy', 'name', 'resourceGroup', 'zonalAffinity', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'load_balancer': _params.loadBalancer,
      'service_endpoints': _params.serviceEndpoints,
      'default_access_policy': _params.defaultAccessPolicy,
      'name': _params.name,
      'resource_group': _params.resourceGroup,
      'zonal_affinity': _params.zonalAffinity,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createPrivatePathServiceGateway');

    const parameters = {
      options: {
        url: '/private_path_service_gateways',
        method: 'POST',
        body,
        qs: query,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a private path service gateway.
   *
   * This request deletes a private path service gateway.  For this request to succeed, the value of
   * `endpoint_gateway_count` must be `0`. This operation cannot be reversed.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The private path service gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deletePrivatePathServiceGateway(
    params: VpcV1.DeletePrivatePathServiceGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deletePrivatePathServiceGateway');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve a private path service gateway.
   *
   * This request retrieves the private path service gateway specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The private path service gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PrivatePathServiceGateway>>}
   */
  public getPrivatePathServiceGateway(
    params: VpcV1.GetPrivatePathServiceGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PrivatePathServiceGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getPrivatePathServiceGateway');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update a private path service gateway.
   *
   * This request updates a private path service gateway with the information provided in a private path service gateway
   * patch object. The private path service gateway patch object is structured in the same way as a retrieved private
   * path service gateway and contains only the information to be updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.id - The private path service gateway identifier.
   * @param {string} [params.defaultAccessPolicy] - The policy to use for bindings from accounts without an explicit
   * account policy.
   * @param {LoadBalancerIdentity} [params.loadBalancer] - The load balancer for this private path service gateway. The
   * load balancer must
   * have `is_private_path` set to `true`, and must be in the same VPC as the private
   * path service gateway.
   * @param {string} [params.name] - The name for this private path service gateway. The name must not be used by
   * another private path service gateway in the VPC.
   * @param {boolean} [params.zonalAffinity] - Updating the value of `zonal_affinity` changes how traffic for existing
   * and future endpoint gateway bindings will be routed:
   * - `true`:  Traffic to the service from a zone the service resides in will remain in
   *            that zone.
   * - `false`: Traffic to the service from a zone will be load balanced across all zones
   *            in the region the service resides in.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PrivatePathServiceGateway>>}
   */
  public updatePrivatePathServiceGateway(
    params: VpcV1.UpdatePrivatePathServiceGatewayParams
  ): Promise<VpcV1.Response<VpcV1.PrivatePathServiceGateway>> {
    const _params = { ...params };
    const _requiredParams = ['id'];
    const _validParams = ['id', 'defaultAccessPolicy', 'loadBalancer', 'name', 'zonalAffinity', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'default_access_policy': _params.defaultAccessPolicy,
      'load_balancer': _params.loadBalancer,
      'name': _params.name,
      'zonal_affinity': _params.zonalAffinity,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updatePrivatePathServiceGateway');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List account policies for a private path service gateway.
   *
   * This request lists account policies for a private path service gateway. Each policy defines how requests to use the
   * private path service gateway from that account will be handled.
   *
   * The account policies will be sorted by their `created_at` property values, with newest account policies first.
   * Account policies with identical `created_at` property values will in turn be sorted by ascending `id` property
   * values.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.accountId] - Filters the collection to resources with an `account.id` property matching the
   * specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayAccountPolicyCollection>>}
   */
  public listPrivatePathServiceGatewayAccountPolicies(
    params: VpcV1.ListPrivatePathServiceGatewayAccountPoliciesParams
  ): Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayAccountPolicyCollection>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId'];
    const _validParams = ['privatePathServiceGatewayId', 'start', 'limit', 'accountId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'account.id': _params.accountId,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listPrivatePathServiceGatewayAccountPolicies');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/account_policies',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create an account policy for a private path service gateway.
   *
   * This request creates an account policy from an account policy prototype object. The prototype object is structured
   * in the same way as a retrieved account policy, and contains the information necessary to create the new account
   * policy.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {string} params.accessPolicy - The access policy for the account. Updating the access policy only affects
   * pending and future endpoint gateway bindings.
   * - permit: access will be permitted
   * - deny: access will be denied
   * - review: access will be manually reviewed
   *
   * - Updating to `review` sets the status of future endpoint gateway bindings from
   *    this account to `pending`.
   * - Updating to `permit` updates both the status of any `pending` and future endpoint
   *   gateway bindings from this account to `permitted`.
   * - Updating to `deny` updates both the status of any `pending` and future endpoint
   *   gateway bindings from this account to `denied`.
   * @param {AccountIdentity} params.account - The account for this access policy. The account must be unique across all
   * account
   * policies for this private path service gateway.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayAccountPolicy>>}
   */
  public createPrivatePathServiceGatewayAccountPolicy(
    params: VpcV1.CreatePrivatePathServiceGatewayAccountPolicyParams
  ): Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayAccountPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId', 'accessPolicy', 'account'];
    const _validParams = ['privatePathServiceGatewayId', 'accessPolicy', 'account', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'access_policy': _params.accessPolicy,
      'account': _params.account,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'createPrivatePathServiceGatewayAccountPolicy');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/account_policies',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete an account policy for a private path service gateway.
   *
   * This request deletes an account policy. This operation cannot be reversed and it does not affect the `status` of
   * any existing endpoint gateway bindings.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {string} params.id - The account policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public deletePrivatePathServiceGatewayAccountPolicy(
    params: VpcV1.DeletePrivatePathServiceGatewayAccountPolicyParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId', 'id'];
    const _validParams = ['privatePathServiceGatewayId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'deletePrivatePathServiceGatewayAccountPolicy');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/account_policies/{id}',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an account policy for a private path service gateway.
   *
   * This request retrieves a single account policy specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {string} params.id - The account policy identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayAccountPolicy>>}
   */
  public getPrivatePathServiceGatewayAccountPolicy(
    params: VpcV1.GetPrivatePathServiceGatewayAccountPolicyParams
  ): Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayAccountPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId', 'id'];
    const _validParams = ['privatePathServiceGatewayId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getPrivatePathServiceGatewayAccountPolicy');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/account_policies/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an account policy for a private path service gateway.
   *
   * This request updates an account policy with the information in a provided account policy patch. The account policy
   * patch object is structured in the same way as a retrieved account policy and contains only the information to be
   * updated.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {string} params.id - The account policy identifier.
   * @param {string} [params.accessPolicy] - The access policy for the account. Updating the access policy only affects
   * pending and future endpoint gateway bindings.
   * - permit: access will be permitted
   * - deny: access will be denied
   * - review: access will be manually reviewed
   *
   * - Updating to `review` sets the status of future endpoint gateway bindings from
   *    this account to `pending`.
   * - Updating to `permit` updates both the status of any `pending` and future endpoint
   *   gateway bindings from this account to `permitted`.
   * - Updating to `deny` updates both the status of any `pending` and future endpoint
   *   gateway bindings from this account to `denied`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayAccountPolicy>>}
   */
  public updatePrivatePathServiceGatewayAccountPolicy(
    params: VpcV1.UpdatePrivatePathServiceGatewayAccountPolicyParams
  ): Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayAccountPolicy>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId', 'id'];
    const _validParams = ['privatePathServiceGatewayId', 'id', 'accessPolicy', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'access_policy': _params.accessPolicy,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'updatePrivatePathServiceGatewayAccountPolicy');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/account_policies/{id}',
        method: 'PATCH',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/merge-patch+json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List endpoint gateway bindings for a private path service gateway.
   *
   * This request lists endpoint gateway bindings for a private path service gateway. Each endpoint gateway binding is
   * implicitly created when an endpoint gateway is created targeting the private path service gateway. The associated
   * account policy is applied to all new endpoint gateway bindings. If an associated account policy doesn't exist, the
   * private path service gateway's `default_access_policy` is used.
   *
   * The endpoint gateway bindings will be sorted by their `created_at` property values, with newest endpoint gateway
   * bindings first. Endpoint gateway bindings with identical
   * `created_at` property values will in turn be sorted by ascending `name` property values.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {string} [params.start] - A server-provided token determining what resource to start the page on.
   * @param {number} [params.limit] - The number of resources to return on a page.
   * @param {string} [params.status] - Filters the collection to endpoint gateway bindings with a `status` property
   * matching the specified value.
   * @param {string} [params.accountId] - Filters the collection to resources with an `account.id` property matching the
   * specified identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayEndpointGatewayBindingCollection>>}
   */
  public listPrivatePathServiceGatewayEndpointGatewayBindings(
    params: VpcV1.ListPrivatePathServiceGatewayEndpointGatewayBindingsParams
  ): Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayEndpointGatewayBindingCollection>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId'];
    const _validParams = ['privatePathServiceGatewayId', 'start', 'limit', 'status', 'accountId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
      'start': _params.start,
      'limit': _params.limit,
      'status': _params.status,
      'account.id': _params.accountId,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'listPrivatePathServiceGatewayEndpointGatewayBindings');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/endpoint_gateway_bindings',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Retrieve an endpoint gateway binding for a private path service gateway.
   *
   * This request retrieves a single endpoint gateway binding specified by the identifier in the URL.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {string} params.id - The endpoint gateway binding identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayEndpointGatewayBinding>>}
   */
  public getPrivatePathServiceGatewayEndpointGatewayBinding(
    params: VpcV1.GetPrivatePathServiceGatewayEndpointGatewayBindingParams
  ): Promise<VpcV1.Response<VpcV1.PrivatePathServiceGatewayEndpointGatewayBinding>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId', 'id'];
    const _validParams = ['privatePathServiceGatewayId', 'id', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'getPrivatePathServiceGatewayEndpointGatewayBinding');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/endpoint_gateway_bindings/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Deny an endpoint gateway binding for a private path service gateway.
   *
   * This request denies a `pending` endpoint gateway request, and optionally sets the policy to deny future requests
   * from the same account.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {string} params.id - The endpoint gateway binding identifier.
   * @param {boolean} [params.setAccountPolicy] - Indicates whether this will become the access policy for any `pending`
   * and future endpoint gateway bindings from the same account.
   *
   * If set to `true`:
   * - If the account has an existing access policy, that policy will be updated to `deny`.
   *   Otherwise, a new `deny` access policy will be created for the account.
   * - All `pending` endpoint gateway bindings for the account will be denied.
   *
   * If set to `false`:
   * - No access policies will be created or updated
   * - All `pending` endpoint gateway bindings for the account will remain `pending`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public denyPrivatePathServiceGatewayEndpointGatewayBinding(
    params: VpcV1.DenyPrivatePathServiceGatewayEndpointGatewayBindingParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId', 'id'];
    const _validParams = ['privatePathServiceGatewayId', 'id', 'setAccountPolicy', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'set_account_policy': _params.setAccountPolicy,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'denyPrivatePathServiceGatewayEndpointGatewayBinding');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/endpoint_gateway_bindings/{id}/deny',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Permit an endpoint gateway binding for a private path service gateway.
   *
   * This request permits a `pending` endpoint gateway request, and optionally sets the policy to permit future requests
   * from the same account.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {string} params.id - The endpoint gateway binding identifier.
   * @param {boolean} [params.setAccountPolicy] - Indicates whether this will become the access policy for any `pending`
   * and future endpoint gateway bindings from the same account.
   *
   * If set to `true`:
   *
   * - If the account has an existing access policy, that policy will be updated to
   *   `permit`. Otherwise, a new `permit` access policy will be created for the account.
   * - All `pending` endpoint gateway bindings for the account will be permitted.
   *
   * If set to `false`:
   *
   * - No access policies will be created or updated
   * - All `pending` endpoint gateway bindings for the account will remain `pending`.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public permitPrivatePathServiceGatewayEndpointGatewayBinding(
    params: VpcV1.PermitPrivatePathServiceGatewayEndpointGatewayBindingParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId', 'id'];
    const _validParams = ['privatePathServiceGatewayId', 'id', 'setAccountPolicy', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'set_account_policy': _params.setAccountPolicy,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'permitPrivatePathServiceGatewayEndpointGatewayBinding');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/endpoint_gateway_bindings/{id}/permit',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Publish a private path service gateway.
   *
   * This request publishes a private path service gateway, allowing any account to request access to it.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public publishPrivatePathServiceGateway(
    params: VpcV1.PublishPrivatePathServiceGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId'];
    const _validParams = ['privatePathServiceGatewayId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'publishPrivatePathServiceGateway');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/publish',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Revoke access to a private path service gateway for an account.
   *
   * This request revokes a consumer account. This operation cannot be reversed. The `status` of all endpoint gateway
   * bindings associated with the specified private path service gateway become `denied`. If the specified account has
   * an existing access policy, that policy will be updated to `denied`. Otherwise, a new `deny` access policy will be
   * created for the account.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {AccountIdentity} params.account - The account that will be revoked access to the private path service
   * gateway.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public revokeAccountForPrivatePathServiceGateway(
    params: VpcV1.RevokeAccountForPrivatePathServiceGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId', 'account'];
    const _validParams = ['privatePathServiceGatewayId', 'account', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'account': _params.account,
    };

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'revokeAccountForPrivatePathServiceGateway');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/revoke_account',
        method: 'POST',
        body,
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Unpublish a private path service gateway.
   *
   * This request unpublishes a private path service gateway. For this request to succeed, any existing access from
   * other accounts must first be revoked. Once unpublished, access will again be restricted to the account that created
   * this private path service gateway.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.privatePathServiceGatewayId - The private path service gateway identifier.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<VpcV1.Response<VpcV1.EmptyObject>>}
   */
  public unpublishPrivatePathServiceGateway(
    params: VpcV1.UnpublishPrivatePathServiceGatewayParams
  ): Promise<VpcV1.Response<VpcV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['privatePathServiceGatewayId'];
    const _validParams = ['privatePathServiceGatewayId', 'signal', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'version': this.version,
      'generation': this.generation,
    };

    const path = {
      'private_path_service_gateway_id': _params.privatePathServiceGatewayId,
    };

    const sdkHeaders = getSdkHeaders(VpcV1.DEFAULT_SERVICE_NAME, 'v1', 'unpublishPrivatePathServiceGateway');

    const parameters = {
      options: {
        url: '/private_path_service_gateways/{private_path_service_gateway_id}/unpublish',
        method: 'POST',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          this.baseOptions.headers,
          {
          },
          _params.headers
        ),
        axiosOptions: {
          signal: _params.signal,
        },
      }),
    };

    return this.createRequest(parameters);
  }
}

/*************************
 * interfaces
 ************************/

namespace VpcV1 {
  /** Options for the `VpcV1` constructor. */
  export interface Options extends UserOptions {
    /** The infrastructure generation. For the API behavior documented here, specify `2`. */
    generation?: number;
    /** The API version, in format `YYYY-MM-DD`. For the API behavior documented here, specify any date between
     *  `2025-04-08` and `2025-04-23`.
     */
    version: string;
  }

  /** An operation response. */
  export interface Response<T = any> {
    result: T;
    status: number;
    statusText: string;
    headers: IncomingHttpHeaders;
  }

  /** The callback for a service request. */
  export type Callback<T> = (error: any, response?: Response<T>) => void;

  /** The body of a service request that returns no response data. */
  export interface EmptyObject {}

  /** A standard JS object, defined to avoid the limitations of `Object` and `object` */
  export interface JsonObject {
    [key: string]: any;
  }

  /*************************
   * request interfaces
   ************************/

   interface DefaultParams {
     headers?: OutgoingHttpHeaders;
     signal?: AbortSignal;
   }

  /** Parameters for the `listVpcs` operation. */
  export interface ListVpcsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to VPCs with a `classic_access` property matching the specified value. */
    classicAccess?: boolean;
  }

  /** Parameters for the `createVpc` operation. */
  export interface CreateVpcParams extends DefaultParams {
    /** Indicates whether a [default address
     *  prefix](https://cloud.ibm.com/docs/vpc?topic=vpc-configuring-address-prefixes) will be automatically created for
     *  each zone in this VPC. If `manual`, this VPC will be created with no default address prefixes.
     *
     *  Since address prefixes are managed identically regardless of whether they were automatically created, the value
     *  is not preserved as a VPC property.
     */
    addressPrefixManagement?: CreateVpcConstants.AddressPrefixManagement | string;
    /** Deprecated: Indicates whether this VPC will be connected to Classic Infrastructure. If true, this VPC's
     *  resources will have private network connectivity to the account's Classic Infrastructure resources. Only one
     *  VPC, per region, may be connected in this way. This value is set at creation and subsequently immutable.
     *
     *  This property has been deprecated. Instead, use a [Transit Gateway](https://cloud.ibm.com/docs/transit-gateway)
     *  to connect this VPC to Classic Infrastructure. For more information, see [upcoming
     *  changes](https://cloud.ibm.com/docs/vpc?topic=vpc-api-change-log#upcoming-changes).
     */
    classicAccess?: boolean;
    /** The DNS configuration for this VPC.
     *
     *  If unspecified, the system will assign DNS servers capable of resolving hosts and endpoint
     *  gateways within this VPC, and hosts on the internet.
     */
    dns?: VPCDNSPrototype;
    /** The name for this VPC. The name must not be used by another VPC in the region. If unspecified, the name will
     *  be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
  }

  /** Constants for the `createVpc` operation. */
  export namespace CreateVpcConstants {
    /** Indicates whether a [default address prefix](https://cloud.ibm.com/docs/vpc?topic=vpc-configuring-address-prefixes) will be automatically created for each zone in this VPC. If `manual`, this VPC will be created with no default address prefixes. Since address prefixes are managed identically regardless of whether they were automatically created, the value is not preserved as a VPC property. */
    export enum AddressPrefixManagement {
      AUTO = 'auto',
      MANUAL = 'manual',
    }
  }

  /** Parameters for the `deleteVpc` operation. */
  export interface DeleteVpcParams extends DefaultParams {
    /** The VPC identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getVpc` operation. */
  export interface GetVpcParams extends DefaultParams {
    /** The VPC identifier. */
    id: string;
  }

  /** Parameters for the `updateVpc` operation. */
  export interface UpdateVpcParams extends DefaultParams {
    /** The VPC identifier. */
    id: string;
    /** The DNS configuration for this VPC. */
    dns?: VPCDNSPatch;
    /** The name for this VPC. The name must not be used by another VPC in the region. */
    name?: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getVpcDefaultNetworkAcl` operation. */
  export interface GetVpcDefaultNetworkAclParams extends DefaultParams {
    /** The VPC identifier. */
    id: string;
  }

  /** Parameters for the `getVpcDefaultRoutingTable` operation. */
  export interface GetVpcDefaultRoutingTableParams extends DefaultParams {
    /** The VPC identifier. */
    id: string;
  }

  /** Parameters for the `getVpcDefaultSecurityGroup` operation. */
  export interface GetVpcDefaultSecurityGroupParams extends DefaultParams {
    /** The VPC identifier. */
    id: string;
  }

  /** Parameters for the `listVpcAddressPrefixes` operation. */
  export interface ListVpcAddressPrefixesParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createVpcAddressPrefix` operation. */
  export interface CreateVpcAddressPrefixParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The IPv4 range of the address prefix, expressed in CIDR format. The range must not overlap with any existing
     *  address prefixes in the VPC or any of the following reserved address ranges:
     *
     *    - `127.0.0.0/8` (IPv4 loopback addresses)
     *    - `161.26.0.0/16` (IBM services)
     *    - `166.8.0.0/14` (Cloud Service Endpoints)
     *    - `169.254.0.0/16` (IPv4 link-local addresses)
     *    - `224.0.0.0/4` (IPv4 multicast addresses)
     *
     *  The prefix length of the address prefix's CIDR must be between `/9` (8,388,608 addresses) and `/29` (8
     *  addresses).
     */
    cidr: string;
    /** The zone this address prefix will reside in. */
    zone: ZoneIdentity;
    /** Indicates whether this will be the default address prefix for this zone in this VPC. If `true`, the VPC must
     *  not have a default address prefix for this zone.
     */
    isDefault?: boolean;
    /** The name for this address prefix. The name must not be used by another address prefix for the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /** Parameters for the `deleteVpcAddressPrefix` operation. */
  export interface DeleteVpcAddressPrefixParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The prefix identifier. */
    id: string;
  }

  /** Parameters for the `getVpcAddressPrefix` operation. */
  export interface GetVpcAddressPrefixParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The prefix identifier. */
    id: string;
  }

  /** Parameters for the `updateVpcAddressPrefix` operation. */
  export interface UpdateVpcAddressPrefixParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The prefix identifier. */
    id: string;
    /** Indicates whether this is the default prefix for this zone in this VPC. Updating to true makes this prefix
     *  the default prefix for this zone in this VPC, provided the VPC currently has no default address prefix for this
     *  zone. Updating to false removes the default prefix for this zone in this VPC.
     */
    isDefault?: boolean;
    /** The name for this address prefix. The name must not be used by another address prefix for the VPC. */
    name?: string;
  }

  /** Parameters for the `listVpcDnsResolutionBindings` operation. */
  export interface ListVpcDnsResolutionBindingsParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListVpcDnsResolutionBindingsConstants.Sort | string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to resources with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to resources with a `vpc.name` property matching the exact specified name. */
    vpcName?: string;
    /** Filters the collection to resources with a `vpc.remote.account.id` property matching the specified account
     *  identifier.
     */
    accountId?: string;
  }

  /** Constants for the `listVpcDnsResolutionBindings` operation. */
  export namespace ListVpcDnsResolutionBindingsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createVpcDnsResolutionBinding` operation. */
  export interface CreateVpcDnsResolutionBindingParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** Another VPC to bind this VPC to for DNS resolution. The VPC must have
     *  `dns.enable_hub` set to `true`, and may be in a different account (subject to
     *  IAM policies).
     *
     *  Additionally, the VPC specified in the URL (this VPC) must have `dns.enable_hub`
     *  set to `false` and a `dns.resolution_binding_count` of zero.
     */
    vpc: VPCIdentity;
    /** The name for this DNS resolution binding. The name must not be used by another DNS resolution binding for
     *  the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /** Parameters for the `deleteVpcDnsResolutionBinding` operation. */
  export interface DeleteVpcDnsResolutionBindingParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The DNS resolution binding identifier. */
    id: string;
  }

  /** Parameters for the `getVpcDnsResolutionBinding` operation. */
  export interface GetVpcDnsResolutionBindingParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The DNS resolution binding identifier. */
    id: string;
  }

  /** Parameters for the `updateVpcDnsResolutionBinding` operation. */
  export interface UpdateVpcDnsResolutionBindingParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The DNS resolution binding identifier. */
    id: string;
    /** The name for this DNS resolution binding. The name must not be used by another DNS resolution binding for
     *  the VPC.
     */
    name?: string;
  }

  /** Parameters for the `listVpcRoutes` operation. */
  export interface ListVpcRoutesParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** Filters the collection to resources with a `zone.name` property matching the exact specified name. */
    zoneName?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createVpcRoute` operation. */
  export interface CreateVpcRouteParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The destination CIDR of the route. The host identifier in the CIDR must be zero.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and
     *  `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
     */
    destination: string;
    /** The zone to apply the route to.
     *
     *  If subnets are attached to the route's routing table, egress traffic from those
     *  subnets in this zone will be subject to this route. If this route's routing table
     *  has any of `route_direct_link_ingress`, `route_internet_ingress`,
     *  `route_transit_gateway_ingress` or `route_vpc_zone_ingress`  set to`true`, traffic
     *  from those ingress sources arriving in this zone will be subject to this route.
     */
    zone: ZoneIdentity;
    /** The action to perform with a packet matching the route:
     *  - `delegate`: delegate to system-provided routes
     *  - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
     *  - `deliver`: deliver the packet to the specified `next_hop`
     *  - `drop`: drop the packet.
     */
    action?: CreateVpcRouteConstants.Action | string;
    /** Indicates whether this route will be advertised to the ingress sources specified by the
     *  `advertise_routes_to` routing table property.
     *
     *  All routes in a routing table with the same `destination` and `zone` must have the same
     *  `advertise` value.
     */
    advertise?: boolean;
    /** The name for this route. The name must not be used by another route in the routing table. Names starting
     *  with `ibm-` are reserved for system-provided routes, and are not allowed. If unspecified, the name will be a
     *  hyphenated list of randomly-selected words.
     */
    name?: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to (must not be
     *  `0.0.0.0`). For other `action` values, it must be omitted or specified as `0.0.0.0`.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and `priority`,
     *  and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
     */
    nextHop?: RouteNextHopPrototype;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority?: number;
  }

  /** Constants for the `createVpcRoute` operation. */
  export namespace CreateVpcRouteConstants {
    /** The action to perform with a packet matching the route: - `delegate`: delegate to system-provided routes - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes - `deliver`: deliver the packet to the specified `next_hop` - `drop`: drop the packet. */
    export enum Action {
      DELEGATE = 'delegate',
      DELEGATE_VPC = 'delegate_vpc',
      DELIVER = 'deliver',
      DROP = 'drop',
    }
  }

  /** Parameters for the `deleteVpcRoute` operation. */
  export interface DeleteVpcRouteParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The route identifier. */
    id: string;
  }

  /** Parameters for the `getVpcRoute` operation. */
  export interface GetVpcRouteParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The route identifier. */
    id: string;
  }

  /** Parameters for the `updateVpcRoute` operation. */
  export interface UpdateVpcRouteParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The route identifier. */
    id: string;
    /** Indicates whether this route will be advertised to the ingress sources specified by the
     *  `advertise_routes_to` routing table property.
     *
     *  Since all routes in a routing table with the same `destination` and `zone` must have the same `advertise` value,
     *  this property can only be changed for routes with a unique
     *  `destination` and `zone` in the routing table. For more information, see [Advertising
     *  routes](https://cloud.ibm.com/docs/vpc?topic=vpc-about-custom-routes#rt-advertising-routes).
     */
    advertise?: boolean;
    /** The name for this route. The name must not be used by another route in the routing table. Names starting
     *  with `ibm-` are reserved for system-provided routes, and are not allowed.
     */
    name?: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to (must not be
     *  `0.0.0.0`). For other `action` values, specify `0.0.0.0` or remove it by specifying
     *  `null`.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and `priority`,
     *  and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
     */
    nextHop?: RouteNextHopPatch;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority?: number;
  }

  /** Parameters for the `listVpcRoutingTables` operation. */
  export interface ListVpcRoutingTablesParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to routing tables with an `is_default` property matching the specified value. */
    isDefault?: boolean;
  }

  /** Parameters for the `createVpcRoutingTable` operation. */
  export interface CreateVpcRoutingTableParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The filters specifying the resources that may create routes in this routing table.
     *
     *  If specified, `resource_type` must be `vpn_gateway` or `vpn_server`.
     */
    acceptRoutesFrom?: ResourceFilter[];
    /** The ingress sources to advertise routes to. Routes in the table with `advertise` enabled will be advertised
     *  to these sources.
     */
    advertiseRoutesTo?: CreateVpcRoutingTableConstants.AdvertiseRoutesTo[] | string[];
    /** The name for this routing table. The name must not be used by another routing table in the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** If set to `true`, this routing table will be used to route traffic that originates from [Direct
     *  Link](https://cloud.ibm.com/docs/dl) to this VPC. The VPC must not already have a routing table with this
     *  property set to `true`.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     *
     *  If [Classic Access](https://cloud.ibm.com/docs/vpc?topic=vpc-setting-up-access-to-classic-infrastructure) is
     *  enabled for this VPC, and this property is set to `true`, its incoming traffic will also be routed according to
     *  this routing table.
     */
    routeDirectLinkIngress?: boolean;
    /** If set to `true`, this routing table will be used to route traffic that originates from the internet. For
     *  this to succeed, the VPC must not already have a routing table with this property set to `true`.
     *
     *  Incoming traffic will be routed according to the routing table with two exceptions:
     *  - Traffic destined for IP addresses associated with public gateways will not be
     *    subject to routes in this routing table.
     *  - Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is
     *    an IP address in a subnet in the route's `zone` that is able to accept traffic.
     *    Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *    connection, the packet will be dropped.
     */
    routeInternetIngress?: boolean;
    /** If set to `true`, this routing table will be used to route traffic that originates from [Transit
     *  Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC. The VPC must not already have a routing table
     *  with this property set to `true`.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     */
    routeTransitGatewayIngress?: boolean;
    /** If set to `true`, this routing table will be used to route traffic that originates from subnets in other
     *  zones in this VPC. The VPC must not already have a routing table with this property set to `true`.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     */
    routeVpcZoneIngress?: boolean;
    /** The prototype objects for routes to create for this routing table. If unspecified, the routing table will be
     *  created with no routes.
     */
    routes?: RoutePrototype[];
  }

  /** Constants for the `createVpcRoutingTable` operation. */
  export namespace CreateVpcRoutingTableConstants {
    /** An ingress source that routes can be advertised to: - `direct_link` (requires `route_direct_link_ingress` be set to `true`) - `transit_gateway` (requires `route_transit_gateway_ingress` be set to `true`). */
    export enum AdvertiseRoutesTo {
      DIRECT_LINK = 'direct_link',
      TRANSIT_GATEWAY = 'transit_gateway',
    }
  }

  /** Parameters for the `deleteVpcRoutingTable` operation. */
  export interface DeleteVpcRoutingTableParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getVpcRoutingTable` operation. */
  export interface GetVpcRoutingTableParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    id: string;
  }

  /** Parameters for the `updateVpcRoutingTable` operation. */
  export interface UpdateVpcRoutingTableParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    id: string;
    /** The filters specifying the resources that may create routes in this routing table
     *  (replacing any existing filters). All routes created by resources that match a given filter will be removed when
     *  an existing filter is removed. Therefore, if an empty array is specified, all filters will be removed, resulting
     *  in all routes not directly created by the user being removed.
     *
     *  If specified, `resource_type` must be `vpn_gateway` or `vpn_server`.
     */
    acceptRoutesFrom?: ResourceFilter[];
    /** The ingress sources to advertise routes to, replacing any existing sources to advertise to. Routes in the
     *  table with `advertise` enabled will be advertised to these sources.
     */
    advertiseRoutesTo?: UpdateVpcRoutingTableConstants.AdvertiseRoutesTo[] | string[];
    /** The name for this routing table. The name must not be used by another routing table in the VPC. */
    name?: string;
    /** Indicates whether this routing table is used to route traffic that originates from
     *  [Direct Link](https://cloud.ibm.com/docs/dl/) to this VPC. Updating to `true` selects this routing table,
     *  provided no other routing table in the VPC already has this property set to `true`, and no subnets are attached
     *  to this routing table. Updating to
     *  `false` deselects this routing table, provided `direct_link` is absent from
     *  `advertise_routes_to`.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     */
    routeDirectLinkIngress?: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from the internet.  Updating
     *  to `true` selects this routing table, provided no other routing table in the VPC already has this property set
     *  to `true`.  Updating to `false` deselects this routing table.
     *
     *  Incoming traffic will be routed according to the routing table with two exceptions:
     *  -  Traffic destined for IP addresses associated with public gateways will not be subject
     *     to routes in this routing table.
     *  -  Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is an
     *     IP address in a subnet in the route's `zone` that is able to accept traffic.
     *     Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *     connection, the packet will be dropped.
     */
    routeInternetIngress?: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from
     *  [Transit Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC. Updating to
     *  `true` selects this routing table, provided no other routing table in the VPC already has this property set to
     *  `true`, and no subnets are attached to this routing table. Updating to `false` deselects this routing table,
     *  provided `transit_gateway` is absent from `advertise_routes_to`.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     *
     *  If [Classic Access](https://cloud.ibm.com/docs/vpc?topic=vpc-setting-up-access-to-classic-infrastructure) is
     *  enabled for this VPC, and this property is set to `true`, its incoming traffic will also be routed according to
     *  this routing table.
     */
    routeTransitGatewayIngress?: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from subnets in other zones in
     *  this VPC. Updating to `true` selects this routing table, provided no other routing table in the VPC already has
     *  this property set to `true`, and no subnets are attached to this routing table. Updating to `false` deselects
     *  this routing table.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     */
    routeVpcZoneIngress?: boolean;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Constants for the `updateVpcRoutingTable` operation. */
  export namespace UpdateVpcRoutingTableConstants {
    /** An ingress source that routes can be advertised to: - `direct_link` (requires `route_direct_link_ingress` be set to `true`) - `transit_gateway` (requires `route_transit_gateway_ingress` be set to `true`). */
    export enum AdvertiseRoutesTo {
      DIRECT_LINK = 'direct_link',
      TRANSIT_GATEWAY = 'transit_gateway',
    }
  }

  /** Parameters for the `listVpcRoutingTableRoutes` operation. */
  export interface ListVpcRoutingTableRoutesParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    routingTableId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createVpcRoutingTableRoute` operation. */
  export interface CreateVpcRoutingTableRouteParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    routingTableId: string;
    /** The destination CIDR of the route. The host identifier in the CIDR must be zero.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and
     *  `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
     */
    destination: string;
    /** The zone to apply the route to.
     *
     *  If subnets are attached to the route's routing table, egress traffic from those
     *  subnets in this zone will be subject to this route. If this route's routing table
     *  has any of `route_direct_link_ingress`, `route_internet_ingress`,
     *  `route_transit_gateway_ingress` or `route_vpc_zone_ingress`  set to`true`, traffic
     *  from those ingress sources arriving in this zone will be subject to this route.
     */
    zone: ZoneIdentity;
    /** The action to perform with a packet matching the route:
     *  - `delegate`: delegate to system-provided routes
     *  - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
     *  - `deliver`: deliver the packet to the specified `next_hop`
     *  - `drop`: drop the packet.
     */
    action?: CreateVpcRoutingTableRouteConstants.Action | string;
    /** Indicates whether this route will be advertised to the ingress sources specified by the
     *  `advertise_routes_to` routing table property.
     *
     *  All routes in a routing table with the same `destination` and `zone` must have the same
     *  `advertise` value.
     */
    advertise?: boolean;
    /** The name for this route. The name must not be used by another route in the routing table. Names starting
     *  with `ibm-` are reserved for system-provided routes, and are not allowed. If unspecified, the name will be a
     *  hyphenated list of randomly-selected words.
     */
    name?: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to (must not be
     *  `0.0.0.0`). For other `action` values, it must be omitted or specified as `0.0.0.0`.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and `priority`,
     *  and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
     */
    nextHop?: RouteNextHopPrototype;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority?: number;
  }

  /** Constants for the `createVpcRoutingTableRoute` operation. */
  export namespace CreateVpcRoutingTableRouteConstants {
    /** The action to perform with a packet matching the route: - `delegate`: delegate to system-provided routes - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes - `deliver`: deliver the packet to the specified `next_hop` - `drop`: drop the packet. */
    export enum Action {
      DELEGATE = 'delegate',
      DELEGATE_VPC = 'delegate_vpc',
      DELIVER = 'deliver',
      DROP = 'drop',
    }
  }

  /** Parameters for the `deleteVpcRoutingTableRoute` operation. */
  export interface DeleteVpcRoutingTableRouteParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    routingTableId: string;
    /** The VPC routing table route identifier. */
    id: string;
  }

  /** Parameters for the `getVpcRoutingTableRoute` operation. */
  export interface GetVpcRoutingTableRouteParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    routingTableId: string;
    /** The VPC routing table route identifier. */
    id: string;
  }

  /** Parameters for the `updateVpcRoutingTableRoute` operation. */
  export interface UpdateVpcRoutingTableRouteParams extends DefaultParams {
    /** The VPC identifier. */
    vpcId: string;
    /** The routing table identifier. */
    routingTableId: string;
    /** The VPC routing table route identifier. */
    id: string;
    /** Indicates whether this route will be advertised to the ingress sources specified by the
     *  `advertise_routes_to` routing table property.
     *
     *  Since all routes in a routing table with the same `destination` and `zone` must have the same `advertise` value,
     *  this property can only be changed for routes with a unique
     *  `destination` and `zone` in the routing table. For more information, see [Advertising
     *  routes](https://cloud.ibm.com/docs/vpc?topic=vpc-about-custom-routes#rt-advertising-routes).
     */
    advertise?: boolean;
    /** The name for this route. The name must not be used by another route in the routing table. Names starting
     *  with `ibm-` are reserved for system-provided routes, and are not allowed.
     */
    name?: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to (must not be
     *  `0.0.0.0`). For other `action` values, specify `0.0.0.0` or remove it by specifying
     *  `null`.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and `priority`,
     *  and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
     */
    nextHop?: RouteNextHopPatch;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority?: number;
  }

  /** Parameters for the `listSubnets` operation. */
  export interface ListSubnetsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `zone.name` property matching the exact specified name. */
    zoneName?: string;
    /** Filters the collection to resources with a `vpc.id` property matching the specified identifier. */
    vpcId?: string;
    /** Filters the collection to resources with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to resources with a `vpc.name` property matching the exact specified name. */
    vpcName?: string;
    /** Filters the collection to subnets with a `routing_table.id` property matching the specified identifier. */
    routingTableId?: string;
    /** Filters the collection to subnets with a `routing_table.name` property matching the exact specified name. */
    routingTableName?: string;
  }

  /** Parameters for the `createSubnet` operation. */
  export interface CreateSubnetParams extends DefaultParams {
    /** The subnet prototype object. */
    subnetPrototype: SubnetPrototype;
  }

  /** Parameters for the `deleteSubnet` operation. */
  export interface DeleteSubnetParams extends DefaultParams {
    /** The subnet identifier. */
    id: string;
  }

  /** Parameters for the `getSubnet` operation. */
  export interface GetSubnetParams extends DefaultParams {
    /** The subnet identifier. */
    id: string;
  }

  /** Parameters for the `updateSubnet` operation. */
  export interface UpdateSubnetParams extends DefaultParams {
    /** The subnet identifier. */
    id: string;
    /** The name for this subnet. The name must not be used by another subnet in the VPC. */
    name?: string;
    /** The network ACL to use for this subnet. */
    networkAcl?: NetworkACLIdentity;
    /** The public gateway to use for internet-bound traffic for this subnet. */
    publicGateway?: SubnetPublicGatewayPatch;
    /** The routing table to use for this subnet.  The routing table properties
     *  `route_direct_link_ingress`, `route_internet_ingress`,
     *  `route_transit_gateway_ingress`, and `route_vpc_zone_ingress` must be `false`.
     */
    routingTable?: RoutingTableIdentity;
  }

  /** Parameters for the `getSubnetNetworkAcl` operation. */
  export interface GetSubnetNetworkAclParams extends DefaultParams {
    /** The subnet identifier. */
    id: string;
  }

  /** Parameters for the `replaceSubnetNetworkAcl` operation. */
  export interface ReplaceSubnetNetworkAclParams extends DefaultParams {
    /** The subnet identifier. */
    id: string;
    /** The network ACL identity. */
    networkAclIdentity: NetworkACLIdentity;
  }

  /** Parameters for the `unsetSubnetPublicGateway` operation. */
  export interface UnsetSubnetPublicGatewayParams extends DefaultParams {
    /** The subnet identifier. */
    id: string;
  }

  /** Parameters for the `getSubnetPublicGateway` operation. */
  export interface GetSubnetPublicGatewayParams extends DefaultParams {
    /** The subnet identifier. */
    id: string;
  }

  /** Parameters for the `setSubnetPublicGateway` operation. */
  export interface SetSubnetPublicGatewayParams extends DefaultParams {
    /** The subnet identifier. */
    id: string;
    /** The public gateway identity. */
    publicGatewayIdentity: PublicGatewayIdentity;
  }

  /** Parameters for the `getSubnetRoutingTable` operation. */
  export interface GetSubnetRoutingTableParams extends DefaultParams {
    /** The subnet identifier. */
    id: string;
  }

  /** Parameters for the `replaceSubnetRoutingTable` operation. */
  export interface ReplaceSubnetRoutingTableParams extends DefaultParams {
    /** The subnet identifier. */
    id: string;
    /** The routing table identity. */
    routingTableIdentity: RoutingTableIdentity;
  }

  /** Parameters for the `listSubnetReservedIps` operation. */
  export interface ListSubnetReservedIpsParams extends DefaultParams {
    /** The subnet identifier. */
    subnetId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListSubnetReservedIpsConstants.Sort | string;
    /** Filters the collection to resources with a `target.id` property matching the specified identifier. */
    targetId?: string;
    /** Filters the collection to resources with a `target.crn` property matching the specified CRN. */
    targetCrn?: string;
    /** Filters the collection to resources with a `target.name` property matching the exact specified name. */
    targetName?: string;
    /** Filters the collection to resources with a `target.resource_type` property matching the specified value. */
    targetResourceType?: string;
  }

  /** Constants for the `listSubnetReservedIps` operation. */
  export namespace ListSubnetReservedIpsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      ADDRESS = 'address',
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createSubnetReservedIp` operation. */
  export interface CreateSubnetReservedIpParams extends DefaultParams {
    /** The subnet identifier. */
    subnetId: string;
    /** The IP address to reserve, which must not already be reserved on the subnet.
     *
     *  If unspecified, an available address on the subnet will automatically be selected.
     */
    address?: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound. Must be `false` if the reserved IP is unbound.
     */
    autoDelete?: boolean;
    /** The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The target to bind this reserved IP to.  The target must be in the same VPC.
     *
     *  The following targets are supported:
     *  - An endpoint gateway not already bound to a reserved IP in the subnet's zone.
     *  - A virtual network interface.
     *
     *  If unspecified, the reserved IP will be created unbound.
     */
    target?: ReservedIPTargetPrototype;
  }

  /** Parameters for the `deleteSubnetReservedIp` operation. */
  export interface DeleteSubnetReservedIpParams extends DefaultParams {
    /** The subnet identifier. */
    subnetId: string;
    /** The reserved IP identifier. */
    id: string;
  }

  /** Parameters for the `getSubnetReservedIp` operation. */
  export interface GetSubnetReservedIpParams extends DefaultParams {
    /** The subnet identifier. */
    subnetId: string;
    /** The reserved IP identifier. */
    id: string;
  }

  /** Parameters for the `updateSubnetReservedIp` operation. */
  export interface UpdateSubnetReservedIpParams extends DefaultParams {
    /** The subnet identifier. */
    subnetId: string;
    /** The reserved IP identifier. */
    id: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound. Must be `false` if the reserved IP is unbound.
     */
    autoDelete?: boolean;
    /** The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
  }

  /** Parameters for the `listImages` operation. */
  export interface ListImagesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to images with a `status` property matching one of the specified comma-separated
     *  values.
     */
    status?: ListImagesConstants.Status[] | string[];
    /** Filters the collection to images with a `visibility` property matching the specified value. */
    visibility?: ListImagesConstants.Visibility | string;
    /** Filters the collection to images with a `user_data_format` property matching one of the specified
     *  comma-separated values.
     */
    userDataFormat?: ListImagesConstants.UserDataFormat[] | string[];
    /** Filters the collection to images with an `owner_type` property matching the specified value. */
    ownerType?: ListImagesConstants.OwnerType | string;
  }

  /** Constants for the `listImages` operation. */
  export namespace ListImagesConstants {
    /** Filters the collection to images with a `status` property matching one of the specified comma-separated values. */
    export enum Status {
      AVAILABLE = 'available',
      DELETING = 'deleting',
      DEPRECATED = 'deprecated',
      FAILED = 'failed',
      OBSOLETE = 'obsolete',
      PENDING = 'pending',
      UNUSABLE = 'unusable',
    }
    /** Filters the collection to images with a `visibility` property matching the specified value. */
    export enum Visibility {
      PRIVATE = 'private',
      PUBLIC = 'public',
    }
    /** Filters the collection to images with a `user_data_format` property matching one of the specified comma-separated values. */
    export enum UserDataFormat {
      CLOUD_INIT = 'cloud_init',
      ESXI_KICKSTART = 'esxi_kickstart',
      IPXE = 'ipxe',
    }
    /** Filters the collection to images with an `owner_type` property matching the specified value. */
    export enum OwnerType {
      PROVIDER = 'provider',
      USER = 'user',
    }
  }

  /** Parameters for the `createImage` operation. */
  export interface CreateImageParams extends DefaultParams {
    /** The image prototype object. */
    imagePrototype: ImagePrototype;
  }

  /** Parameters for the `deleteImage` operation. */
  export interface DeleteImageParams extends DefaultParams {
    /** The image identifier. */
    id: string;
  }

  /** Parameters for the `getImage` operation. */
  export interface GetImageParams extends DefaultParams {
    /** The image identifier. */
    id: string;
  }

  /** Parameters for the `updateImage` operation. */
  export interface UpdateImageParams extends DefaultParams {
    /** The image identifier. */
    id: string;
    /** The deprecation date and time to set for this image.
     *
     *  This cannot be set if the image has a `status` of `failed` or `deleting`, or if
     *  `catalog_offering.managed` is `true`.
     *
     *  The date and time must not be in the past, and must be earlier than `obsolescence_at`
     *  (if `obsolescence_at` is set). Additionally, if the image status is currently
     *  `deprecated`, the value cannot be changed (but may be removed).
     *
     *  Specify `null` to remove an existing deprecation date and time. If the image status is currently `deprecated`,
     *  it will become `available`.
     *
     *  If the deprecation date and time is reached while the image has a status of `pending`, the image's status will
     *  transition to `deprecated` upon its successful creation (or
     *  `obsolete` if the obsolescence date and time was also reached).
     */
    deprecationAt?: string;
    /** The name for this image. The name must not be used by another image in the region. Names starting with
     *  `ibm-` are reserved for system-provided images, and are not allowed.
     */
    name?: string;
    /** The obsolescence date and time to set for this image.
     *
     *  This cannot be set if the image has a `status` of `failed` or `deleting`, or if
     *  `catalog_offering.managed` is `true`.
     *
     *  The date and time must not be in the past, and must be later than `deprecation_at` (if
     *  `deprecation_at` is set). Additionally, if the image status is currently `obsolete`, the value cannot be changed
     *  (but may be removed).
     *
     *  Specify `null` to remove an existing obsolescence date and time. If the image status is currently `obsolete`, it
     *  will become `deprecated` if `deprecation_at` is in the past. Otherwise, it will become `available`.
     *
     *  If the obsolescence date and time is reached while the image has a status of `pending`, the image's status will
     *  transition to `obsolete` upon its successful creation.
     */
    obsolescenceAt?: string;
  }

  /** Parameters for the `deprecateImage` operation. */
  export interface DeprecateImageParams extends DefaultParams {
    /** The image identifier. */
    id: string;
  }

  /** Parameters for the `obsoleteImage` operation. */
  export interface ObsoleteImageParams extends DefaultParams {
    /** The image identifier. */
    id: string;
  }

  /** Parameters for the `listImageExportJobs` operation. */
  export interface ListImageExportJobsParams extends DefaultParams {
    /** The image identifier. */
    imageId: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
  }

  /** Parameters for the `createImageExportJob` operation. */
  export interface CreateImageExportJobParams extends DefaultParams {
    /** The image identifier. */
    imageId: string;
    /** The Cloud Object Storage bucket to export the image to. The bucket must exist and an IAM
     *  service authorization must grant `Image Service for VPC` of
     *  `VPC Infrastructure Services` writer access to the bucket.
     */
    storageBucket: CloudObjectStorageBucketIdentity;
    /** The format to use for the exported image. If the image is encrypted, only `qcow2` is supported. */
    format?: CreateImageExportJobConstants.Format | string;
    /** The name for this image export job. The name must not be used by another export job for the image. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words prefixed with the first 16 characters
     *  of the parent image name.
     *
     *  The exported image object name in Cloud Object Storage (`storage_object.name` in the response) will be based on
     *  this name. The object name will be unique within the bucket.
     */
    name?: string;
  }

  /** Constants for the `createImageExportJob` operation. */
  export namespace CreateImageExportJobConstants {
    /** The format to use for the exported image. If the image is encrypted, only `qcow2` is supported. */
    export enum Format {
      QCOW2 = 'qcow2',
      VHD = 'vhd',
    }
  }

  /** Parameters for the `deleteImageExportJob` operation. */
  export interface DeleteImageExportJobParams extends DefaultParams {
    /** The image identifier. */
    imageId: string;
    /** The image export job identifier. */
    id: string;
  }

  /** Parameters for the `getImageExportJob` operation. */
  export interface GetImageExportJobParams extends DefaultParams {
    /** The image identifier. */
    imageId: string;
    /** The image export job identifier. */
    id: string;
  }

  /** Parameters for the `updateImageExportJob` operation. */
  export interface UpdateImageExportJobParams extends DefaultParams {
    /** The image identifier. */
    imageId: string;
    /** The image export job identifier. */
    id: string;
    /** The name for this image export job. The name must not be used by another export job for the image. Changing
     *  the name will not affect the exported image name,
     *  `storage_object.name`, or `storage_href` values.
     */
    name?: string;
  }

  /** Parameters for the `listOperatingSystems` operation. */
  export interface ListOperatingSystemsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `getOperatingSystem` operation. */
  export interface GetOperatingSystemParams extends DefaultParams {
    /** The operating system name. */
    name: string;
  }

  /** Parameters for the `listKeys` operation. */
  export interface ListKeysParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
  }

  /** Parameters for the `createKey` operation. */
  export interface CreateKeyParams extends DefaultParams {
    /** The public SSH key to use, in OpenSSH format (consisting of three space-separated fields: the algorithm
     *  name, base64-encoded key value, and a comment). The algorithm and comment fields may be omitted, as only the key
     *  field is used.
     *
     *  The key field must not match another key in the region.
     *
     *  Keys of type `rsa` must be 2048 or 4096 bits in length (4096 is recommended). Keys of type `ed25519` must be 256
     *  bits in length.
     */
    publicKey: string;
    /** The name for this key. The name must not be used by another key in the region. If unspecified, the name will
     *  be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** The crypto-system for this key. */
    type?: CreateKeyConstants.Type | string;
  }

  /** Constants for the `createKey` operation. */
  export namespace CreateKeyConstants {
    /** The crypto-system for this key. */
    export enum Type {
      ED25519 = 'ed25519',
      RSA = 'rsa',
    }
  }

  /** Parameters for the `deleteKey` operation. */
  export interface DeleteKeyParams extends DefaultParams {
    /** The key identifier. */
    id: string;
  }

  /** Parameters for the `getKey` operation. */
  export interface GetKeyParams extends DefaultParams {
    /** The key identifier. */
    id: string;
  }

  /** Parameters for the `updateKey` operation. */
  export interface UpdateKeyParams extends DefaultParams {
    /** The key identifier. */
    id: string;
    /** The name for this key. The name must not be used by another key in the region. */
    name?: string;
  }

  /** Parameters for the `listInstanceProfiles` operation. */
  export interface ListInstanceProfilesParams extends DefaultParams {
  }

  /** Parameters for the `getInstanceProfile` operation. */
  export interface GetInstanceProfileParams extends DefaultParams {
    /** The instance profile name. */
    name: string;
  }

  /** Parameters for the `listInstanceTemplates` operation. */
  export interface ListInstanceTemplatesParams extends DefaultParams {
  }

  /** Parameters for the `createInstanceTemplate` operation. */
  export interface CreateInstanceTemplateParams extends DefaultParams {
    /** The instance template prototype object. */
    instanceTemplatePrototype: InstanceTemplatePrototype;
  }

  /** Parameters for the `deleteInstanceTemplate` operation. */
  export interface DeleteInstanceTemplateParams extends DefaultParams {
    /** The instance template identifier. */
    id: string;
  }

  /** Parameters for the `getInstanceTemplate` operation. */
  export interface GetInstanceTemplateParams extends DefaultParams {
    /** The instance template identifier. */
    id: string;
  }

  /** Parameters for the `updateInstanceTemplate` operation. */
  export interface UpdateInstanceTemplateParams extends DefaultParams {
    /** The instance template identifier. */
    id: string;
    /** The name for this instance template. The name must not be used by another instance template in the region. */
    name?: string;
  }

  /** Parameters for the `listInstances` operation. */
  export interface ListInstancesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to instances with a `cluster_network.id` property matching the specified identifier. */
    clusterNetworkId?: string;
    /** Filters the collection to instances with a `cluster_network.crn` property matching the specified CRN. */
    clusterNetworkCrn?: string;
    /** Filters the collection to resources with a `cluster_network.name` property matching the exact specified
     *  name.
     */
    clusterNetworkName?: string;
    /** Filters the collection to resources with a `dedicated_host.id` property matching the specified identifier. */
    dedicatedHostId?: string;
    /** Filters the collection to resources with a `dedicated_host.crn` property matching the specified CRN. */
    dedicatedHostCrn?: string;
    /** Filters the collection to resources with a `dedicated_host.name` property matching the exact specified name. */
    dedicatedHostName?: string;
    /** Filters the collection to resources with a `placement_target.id` property matching the specified placement
     *  group identifier.
     */
    placementGroupId?: string;
    /** Filters the collection to resources with a `placement_target.crn` property matching the specified placement
     *  group CRN.
     */
    placementGroupCrn?: string;
    /** Filters the collection to resources with a `placement_target.name` property matching the exact specified
     *  placement group name.
     */
    placementGroupName?: string;
    /** Filters the collection to instances with a `reservation_affinity.policy` property matching the specified
     *  value.
     */
    reservationAffinityPolicy?: ListInstancesConstants.ReservationAffinityPolicy | string;
    /** Filters the collection to resources with a `reservation.id` property matching the specified identifier. */
    reservationId?: string;
    /** Filters the collection to resources with a `reservation.crn` property matching the specified identifier. */
    reservationCrn?: string;
    /** Filters the collection to resources with a `reservation.name` property matching the specified identifier. */
    reservationName?: string;
    /** Filters the collection to resources with a `vpc.id` property matching the specified identifier. */
    vpcId?: string;
    /** Filters the collection to resources with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to resources with a `vpc.name` property matching the exact specified name. */
    vpcName?: string;
  }

  /** Constants for the `listInstances` operation. */
  export namespace ListInstancesConstants {
    /** Filters the collection to instances with a `reservation_affinity.policy` property matching the specified value. */
    export enum ReservationAffinityPolicy {
      AUTOMATIC = 'automatic',
      DISABLED = 'disabled',
      MANUAL = 'manual',
    }
  }

  /** Parameters for the `createInstance` operation. */
  export interface CreateInstanceParams extends DefaultParams {
    /** The instance prototype object. */
    instancePrototype: InstancePrototype;
  }

  /** Parameters for the `deleteInstance` operation. */
  export interface DeleteInstanceParams extends DefaultParams {
    /** The virtual server instance identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getInstance` operation. */
  export interface GetInstanceParams extends DefaultParams {
    /** The virtual server instance identifier. */
    id: string;
  }

  /** Parameters for the `updateInstance` operation. */
  export interface UpdateInstanceParams extends DefaultParams {
    /** The virtual server instance identifier. */
    id: string;
    /** The availability policy for this virtual server instance. */
    availabilityPolicy?: InstanceAvailabilityPolicyPatch;
    /** The confidential compute mode to use for this virtual server instance.
     *
     *  For this property to be changed, the virtual server instance `status` must be
     *  `stopping` or `stopped`.
     */
    confidentialComputeMode?: UpdateInstanceConstants.ConfidentialComputeMode | string;
    /** Indicates whether secure boot is enabled for this virtual server instance.
     *
     *  For this property to be changed, the virtual server instance `status` must be
     *  `stopping` or `stopped`.
     */
    enableSecureBoot?: boolean;
    /** The metadata service configuration. */
    metadataService?: InstanceMetadataServicePatch;
    /** The name for this virtual server instance. The name must not be used by another virtual server instance in
     *  the region. Changing the name will not affect the system hostname.
     */
    name?: string;
    /** The placement restrictions to use for the virtual server instance. For the placement restrictions to be
     *  changed, the instance `status` must be `stopping` or `stopped`.
     *  If set, `reservation_affinity.policy` must be `disabled`.
     */
    placementTarget?: InstancePlacementTargetPatch;
    /** The profile to use for this virtual server instance. Any disks associated with the
     *  current profile will be deleted, and any disks associated with the requested profile
     *  will be created.
     *
     *  For the profile to be changed, the instance `status` must be `stopping` or `stopped`.
     *  In addition, the requested profile must:
     *  - Be compatible with any `placement_target` constraints. For example, if the
     *    instance is placed on a dedicated host, the requested profile `family` must be
     *    the same as the dedicated host `family`.
     *  - Have the same `vcpu.architecture`.
     *  - Support the number of network attachments or network interfaces the instance
     *    currently has.
     */
    profile?: InstancePatchProfile;
    reservationAffinity?: InstanceReservationAffinityPatch;
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An
     *  increase in this value will result in a corresponding decrease to
     *  `total_network_bandwidth`.
     */
    totalVolumeBandwidth?: number;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Constants for the `updateInstance` operation. */
  export namespace UpdateInstanceConstants {
    /** The confidential compute mode to use for this virtual server instance. For this property to be changed, the virtual server instance `status` must be `stopping` or `stopped`. */
    export enum ConfidentialComputeMode {
      DISABLED = 'disabled',
      SGX = 'sgx',
      TDX = 'tdx',
    }
  }

  /** Parameters for the `getInstanceInitialization` operation. */
  export interface GetInstanceInitializationParams extends DefaultParams {
    /** The instance identifier. */
    id: string;
  }

  /** Parameters for the `createInstanceAction` operation. */
  export interface CreateInstanceActionParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The type of action. */
    type: CreateInstanceActionConstants.Type | string;
    /** If set to true, the action will be forced immediately, and all queued actions deleted. Ignored for the start
     *  action.
     */
    force?: boolean;
  }

  /** Constants for the `createInstanceAction` operation. */
  export namespace CreateInstanceActionConstants {
    /** The type of action. */
    export enum Type {
      REBOOT = 'reboot',
      START = 'start',
      STOP = 'stop',
    }
  }

  /** Parameters for the `listInstanceClusterNetworkAttachments` operation. */
  export interface ListInstanceClusterNetworkAttachmentsParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createClusterNetworkAttachment` operation. */
  export interface CreateClusterNetworkAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** A cluster network interface for the instance cluster network attachment. This can be
     *  specified using an existing cluster network interface that does not already have a `target`,
     *  or a prototype object for a new cluster network interface.
     *
     *  This instance must reside in the same VPC as the specified cluster network interface. The
     *  cluster network interface must reside in the same cluster network as the
     *  `cluster_network_interface` of any other `cluster_network_attachments` for this instance.
     */
    clusterNetworkInterface: InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterface;
    /** The instance cluster network attachment to insert this instance cluster network attachment
     *  immediately before.
     *
     *  If unspecified, this instance cluster network attachment will be inserted after all
     *  existing instance cluster network attachments.
     */
    before?: InstanceClusterNetworkAttachmentBeforePrototype;
    /** The name for this cluster network attachment. Names must be unique within the instance the cluster network
     *  attachment resides in. If unspecified, the name will be a hyphenated list of randomly-selected words. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
  }

  /** Parameters for the `deleteInstanceClusterNetworkAttachment` operation. */
  export interface DeleteInstanceClusterNetworkAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance cluster network attachment identifier. */
    id: string;
  }

  /** Parameters for the `getInstanceClusterNetworkAttachment` operation. */
  export interface GetInstanceClusterNetworkAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance cluster network attachment identifier. */
    id: string;
  }

  /** Parameters for the `updateInstanceClusterNetworkAttachment` operation. */
  export interface UpdateInstanceClusterNetworkAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance cluster network attachment identifier. */
    id: string;
    /** The name for this network attachment. The name must not be used by another network attachment for the
     *  instance. Names starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
  }

  /** Parameters for the `createInstanceConsoleAccessToken` operation. */
  export interface CreateInstanceConsoleAccessTokenParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance console type for which this token may be used. */
    consoleType: CreateInstanceConsoleAccessTokenConstants.ConsoleType | string;
    /** Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.
     *  This has no effect on VNC consoles.
     */
    force?: boolean;
  }

  /** Constants for the `createInstanceConsoleAccessToken` operation. */
  export namespace CreateInstanceConsoleAccessTokenConstants {
    /** The instance console type for which this token may be used. */
    export enum ConsoleType {
      SERIAL = 'serial',
      VNC = 'vnc',
    }
  }

  /** Parameters for the `listInstanceDisks` operation. */
  export interface ListInstanceDisksParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
  }

  /** Parameters for the `getInstanceDisk` operation. */
  export interface GetInstanceDiskParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance disk identifier. */
    id: string;
  }

  /** Parameters for the `updateInstanceDisk` operation. */
  export interface UpdateInstanceDiskParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance disk identifier. */
    id: string;
    /** The name for this instance disk. The name must not be used by another disk on the instance. */
    name?: string;
  }

  /** Parameters for the `listInstanceNetworkAttachments` operation. */
  export interface ListInstanceNetworkAttachmentsParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
  }

  /** Parameters for the `createInstanceNetworkAttachment` operation. */
  export interface CreateInstanceNetworkAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** A virtual network interface for the instance network attachment. This can be specified
     *  using an existing virtual network interface, or a prototype object for a new virtual
     *  network interface.
     *
     *  If an existing virtual network interface is specified, `enable_infrastructure_nat` must be
     *  `true`.
     */
    virtualNetworkInterface: InstanceNetworkAttachmentPrototypeVirtualNetworkInterface;
    /** The name for this network attachment. Names must be unique within the instance the network attachment
     *  resides in. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /** Parameters for the `deleteInstanceNetworkAttachment` operation. */
  export interface DeleteInstanceNetworkAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network attachment identifier. */
    id: string;
  }

  /** Parameters for the `getInstanceNetworkAttachment` operation. */
  export interface GetInstanceNetworkAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network attachment identifier. */
    id: string;
  }

  /** Parameters for the `updateInstanceNetworkAttachment` operation. */
  export interface UpdateInstanceNetworkAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network attachment identifier. */
    id: string;
    /** The name for this network attachment. The name must not be used by another network attachment for the
     *  instance.
     */
    name?: string;
  }

  /** Parameters for the `listInstanceNetworkInterfaces` operation. */
  export interface ListInstanceNetworkInterfacesParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
  }

  /** Parameters for the `createInstanceNetworkInterface` operation. */
  export interface CreateInstanceNetworkInterfaceParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The associated subnet. */
    subnet: SubnetIdentity;
    /** Indicates whether source IP spoofing is allowed on this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and source IP spoofing is managed
     *  on the attached virtual network interface.
     */
    allowIpSpoofing?: boolean;
    /** The name for the instance network interface. The name must not be used by another network interface on the
     *  virtual server instance. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The primary IP address to bind to the instance network interface. This can be
     *  specified using an existing reserved IP, or a prototype object for a new reserved IP.
     *
     *  If an existing reserved IP or a prototype object with an address is specified, it must
     *  be available on the instance network interface's subnet. Otherwise, an
     *  available address on the subnet will be automatically selected and reserved.
     */
    primaryIp?: NetworkInterfaceIPPrototype;
    /** The security groups to use for this instance network interface. If unspecified, the VPC's default security
     *  group is used.
     */
    securityGroups?: SecurityGroupIdentity[];
  }

  /** Parameters for the `deleteInstanceNetworkInterface` operation. */
  export interface DeleteInstanceNetworkInterfaceParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    id: string;
  }

  /** Parameters for the `getInstanceNetworkInterface` operation. */
  export interface GetInstanceNetworkInterfaceParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    id: string;
  }

  /** Parameters for the `updateInstanceNetworkInterface` operation. */
  export interface UpdateInstanceNetworkInterfaceParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    id: string;
    /** Indicates whether source IP spoofing is allowed on this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and source IP spoofing is managed
     *  on the attached virtual network interface.
     */
    allowIpSpoofing?: boolean;
    /** The name for the instance network interface. The name must not be used by another network interface on the
     *  virtual server instance.
     */
    name?: string;
  }

  /** Parameters for the `listInstanceNetworkInterfaceFloatingIps` operation. */
  export interface ListInstanceNetworkInterfaceFloatingIpsParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
  }

  /** Parameters for the `removeInstanceNetworkInterfaceFloatingIp` operation. */
  export interface RemoveInstanceNetworkInterfaceFloatingIpParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
  }

  /** Parameters for the `getInstanceNetworkInterfaceFloatingIp` operation. */
  export interface GetInstanceNetworkInterfaceFloatingIpParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
  }

  /** Parameters for the `addInstanceNetworkInterfaceFloatingIp` operation. */
  export interface AddInstanceNetworkInterfaceFloatingIpParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
  }

  /** Parameters for the `listInstanceNetworkInterfaceIps` operation. */
  export interface ListInstanceNetworkInterfaceIpsParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `getInstanceNetworkInterfaceIp` operation. */
  export interface GetInstanceNetworkInterfaceIpParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The instance network interface identifier. */
    networkInterfaceId: string;
    /** The reserved IP identifier. */
    id: string;
  }

  /** Parameters for the `listInstanceVolumeAttachments` operation. */
  export interface ListInstanceVolumeAttachmentsParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
  }

  /** Parameters for the `createInstanceVolumeAttachment` operation. */
  export interface CreateInstanceVolumeAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The volume to use for this attachment. This can be specified as an existing unattached
     *  volume, or a prototype object for a new volume.
     */
    volume: VolumeAttachmentPrototypeVolume;
    /** Indicates whether deleting the instance will also delete the attached volume. */
    deleteVolumeOnInstanceDelete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /** Parameters for the `deleteInstanceVolumeAttachment` operation. */
  export interface DeleteInstanceVolumeAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The volume attachment identifier. */
    id: string;
  }

  /** Parameters for the `getInstanceVolumeAttachment` operation. */
  export interface GetInstanceVolumeAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The volume attachment identifier. */
    id: string;
  }

  /** Parameters for the `updateInstanceVolumeAttachment` operation. */
  export interface UpdateInstanceVolumeAttachmentParams extends DefaultParams {
    /** The virtual server instance identifier. */
    instanceId: string;
    /** The volume attachment identifier. */
    id: string;
    /** Indicates whether deleting the instance will also delete the attached volume. */
    deleteVolumeOnInstanceDelete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance. */
    name?: string;
  }

  /** Parameters for the `listInstanceGroups` operation. */
  export interface ListInstanceGroupsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createInstanceGroup` operation. */
  export interface CreateInstanceGroupParams extends DefaultParams {
    /** Instance template to use when creating new instances.
     *
     *  Instance groups are not compatible with instance templates that specify `true` for
     *  `default_trusted_profile.auto_link`.
     */
    instanceTemplate: InstanceTemplateIdentity;
    /** The subnets to use when creating new instances. */
    subnets: SubnetIdentity[];
    /** The port to use for new load balancer pool members created by this instance group. The load balancer pool
     *  member will receive load balancer traffic on this port, unless the load balancer listener is using a port range.
     *  (Traffic received on a listener using a port range will be sent to members using the same port the listener
     *  received it on.)
     *
     *  This port will also be used for health checks unless the port property of
     *  `health_monitor` property is specified.
     *
     *  This property must be specified if and only if `load_balancer_pool` has been specified.
     */
    applicationPort?: number;
    /** The load balancer associated with the specified load balancer pool.
     *  Required if `load_balancer_pool` is specified. The load balancer must have
     *  `instance_groups_supported` set to `true`.
     */
    loadBalancer?: LoadBalancerIdentity;
    /** If specified, this instance group will manage the load balancer pool. A pool member
     *  will be created for each instance created by this group.  The specified load
     *  balancer pool must not be used by another instance group in the VPC.
     *
     *  If specified, `load_balancer` and `application_port` must also be specified.
     */
    loadBalancerPool?: LoadBalancerPoolIdentity;
    /** The number of instances in the instance group. */
    membershipCount?: number;
    /** The name for this instance group. The name must not be used by another instance group in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
  }

  /** Parameters for the `deleteInstanceGroup` operation. */
  export interface DeleteInstanceGroupParams extends DefaultParams {
    /** The instance group identifier. */
    id: string;
  }

  /** Parameters for the `getInstanceGroup` operation. */
  export interface GetInstanceGroupParams extends DefaultParams {
    /** The instance group identifier. */
    id: string;
  }

  /** Parameters for the `updateInstanceGroup` operation. */
  export interface UpdateInstanceGroupParams extends DefaultParams {
    /** The instance group identifier. */
    id: string;
    /** The port to use for new load balancer pool members created by this instance group.
     *
     *  This property must be set if and only if `load_balancer_pool` has been set.
     */
    applicationPort?: number;
    /** Instance template to use when creating new instances.
     *
     *  Instance groups are not compatible with instance templates that specify `true` for
     *  `default_trusted_profile.auto_link`.
     */
    instanceTemplate?: InstanceTemplateIdentity;
    /** The load balancer associated with `load_balancer_pool`.
     *  The load balancer must have `instance_groups_supported` set to `true`.
     *
     *  This property must be set if and only if `load_balancer_pool` has been set.
     */
    loadBalancer?: LoadBalancerIdentity;
    /** If specified, this instance group will manage the load balancer pool. A pool member
     *  will be created for each instance created by this group.  The specified load
     *  balancer pool must not be used by another instance group in the VPC.
     *
     *  If set, `load_balancer` and `application_port` must also be set.
     */
    loadBalancerPool?: LoadBalancerPoolIdentity;
    /** The number of instances in the instance group. */
    membershipCount?: number;
    /** The name for this instance group. The name must not be used by another instance group in the region. */
    name?: string;
    /** The subnets to use when creating new instances. */
    subnets?: SubnetIdentity[];
  }

  /** Parameters for the `deleteInstanceGroupLoadBalancer` operation. */
  export interface DeleteInstanceGroupLoadBalancerParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
  }

  /** Parameters for the `listInstanceGroupManagers` operation. */
  export interface ListInstanceGroupManagersParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createInstanceGroupManager` operation. */
  export interface CreateInstanceGroupManagerParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager prototype object. */
    instanceGroupManagerPrototype: InstanceGroupManagerPrototype;
  }

  /** Parameters for the `deleteInstanceGroupManager` operation. */
  export interface DeleteInstanceGroupManagerParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    id: string;
  }

  /** Parameters for the `getInstanceGroupManager` operation. */
  export interface GetInstanceGroupManagerParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    id: string;
  }

  /** Parameters for the `updateInstanceGroupManager` operation. */
  export interface UpdateInstanceGroupManagerParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    id: string;
    /** The time window in seconds to aggregate metrics prior to evaluation. */
    aggregationWindow?: number;
    /** The duration of time in seconds to pause further scale actions after scaling has taken place. */
    cooldown?: number;
    /** Indicates whether this manager will control the instance group. */
    managementEnabled?: boolean;
    /** The maximum number of members in a managed instance group. */
    maxMembershipCount?: number;
    /** The minimum number of members in a managed instance group. */
    minMembershipCount?: number;
    /** The name for this instance group manager. The name must not be used by another manager for the instance
     *  group.
     */
    name?: string;
  }

  /** Parameters for the `listInstanceGroupManagerActions` operation. */
  export interface ListInstanceGroupManagerActionsParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createInstanceGroupManagerAction` operation. */
  export interface CreateInstanceGroupManagerActionParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager action prototype object. */
    instanceGroupManagerActionPrototype: InstanceGroupManagerActionPrototype;
  }

  /** Parameters for the `deleteInstanceGroupManagerAction` operation. */
  export interface DeleteInstanceGroupManagerActionParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager action identifier. */
    id: string;
  }

  /** Parameters for the `getInstanceGroupManagerAction` operation. */
  export interface GetInstanceGroupManagerActionParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager action identifier. */
    id: string;
  }

  /** Parameters for the `updateInstanceGroupManagerAction` operation. */
  export interface UpdateInstanceGroupManagerActionParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager action identifier. */
    id: string;
    /** Indicates whether this scheduled action will be automatically deleted after it has completed and
     *  `auto_delete_timeout` hours have passed.
     */
    autoDelete?: boolean;
    /** If `auto_delete` is `true`, and this scheduled action has finished, the hours after which it will be
     *  automatically deleted. If the value is `0`, the action will be deleted once it has finished.
     */
    autoDeleteTimeout?: number;
    /** The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within
     *  a 5 min period.
     */
    cronSpec?: string;
    group?: InstanceGroupManagerActionGroupPatch;
    manager?: InstanceGroupManagerActionManagerPatch;
    /** The name for this instance group manager action. The name must not be used by another action for the
     *  instance group manager.
     */
    name?: string;
    /** The date and time the scheduled action will run. */
    runAt?: string;
  }

  /** Parameters for the `listInstanceGroupManagerPolicies` operation. */
  export interface ListInstanceGroupManagerPoliciesParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createInstanceGroupManagerPolicy` operation. */
  export interface CreateInstanceGroupManagerPolicyParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager policy prototype object. */
    instanceGroupManagerPolicyPrototype: InstanceGroupManagerPolicyPrototype;
  }

  /** Parameters for the `deleteInstanceGroupManagerPolicy` operation. */
  export interface DeleteInstanceGroupManagerPolicyParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager policy identifier. */
    id: string;
  }

  /** Parameters for the `getInstanceGroupManagerPolicy` operation. */
  export interface GetInstanceGroupManagerPolicyParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager policy identifier. */
    id: string;
  }

  /** Parameters for the `updateInstanceGroupManagerPolicy` operation. */
  export interface UpdateInstanceGroupManagerPolicyParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group manager identifier. */
    instanceGroupManagerId: string;
    /** The instance group manager policy identifier. */
    id: string;
    /** The type of metric to be evaluated. */
    metricType?: UpdateInstanceGroupManagerPolicyConstants.MetricType | string;
    /** The metric value to be evaluated. */
    metricValue?: number;
    /** The name for this instance group manager policy. The name must not be used by another policy for the
     *  instance group manager.
     */
    name?: string;
  }

  /** Constants for the `updateInstanceGroupManagerPolicy` operation. */
  export namespace UpdateInstanceGroupManagerPolicyConstants {
    /** The type of metric to be evaluated. */
    export enum MetricType {
      CPU = 'cpu',
      MEMORY = 'memory',
      NETWORK_IN = 'network_in',
      NETWORK_OUT = 'network_out',
    }
  }

  /** Parameters for the `deleteInstanceGroupMemberships` operation. */
  export interface DeleteInstanceGroupMembershipsParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
  }

  /** Parameters for the `listInstanceGroupMemberships` operation. */
  export interface ListInstanceGroupMembershipsParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `deleteInstanceGroupMembership` operation. */
  export interface DeleteInstanceGroupMembershipParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group membership identifier. */
    id: string;
  }

  /** Parameters for the `getInstanceGroupMembership` operation. */
  export interface GetInstanceGroupMembershipParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group membership identifier. */
    id: string;
  }

  /** Parameters for the `updateInstanceGroupMembership` operation. */
  export interface UpdateInstanceGroupMembershipParams extends DefaultParams {
    /** The instance group identifier. */
    instanceGroupId: string;
    /** The instance group membership identifier. */
    id: string;
    /** If set to true, when deleting the membership the instance will also be deleted. */
    deleteInstanceOnMembershipDelete?: boolean;
    /** The name for this instance group membership. The name must not be used by another membership for the
     *  instance group manager.
     */
    name?: string;
  }

  /** Parameters for the `listReservations` operation. */
  export interface ListReservationsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection of resources with a `profile.resource_type` property matching the specified value. */
    profileResourceType?: string;
    /** Filters the collection to reservations with an `affinity_policy` property matching the specified value. */
    affinityPolicy?: ListReservationsConstants.AffinityPolicy | string;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `zone.name` property matching the exact specified name. */
    zoneName?: string;
  }

  /** Constants for the `listReservations` operation. */
  export namespace ListReservationsConstants {
    /** Filters the collection to reservations with an `affinity_policy` property matching the specified value. */
    export enum AffinityPolicy {
      AUTOMATIC = 'automatic',
      RESTRICTED = 'restricted',
    }
  }

  /** Parameters for the `createReservation` operation. */
  export interface CreateReservationParams extends DefaultParams {
    /** The capacity reservation configuration to use. */
    capacity: ReservationCapacityPrototype;
    /** The committed use configuration to use for this reservation. */
    committedUse: ReservationCommittedUsePrototype;
    /** The [instance profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) or
     *  [bare metal server
     *  profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
     *  to use for this reservation.
     */
    profile: ReservationProfilePrototype;
    /** The zone to use for this reservation. */
    zone: ZoneIdentity;
    /** The affinity policy to use for this reservation:
     *  - `automatic`: The reservation will be automatically selected
     *  - `restricted`: The reservation must be manually requested.
     */
    affinityPolicy?: CreateReservationConstants.AffinityPolicy | string;
    /** The name for this reservation. The name must not be used by another reservation in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
  }

  /** Constants for the `createReservation` operation. */
  export namespace CreateReservationConstants {
    /** The affinity policy to use for this reservation: - `automatic`: The reservation will be automatically selected - `restricted`: The reservation must be manually requested. */
    export enum AffinityPolicy {
      AUTOMATIC = 'automatic',
      RESTRICTED = 'restricted',
    }
  }

  /** Parameters for the `deleteReservation` operation. */
  export interface DeleteReservationParams extends DefaultParams {
    /** The reservation identifier. */
    id: string;
  }

  /** Parameters for the `getReservation` operation. */
  export interface GetReservationParams extends DefaultParams {
    /** The reservation identifier. */
    id: string;
  }

  /** Parameters for the `updateReservation` operation. */
  export interface UpdateReservationParams extends DefaultParams {
    /** The reservation identifier. */
    id: string;
    /** The affinity policy to use for this reservation:
     *  - `automatic`: The reservation will be automatically selected
     *  - `restricted`: The reservation must be manually requested
     *
     *  The affinity policy can only be changed for a reservation with a `status` of `inactive`.
     */
    affinityPolicy?: UpdateReservationConstants.AffinityPolicy | string;
    /** The capacity reservation configuration to use.
     *
     *  The configuration can only be changed for reservations with a `status` of `inactive`.
     */
    capacity?: ReservationCapacityPatch;
    /** The committed use configuration to use for this reservation. */
    committedUse?: ReservationCommittedUsePatch;
    /** The name for this reservation. The name must not be used by another reservation in the region. */
    name?: string;
    /** The [instance profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) or
     *  [bare metal server
     *  profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
     *  to use for this reservation.
     */
    profile?: ReservationProfilePatch;
  }

  /** Constants for the `updateReservation` operation. */
  export namespace UpdateReservationConstants {
    /** The affinity policy to use for this reservation: - `automatic`: The reservation will be automatically selected - `restricted`: The reservation must be manually requested The affinity policy can only be changed for a reservation with a `status` of `inactive`. */
    export enum AffinityPolicy {
      AUTOMATIC = 'automatic',
      RESTRICTED = 'restricted',
    }
  }

  /** Parameters for the `activateReservation` operation. */
  export interface ActivateReservationParams extends DefaultParams {
    /** The reservation identifier. */
    id: string;
  }

  /** Parameters for the `listDedicatedHostGroups` operation. */
  export interface ListDedicatedHostGroupsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `zone.name` property matching the exact specified name. */
    zoneName?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
  }

  /** Parameters for the `createDedicatedHostGroup` operation. */
  export interface CreateDedicatedHostGroupParams extends DefaultParams {
    /** The dedicated host profile class for hosts in this group. */
    _class: string;
    /** The dedicated host profile family for hosts in this group. */
    family: CreateDedicatedHostGroupConstants.Family | string;
    /** The zone this dedicated host group will reside in. */
    zone: ZoneIdentity;
    /** The name for this dedicated host group. The name must not be used by another dedicated host group in the
     *  region. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
  }

  /** Constants for the `createDedicatedHostGroup` operation. */
  export namespace CreateDedicatedHostGroupConstants {
    /** The dedicated host profile family for hosts in this group. */
    export enum Family {
      BALANCED = 'balanced',
      COMPUTE = 'compute',
      MEMORY = 'memory',
    }
  }

  /** Parameters for the `deleteDedicatedHostGroup` operation. */
  export interface DeleteDedicatedHostGroupParams extends DefaultParams {
    /** The dedicated host group identifier. */
    id: string;
  }

  /** Parameters for the `getDedicatedHostGroup` operation. */
  export interface GetDedicatedHostGroupParams extends DefaultParams {
    /** The dedicated host group identifier. */
    id: string;
  }

  /** Parameters for the `updateDedicatedHostGroup` operation. */
  export interface UpdateDedicatedHostGroupParams extends DefaultParams {
    /** The dedicated host group identifier. */
    id: string;
    /** The name for this dedicated host group. The name must not be used by another dedicated host group in the
     *  region.
     */
    name?: string;
  }

  /** Parameters for the `listDedicatedHostProfiles` operation. */
  export interface ListDedicatedHostProfilesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `getDedicatedHostProfile` operation. */
  export interface GetDedicatedHostProfileParams extends DefaultParams {
    /** The dedicated host profile name. */
    name: string;
  }

  /** Parameters for the `listDedicatedHosts` operation. */
  export interface ListDedicatedHostsParams extends DefaultParams {
    /** Filters the collection to dedicated hosts with a `group.id` property matching the specified identifier. */
    dedicatedHostGroupId?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `zone.name` property matching the exact specified name. */
    zoneName?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
  }

  /** Parameters for the `createDedicatedHost` operation. */
  export interface CreateDedicatedHostParams extends DefaultParams {
    /** The dedicated host prototype object. */
    dedicatedHostPrototype: DedicatedHostPrototype;
  }

  /** Parameters for the `listDedicatedHostDisks` operation. */
  export interface ListDedicatedHostDisksParams extends DefaultParams {
    /** The dedicated host identifier. */
    dedicatedHostId: string;
  }

  /** Parameters for the `getDedicatedHostDisk` operation. */
  export interface GetDedicatedHostDiskParams extends DefaultParams {
    /** The dedicated host identifier. */
    dedicatedHostId: string;
    /** The dedicated host disk identifier. */
    id: string;
  }

  /** Parameters for the `updateDedicatedHostDisk` operation. */
  export interface UpdateDedicatedHostDiskParams extends DefaultParams {
    /** The dedicated host identifier. */
    dedicatedHostId: string;
    /** The dedicated host disk identifier. */
    id: string;
    /** The name for this dedicated host disk. The name must not be used by another disk on the dedicated host. */
    name?: string;
  }

  /** Parameters for the `deleteDedicatedHost` operation. */
  export interface DeleteDedicatedHostParams extends DefaultParams {
    /** The dedicated host identifier. */
    id: string;
  }

  /** Parameters for the `getDedicatedHost` operation. */
  export interface GetDedicatedHostParams extends DefaultParams {
    /** The dedicated host identifier. */
    id: string;
  }

  /** Parameters for the `updateDedicatedHost` operation. */
  export interface UpdateDedicatedHostParams extends DefaultParams {
    /** The dedicated host identifier. */
    id: string;
    /** If set to true, instances can be placed on this dedicated host. */
    instancePlacementEnabled?: boolean;
    /** The name for this dedicated host. The name must not be used by another dedicated host in the region. */
    name?: string;
  }

  /** Parameters for the `listPlacementGroups` operation. */
  export interface ListPlacementGroupsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createPlacementGroup` operation. */
  export interface CreatePlacementGroupParams extends DefaultParams {
    /** The strategy for this placement group:
     *  - `host_spread`: place on different compute hosts
     *  - `power_spread`: place on compute hosts that use different power sources.
     */
    strategy: CreatePlacementGroupConstants.Strategy | string;
    /** The name for this placement group. The name must not be used by another placement group in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
  }

  /** Constants for the `createPlacementGroup` operation. */
  export namespace CreatePlacementGroupConstants {
    /** The strategy for this placement group: - `host_spread`: place on different compute hosts - `power_spread`: place on compute hosts that use different power sources. */
    export enum Strategy {
      HOST_SPREAD = 'host_spread',
      POWER_SPREAD = 'power_spread',
    }
  }

  /** Parameters for the `deletePlacementGroup` operation. */
  export interface DeletePlacementGroupParams extends DefaultParams {
    /** The placement group identifier. */
    id: string;
  }

  /** Parameters for the `getPlacementGroup` operation. */
  export interface GetPlacementGroupParams extends DefaultParams {
    /** The placement group identifier. */
    id: string;
  }

  /** Parameters for the `updatePlacementGroup` operation. */
  export interface UpdatePlacementGroupParams extends DefaultParams {
    /** The placement group identifier. */
    id: string;
    /** The name for this placement group. The name must not be used by another placement group in the region. */
    name?: string;
  }

  /** Parameters for the `listBareMetalServerProfiles` operation. */
  export interface ListBareMetalServerProfilesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `getBareMetalServerProfile` operation. */
  export interface GetBareMetalServerProfileParams extends DefaultParams {
    /** The bare metal server profile name. */
    name: string;
  }

  /** Parameters for the `listBareMetalServers` operation. */
  export interface ListBareMetalServersParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to resources with a `reservation.id` property matching the specified identifier. */
    reservationId?: string;
    /** Filters the collection to resources with a `reservation.crn` property matching the specified identifier. */
    reservationCrn?: string;
    /** Filters the collection to resources with a `reservation.name` property matching the specified identifier. */
    reservationName?: string;
    /** Filters the collection to resources with a `vpc.id` property matching the specified identifier. */
    vpcId?: string;
    /** Filters the collection to resources with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to resources with a `vpc.name` property matching the exact specified name. */
    vpcName?: string;
  }

  /** Parameters for the `createBareMetalServer` operation. */
  export interface CreateBareMetalServerParams extends DefaultParams {
    /** The bare metal server prototype object. */
    bareMetalServerPrototype: BareMetalServerPrototype;
  }

  /** Parameters for the `createBareMetalServerConsoleAccessToken` operation. */
  export interface CreateBareMetalServerConsoleAccessTokenParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server console type for which this token may be used
     *
     *  Must be `serial` for bare metal servers with a `cpu.architecture` of `s390x`.
     */
    consoleType: CreateBareMetalServerConsoleAccessTokenConstants.ConsoleType | string;
    /** Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.
     *  This has no effect on VNC consoles.
     */
    force?: boolean;
  }

  /** Constants for the `createBareMetalServerConsoleAccessToken` operation. */
  export namespace CreateBareMetalServerConsoleAccessTokenConstants {
    /** The bare metal server console type for which this token may be used Must be `serial` for bare metal servers with a `cpu.architecture` of `s390x`. */
    export enum ConsoleType {
      SERIAL = 'serial',
      VNC = 'vnc',
    }
  }

  /** Parameters for the `listBareMetalServerDisks` operation. */
  export interface ListBareMetalServerDisksParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
  }

  /** Parameters for the `getBareMetalServerDisk` operation. */
  export interface GetBareMetalServerDiskParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server disk identifier. */
    id: string;
  }

  /** Parameters for the `updateBareMetalServerDisk` operation. */
  export interface UpdateBareMetalServerDiskParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server disk identifier. */
    id: string;
    /** The name for this bare metal server disk. The name must not be used by another disk on the bare metal
     *  server.
     */
    name?: string;
  }

  /** Parameters for the `listBareMetalServerNetworkAttachments` operation. */
  export interface ListBareMetalServerNetworkAttachmentsParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createBareMetalServerNetworkAttachment` operation. */
  export interface CreateBareMetalServerNetworkAttachmentParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network attachment prototype object. */
    bareMetalServerNetworkAttachmentPrototype: BareMetalServerNetworkAttachmentPrototype;
  }

  /** Parameters for the `deleteBareMetalServerNetworkAttachment` operation. */
  export interface DeleteBareMetalServerNetworkAttachmentParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network attachment identifier. */
    id: string;
  }

  /** Parameters for the `getBareMetalServerNetworkAttachment` operation. */
  export interface GetBareMetalServerNetworkAttachmentParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network attachment identifier. */
    id: string;
  }

  /** Parameters for the `updateBareMetalServerNetworkAttachment` operation. */
  export interface UpdateBareMetalServerNetworkAttachmentParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network attachment identifier. */
    id: string;
    /** The VLAN IDs to allow for `vlan` attachments using this PCI attachment, replacing any existing VLAN IDs. The
     *  specified values must include IDs for all `vlan` attachments currently using this PCI attachment.
     */
    allowedVlans?: number[];
    /** The name for this network attachment. The name must not be used by another network attachment for the bare
     *  metal server.
     */
    name?: string;
  }

  /** Parameters for the `listBareMetalServerNetworkInterfaces` operation. */
  export interface ListBareMetalServerNetworkInterfacesParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createBareMetalServerNetworkInterface` operation. */
  export interface CreateBareMetalServerNetworkInterfaceParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface prototype object. */
    bareMetalServerNetworkInterfacePrototype: BareMetalServerNetworkInterfacePrototype;
  }

  /** Parameters for the `deleteBareMetalServerNetworkInterface` operation. */
  export interface DeleteBareMetalServerNetworkInterfaceParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    id: string;
  }

  /** Parameters for the `getBareMetalServerNetworkInterface` operation. */
  export interface GetBareMetalServerNetworkInterfaceParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    id: string;
  }

  /** Parameters for the `updateBareMetalServerNetworkInterface` operation. */
  export interface UpdateBareMetalServerNetworkInterfaceParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    id: string;
    /** Indicates whether source IP spoofing is allowed on this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and source IP spoofing is managed
     *  on the attached virtual network interface.
     */
    allowIpSpoofing?: boolean;
    /** The VLAN IDs to allow for `vlan` interfaces using this PCI interface, replacing any existing VLAN IDs. The
     *  specified values must include IDs for all `vlan` interfaces currently using this PCI interface.
     */
    allowedVlans?: number[];
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the bare metal server network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - `interface_type` must not be `hipersocket`.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and infrastructure NAT is managed
     *  on the attached virtual network interface.
     */
    enableInfrastructureNat?: boolean;
    /** The name for this bare metal server network interface. The name must not be used by another network
     *  interface on the bare metal server.
     */
    name?: string;
  }

  /** Parameters for the `listBareMetalServerNetworkInterfaceFloatingIps` operation. */
  export interface ListBareMetalServerNetworkInterfaceFloatingIpsParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
  }

  /** Parameters for the `removeBareMetalServerNetworkInterfaceFloatingIp` operation. */
  export interface RemoveBareMetalServerNetworkInterfaceFloatingIpParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
  }

  /** Parameters for the `getBareMetalServerNetworkInterfaceFloatingIp` operation. */
  export interface GetBareMetalServerNetworkInterfaceFloatingIpParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
  }

  /** Parameters for the `addBareMetalServerNetworkInterfaceFloatingIp` operation. */
  export interface AddBareMetalServerNetworkInterfaceFloatingIpParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
  }

  /** Parameters for the `listBareMetalServerNetworkInterfaceIps` operation. */
  export interface ListBareMetalServerNetworkInterfaceIpsParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
  }

  /** Parameters for the `getBareMetalServerNetworkInterfaceIp` operation. */
  export interface GetBareMetalServerNetworkInterfaceIpParams extends DefaultParams {
    /** The bare metal server identifier. */
    bareMetalServerId: string;
    /** The bare metal server network interface identifier. */
    networkInterfaceId: string;
    /** The reserved IP identifier. */
    id: string;
  }

  /** Parameters for the `deleteBareMetalServer` operation. */
  export interface DeleteBareMetalServerParams extends DefaultParams {
    /** The bare metal server identifier. */
    id: string;
  }

  /** Parameters for the `getBareMetalServer` operation. */
  export interface GetBareMetalServerParams extends DefaultParams {
    /** The bare metal server identifier. */
    id: string;
  }

  /** Parameters for the `updateBareMetalServer` operation. */
  export interface UpdateBareMetalServerParams extends DefaultParams {
    /** The bare metal server identifier. */
    id: string;
    /** The total bandwidth (in megabits per second) shared across the bare metal server's network interfaces. The
     *  specified value must match one of the bandwidth values in the bare metal server's profile.
     */
    bandwidth?: number;
    /** Indicates whether secure boot is enabled. If enabled, the image must support secure boot or the bare metal
     *  server will fail to boot.
     *
     *  For `enable_secure_boot` to be changed, the bare metal server `status` must be
     *  `stopped`.
     */
    enableSecureBoot?: boolean;
    /** The name for this bare metal server. The name must not be used by another bare metal server in the region.
     *  Changing the name will not affect the system hostname.
     */
    name?: string;
    reservationAffinity?: BareMetalServerReservationAffinityPatch;
    trustedPlatformModule?: BareMetalServerTrustedPlatformModulePatch;
  }

  /** Parameters for the `updateFirmwareForBareMetalServer` operation. */
  export interface UpdateFirmwareForBareMetalServerParams extends DefaultParams {
    /** The bare metal server identifier. */
    id: string;
    /** Indicates whether to automatically start the bare metal server after the firmware update is successfully
     *  completed.
     */
    autoStart?: boolean;
  }

  /** Parameters for the `getBareMetalServerInitialization` operation. */
  export interface GetBareMetalServerInitializationParams extends DefaultParams {
    /** The bare metal server identifier. */
    id: string;
  }

  /** Parameters for the `replaceBareMetalServerInitialization` operation. */
  export interface ReplaceBareMetalServerInitializationParams extends DefaultParams {
    /** The bare metal server identifier. */
    id: string;
    /** The image to be used when provisioning the bare metal server. */
    image: ImageIdentity;
    /** The public SSH keys to install on the bare metal server. Keys will be made available to the bare metal
     *  server as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as SSH authorized
     *  keys for the [default
     *  user](https://cloud.ibm.com/docs/vpc?topic=vpc-vsi_is_connecting_linux#determining-default-user-account).
     *
     *  For Windows images, at least one key must be specified, and one will be selected to encrypt the administrator
     *  password. Keys are optional for other images, but if no keys are specified, the bare metal server will be
     *  inaccessible unless the specified image provides another means of access.
     */
    keys: KeyIdentity[];
    /** User data to be made available when initializing the bare metal server.
     *
     *  If unspecified, no user data will be made available.
     */
    userData?: string;
  }

  /** Parameters for the `restartBareMetalServer` operation. */
  export interface RestartBareMetalServerParams extends DefaultParams {
    /** The bare metal server identifier. */
    id: string;
  }

  /** Parameters for the `startBareMetalServer` operation. */
  export interface StartBareMetalServerParams extends DefaultParams {
    /** The bare metal server identifier. */
    id: string;
  }

  /** Parameters for the `stopBareMetalServer` operation. */
  export interface StopBareMetalServerParams extends DefaultParams {
    /** The bare metal server identifier. */
    id: string;
    /** The type of stop operation:
     *  - `soft`: signal running operating system to quiesce and shutdown cleanly
     *  - `hard`: immediately stop the server.
     */
    type: StopBareMetalServerConstants.Type | string;
  }

  /** Constants for the `stopBareMetalServer` operation. */
  export namespace StopBareMetalServerConstants {
    /** The type of stop operation: - `soft`: signal running operating system to quiesce and shutdown cleanly - `hard`: immediately stop the server. */
    export enum Type {
      HARD = 'hard',
      SOFT = 'soft',
    }
  }

  /** Parameters for the `listVolumeProfiles` operation. */
  export interface ListVolumeProfilesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `getVolumeProfile` operation. */
  export interface GetVolumeProfileParams extends DefaultParams {
    /** The volume profile name. */
    name: string;
  }

  /** Parameters for the `listVolumes` operation. */
  export interface ListVolumesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to volumes with an `attachment_state` property matching the specified value. */
    attachmentState?: ListVolumesConstants.AttachmentState | string;
    /** Filters the collection to resources with an `encryption` property matching the specified value. */
    encryption?: ListVolumesConstants.Encryption | string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to resources with an `operating_system.family` property matching the specified
     *  operating system family.
     *
     *  This parameter also supports the values `null` and `not:null` which filter the collection to resources which
     *  have no operating system or any operating system, respectively.
     */
    operatingSystemFamily?: string;
    /** Filters the collection to resources with an `operating_system.architecture` property matching the specified
     *  operating system architecture.
     *
     *  This parameter also supports the values `null` and `not:null` which filter the collection to resources which
     *  have no operating system or any operating system, respectively.
     */
    operatingSystemArchitecture?: string;
    /** Filters the collection to resources with an item in the `tags` property matching the exact specified tag. */
    tag?: string;
    /** Filters the collection to resources with a `zone.name` property matching the exact specified name. */
    zoneName?: string;
  }

  /** Constants for the `listVolumes` operation. */
  export namespace ListVolumesConstants {
    /** Filters the collection to volumes with an `attachment_state` property matching the specified value. */
    export enum AttachmentState {
      ATTACHED = 'attached',
      UNATTACHED = 'unattached',
      UNUSABLE = 'unusable',
    }
    /** Filters the collection to resources with an `encryption` property matching the specified value. */
    export enum Encryption {
      PROVIDER_MANAGED = 'provider_managed',
      USER_MANAGED = 'user_managed',
    }
  }

  /** Parameters for the `createVolume` operation. */
  export interface CreateVolumeParams extends DefaultParams {
    /** The volume prototype object. */
    volumePrototype: VolumePrototype;
  }

  /** Parameters for the `deleteVolume` operation. */
  export interface DeleteVolumeParams extends DefaultParams {
    /** The volume identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getVolume` operation. */
  export interface GetVolumeParams extends DefaultParams {
    /** The volume identifier. */
    id: string;
  }

  /** Parameters for the `updateVolume` operation. */
  export interface UpdateVolumeParams extends DefaultParams {
    /** The volume identifier. */
    id: string;
    /** The maximum bandwidth (in megabits per second) for the volume.
     *
     *  If specified, the volume profile must not have a `bandwidth.type` of `dependent`.
     */
    bandwidth?: number;
    /** The capacity to use for the volume (in gigabytes). For the capacity to be changed the volume's current
     *  `attachment_state` must be one of the values included in
     *  `adjustable_capacity_states`. If `adjustable_capacity_states` is empty, then the volume capacity cannot be
     *  changed.  Additionally:
     *  - The specified value must not be less than the current capacity.
     *  - If the volume is attached as a boot volume, the specified value must not exceed
     *    the `boot_capacity.max` of the volume profile.
     *  - If the volume is attached as a data volume, the specified value must not exceed
     *    the `capacity.max` of the volume profile.
     */
    capacity?: number;
    /** The maximum I/O operations per second (IOPS) to use for this volume.  For the IOPS to be changed the
     *  volume's current `attachment_state` must be one of the values included in `adjustable_iops_states`. If
     *  `adjustable_iops_states` is empty, then the IOPS cannot be changed.
     */
    iops?: number;
    /** The name for this volume. The name must not be used by another volume in the region. */
    name?: string;
    /** The profile to use for this volume. The requested profile must have the same
     *  `family` and `storage_generation` values as the current profile. Additionally:
     *  - If the volume is a boot volume then the value specified for `capacity` property
     *  must not be less than the `boot_capacity.min` and must not exceed the
     *  `boot_capacity.max` of the specified volume profile.
     *  - If the volume is a data volume then the value specified for `capacity` property
     *  must not be less than the `capacity.min` and must not exceed the `capacity.max`
     *  of the specified volume profile.
     */
    profile?: VolumeProfileIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume (replacing
     *  any existing tags).
     */
    userTags?: string[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Parameters for the `listSnapshotConsistencyGroups` operation. */
  export interface ListSnapshotConsistencyGroupsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListSnapshotConsistencyGroupsConstants.Sort | string;
    /** Filters the collection to backup policy jobs with a `backup_policy_plan.id` property matching the specified
     *  identifier.
     */
    backupPolicyPlanId?: string;
  }

  /** Constants for the `listSnapshotConsistencyGroups` operation. */
  export namespace ListSnapshotConsistencyGroupsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createSnapshotConsistencyGroup` operation. */
  export interface CreateSnapshotConsistencyGroupParams extends DefaultParams {
    /** The snapshot consistency group prototype object. */
    snapshotConsistencyGroupPrototype: SnapshotConsistencyGroupPrototype;
  }

  /** Parameters for the `deleteSnapshotConsistencyGroup` operation. */
  export interface DeleteSnapshotConsistencyGroupParams extends DefaultParams {
    /** The snapshot consistency group identifier. */
    id: string;
  }

  /** Parameters for the `getSnapshotConsistencyGroup` operation. */
  export interface GetSnapshotConsistencyGroupParams extends DefaultParams {
    /** The snapshot consistency group identifier. */
    id: string;
  }

  /** Parameters for the `updateSnapshotConsistencyGroup` operation. */
  export interface UpdateSnapshotConsistencyGroupParams extends DefaultParams {
    /** The snapshot consistency group identifier. */
    id: string;
    /** Indicates whether deleting the snapshot consistency group will also delete the snapshots in the group. */
    deleteSnapshotsOnDelete?: boolean;
    /** The name for this snapshot consistency group. The name must not be used by another snapshot consistency
     *  groups in the region.
     */
    name?: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Parameters for the `deleteSnapshots` operation. */
  export interface DeleteSnapshotsParams extends DefaultParams {
    /** Filters the collection to resources with a `source_volume.id` property matching the specified identifier. */
    sourceVolumeId: string;
  }

  /** Parameters for the `listSnapshots` operation. */
  export interface ListSnapshotsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with an item in the `tags` property matching the exact specified tag. */
    tag?: string;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to resources with a `source_volume.id` property matching the specified identifier. */
    sourceVolumeId?: string;
    /** Filters the collection to resources with a `source_volume.crn` property matching the specified CRN. */
    sourceVolumeCrn?: string;
    /** Filters the collection to resources with a `source_image.id` property matching the specified identifier.
     *
     *  This parameter also supports the values `null` and `not:null` which filter the collection to resources which
     *  have no source image or any existent source image, respectively.
     */
    sourceImageId?: string;
    /** Filters the collection to resources with a `source_image.crn` property matching the specified CRN.
     *
     *  This parameter also supports the values `null` and `not:null` which filter the collection to resources which
     *  have no source image or any existent source image, respectively.
     */
    sourceImageCrn?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListSnapshotsConstants.Sort | string;
    /** Filters the collection to backup policy jobs with a `backup_policy_plan.id` property matching the specified
     *  identifier.
     */
    backupPolicyPlanId?: string;
    /** Filters the collection to snapshots with an item in the `copies` property with an `id` property matching the
     *  specified identifier.
     */
    copiesId?: string;
    /** Filters the collection to snapshots with an item in the `copies` property with a `name` property matching
     *  the exact specified name.
     */
    copiesName?: string;
    /** Filters the collection to snapshots with an item in the `copies` property with a `crn` property matching the
     *  specified CRN.
     */
    copiesCrn?: string;
    /** Filters the collection to snapshots with an item in the `copies` property with a
     *  `remote.region.name` property matching the exact specified name.
     */
    copiesRemoteRegionName?: string;
    /** Filters the collection to resources with a `source_snapshot.id` property matching the specified identifier. */
    sourceSnapshotId?: string;
    /** Filters the collection to resources with a `source_snapshot.remote.region.name` property matching the exact
     *  specified name.
     */
    sourceSnapshotRemoteRegionName?: string;
    /** Filters the collection to resources with a `source_volume.remote.region.name` property matching the exact
     *  specified name.
     */
    sourceVolumeRemoteRegionName?: string;
    /** Filters the collection to resources with a `source_image.remote.region.name` property matching the exact
     *  specified name.
     */
    sourceImageRemoteRegionName?: string;
    /** Filters the collection to snapshots with an item in the `clones` property with a `zone.name` property
     *  matching the exact specified name.
     */
    clonesZoneName?: string;
    /** Filters the collection to resources with a `snapshot_consistency_group.id` property matching the specified
     *  identifier.
     */
    snapshotConsistencyGroupId?: string;
    /** Filters the collection to resources with a `snapshot_consistency_group.crn` property matching the specified
     *  identifier.
     */
    snapshotConsistencyGroupCrn?: string;
  }

  /** Constants for the `listSnapshots` operation. */
  export namespace ListSnapshotsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createSnapshot` operation. */
  export interface CreateSnapshotParams extends DefaultParams {
    /** The snapshot prototype object. */
    snapshotPrototype: SnapshotPrototype;
  }

  /** Parameters for the `deleteSnapshot` operation. */
  export interface DeleteSnapshotParams extends DefaultParams {
    /** The snapshot identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getSnapshot` operation. */
  export interface GetSnapshotParams extends DefaultParams {
    /** The snapshot identifier. */
    id: string;
  }

  /** Parameters for the `updateSnapshot` operation. */
  export interface UpdateSnapshotParams extends DefaultParams {
    /** The snapshot identifier. */
    id: string;
    /** The name for this snapshot. The name must not be used by another snapshot in the region. */
    name?: string;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot. */
    userTags?: string[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Parameters for the `listSnapshotClones` operation. */
  export interface ListSnapshotClonesParams extends DefaultParams {
    /** The snapshot identifier. */
    id: string;
  }

  /** Parameters for the `deleteSnapshotClone` operation. */
  export interface DeleteSnapshotCloneParams extends DefaultParams {
    /** The snapshot identifier. */
    id: string;
    /** The zone name. */
    zoneName: string;
  }

  /** Parameters for the `getSnapshotClone` operation. */
  export interface GetSnapshotCloneParams extends DefaultParams {
    /** The snapshot identifier. */
    id: string;
    /** The zone name. */
    zoneName: string;
  }

  /** Parameters for the `createSnapshotClone` operation. */
  export interface CreateSnapshotCloneParams extends DefaultParams {
    /** The snapshot identifier. */
    id: string;
    /** The zone name. */
    zoneName: string;
  }

  /** Parameters for the `listShareProfiles` operation. */
  export interface ListShareProfilesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListShareProfilesConstants.Sort | string;
  }

  /** Constants for the `listShareProfiles` operation. */
  export namespace ListShareProfilesConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `getShareProfile` operation. */
  export interface GetShareProfileParams extends DefaultParams {
    /** The file share profile name. */
    name: string;
  }

  /** Parameters for the `listShares` operation. */
  export interface ListSharesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListSharesConstants.Sort | string;
    /** Filters the collection to file shares with a `replication_role` property matching the specified value. */
    replicationRole?: ListSharesConstants.ReplicationRole | string;
  }

  /** Constants for the `listShares` operation. */
  export namespace ListSharesConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
    /** Filters the collection to file shares with a `replication_role` property matching the specified value. */
    export enum ReplicationRole {
      NONE = 'none',
      REPLICA = 'replica',
      SOURCE = 'source',
    }
  }

  /** Parameters for the `createShare` operation. */
  export interface CreateShareParams extends DefaultParams {
    /** The file share prototype object. */
    sharePrototype: SharePrototype;
  }

  /** Parameters for the `deleteShare` operation. */
  export interface DeleteShareParams extends DefaultParams {
    /** The file share identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getShare` operation. */
  export interface GetShareParams extends DefaultParams {
    /** The file share identifier. */
    id: string;
  }

  /** Parameters for the `updateShare` operation. */
  export interface UpdateShareParams extends DefaultParams {
    /** The file share identifier. */
    id: string;
    /** The access control mode for the share:
     *
     *  - `security_group`: The security groups on the virtual network interface for a
     *    mount target control access to the mount target.
     *  - `vpc`: All clients in the VPC for a mount target have access to the mount target.
     *
     *  For this property to be changed, the share must have no mount targets,
     *  `replication_role` must be `none` and `accessor_binding_role` must not be `accessor`.
     */
    accessControlMode?: UpdateShareConstants.AccessControlMode | string;
    /** The transit encryption modes to allow for this share
     *  (replacing the existing allowed transit encryption modes). The specified transit encryption modes must contain
     *  all transit_encryption modes specified by existing mount targets.
     *
     *  For this property to be updated, the `accessor_binding_role` must be `none`.
     */
    allowedTransitEncryptionModes?: UpdateShareConstants.AllowedTransitEncryptionModes[] | string[];
    /** The maximum input/output operations per second (IOPS) for the file share.
     *
     *  The maximum IOPS for a share may increase in the future. For this property to be changed, the share
     *  `accessor_binding_role` must not be `accessor`, the share profile must not have an `iops.type` of `dependent` or
     *  `fixed`, and the specified value must be within the `iops` range of the share's profile supported by the share's
     *  size.
     */
    iops?: number;
    /** The name for this share. The name must not be used by another share in the region. */
    name?: string;
    /** The profile to use for this file share.
     *
     *  The requested profile must be in the same `family`.
     */
    profile?: ShareProfileIdentity;
    /** The cron specification for the file share replication schedule.
     *
     *  Replication of a share can be scheduled to occur at most once every 15 minutes.
     *
     *  For this property to be changed, the share `replication_role` must be `replica`.
     */
    replicationCronSpec?: string;
    /** The size of the file share (in gigabytes), excluding share snapshots. The value must not be less than the
     *  share's current size, and must not exceed the maximum supported by the share's profile and IOPS.
     *
     *  For this property to be changed:
     *  - The share `lifecycle_state` must be `stable`
     *  - The share `replication_role` must not be `replica`
     *  - The share `accessor_binding_role` must not be `accessor`.
     */
    size?: number;
    /** Tags for this resource. */
    userTags?: string[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Constants for the `updateShare` operation. */
  export namespace UpdateShareConstants {
    /** The access control mode for the share: - `security_group`: The security groups on the virtual network interface for a mount target control access to the mount target. - `vpc`: All clients in the VPC for a mount target have access to the mount target. For this property to be changed, the share must have no mount targets, `replication_role` must be `none` and `accessor_binding_role` must not be `accessor`. */
    export enum AccessControlMode {
      SECURITY_GROUP = 'security_group',
      VPC = 'vpc',
    }
    /** AllowedTransitEncryptionModes */
    export enum AllowedTransitEncryptionModes {
      NONE = 'none',
      USER_MANAGED = 'user_managed',
    }
  }

  /** Parameters for the `listShareAccessorBindings` operation. */
  export interface ListShareAccessorBindingsParams extends DefaultParams {
    /** The file share identifier. */
    id: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `deleteShareAccessorBinding` operation. */
  export interface DeleteShareAccessorBindingParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** The file share accessor binding identifier. */
    id: string;
  }

  /** Parameters for the `getShareAccessorBinding` operation. */
  export interface GetShareAccessorBindingParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** The file share accessor binding identifier. */
    id: string;
  }

  /** Parameters for the `failoverShare` operation. */
  export interface FailoverShareParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** The action to take if the failover request is accepted but cannot be performed or times out:
     *  - `fail`: Fail the operation, resulting in the replication relationship being unchanged.
     *  - `split`: Split the replica from its source, resulting in two individual read-write
     *      file shares. Because the final sync was not completed, the replica may be
     *      out-of-date. This occurs in disaster recovery scenarios where the source is known to
     *      be unreachable.
     */
    fallbackPolicy?: FailoverShareConstants.FallbackPolicy | string;
    /** The failover timeout in seconds.
     *
     *  If the timeout is reached, the `fallback_policy` will be triggered.
     */
    timeout?: number;
  }

  /** Constants for the `failoverShare` operation. */
  export namespace FailoverShareConstants {
    /** The action to take if the failover request is accepted but cannot be performed or times out: - `fail`: Fail the operation, resulting in the replication relationship being unchanged. - `split`: Split the replica from its source, resulting in two individual read-write file shares. Because the final sync was not completed, the replica may be out-of-date. This occurs in disaster recovery scenarios where the source is known to be unreachable. */
    export enum FallbackPolicy {
      FAIL = 'fail',
      SPLIT = 'split',
    }
  }

  /** Parameters for the `listShareMountTargets` operation. */
  export interface ListShareMountTargetsParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createShareMountTarget` operation. */
  export interface CreateShareMountTargetParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** The share mount target prototype object. */
    shareMountTargetPrototype: ShareMountTargetPrototype;
  }

  /** Parameters for the `deleteShareMountTarget` operation. */
  export interface DeleteShareMountTargetParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** The file share mount target identifier. */
    id: string;
  }

  /** Parameters for the `getShareMountTarget` operation. */
  export interface GetShareMountTargetParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** The file share mount target identifier. */
    id: string;
  }

  /** Parameters for the `updateShareMountTarget` operation. */
  export interface UpdateShareMountTargetParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** The file share mount target identifier. */
    id: string;
    /** The name for this share mount target. The name must not be used by another mount target for the file share. */
    name?: string;
  }

  /** Parameters for the `listShareSnapshots` operation. */
  export interface ListShareSnapshotsParams extends DefaultParams {
    /** The file share identifier, or `-` to wildcard all accessible file shares. */
    shareId: string;
    /** Filters the collection to backup policy jobs with a `backup_policy_plan.id` property matching the specified
     *  identifier.
     */
    backupPolicyPlanId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListShareSnapshotsConstants.Sort | string;
  }

  /** Constants for the `listShareSnapshots` operation. */
  export namespace ListShareSnapshotsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createShareSnapshot` operation. */
  export interface CreateShareSnapshotParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** The name for this share snapshot. The name must not be used by another snapshot for the file share. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this share snapshot. */
    userTags?: string[];
  }

  /** Parameters for the `deleteShareSnapshot` operation. */
  export interface DeleteShareSnapshotParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** The share snapshot identifier. */
    id: string;
  }

  /** Parameters for the `getShareSnapshot` operation. */
  export interface GetShareSnapshotParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** The share snapshot identifier. */
    id: string;
  }

  /** Parameters for the `updateShareSnapshot` operation. */
  export interface UpdateShareSnapshotParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
    /** The share snapshot identifier. */
    id: string;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this share snapshot. */
    userTags?: string[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Parameters for the `deleteShareSource` operation. */
  export interface DeleteShareSourceParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
  }

  /** Parameters for the `getShareSource` operation. */
  export interface GetShareSourceParams extends DefaultParams {
    /** The file share identifier. */
    shareId: string;
  }

  /** Parameters for the `listBackupPolicies` operation. */
  export interface ListBackupPoliciesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to resources with an item in the `tags` property matching the exact specified tag. */
    tag?: string;
  }

  /** Parameters for the `createBackupPolicy` operation. */
  export interface CreateBackupPolicyParams extends DefaultParams {
    /** The backup policy prototype object. */
    backupPolicyPrototype: BackupPolicyPrototype;
  }

  /** Parameters for the `listBackupPolicyJobs` operation. */
  export interface ListBackupPolicyJobsParams extends DefaultParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** Filters the collection to backup policy jobs with a `status` property matching the specified value. */
    status?: ListBackupPolicyJobsConstants.Status | string;
    /** Filters the collection to backup policy jobs with a `backup_policy_plan.id` property matching the specified
     *  identifier.
     */
    backupPolicyPlanId?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListBackupPolicyJobsConstants.Sort | string;
    /** Filters the collection to backup policy jobs with a `source.id` property matching the specified identifier. */
    sourceId?: string;
    /** Filters the collection to backup policy jobs with an item in the `target_snapshots` property with an `id`
     *  property matching the specified identifier.
     */
    targetSnapshotsId?: string;
    /** Filters the collection to backup policy jobs with an item in the `target_snapshots` property with a `crn`
     *  property matching the specified CRN.
     */
    targetSnapshotsCrn?: string;
  }

  /** Constants for the `listBackupPolicyJobs` operation. */
  export namespace ListBackupPolicyJobsConstants {
    /** Filters the collection to backup policy jobs with a `status` property matching the specified value. */
    export enum Status {
      FAILED = 'failed',
      RUNNING = 'running',
      SUCCEEDED = 'succeeded',
    }
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `getBackupPolicyJob` operation. */
  export interface GetBackupPolicyJobParams extends DefaultParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** The backup policy job identifier. */
    id: string;
  }

  /** Parameters for the `listBackupPolicyPlans` operation. */
  export interface ListBackupPolicyPlansParams extends DefaultParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
  }

  /** Parameters for the `createBackupPolicyPlan` operation. */
  export interface CreateBackupPolicyPlanParams extends DefaultParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** The cron specification for the backup schedule. The backup policy jobs
     *  (which create and delete backups for this plan) will not start until this time, and may start for up to 90
     *  minutes after this time.
     *
     *  All backup schedules for plans in the same policy must be at least an hour apart.
     */
    cronSpec: string;
    /** Indicates whether the plan is active. */
    active?: boolean;
    /** User tags to attach to each backup (snapshot) created by this plan. If unspecified, no user tags will be
     *  attached.
     */
    attachUserTags?: string[];
    clonePolicy?: BackupPolicyPlanClonePolicyPrototype;
    /** Indicates whether to copy the source's user tags to the created backups (snapshots). */
    copyUserTags?: boolean;
    deletionTrigger?: BackupPolicyPlanDeletionTriggerPrototype;
    /** The name for this backup policy plan. The name must not be used by another plan for the backup policy. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The policies for additional backups in remote regions. */
    remoteRegionPolicies?: BackupPolicyPlanRemoteRegionPolicyPrototype[];
  }

  /** Parameters for the `deleteBackupPolicyPlan` operation. */
  export interface DeleteBackupPolicyPlanParams extends DefaultParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** The backup policy plan identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getBackupPolicyPlan` operation. */
  export interface GetBackupPolicyPlanParams extends DefaultParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** The backup policy plan identifier. */
    id: string;
  }

  /** Parameters for the `updateBackupPolicyPlan` operation. */
  export interface UpdateBackupPolicyPlanParams extends DefaultParams {
    /** The backup policy identifier. */
    backupPolicyId: string;
    /** The backup policy plan identifier. */
    id: string;
    /** Indicates whether the plan is active. */
    active?: boolean;
    /** The user tags to attach to backups (snapshots) created by this plan. Updating this value does not change the
     *  user tags for backups that have already been created by this plan.
     */
    attachUserTags?: string[];
    clonePolicy?: BackupPolicyPlanClonePolicyPatch;
    /** Indicates whether to copy the source's user tags to the created backups (snapshots). */
    copyUserTags?: boolean;
    /** The cron specification for the backup schedule. The backup policy jobs
     *  (which create and delete backups for this plan) will not start until this time, and may start for up to 90
     *  minutes after this time.
     *
     *  All backup schedules for plans in the same policy must be at least an hour apart.
     */
    cronSpec?: string;
    deletionTrigger?: BackupPolicyPlanDeletionTriggerPatch;
    /** The name for this backup policy plan. The name must not be used by another plan for the backup policy. */
    name?: string;
    /** The policies for additional backups in remote regions (replacing any existing policies). */
    remoteRegionPolicies?: BackupPolicyPlanRemoteRegionPolicyPrototype[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Parameters for the `deleteBackupPolicy` operation. */
  export interface DeleteBackupPolicyParams extends DefaultParams {
    /** The backup policy identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getBackupPolicy` operation. */
  export interface GetBackupPolicyParams extends DefaultParams {
    /** The backup policy identifier. */
    id: string;
  }

  /** Parameters for the `updateBackupPolicy` operation. */
  export interface UpdateBackupPolicyParams extends DefaultParams {
    /** The backup policy identifier. */
    id: string;
    /** The included content for backups created using this policy:
     *  - `boot_volume`: Include the instance's boot volume.
     *  - `data_volumes`: Include the instance's data volumes.
     */
    includedContent?: UpdateBackupPolicyConstants.IncludedContent[] | string[];
    /** The user tags this backup policy will apply to (replacing any existing tags). Resources that have both a
     *  matching user tag and a matching type will be subject to the backup policy.
     */
    matchUserTags?: string[];
    /** The name for this backup policy. The name must not be used by another backup policy in the region. */
    name?: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Constants for the `updateBackupPolicy` operation. */
  export namespace UpdateBackupPolicyConstants {
    /** An item to include. */
    export enum IncludedContent {
      BOOT_VOLUME = 'boot_volume',
      DATA_VOLUMES = 'data_volumes',
    }
  }

  /** Parameters for the `listRegions` operation. */
  export interface ListRegionsParams extends DefaultParams {
  }

  /** Parameters for the `getRegion` operation. */
  export interface GetRegionParams extends DefaultParams {
    /** The region name. */
    name: string;
  }

  /** Parameters for the `listRegionZones` operation. */
  export interface ListRegionZonesParams extends DefaultParams {
    /** The region name. */
    regionName: string;
  }

  /** Parameters for the `getRegionZone` operation. */
  export interface GetRegionZoneParams extends DefaultParams {
    /** The region name. */
    regionName: string;
    /** The zone name. */
    name: string;
  }

  /** Parameters for the `listVirtualNetworkInterfaces` operation. */
  export interface ListVirtualNetworkInterfacesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
  }

  /** Parameters for the `createVirtualNetworkInterface` operation. */
  export interface CreateVirtualNetworkInterfaceParams extends DefaultParams {
    /** Indicates whether source IP spoofing is allowed on this interface. If `false`, source IP spoofing is
     *  prevented on this interface. If `true`, source IP spoofing is allowed on this interface.
     */
    allowIpSpoofing?: boolean;
    /** Indicates whether this virtual network interface will be automatically deleted when
     *  `target` is deleted. Must be `false` if the virtual network interface is unbound.
     */
    autoDelete?: boolean;
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the virtual network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - Can only be attached to a `target` with a `resource_type` of
     *    `bare_metal_server_network_attachment`.
     */
    enableInfrastructureNat?: boolean;
    /** Additional IP addresses to bind to the virtual network interface. Each item may be either a reserved IP
     *  identity, or a reserved IP prototype object which will be used to create a new reserved IP. All IP addresses
     *  must be in the primary IP's subnet.
     *
     *  If reserved IP identities are provided, the specified reserved IPs must be unbound.
     *
     *  If reserved IP prototype objects with addresses are provided, the addresses must be available on the virtual
     *  network interface's subnet. For any prototype objects that do not specify an address, an available address on
     *  the subnet will be automatically selected and reserved.
     */
    ips?: VirtualNetworkInterfaceIPPrototype[];
    /** The name for this virtual network interface. The name must not be used by another virtual network interface
     *  in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words. Names beginning with
     *  `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
    /** The primary IP address to bind to the virtual network interface. May be either a
     *  reserved IP identity, or a reserved IP prototype object which will be used to create a
     *  new reserved IP.
     *
     *  If a reserved IP identity is provided, the specified reserved IP must be unbound.
     *
     *  If a reserved IP prototype object with an address is provided, the address must be
     *  available on the virtual network interface's subnet. If no address is specified,
     *  an available address on the subnet will be automatically selected and reserved.
     */
    primaryIp?: VirtualNetworkInterfacePrimaryIPPrototype;
    /** The protocol state filtering mode to use for this virtual network interface. If
     *  `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target`
     *  resource type:
     *
     *  - `bare_metal_server_network_attachment`: disabled
     *  - `instance_network_attachment`: enabled
     *  - `share_mount_target`: enabled
     *
     *  Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops
     *  any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering
     *  mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information.
     */
    protocolStateFilteringMode?: CreateVirtualNetworkInterfaceConstants.ProtocolStateFilteringMode | string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** The security groups to use for this virtual network interface. If unspecified, the default security group of
     *  the VPC for the subnet is used.
     */
    securityGroups?: SecurityGroupIdentity[];
    /** The associated subnet. Required if `primary_ip` does not specify a reserved IP identity. */
    subnet?: SubnetIdentity;
  }

  /** Constants for the `createVirtualNetworkInterface` operation. */
  export namespace CreateVirtualNetworkInterfaceConstants {
    /** The protocol state filtering mode to use for this virtual network interface. If `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target` resource type: - `bare_metal_server_network_attachment`: disabled - `instance_network_attachment`: enabled - `share_mount_target`: enabled Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information. */
    export enum ProtocolStateFilteringMode {
      AUTO = 'auto',
      DISABLED = 'disabled',
      ENABLED = 'enabled',
    }
  }

  /** Parameters for the `deleteVirtualNetworkInterfaces` operation. */
  export interface DeleteVirtualNetworkInterfacesParams extends DefaultParams {
    /** The virtual network interface identifier. */
    id: string;
  }

  /** Parameters for the `getVirtualNetworkInterface` operation. */
  export interface GetVirtualNetworkInterfaceParams extends DefaultParams {
    /** The virtual network interface identifier. */
    id: string;
  }

  /** Parameters for the `updateVirtualNetworkInterface` operation. */
  export interface UpdateVirtualNetworkInterfaceParams extends DefaultParams {
    /** The virtual network interface identifier. */
    id: string;
    /** Indicates whether source IP spoofing is allowed on this interface.
     *
     *  Must be `false` if `target` is a file share mount target.
     */
    allowIpSpoofing?: boolean;
    /** Indicates whether this virtual network interface will be automatically deleted when
     *  `target` is deleted. Must be `false` if the virtual network interface is unbound.
     */
    autoDelete?: boolean;
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the virtual network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - Can only be attached to a `target` with a `resource_type` of
     *    `bare_metal_server_network_attachment`.
     */
    enableInfrastructureNat?: boolean;
    /** The name for this virtual network interface. The name must not be used by another virtual network interface
     *  in the region. Names beginning with `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
    /** The protocol state filtering mode to use for this virtual network interface. If
     *  `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target`
     *  resource type:
     *
     *  - `bare_metal_server_network_attachment`: disabled
     *  - `instance_network_attachment`: enabled
     *  - `share_mount_target`: enabled
     *
     *  Must not be `disabled` if the virtual network interface's `target` resource type is
     *  `share_mount_target`.
     *
     *  Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops
     *  any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering
     *  mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information.
     */
    protocolStateFilteringMode?: UpdateVirtualNetworkInterfaceConstants.ProtocolStateFilteringMode | string;
  }

  /** Constants for the `updateVirtualNetworkInterface` operation. */
  export namespace UpdateVirtualNetworkInterfaceConstants {
    /** The protocol state filtering mode to use for this virtual network interface. If `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target` resource type: - `bare_metal_server_network_attachment`: disabled - `instance_network_attachment`: enabled - `share_mount_target`: enabled Must not be `disabled` if the virtual network interface's `target` resource type is `share_mount_target`. Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information. */
    export enum ProtocolStateFilteringMode {
      AUTO = 'auto',
      DISABLED = 'disabled',
      ENABLED = 'enabled',
    }
  }

  /** Parameters for the `listNetworkInterfaceFloatingIps` operation. */
  export interface ListNetworkInterfaceFloatingIpsParams extends DefaultParams {
    /** The virtual network interface identifier. */
    virtualNetworkInterfaceId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value
     *  `-name` sorts the collection by the `name` property in descending order, and the value `name` sorts it by the
     *  `name` property in ascending order.
     */
    sort?: ListNetworkInterfaceFloatingIpsConstants.Sort | string;
  }

  /** Constants for the `listNetworkInterfaceFloatingIps` operation. */
  export namespace ListNetworkInterfaceFloatingIpsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-name` sorts the collection by the `name` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      ADDRESS = 'address',
      NAME = 'name',
    }
  }

  /** Parameters for the `removeNetworkInterfaceFloatingIp` operation. */
  export interface RemoveNetworkInterfaceFloatingIpParams extends DefaultParams {
    /** The virtual network interface identifier. */
    virtualNetworkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
  }

  /** Parameters for the `getNetworkInterfaceFloatingIp` operation. */
  export interface GetNetworkInterfaceFloatingIpParams extends DefaultParams {
    /** The virtual network interface identifier. */
    virtualNetworkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
  }

  /** Parameters for the `addNetworkInterfaceFloatingIp` operation. */
  export interface AddNetworkInterfaceFloatingIpParams extends DefaultParams {
    /** The virtual network interface identifier. */
    virtualNetworkInterfaceId: string;
    /** The floating IP identifier. */
    id: string;
  }

  /** Parameters for the `listVirtualNetworkInterfaceIps` operation. */
  export interface ListVirtualNetworkInterfaceIpsParams extends DefaultParams {
    /** The virtual network interface identifier. */
    virtualNetworkInterfaceId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value
     *  `-name` sorts the collection by the `name` property in descending order, and the value `name` sorts it by the
     *  `name` property in ascending order.
     */
    sort?: ListVirtualNetworkInterfaceIpsConstants.Sort | string;
  }

  /** Constants for the `listVirtualNetworkInterfaceIps` operation. */
  export namespace ListVirtualNetworkInterfaceIpsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-name` sorts the collection by the `name` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      ADDRESS = 'address',
      NAME = 'name',
    }
  }

  /** Parameters for the `removeVirtualNetworkInterfaceIp` operation. */
  export interface RemoveVirtualNetworkInterfaceIpParams extends DefaultParams {
    /** The virtual network interface identifier. */
    virtualNetworkInterfaceId: string;
    /** The reserved IP identifier. */
    id: string;
  }

  /** Parameters for the `getVirtualNetworkInterfaceIp` operation. */
  export interface GetVirtualNetworkInterfaceIpParams extends DefaultParams {
    /** The virtual network interface identifier. */
    virtualNetworkInterfaceId: string;
    /** The reserved IP identifier. */
    id: string;
  }

  /** Parameters for the `addVirtualNetworkInterfaceIp` operation. */
  export interface AddVirtualNetworkInterfaceIpParams extends DefaultParams {
    /** The virtual network interface identifier. */
    virtualNetworkInterfaceId: string;
    /** The reserved IP identifier. */
    id: string;
  }

  /** Parameters for the `listClusterNetworkProfiles` operation. */
  export interface ListClusterNetworkProfilesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `getClusterNetworkProfile` operation. */
  export interface GetClusterNetworkProfileParams extends DefaultParams {
    /** The cluster network profile name. */
    name: string;
  }

  /** Parameters for the `listClusterNetworks` operation. */
  export interface ListClusterNetworksParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListClusterNetworksConstants.Sort | string;
    /** Filters the collection to cluster networks with a `vpc.id` property matching the specified id. */
    vpcId?: string;
    /** Filters the collection to cluster networks with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to cluster networks with a `vpc.name` property matching the specified name. */
    vpcName?: string;
  }

  /** Constants for the `listClusterNetworks` operation. */
  export namespace ListClusterNetworksConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createClusterNetwork` operation. */
  export interface CreateClusterNetworkParams extends DefaultParams {
    /** The profile to use for this cluster network. */
    profile: ClusterNetworkProfileIdentity;
    /** The VPC this cluster network will reside in. */
    vpc: VPCIdentity;
    /** The zone this cluster network will reside in. The zone must be listed
     *  as supported on the specified cluster network profile.
     */
    zone: ZoneIdentity;
    /** The name for this cluster network. The name must not be used by another cluster network in the region. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
    subnetPrefixes?: ClusterNetworkSubnetPrefixPrototype[];
  }

  /** Parameters for the `listClusterNetworkInterfaces` operation. */
  export interface ListClusterNetworkInterfacesParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListClusterNetworkInterfacesConstants.Sort | string;
  }

  /** Constants for the `listClusterNetworkInterfaces` operation. */
  export namespace ListClusterNetworkInterfacesConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createClusterNetworkInterface` operation. */
  export interface CreateClusterNetworkInterfaceParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The name for this cluster network interface. The name must not be used by another interface in the cluster
     *  network. Names beginning with `ibm-` are reserved for provider-owned resources, and are not allowed. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The primary IP address to bind to the cluster network interface. May be either
     *  a cluster network subnet reserved IP identity, or a cluster network subnet reserved IP
     *  prototype object which will be used to create a new cluster network subnet reserved IP.
     *
     *  If a cluster network subnet reserved IP identity is provided, the specified cluster
     *  network subnet reserved IP must be unbound.
     *
     *  If a cluster network subnet reserved IP prototype object with an address is provided,
     *  the address must be available on the cluster network interface's cluster network
     *  subnet. If no address is specified, an available address on the cluster network subnet
     *  will be automatically selected and reserved.
     */
    primaryIp?: ClusterNetworkInterfacePrimaryIPPrototype;
    /** The associated cluster network subnet. Required if `primary_ip` does not specify a cluster
     *  network subnet reserved IP identity.
     */
    subnet?: ClusterNetworkSubnetIdentity;
  }

  /** Parameters for the `deleteClusterNetworkInterface` operation. */
  export interface DeleteClusterNetworkInterfaceParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network interface identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getClusterNetworkInterface` operation. */
  export interface GetClusterNetworkInterfaceParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network interface identifier. */
    id: string;
  }

  /** Parameters for the `updateClusterNetworkInterface` operation. */
  export interface UpdateClusterNetworkInterfaceParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network interface identifier. */
    id: string;
    /** Indicates whether this cluster network interface will be automatically deleted when `target` is deleted.
     *  Must be `false` if the cluster network interface is unbound.
     */
    autoDelete?: boolean;
    /** The name for this cluster network interface. The name must not be used by another interface in the cluster
     *  network. Names beginning with `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Parameters for the `listClusterNetworkSubnets` operation. */
  export interface ListClusterNetworkSubnetsParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListClusterNetworkSubnetsConstants.Sort | string;
  }

  /** Constants for the `listClusterNetworkSubnets` operation. */
  export namespace ListClusterNetworkSubnetsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createClusterNetworkSubnet` operation. */
  export interface CreateClusterNetworkSubnetParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network subnet prototype object. */
    clusterNetworkSubnetPrototype: ClusterNetworkSubnetPrototype;
  }

  /** Parameters for the `listClusterNetworkSubnetReservedIps` operation. */
  export interface ListClusterNetworkSubnetReservedIpsParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network subnet identifier. */
    clusterNetworkSubnetId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListClusterNetworkSubnetReservedIpsConstants.Sort | string;
  }

  /** Constants for the `listClusterNetworkSubnetReservedIps` operation. */
  export namespace ListClusterNetworkSubnetReservedIpsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      ADDRESS = 'address',
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createClusterNetworkSubnetReservedIp` operation. */
  export interface CreateClusterNetworkSubnetReservedIpParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network subnet identifier. */
    clusterNetworkSubnetId: string;
    /** The IP address to reserve, which must not already be reserved on the subnet.
     *
     *  If unspecified, an available address on the subnet will automatically be selected.
     */
    address?: string;
    /** The name for this cluster network subnet reserved IP. The name must not be used by another reserved IP in
     *  the cluster network subnet. Names starting with `ibm-` are reserved for provider-owned resources, and are not
     *  allowed. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /** Parameters for the `deleteClusterNetworkSubnetReservedIp` operation. */
  export interface DeleteClusterNetworkSubnetReservedIpParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network subnet identifier. */
    clusterNetworkSubnetId: string;
    /** The cluster network subnet reserved IP identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getClusterNetworkSubnetReservedIp` operation. */
  export interface GetClusterNetworkSubnetReservedIpParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network subnet identifier. */
    clusterNetworkSubnetId: string;
    /** The cluster network subnet reserved IP identifier. */
    id: string;
  }

  /** Parameters for the `updateClusterNetworkSubnetReservedIp` operation. */
  export interface UpdateClusterNetworkSubnetReservedIpParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network subnet identifier. */
    clusterNetworkSubnetId: string;
    /** The cluster network subnet reserved IP identifier. */
    id: string;
    /** Indicates whether this cluster network subnet reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the cluster network subnet reserved IP is unbound. Must be `false` if the cluster
     *  network subnet reserved IP is unbound.
     */
    autoDelete?: boolean;
    /** The name for this cluster network subnet reserved IP. The name must not be used by another reserved IP in
     *  the cluster network subnet. Names starting with `ibm-` are reserved for provider-owned resources, and are not
     *  allowed.
     */
    name?: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Parameters for the `deleteClusterNetworkSubnet` operation. */
  export interface DeleteClusterNetworkSubnetParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network subnet identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getClusterNetworkSubnet` operation. */
  export interface GetClusterNetworkSubnetParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network subnet identifier. */
    id: string;
  }

  /** Parameters for the `updateClusterNetworkSubnet` operation. */
  export interface UpdateClusterNetworkSubnetParams extends DefaultParams {
    /** The cluster network identifier. */
    clusterNetworkId: string;
    /** The cluster network subnet identifier. */
    id: string;
    /** The name for this cluster network subnet. The name must not be used by another cluster network subnet in the
     *  cluster network. Names starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Parameters for the `deleteClusterNetwork` operation. */
  export interface DeleteClusterNetworkParams extends DefaultParams {
    /** The cluster network identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getClusterNetwork` operation. */
  export interface GetClusterNetworkParams extends DefaultParams {
    /** The cluster network identifier. */
    id: string;
  }

  /** Parameters for the `updateClusterNetwork` operation. */
  export interface UpdateClusterNetworkParams extends DefaultParams {
    /** The cluster network identifier. */
    id: string;
    /** The name for this cluster network. The name must not be used by another cluster network in the region. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Parameters for the `listPublicGateways` operation. */
  export interface ListPublicGatewaysParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
  }

  /** Parameters for the `createPublicGateway` operation. */
  export interface CreatePublicGatewayParams extends DefaultParams {
    /** The VPC this public gateway will reside in. */
    vpc: VPCIdentity;
    /** The zone this public gateway will reside in. */
    zone: ZoneIdentity;
    floatingIp?: PublicGatewayFloatingIPPrototype;
    /** The name for this public gateway. The name must not be used by another public gateway in the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
  }

  /** Parameters for the `deletePublicGateway` operation. */
  export interface DeletePublicGatewayParams extends DefaultParams {
    /** The public gateway identifier. */
    id: string;
  }

  /** Parameters for the `getPublicGateway` operation. */
  export interface GetPublicGatewayParams extends DefaultParams {
    /** The public gateway identifier. */
    id: string;
  }

  /** Parameters for the `updatePublicGateway` operation. */
  export interface UpdatePublicGatewayParams extends DefaultParams {
    /** The public gateway identifier. */
    id: string;
    /** The name for this public gateway. The name must not be used by another public gateway in the VPC. */
    name?: string;
  }

  /** Parameters for the `listFloatingIps` operation. */
  export interface ListFloatingIpsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListFloatingIpsConstants.Sort | string;
    /** Filters the collection to resources with a `target.id` property matching the specified identifier. */
    targetId?: string;
    /** Filters the collection to resources with a `target.crn` property matching the specified CRN. */
    targetCrn?: string;
    /** Filters the collection to resources with a `target.name` property matching the exact specified name. */
    targetName?: string;
    /** Filters the collection to resources with a `target.resource_type` property matching the specified value. */
    targetResourceType?: string;
  }

  /** Constants for the `listFloatingIps` operation. */
  export namespace ListFloatingIpsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createFloatingIp` operation. */
  export interface CreateFloatingIpParams extends DefaultParams {
    /** The floating IP prototype object. */
    floatingIpPrototype: FloatingIPPrototype;
  }

  /** Parameters for the `deleteFloatingIp` operation. */
  export interface DeleteFloatingIpParams extends DefaultParams {
    /** The floating IP identifier. */
    id: string;
  }

  /** Parameters for the `getFloatingIp` operation. */
  export interface GetFloatingIpParams extends DefaultParams {
    /** The floating IP identifier. */
    id: string;
  }

  /** Parameters for the `updateFloatingIp` operation. */
  export interface UpdateFloatingIpParams extends DefaultParams {
    /** The floating IP identifier. */
    id: string;
    /** The name for this floating IP. The name must not be used by another floating IP in the region. */
    name?: string;
    /** The target resource to bind this floating IP to, replacing any existing binding.
     *  The floating IP must not be required by another resource, such as a public gateway.
     *
     *  The target resource must not already have a floating IP bound to it if the target
     *  resource is:
     *
     *  - an instance network interface
     *  - a bare metal server network interface with `enable_infrastructure_nat` set to `true`
     *  - a virtual network interface with `enable_infrastructure_nat` set to `true`
     *
     *  Specify `null` to remove an existing binding.
     */
    target?: FloatingIPTargetPatch;
  }

  /** Parameters for the `listNetworkAcls` operation. */
  export interface ListNetworkAclsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
  }

  /** Parameters for the `createNetworkAcl` operation. */
  export interface CreateNetworkAclParams extends DefaultParams {
    /** The network ACL prototype object. */
    networkAclPrototype: NetworkACLPrototype;
  }

  /** Parameters for the `deleteNetworkAcl` operation. */
  export interface DeleteNetworkAclParams extends DefaultParams {
    /** The network ACL identifier. */
    id: string;
  }

  /** Parameters for the `getNetworkAcl` operation. */
  export interface GetNetworkAclParams extends DefaultParams {
    /** The network ACL identifier. */
    id: string;
  }

  /** Parameters for the `updateNetworkAcl` operation. */
  export interface UpdateNetworkAclParams extends DefaultParams {
    /** The network ACL identifier. */
    id: string;
    /** The name for this network ACL. The name must not be used by another network ACL for the VPC. */
    name?: string;
  }

  /** Parameters for the `listNetworkAclRules` operation. */
  export interface ListNetworkAclRulesParams extends DefaultParams {
    /** The network ACL identifier. */
    networkAclId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to rules with a `direction` property matching the specified value. */
    direction?: ListNetworkAclRulesConstants.Direction | string;
  }

  /** Constants for the `listNetworkAclRules` operation. */
  export namespace ListNetworkAclRulesConstants {
    /** Filters the collection to rules with a `direction` property matching the specified value. */
    export enum Direction {
      INBOUND = 'inbound',
      OUTBOUND = 'outbound',
    }
  }

  /** Parameters for the `createNetworkAclRule` operation. */
  export interface CreateNetworkAclRuleParams extends DefaultParams {
    /** The network ACL identifier. */
    networkAclId: string;
    /** The network ACL rule prototype object. */
    networkAclRulePrototype: NetworkACLRulePrototype;
  }

  /** Parameters for the `deleteNetworkAclRule` operation. */
  export interface DeleteNetworkAclRuleParams extends DefaultParams {
    /** The network ACL identifier. */
    networkAclId: string;
    /** The rule identifier. */
    id: string;
  }

  /** Parameters for the `getNetworkAclRule` operation. */
  export interface GetNetworkAclRuleParams extends DefaultParams {
    /** The network ACL identifier. */
    networkAclId: string;
    /** The rule identifier. */
    id: string;
  }

  /** Parameters for the `updateNetworkAclRule` operation. */
  export interface UpdateNetworkAclRuleParams extends DefaultParams {
    /** The network ACL identifier. */
    networkAclId: string;
    /** The rule identifier. */
    id: string;
    /** The action to perform for a packet matching the rule. */
    action?: UpdateNetworkAclRuleConstants.Action | string;
    /** The rule to move this rule immediately before.
     *
     *  Specify `null` to move this rule after all existing rules.
     */
    before?: NetworkACLRuleBeforePatch;
    /** The ICMP traffic code to match. If set, `type` must also be set.
     *
     *  Specify `null` to remove an existing ICMP traffic code.
     */
    code?: number;
    /** The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination
     *  addresses.
     */
    destination?: string;
    /** The inclusive upper bound of the TCP or UDP destination port range.
     *
     *  Must be larger than or equal to `destination_port_min`.
     */
    destinationPortMax?: number;
    /** The inclusive lower bound of the TCP or UDP destination port range.
     *
     *  Must be smaller than or equal to `destination_port_max`.
     */
    destinationPortMin?: number;
    /** The direction of traffic to match. */
    direction?: UpdateNetworkAclRuleConstants.Direction | string;
    /** The name for this network ACL rule. The name must not be used by another rule for the network ACL. */
    name?: string;
    /** The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses. */
    source?: string;
    /** The inclusive upper bound of the TCP or UDP source port range.
     *
     *  Must be larger than or equal to `source_port_min`.
     */
    sourcePortMax?: number;
    /** The inclusive lower bound of the TCP or UDP source port range.
     *
     *  Must be smaller than or equal to `source_port_max`.
     */
    sourcePortMin?: number;
    /** The ICMP traffic type to match.
     *
     *  Specify `null` to remove an existing ICMP traffic type value.
     */
    type?: number;
  }

  /** Constants for the `updateNetworkAclRule` operation. */
  export namespace UpdateNetworkAclRuleConstants {
    /** The action to perform for a packet matching the rule. */
    export enum Action {
      ALLOW = 'allow',
      DENY = 'deny',
    }
    /** The direction of traffic to match. */
    export enum Direction {
      INBOUND = 'inbound',
      OUTBOUND = 'outbound',
    }
  }

  /** Parameters for the `listSecurityGroups` operation. */
  export interface ListSecurityGroupsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `vpc.id` property matching the specified identifier. */
    vpcId?: string;
    /** Filters the collection to resources with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to resources with a `vpc.name` property matching the exact specified name. */
    vpcName?: string;
  }

  /** Parameters for the `createSecurityGroup` operation. */
  export interface CreateSecurityGroupParams extends DefaultParams {
    /** The VPC this security group will reside in. */
    vpc: VPCIdentity;
    /** The name for this security group. The name must not be used by another security group for the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** The prototype objects for rules to be created for this security group. If unspecified, no rules will be
     *  created, resulting in no traffic being allowed.
     */
    rules?: SecurityGroupRulePrototype[];
  }

  /** Parameters for the `deleteSecurityGroup` operation. */
  export interface DeleteSecurityGroupParams extends DefaultParams {
    /** The security group identifier. */
    id: string;
  }

  /** Parameters for the `getSecurityGroup` operation. */
  export interface GetSecurityGroupParams extends DefaultParams {
    /** The security group identifier. */
    id: string;
  }

  /** Parameters for the `updateSecurityGroup` operation. */
  export interface UpdateSecurityGroupParams extends DefaultParams {
    /** The security group identifier. */
    id: string;
    /** The name for this security group. The name must not be used by another security group for the VPC. */
    name?: string;
  }

  /** Parameters for the `listSecurityGroupRules` operation. */
  export interface ListSecurityGroupRulesParams extends DefaultParams {
    /** The security group identifier. */
    securityGroupId: string;
  }

  /** Parameters for the `createSecurityGroupRule` operation. */
  export interface CreateSecurityGroupRuleParams extends DefaultParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The properties of the security group rule to be created. */
    securityGroupRulePrototype: SecurityGroupRulePrototype;
  }

  /** Parameters for the `deleteSecurityGroupRule` operation. */
  export interface DeleteSecurityGroupRuleParams extends DefaultParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The rule identifier. */
    id: string;
  }

  /** Parameters for the `getSecurityGroupRule` operation. */
  export interface GetSecurityGroupRuleParams extends DefaultParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The rule identifier. */
    id: string;
  }

  /** Parameters for the `updateSecurityGroupRule` operation. */
  export interface UpdateSecurityGroupRuleParams extends DefaultParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The rule identifier. */
    id: string;
    /** The ICMP traffic code to allow. If set, `type` must also be set.
     *
     *  Specify `null` to remove an existing ICMP traffic code.
     */
    code?: number;
    /** The direction of traffic to allow. */
    direction?: UpdateSecurityGroupRuleConstants.Direction | string;
    /** The IP version to allow. The format of `local.address`, `remote.address`,
     *  `local.cidr_block` or `remote.cidr_block` must match this property, if they are used.
     *
     *  If `remote` references a security group, then this rule only applies to IP addresses in that group matching this
     *  IP version.
     */
    ipVersion?: UpdateSecurityGroupRuleConstants.IpVersion | string;
    /** The local IP address or range of local IP addresses to which this rule will allow inbound
     *  traffic (or from which, for outbound traffic). Can be specified as an IP address or a CIDR
     *  block.
     *
     *  Specify a CIDR block of `0.0.0.0/0` to allow traffic to all local IP addresses (or from all
     *  local IP addresses, for outbound rules).
     */
    local?: SecurityGroupRuleLocalPatch;
    /** The inclusive upper bound of the protocol destination port range. If set, `port_min` must also be set, and
     *  must not be larger.
     *
     *  Specify `null` to remove an existing upper bound.
     */
    portMax?: number;
    /** The inclusive lower bound of the protocol destination port range. If set, `port_max` must also be set, and
     *  must not be smaller.
     *
     *  Specify `null` to remove an existing lower bound.
     */
    portMin?: number;
    /** The remote IP addresses or security groups from which this rule will allow traffic (or to
     *  which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
     *  security group. A CIDR block of `0.0.0.0/0` will allow traffic from any source (or to
     *  any destination, for outbound rules).
     */
    remote?: SecurityGroupRuleRemotePatch;
    /** The ICMP traffic type to allow.
     *
     *  Specify `null` to remove an existing ICMP traffic type value.
     */
    type?: number;
  }

  /** Constants for the `updateSecurityGroupRule` operation. */
  export namespace UpdateSecurityGroupRuleConstants {
    /** The direction of traffic to allow. */
    export enum Direction {
      INBOUND = 'inbound',
      OUTBOUND = 'outbound',
    }
    /** The IP version to allow. The format of `local.address`, `remote.address`, `local.cidr_block` or `remote.cidr_block` must match this property, if they are used. If `remote` references a security group, then this rule only applies to IP addresses in that group matching this IP version. */
    export enum IpVersion {
      IPV4 = 'ipv4',
    }
  }

  /** Parameters for the `listSecurityGroupTargets` operation. */
  export interface ListSecurityGroupTargetsParams extends DefaultParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `deleteSecurityGroupTargetBinding` operation. */
  export interface DeleteSecurityGroupTargetBindingParams extends DefaultParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The security group target identifier. */
    id: string;
  }

  /** Parameters for the `getSecurityGroupTarget` operation. */
  export interface GetSecurityGroupTargetParams extends DefaultParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The security group target identifier. */
    id: string;
  }

  /** Parameters for the `createSecurityGroupTargetBinding` operation. */
  export interface CreateSecurityGroupTargetBindingParams extends DefaultParams {
    /** The security group identifier. */
    securityGroupId: string;
    /** The security group target identifier. */
    id: string;
  }

  /** Parameters for the `listIkePolicies` operation. */
  export interface ListIkePoliciesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createIkePolicy` operation. */
  export interface CreateIkePolicyParams extends DefaultParams {
    /** The authentication algorithm. */
    authenticationAlgorithm: CreateIkePolicyConstants.AuthenticationAlgorithm | string;
    /** The Diffie-Hellman group. */
    dhGroup: number;
    /** The encryption algorithm. */
    encryptionAlgorithm: CreateIkePolicyConstants.EncryptionAlgorithm | string;
    /** The IKE protocol version. */
    ikeVersion: number;
    /** The key lifetime in seconds. */
    keyLifetime?: number;
    /** The name for this IKE policy. The name must not be used by another IKE policies in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
  }

  /** Constants for the `createIkePolicy` operation. */
  export namespace CreateIkePolicyConstants {
    /** The authentication algorithm. */
    export enum AuthenticationAlgorithm {
      SHA256 = 'sha256',
      SHA384 = 'sha384',
      SHA512 = 'sha512',
    }
    /** The encryption algorithm. */
    export enum EncryptionAlgorithm {
      AES128 = 'aes128',
      AES192 = 'aes192',
      AES256 = 'aes256',
    }
  }

  /** Parameters for the `deleteIkePolicy` operation. */
  export interface DeleteIkePolicyParams extends DefaultParams {
    /** The IKE policy identifier. */
    id: string;
  }

  /** Parameters for the `getIkePolicy` operation. */
  export interface GetIkePolicyParams extends DefaultParams {
    /** The IKE policy identifier. */
    id: string;
  }

  /** Parameters for the `updateIkePolicy` operation. */
  export interface UpdateIkePolicyParams extends DefaultParams {
    /** The IKE policy identifier. */
    id: string;
    /** The authentication algorithm. */
    authenticationAlgorithm?: UpdateIkePolicyConstants.AuthenticationAlgorithm | string;
    /** The Diffie-Hellman group. */
    dhGroup?: number;
    /** The encryption algorithm. */
    encryptionAlgorithm?: UpdateIkePolicyConstants.EncryptionAlgorithm | string;
    /** The IKE protocol version. */
    ikeVersion?: number;
    /** The key lifetime in seconds. */
    keyLifetime?: number;
    /** The name for this IKE policy. The name must not be used by another IKE policy in the region. */
    name?: string;
  }

  /** Constants for the `updateIkePolicy` operation. */
  export namespace UpdateIkePolicyConstants {
    /** The authentication algorithm. */
    export enum AuthenticationAlgorithm {
      SHA256 = 'sha256',
      SHA384 = 'sha384',
      SHA512 = 'sha512',
    }
    /** The encryption algorithm. */
    export enum EncryptionAlgorithm {
      AES128 = 'aes128',
      AES192 = 'aes192',
      AES256 = 'aes256',
    }
  }

  /** Parameters for the `listIkePolicyConnections` operation. */
  export interface ListIkePolicyConnectionsParams extends DefaultParams {
    /** The IKE policy identifier. */
    id: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `listIpsecPolicies` operation. */
  export interface ListIpsecPoliciesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createIpsecPolicy` operation. */
  export interface CreateIpsecPolicyParams extends DefaultParams {
    /** The authentication algorithm
     *
     *  Must be `disabled` if and only if the `encryption_algorithm` is `aes128gcm16`,
     *  `aes192gcm16`, or `aes256gcm16`
     *
     *  The `md5` and `sha1` algorithms have been deprecated.
     */
    authenticationAlgorithm: CreateIpsecPolicyConstants.AuthenticationAlgorithm | string;
    /** The encryption algorithm
     *
     *  The `authentication_algorithm` must be `disabled` if and only if
     *  `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`
     *
     *  The `triple_des` algorithm has been deprecated.
     */
    encryptionAlgorithm: CreateIpsecPolicyConstants.EncryptionAlgorithm | string;
    /** The Perfect Forward Secrecy group.
     *
     *  Groups `group_2` and `group_5` have been deprecated.
     */
    pfs: CreateIpsecPolicyConstants.Pfs | string;
    /** The key lifetime in seconds. */
    keyLifetime?: number;
    /** The name for this IPsec policy. The name must not be used by another IPsec policies in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
  }

  /** Constants for the `createIpsecPolicy` operation. */
  export namespace CreateIpsecPolicyConstants {
    /** The authentication algorithm Must be `disabled` if and only if the `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16` The `md5` and `sha1` algorithms have been deprecated. */
    export enum AuthenticationAlgorithm {
      DISABLED = 'disabled',
      SHA256 = 'sha256',
      SHA384 = 'sha384',
      SHA512 = 'sha512',
    }
    /** The encryption algorithm The `authentication_algorithm` must be `disabled` if and only if `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16` The `triple_des` algorithm has been deprecated. */
    export enum EncryptionAlgorithm {
      AES128 = 'aes128',
      AES128GCM16 = 'aes128gcm16',
      AES192 = 'aes192',
      AES192GCM16 = 'aes192gcm16',
      AES256 = 'aes256',
      AES256GCM16 = 'aes256gcm16',
    }
    /** The Perfect Forward Secrecy group. Groups `group_2` and `group_5` have been deprecated. */
    export enum Pfs {
      DISABLED = 'disabled',
      GROUP_14 = 'group_14',
      GROUP_15 = 'group_15',
      GROUP_16 = 'group_16',
      GROUP_17 = 'group_17',
      GROUP_18 = 'group_18',
      GROUP_19 = 'group_19',
      GROUP_20 = 'group_20',
      GROUP_21 = 'group_21',
      GROUP_22 = 'group_22',
      GROUP_23 = 'group_23',
      GROUP_24 = 'group_24',
      GROUP_31 = 'group_31',
    }
  }

  /** Parameters for the `deleteIpsecPolicy` operation. */
  export interface DeleteIpsecPolicyParams extends DefaultParams {
    /** The IPsec policy identifier. */
    id: string;
  }

  /** Parameters for the `getIpsecPolicy` operation. */
  export interface GetIpsecPolicyParams extends DefaultParams {
    /** The IPsec policy identifier. */
    id: string;
  }

  /** Parameters for the `updateIpsecPolicy` operation. */
  export interface UpdateIpsecPolicyParams extends DefaultParams {
    /** The IPsec policy identifier. */
    id: string;
    /** The authentication algorithm
     *
     *  Must be `disabled` if and only if the `encryption_algorithm` is `aes128gcm16`,
     *  `aes192gcm16`, or `aes256gcm16`
     *
     *  The `md5` and `sha1` algorithms have been deprecated.
     */
    authenticationAlgorithm?: UpdateIpsecPolicyConstants.AuthenticationAlgorithm | string;
    /** The encryption algorithm
     *
     *  The `authentication_algorithm` must be `disabled` if and only if
     *  `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`
     *
     *  The `triple_des` algorithm has been deprecated.
     */
    encryptionAlgorithm?: UpdateIpsecPolicyConstants.EncryptionAlgorithm | string;
    /** The key lifetime in seconds. */
    keyLifetime?: number;
    /** The name for this IPsec policy. The name must not be used by another IPsec policy in the region. */
    name?: string;
    /** The Perfect Forward Secrecy group.
     *
     *  Groups `group_2` and `group_5` have been deprecated.
     */
    pfs?: UpdateIpsecPolicyConstants.Pfs | string;
  }

  /** Constants for the `updateIpsecPolicy` operation. */
  export namespace UpdateIpsecPolicyConstants {
    /** The authentication algorithm Must be `disabled` if and only if the `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16` The `md5` and `sha1` algorithms have been deprecated. */
    export enum AuthenticationAlgorithm {
      DISABLED = 'disabled',
      SHA256 = 'sha256',
      SHA384 = 'sha384',
      SHA512 = 'sha512',
    }
    /** The encryption algorithm The `authentication_algorithm` must be `disabled` if and only if `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or `aes256gcm16` The `triple_des` algorithm has been deprecated. */
    export enum EncryptionAlgorithm {
      AES128 = 'aes128',
      AES128GCM16 = 'aes128gcm16',
      AES192 = 'aes192',
      AES192GCM16 = 'aes192gcm16',
      AES256 = 'aes256',
      AES256GCM16 = 'aes256gcm16',
    }
    /** The Perfect Forward Secrecy group. Groups `group_2` and `group_5` have been deprecated. */
    export enum Pfs {
      DISABLED = 'disabled',
      GROUP_14 = 'group_14',
      GROUP_15 = 'group_15',
      GROUP_16 = 'group_16',
      GROUP_17 = 'group_17',
      GROUP_18 = 'group_18',
      GROUP_19 = 'group_19',
      GROUP_20 = 'group_20',
      GROUP_21 = 'group_21',
      GROUP_22 = 'group_22',
      GROUP_23 = 'group_23',
      GROUP_24 = 'group_24',
      GROUP_31 = 'group_31',
    }
  }

  /** Parameters for the `listIpsecPolicyConnections` operation. */
  export interface ListIpsecPolicyConnectionsParams extends DefaultParams {
    /** The IPsec policy identifier. */
    id: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `listVpnGateways` operation. */
  export interface ListVpnGatewaysParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListVpnGatewaysConstants.Sort | string;
    /** Filters the collection to VPN gateways with a `mode` property matching the specified value. */
    mode?: ListVpnGatewaysConstants.Mode | string;
  }

  /** Constants for the `listVpnGateways` operation. */
  export namespace ListVpnGatewaysConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
    /** Filters the collection to VPN gateways with a `mode` property matching the specified value. */
    export enum Mode {
      POLICY = 'policy',
      ROUTE = 'route',
    }
  }

  /** Parameters for the `createVpnGateway` operation. */
  export interface CreateVpnGatewayParams extends DefaultParams {
    /** The VPN gateway prototype object. */
    vpnGatewayPrototype: VPNGatewayPrototype;
  }

  /** Parameters for the `deleteVpnGateway` operation. */
  export interface DeleteVpnGatewayParams extends DefaultParams {
    /** The VPN gateway identifier. */
    id: string;
  }

  /** Parameters for the `getVpnGateway` operation. */
  export interface GetVpnGatewayParams extends DefaultParams {
    /** The VPN gateway identifier. */
    id: string;
  }

  /** Parameters for the `updateVpnGateway` operation. */
  export interface UpdateVpnGatewayParams extends DefaultParams {
    /** The VPN gateway identifier. */
    id: string;
    /** The name for this VPN gateway. The name must not be used by another VPN gateway in the VPC. */
    name?: string;
  }

  /** Parameters for the `listVpnGatewayConnections` operation. */
  export interface ListVpnGatewayConnectionsParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to VPN gateway connections with a `status` property matching the specified value. */
    status?: ListVpnGatewayConnectionsConstants.Status | string;
  }

  /** Constants for the `listVpnGatewayConnections` operation. */
  export namespace ListVpnGatewayConnectionsConstants {
    /** Filters the collection to VPN gateway connections with a `status` property matching the specified value. */
    export enum Status {
      DOWN = 'down',
      UP = 'up',
    }
  }

  /** Parameters for the `createVpnGatewayConnection` operation. */
  export interface CreateVpnGatewayConnectionParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection prototype object. */
    vpnGatewayConnectionPrototype: VPNGatewayConnectionPrototype;
  }

  /** Parameters for the `deleteVpnGatewayConnection` operation. */
  export interface DeleteVpnGatewayConnectionParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
  }

  /** Parameters for the `getVpnGatewayConnection` operation. */
  export interface GetVpnGatewayConnectionParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
  }

  /** Parameters for the `updateVpnGatewayConnection` operation. */
  export interface UpdateVpnGatewayConnectionParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** If set to false, the VPN gateway connection is shut down. */
    adminStateUp?: boolean;
    /** The Dead Peer Detection settings. */
    deadPeerDetection?: VPNGatewayConnectionDPDPatch;
    /** Indicates whether the traffic is distributed between the `up` tunnels of the VPN gateway connection when the
     *  VPC route's next hop is a VPN connection. If `false`, the traffic is only routed through the `up` tunnel with
     *  the lower `public_ip` address. Before enabling it on VPN connections to on-prem private networks, review
     *  [distributing traffic
     *  restrictions](https://cloud.ibm.com/docs/vpc?topic=vpc-vpn-limitations#distributing-traffic-restrictions).
     *
     *  If specified, `mode` must be `route`.
     */
    distributeTraffic?: boolean;
    /** The establish mode of the VPN gateway connection:
     *  - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol
     *     negotiations or rekeying processes.
     *  - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway
     *     connection. Additionally, the peer is responsible for initiating the rekeying process
     *     after the connection is established. If rekeying does not occur, the VPN gateway
     *     connection will be brought down after its lifetime expires.
     */
    establishMode?: UpdateVpnGatewayConnectionConstants.EstablishMode | string;
    /** The IKE policy to use. Specify `null` to remove any existing policy, [resulting in
     *  auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
     */
    ikePolicy?: VPNGatewayConnectionIKEPolicyPatch;
    /** The IPsec policy to use. Specify `null` to remove any existing policy, [resulting in
     *  auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
     */
    ipsecPolicy?: VPNGatewayConnectionIPsecPolicyPatch;
    /** The name for this VPN gateway connection. The name must not be used by another connection for the VPN
     *  gateway.
     */
    name?: string;
    peer?: VPNGatewayConnectionPeerPatch;
    /** The pre-shared key. */
    psk?: string;
  }

  /** Constants for the `updateVpnGatewayConnection` operation. */
  export namespace UpdateVpnGatewayConnectionConstants {
    /** The establish mode of the VPN gateway connection: - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol negotiations or rekeying processes. - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway connection. Additionally, the peer is responsible for initiating the rekeying process after the connection is established. If rekeying does not occur, the VPN gateway connection will be brought down after its lifetime expires. */
    export enum EstablishMode {
      BIDIRECTIONAL = 'bidirectional',
      PEER_ONLY = 'peer_only',
    }
  }

  /** Parameters for the `listVpnGatewayConnectionsLocalCidrs` operation. */
  export interface ListVpnGatewayConnectionsLocalCidrsParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
  }

  /** Parameters for the `removeVpnGatewayConnectionsLocalCidr` operation. */
  export interface RemoveVpnGatewayConnectionsLocalCidrParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The IP address range in CIDR block notation. */
    cidr: string;
  }

  /** Parameters for the `checkVpnGatewayConnectionsLocalCidr` operation. */
  export interface CheckVpnGatewayConnectionsLocalCidrParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The IP address range in CIDR block notation. */
    cidr: string;
  }

  /** Parameters for the `addVpnGatewayConnectionsLocalCidr` operation. */
  export interface AddVpnGatewayConnectionsLocalCidrParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The IP address range in CIDR block notation. */
    cidr: string;
  }

  /** Parameters for the `listVpnGatewayConnectionsPeerCidrs` operation. */
  export interface ListVpnGatewayConnectionsPeerCidrsParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
  }

  /** Parameters for the `removeVpnGatewayConnectionsPeerCidr` operation. */
  export interface RemoveVpnGatewayConnectionsPeerCidrParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The IP address range in CIDR block notation. */
    cidr: string;
  }

  /** Parameters for the `checkVpnGatewayConnectionsPeerCidr` operation. */
  export interface CheckVpnGatewayConnectionsPeerCidrParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The IP address range in CIDR block notation. */
    cidr: string;
  }

  /** Parameters for the `addVpnGatewayConnectionsPeerCidr` operation. */
  export interface AddVpnGatewayConnectionsPeerCidrParams extends DefaultParams {
    /** The VPN gateway identifier. */
    vpnGatewayId: string;
    /** The VPN gateway connection identifier. */
    id: string;
    /** The IP address range in CIDR block notation. */
    cidr: string;
  }

  /** Parameters for the `listVpnServers` operation. */
  export interface ListVpnServersParams extends DefaultParams {
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListVpnServersConstants.Sort | string;
  }

  /** Constants for the `listVpnServers` operation. */
  export namespace ListVpnServersConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createVpnServer` operation. */
  export interface CreateVpnServerParams extends DefaultParams {
    /** The certificate instance for this VPN server. */
    certificate: CertificateInstanceIdentity;
    /** The methods used to authenticate VPN clients to this VPN server. VPN clients must authenticate against all
     *  specified methods.
     */
    clientAuthentication: VPNServerAuthenticationPrototype[];
    /** The VPN client IPv4 address pool, expressed in CIDR format. The request must not overlap with any existing
     *  address prefixes in the VPC or any of the following reserved address ranges:
     *    - `127.0.0.0/8` (IPv4 loopback addresses)
     *    - `161.26.0.0/16` (IBM services)
     *    - `166.8.0.0/14` (Cloud Service Endpoints)
     *    - `169.254.0.0/16` (IPv4 link-local addresses)
     *    - `224.0.0.0/4` (IPv4 multicast addresses)
     *
     *  The prefix length of the client IP address pool's CIDR must be between
     *  `/9` (8,388,608 addresses) and `/22` (1024 addresses). A CIDR block that contains twice the number of IP
     *  addresses that are required to enable the maximum number of concurrent connections is recommended.
     */
    clientIpPool: string;
    /** The subnets to provision this VPN server in.  Use subnets in different zones for high availability. */
    subnets: SubnetIdentity[];
    /** The DNS server addresses that will be provided to VPN clients connected to this VPN server. */
    clientDnsServerIps?: IP[];
    /** The seconds a VPN client can be idle before this VPN server will disconnect it.   Specify `0` to prevent the
     *  server from disconnecting idle clients.
     */
    clientIdleTimeout?: number;
    /** Indicates whether the split tunneling is enabled on this VPN server. */
    enableSplitTunneling?: boolean;
    /** The name for this VPN server. The name must not be used by another VPN server in the VPC. If unspecified,
     *  the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The port number to use for this VPN server. */
    port?: number;
    /** The transport protocol to use for this VPN server. */
    protocol?: CreateVpnServerConstants.Protocol | string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** The security groups to use for this VPN server. If unspecified, the VPC's default security group is used. */
    securityGroups?: SecurityGroupIdentity[];
  }

  /** Constants for the `createVpnServer` operation. */
  export namespace CreateVpnServerConstants {
    /** The transport protocol to use for this VPN server. */
    export enum Protocol {
      TCP = 'tcp',
      UDP = 'udp',
    }
  }

  /** Parameters for the `deleteVpnServer` operation. */
  export interface DeleteVpnServerParams extends DefaultParams {
    /** The VPN server identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getVpnServer` operation. */
  export interface GetVpnServerParams extends DefaultParams {
    /** The VPN server identifier. */
    id: string;
  }

  /** Parameters for the `updateVpnServer` operation. */
  export interface UpdateVpnServerParams extends DefaultParams {
    /** The VPN server identifier. */
    id: string;
    /** The certificate instance for this VPN server. */
    certificate?: CertificateInstanceIdentity;
    /** The authentication methods to use to authenticate VPN client on this VPN server
     *  (replacing any existing methods).
     */
    clientAuthentication?: VPNServerAuthenticationPrototype[];
    /** The DNS server addresses that will be provided to VPN clients connected to this VPN server (replacing any
     *  existing addresses).
     */
    clientDnsServerIps?: IP[];
    /** The seconds a VPN client can be idle before this VPN server will disconnect it.  If `0`, the server will not
     *  disconnect idle clients.
     */
    clientIdleTimeout?: number;
    /** The VPN client IPv4 address pool, expressed in CIDR format. The request must not overlap with any existing
     *  address prefixes in the VPC or any of the following reserved address ranges:
     *    - `127.0.0.0/8` (IPv4 loopback addresses)
     *    - `161.26.0.0/16` (IBM services)
     *    - `166.8.0.0/14` (Cloud Service Endpoints)
     *    - `169.254.0.0/16` (IPv4 link-local addresses)
     *    - `224.0.0.0/4` (IPv4 multicast addresses)
     *
     *  The prefix length of the client IP address pool's CIDR must be between
     *  `/9` (8,388,608 addresses) and `/22` (1024 addresses). A CIDR block that contains twice the number of IP
     *  addresses that are required to enable the maximum number of concurrent connections is recommended.
     */
    clientIpPool?: string;
    /** Indicates whether the split tunneling is enabled on this VPN server. */
    enableSplitTunneling?: boolean;
    /** The name for this VPN server. The name must not be used by another VPN server in the VPC. */
    name?: string;
    /** The port number used by this VPN server. */
    port?: number;
    /** The transport protocol to use for this VPN server. */
    protocol?: UpdateVpnServerConstants.Protocol | string;
    /** The subnets to provision this VPN server in (replacing the existing subnets). */
    subnets?: SubnetIdentity[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Constants for the `updateVpnServer` operation. */
  export namespace UpdateVpnServerConstants {
    /** The transport protocol to use for this VPN server. */
    export enum Protocol {
      TCP = 'tcp',
      UDP = 'udp',
    }
  }

  /** Parameters for the `getVpnServerClientConfiguration` operation. */
  export interface GetVpnServerClientConfigurationParams extends DefaultParams {
    /** The VPN server identifier. */
    id: string;
  }

  /** Parameters for the `listVpnServerClients` operation. */
  export interface ListVpnServerClientsParams extends DefaultParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order.
     */
    sort?: ListVpnServerClientsConstants.Sort | string;
  }

  /** Constants for the `listVpnServerClients` operation. */
  export namespace ListVpnServerClientsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
    }
  }

  /** Parameters for the `deleteVpnServerClient` operation. */
  export interface DeleteVpnServerClientParams extends DefaultParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN client identifier. */
    id: string;
  }

  /** Parameters for the `getVpnServerClient` operation. */
  export interface GetVpnServerClientParams extends DefaultParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN client identifier. */
    id: string;
  }

  /** Parameters for the `disconnectVpnClient` operation. */
  export interface DisconnectVpnClientParams extends DefaultParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN client identifier. */
    id: string;
  }

  /** Parameters for the `listVpnServerRoutes` operation. */
  export interface ListVpnServerRoutesParams extends DefaultParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListVpnServerRoutesConstants.Sort | string;
  }

  /** Constants for the `listVpnServerRoutes` operation. */
  export namespace ListVpnServerRoutesConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `createVpnServerRoute` operation. */
  export interface CreateVpnServerRouteParams extends DefaultParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The destination to use for this VPN route in the VPN server. Must be unique within the VPN server. If an
     *  incoming packet does not match any destination, it will be dropped.
     */
    destination: string;
    /** The action to perform with a packet matching the VPN route:
     *  - `translate`: translate the source IP address to one of the private IP addresses of
     *    the VPN server, then deliver the packet to target.
     *  - `deliver`: deliver the packet to the target.
     *  - `drop`: drop the packet.
     */
    action?: CreateVpnServerRouteConstants.Action | string;
    /** The name for this VPN server route. The name must not be used by another route for the VPN server. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /** Constants for the `createVpnServerRoute` operation. */
  export namespace CreateVpnServerRouteConstants {
    /** The action to perform with a packet matching the VPN route: - `translate`: translate the source IP address to one of the private IP addresses of the VPN server, then deliver the packet to target. - `deliver`: deliver the packet to the target. - `drop`: drop the packet. */
    export enum Action {
      DELIVER = 'deliver',
      DROP = 'drop',
      TRANSLATE = 'translate',
    }
  }

  /** Parameters for the `deleteVpnServerRoute` operation. */
  export interface DeleteVpnServerRouteParams extends DefaultParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN route identifier. */
    id: string;
  }

  /** Parameters for the `getVpnServerRoute` operation. */
  export interface GetVpnServerRouteParams extends DefaultParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN route identifier. */
    id: string;
  }

  /** Parameters for the `updateVpnServerRoute` operation. */
  export interface UpdateVpnServerRouteParams extends DefaultParams {
    /** The VPN server identifier. */
    vpnServerId: string;
    /** The VPN route identifier. */
    id: string;
    /** The name for this VPN server route. The name must not be used by another route for the VPN server. */
    name?: string;
  }

  /** Parameters for the `listLoadBalancerProfiles` operation. */
  export interface ListLoadBalancerProfilesParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `getLoadBalancerProfile` operation. */
  export interface GetLoadBalancerProfileParams extends DefaultParams {
    /** The load balancer profile name. */
    name: string;
  }

  /** Parameters for the `listLoadBalancers` operation. */
  export interface ListLoadBalancersParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
  }

  /** Parameters for the `createLoadBalancer` operation. */
  export interface CreateLoadBalancerParams extends DefaultParams {
    /** Indicates whether this load balancer is public.
     *
     *  At present,
     *  - If `route_mode` is set to `true`, the load balancer must be private.
     *  - If `is_private_path` is specified, it must be set to `false`.
     */
    isPublic: boolean;
    /** The subnets to provision this load balancer in.  The subnets must be in the same VPC.
     *  - If 'availability' is specified as `subnet` in the profile, the load balancer's availability will depend on the
     *  availability of the zones that the subnets reside in.
     *  - If 'availability' is specified as `region` in the profile, the load balancer remains available as long as any
     *  zone in the region is available. Only members in healthy zones will be sent new connections.
     *
     *  Load balancers in the `network` family allow only one subnet to be specified.
     */
    subnets: SubnetIdentity[];
    /** The DNS configuration for this load balancer.
     *
     *  If unspecified, DNS `A` records for this load balancer's `hostname` property will be added
     *  to the public DNS zone `lb.appdomain.cloud`. Otherwise, those DNS `A` records will be
     *  added to the specified `zone`.
     *
     *  Not supported by private path load balancers.
     */
    dns?: LoadBalancerDNSPrototype;
    /** Indicates whether this is a private path load balancer. */
    isPrivatePath?: boolean;
    /** The listeners of this load balancer. */
    listeners?: LoadBalancerListenerPrototypeLoadBalancerContext[];
    /** The logging configuration to use for this load balancer. See [VPC Datapath
     *  Logging](https://cloud.ibm.com/docs/vpc?topic=vpc-datapath-logging) on the logging
     *  format, fields and permitted values. If unspecified, `datapath.active` will be `false`.
     *
     *  To activate logging, the load balancer profile must support the specified logging type.
     */
    logging?: LoadBalancerLoggingPrototype;
    /** The name for this load balancer. The name must not be used by another load balancer in the VPC.  If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The pools of this load balancer. */
    pools?: LoadBalancerPoolPrototypeLoadBalancerContext[];
    /** The profile to use for this load balancer.
     *
     *  If unspecified, `application` will be used.
     */
    profile?: LoadBalancerProfileIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** Indicates whether [route mode](https://cloud.ibm.com/docs/vpc?topic=vpc-nlb-vnf&interface=ui) is enabled for
     *  this load balancer.
     *
     *  At present, public load balancers are not supported with route mode enabled.
     */
    routeMode?: boolean;
    /** The security groups to use for this load balancer. If unspecified, the VPC's default security group is used.
     *
     *  The load balancer profile must support security groups.
     */
    securityGroups?: SecurityGroupIdentity[];
  }

  /** Parameters for the `deleteLoadBalancer` operation. */
  export interface DeleteLoadBalancerParams extends DefaultParams {
    /** The load balancer identifier. */
    id: string;
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getLoadBalancer` operation. */
  export interface GetLoadBalancerParams extends DefaultParams {
    /** The load balancer identifier. */
    id: string;
  }

  /** Parameters for the `updateLoadBalancer` operation. */
  export interface UpdateLoadBalancerParams extends DefaultParams {
    /** The load balancer identifier. */
    id: string;
    /** The DNS configuration for this load balancer.
     *
     *  Specify `null` to remove the existing DNS configuration, which will remove all DNS `A`
     *  records for this load balancer that had been added to `zone`, and add equivalent `A`
     *  records to the public DNS zone `lb.appdomain.cloud`.
     *
     *  Not supported by private path load balancers.
     */
    dns?: LoadBalancerDNSPatch;
    /** The logging configuration to use for this load balancer.
     *
     *  To activate logging, the load balancer profile must support the specified logging type.
     */
    logging?: LoadBalancerLoggingPatch;
    /** The name for this load balancer. The name must not be used by another load balancer in the VPC. */
    name?: string;
    /** The subnets to provision this load balancer in. The load balancer's availability will depend on the
     *  availability of the zones that the subnets reside in.
     *
     *  The specified subnets must be in the same VPC as the existing subnets, and will completely replace the existing
     *  subnets.
     *
     *  The load balancer must be in the `application` family.
     */
    subnets?: SubnetIdentity[];
    /** If present, the request will fail if the specified ETag value does not match the resource's current ETag
     *  value. Required if the request body includes an array.
     */
    ifMatch?: string;
  }

  /** Parameters for the `getLoadBalancerStatistics` operation. */
  export interface GetLoadBalancerStatisticsParams extends DefaultParams {
    /** The load balancer identifier. */
    id: string;
  }

  /** Parameters for the `listLoadBalancerListeners` operation. */
  export interface ListLoadBalancerListenersParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
  }

  /** Parameters for the `createLoadBalancerListener` operation. */
  export interface CreateLoadBalancerListenerParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener protocol. Each listener in the load balancer must have a non-overlapping port range and
     *  `protocol` combination.
     *
     *  Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
     *  the `application` family support `tcp`, `http` and
     *  `https`.
     *
     *  Additional restrictions:
     *  - If `default_pool` is set, the pool's protocol must match, or be compatible with
     *    the listener's protocol. At present, the compatible protocols are `http` and
     *    `https`.
     *  - If `https_redirect` is set, the protocol must be `http`.
     */
    protocol: CreateLoadBalancerListenerConstants.Protocol | string;
    /** If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load
     *  balancers in the `application` family (otherwise always `false`). Additional restrictions:
     *  - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
     *    match the `accept_proxy_protocol` value of the `https_redirect` listener.
     *  - If this listener is the target of another listener's `https_redirect`, its
     *    `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
     */
    acceptProxyProtocol?: boolean;
    /** The certificate instance to use for SSL termination. The listener must have a `protocol` of `https`. */
    certificateInstance?: CertificateInstanceIdentity;
    /** The concurrent connection limit for the listener. If reached, incoming connections may be queued or
     *  rejected.
     *
     *  Supported for load balancers in the `application` family.
     *
     *  If unspecified, the limit will be `15000` for load balancers in the `application` family.
     */
    connectionLimit?: number;
    /** The default pool for this listener. If `https_redirect` is specified, the
     *  default pool will not be used.
     *  If specified, the pool must:
     *
     *  - Belong to this load balancer.
     *  - Have the same `protocol` as this listener, or have a compatible protocol.
     *    At present, the compatible protocols are `http` and `https`.
     *  - Not already be the `default_pool` for another listener.
     *
     *  If unspecified, this listener will be created with no default pool, but one may be
     *  subsequently set.
     */
    defaultPool?: LoadBalancerPoolIdentity;
    /** The target listener that requests will be redirected to if none of the listener's
     *  `policies` match.
     *
     *  If specified, this listener must have a `protocol` of `http`, and the target
     *  listener must have a `protocol` of `https`.
     */
    httpsRedirect?: LoadBalancerListenerHTTPSRedirectPrototype;
    /** The idle connection timeout of the listener in seconds.
     *
     *  Supported for load balancers in the `application` family.
     *
     *  If unspecified, the timeout will be `50` for load balancers in the `application` family.
     */
    idleConnectionTimeout?: number;
    /** The policy prototype objects for this listener. The load balancer must be in the `application` family. */
    policies?: LoadBalancerListenerPolicyPrototype[];
    /** The listener port number. Each listener in the load balancer must have a non-overlapping port range and
     *  `protocol` combination. Protocol values of `tcp`, `http` and `https` share the TCP port space.
     *
     *  If `port_min` is also specified, `port` must have the same value as `port_min`.
     */
    port?: number;
    /** The inclusive upper bound of the range of ports used by this listener. Must not be less than `port_min`.
     *
     *  Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
     *  `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must
     *  be `65535`.
     *
     *  The specified port range must not overlap with port ranges used by other listeners for this load balancer using
     *  the same protocol. Protocol values of `tcp`, `http` and
     *  `https` share the TCP port space.
     */
    portMax?: number;
    /** The inclusive lower bound of the range of ports used by this listener. Must not be greater than `port_max`.
     *
     *  If specified, `port_max` must also be specified, and must not be smaller. If unspecified, `port_max` must also
     *  be unspecified.
     *
     *  If `port` is also specified, `port_min` must have the same value as `port`.
     *
     *  Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
     *  `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must
     *  be `1`.
     *
     *  The specified port range must not overlap with port ranges used by other listeners for this load balancer using
     *  the same protocol. Protocol values of `tcp`, `http` and
     *  `https` share the TCP port space.
     */
    portMin?: number;
  }

  /** Constants for the `createLoadBalancerListener` operation. */
  export namespace CreateLoadBalancerListenerConstants {
    /** The listener protocol. Each listener in the load balancer must have a non-overlapping port range and `protocol` combination. Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the `application` family support `tcp`, `http` and `https`. Additional restrictions: - If `default_pool` is set, the pool's protocol must match, or be compatible with the listener's protocol. At present, the compatible protocols are `http` and `https`. - If `https_redirect` is set, the protocol must be `http`. */
    export enum Protocol {
      HTTP = 'http',
      HTTPS = 'https',
      TCP = 'tcp',
      UDP = 'udp',
    }
  }

  /** Parameters for the `deleteLoadBalancerListener` operation. */
  export interface DeleteLoadBalancerListenerParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    id: string;
  }

  /** Parameters for the `getLoadBalancerListener` operation. */
  export interface GetLoadBalancerListenerParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    id: string;
  }

  /** Parameters for the `updateLoadBalancerListener` operation. */
  export interface UpdateLoadBalancerListenerParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    id: string;
    /** If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load
     *  balancers in the `application` family (otherwise always `false`). Additional restrictions:
     *  - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
     *    match the `accept_proxy_protocol` value of the `https_redirect` listener.
     *  - If this listener is the target of another listener's `https_redirect`, its
     *    `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
     */
    acceptProxyProtocol?: boolean;
    /** The certificate instance to use for SSL termination. The listener must have a `protocol` of `https`. */
    certificateInstance?: CertificateInstanceIdentity;
    /** The concurrent connection limit for the listener. If reached, incoming connections may be queued or
     *  rejected.
     *
     *  Supported for load balancers in the `application` family.
     */
    connectionLimit?: number;
    /** The default pool for this listener. If `https_redirect` is set, the default pool will not
     *  be used. The specified pool must:
     *
     *  - Belong to this load balancer
     *  - Have the same `protocol` as this listener, or have a compatible protocol.
     *    At present, the compatible protocols are `http` and `https`.
     *  - Not already be the `default_pool` for another listener
     *
     *  Specify `null` to remove an existing default pool.
     */
    defaultPool?: LoadBalancerListenerDefaultPoolPatch;
    /** The target listener that requests will be redirected to if none of the listener's
     *  `policies` match.
     *
     *  If specified, this listener must have a `protocol` of `http`, and the target listener
     *  must have a `protocol` of `https`.
     *
     *  Specify `null` to remove any existing https redirect.
     */
    httpsRedirect?: LoadBalancerListenerHTTPSRedirectPatch;
    /** The idle connection timeout of the listener in seconds.
     *
     *  Supported for load balancers in the `application` family.
     */
    idleConnectionTimeout?: number;
    /** The inclusive lower bound of the range of ports used by this listener. Must not be greater than `port_max`.
     *  Updating `port` updates `port_min` to the same value.
     *
     *  Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
     *  `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must
     *  be `1`.
     *
     *  Each listener in the load balancer must have a non-overlapping port range and
     *  `protocol` combination. Protocol values of `tcp`, `http` and `https` share the TCP port space.
     */
    port?: number;
    /** The inclusive upper bound of the range of ports used by this listener. Must not be less than `port_min`.
     *
     *  Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
     *  `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must
     *  be `65535`.
     *
     *  The specified port range must not overlap with port ranges used by other listeners for this load balancer using
     *  the same protocol. Protocol values of `tcp`, `http` and
     *  `https` share the TCP port space.
     */
    portMax?: number;
    /** The inclusive lower bound of the range of ports used by this listener. Must not be greater than `port_max`.
     *  Updating `port_min` updates `port` to the same value.
     *
     *  Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
     *  `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must
     *  be `1`.
     *
     *  Each listener in the load balancer must have a non-overlapping port range and
     *  `protocol` combination.
     */
    portMin?: number;
    /** The listener protocol. Each listener in the load balancer must have a non-overlapping port range and
     *  `protocol` combination.
     *
     *  Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
     *  the `application` family support `tcp`, `http` and
     *  `https`.
     *
     *  Additional restrictions:
     *  - If `default_pool` is set, the protocol cannot be changed.
     *  - If `https_redirect` is set, the protocol must be `http`.
     *  - If another listener's `https_redirect` targets this listener, the protocol must be
     *  `https`.
     */
    protocol?: UpdateLoadBalancerListenerConstants.Protocol | string;
  }

  /** Constants for the `updateLoadBalancerListener` operation. */
  export namespace UpdateLoadBalancerListenerConstants {
    /** The listener protocol. Each listener in the load balancer must have a non-overlapping port range and `protocol` combination. Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the `application` family support `tcp`, `http` and `https`. Additional restrictions: - If `default_pool` is set, the protocol cannot be changed. - If `https_redirect` is set, the protocol must be `http`. - If another listener's `https_redirect` targets this listener, the protocol must be `https`. */
    export enum Protocol {
      HTTP = 'http',
      HTTPS = 'https',
      TCP = 'tcp',
      UDP = 'udp',
    }
  }

  /** Parameters for the `listLoadBalancerListenerPolicies` operation. */
  export interface ListLoadBalancerListenerPoliciesParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
  }

  /** Parameters for the `createLoadBalancerListenerPolicy` operation. */
  export interface CreateLoadBalancerListenerPolicyParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy action:
     *  - `forward_to_listener`: Requests will be forwarded to the specified
     *    `target` listener.
     *  - `forward_to_pool`: Requests will be forwarded to the specified `target` pool.
     *  - `https_redirect`: Requests will be redirected to the specified `target.listener`.
     *     This listener must have a `protocol` of `http`, and the target listener must
     *     have a `protocol` of `https`.
     *  - `redirect`: Requests will be redirected to the specified `target.url`
     *  - `reject`: Requests will be rejected with a `403` status code.
     */
    action: CreateLoadBalancerListenerPolicyConstants.Action | string;
    /** Priority of the policy. The priority is unique across all policies for this load balancer listener. Lower
     *  value indicates higher priority.
     */
    priority: number;
    /** The name for this policy. The name must not be used by another policy for the load balancer listener. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The rule prototype objects for this policy. */
    rules?: LoadBalancerListenerPolicyRulePrototype[];
    /** - If `action` is `forward_to_listener`, specify a `LoadBalancerListenerIdentity` in this
     *    load balancer to forward to.
     *  - If `action` is `forward_to_pool`, use `LoadBalancerPoolIdentity` to specify a pool in
     *    this load balancer to forward to.
     *  - If `action` is `https_redirect`, use
     *    `LoadBalancerListenerPolicyHTTPSRedirectPrototype` to specify a listener on this
     *    load balancer to redirect to.
     *  - If `action` is `redirect`, use `LoadBalancerListenerPolicyRedirectURLPrototype`to
     *    specify a URL to redirect to.
     */
    target?: LoadBalancerListenerPolicyTargetPrototype;
  }

  /** Constants for the `createLoadBalancerListenerPolicy` operation. */
  export namespace CreateLoadBalancerListenerPolicyConstants {
    /** The policy action: - `forward_to_listener`: Requests will be forwarded to the specified `target` listener. - `forward_to_pool`: Requests will be forwarded to the specified `target` pool. - `https_redirect`: Requests will be redirected to the specified `target.listener`. This listener must have a `protocol` of `http`, and the target listener must have a `protocol` of `https`. - `redirect`: Requests will be redirected to the specified `target.url` - `reject`: Requests will be rejected with a `403` status code. */
    export enum Action {
      FORWARD_TO_LISTENER = 'forward_to_listener',
      FORWARD_TO_POOL = 'forward_to_pool',
      HTTPS_REDIRECT = 'https_redirect',
      REDIRECT = 'redirect',
      REJECT = 'reject',
    }
  }

  /** Parameters for the `deleteLoadBalancerListenerPolicy` operation. */
  export interface DeleteLoadBalancerListenerPolicyParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    id: string;
  }

  /** Parameters for the `getLoadBalancerListenerPolicy` operation. */
  export interface GetLoadBalancerListenerPolicyParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    id: string;
  }

  /** Parameters for the `updateLoadBalancerListenerPolicy` operation. */
  export interface UpdateLoadBalancerListenerPolicyParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    id: string;
    /** The name for this policy. The name must not be used by another policy for the load balancer listener. */
    name?: string;
    /** Priority of the policy. The priority is unique across all policies for this load balancer listener. Lower
     *  value indicates higher priority.
     */
    priority?: number;
    /** - If `action` is `forward_to_listener`, specify a `LoadBalancerListenerIdentity` for a
     *    listener in this load balancer.
     *  - If `action` is `forward_to_pool`, specify a `LoadBalancerPoolIdentity` for a pool in
     *    this load balancer.
     *  - If `action` is `https_redirect`, specify a
     *    `LoadBalancerListenerPolicyHTTPSRedirectPatch` for a listener in this load balancer
     *    with a `protocol` of `https`.
     *  - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPatch`.
     */
    target?: LoadBalancerListenerPolicyTargetPatch;
  }

  /** Parameters for the `listLoadBalancerListenerPolicyRules` operation. */
  export interface ListLoadBalancerListenerPolicyRulesParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    policyId: string;
  }

  /** Parameters for the `createLoadBalancerListenerPolicyRule` operation. */
  export interface CreateLoadBalancerListenerPolicyRuleParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    policyId: string;
    /** The condition for the rule. */
    condition: CreateLoadBalancerListenerPolicyRuleConstants.Condition | string;
    /** The content the rule applies to:
     *  - `body`: The UTF-8 form-encoded HTTP request body
     *  - `header`: The HTTP header
     *  - `hostname`: The fully-qualified domain name of the server specified in the Host
     *    HTTP request header
     *  - `path`: The path of the HTTP request
     *  - `query`: The query of the HTTP request URL
     *  - `sni_hostname`: The fully-qualified domain name of the server provided in the
     *    "server name indicator" extension during TLS negotiation
     *
     *  - For listeners with `protocol` `http` or `https`, any type may be specified.
     *  - For listeners with `protocol` `tcp`, only type `sni_hostname` may be specified.
     */
    type: CreateLoadBalancerListenerPolicyRuleConstants.Type | string;
    /** The value to be matched for the rule condition.
     *
     *  If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
     */
    value: string;
    /** The field to match for this rule.
     *  - If the `type` is `header`, this property must be specified.
     *  - If the `type` is `body` or `query`, this property may be specified.
     *  - For all other types, this property must not be specified.
     */
    field?: string;
  }

  /** Constants for the `createLoadBalancerListenerPolicyRule` operation. */
  export namespace CreateLoadBalancerListenerPolicyRuleConstants {
    /** The condition for the rule. */
    export enum Condition {
      CONTAINS = 'contains',
      EQUALS = 'equals',
      MATCHES_REGEX = 'matches_regex',
    }
    /** The content the rule applies to: - `body`: The UTF-8 form-encoded HTTP request body - `header`: The HTTP header - `hostname`: The fully-qualified domain name of the server specified in the Host HTTP request header - `path`: The path of the HTTP request - `query`: The query of the HTTP request URL - `sni_hostname`: The fully-qualified domain name of the server provided in the "server name indicator" extension during TLS negotiation - For listeners with `protocol` `http` or `https`, any type may be specified. - For listeners with `protocol` `tcp`, only type `sni_hostname` may be specified. */
    export enum Type {
      BODY = 'body',
      HEADER = 'header',
      HOSTNAME = 'hostname',
      PATH = 'path',
      QUERY = 'query',
      SNI_HOSTNAME = 'sni_hostname',
    }
  }

  /** Parameters for the `deleteLoadBalancerListenerPolicyRule` operation. */
  export interface DeleteLoadBalancerListenerPolicyRuleParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    policyId: string;
    /** The rule identifier. */
    id: string;
  }

  /** Parameters for the `getLoadBalancerListenerPolicyRule` operation. */
  export interface GetLoadBalancerListenerPolicyRuleParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    policyId: string;
    /** The rule identifier. */
    id: string;
  }

  /** Parameters for the `updateLoadBalancerListenerPolicyRule` operation. */
  export interface UpdateLoadBalancerListenerPolicyRuleParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The listener identifier. */
    listenerId: string;
    /** The policy identifier. */
    policyId: string;
    /** The rule identifier. */
    id: string;
    /** The condition for the rule. */
    condition?: UpdateLoadBalancerListenerPolicyRuleConstants.Condition | string;
    /** The field to match for this rule.
     *  - If the `type` is `header`, this property must be specified.
     *  - If the `type` is `body` or `query`, this property may be specified.
     *  - For all other types, this property must not be specified.
     */
    field?: string;
    /** The content the rule applies to:
     *  - `body`: The UTF-8 form-encoded HTTP request body
     *  - `header`: The HTTP header
     *  - `hostname`: The fully-qualified domain name of the server specified in the Host
     *    HTTP request header
     *  - `path`: The path of the HTTP request
     *  - `query`: The query of the HTTP request URL
     *  - `sni_hostname`: The fully-qualified domain name of the server provided in the
     *    "server name indicator" extension during TLS negotiation
     *
     *  - For listeners with `protocol` `http` or `https`, any type may be specified.
     *  - For listeners with `protocol` `tcp`, only type `sni_hostname` may be specified.
     */
    type?: UpdateLoadBalancerListenerPolicyRuleConstants.Type | string;
    /** The value to be matched for the rule condition.
     *
     *  If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
     */
    value?: string;
  }

  /** Constants for the `updateLoadBalancerListenerPolicyRule` operation. */
  export namespace UpdateLoadBalancerListenerPolicyRuleConstants {
    /** The condition for the rule. */
    export enum Condition {
      CONTAINS = 'contains',
      EQUALS = 'equals',
      MATCHES_REGEX = 'matches_regex',
    }
    /** The content the rule applies to: - `body`: The UTF-8 form-encoded HTTP request body - `header`: The HTTP header - `hostname`: The fully-qualified domain name of the server specified in the Host HTTP request header - `path`: The path of the HTTP request - `query`: The query of the HTTP request URL - `sni_hostname`: The fully-qualified domain name of the server provided in the "server name indicator" extension during TLS negotiation - For listeners with `protocol` `http` or `https`, any type may be specified. - For listeners with `protocol` `tcp`, only type `sni_hostname` may be specified. */
    export enum Type {
      BODY = 'body',
      HEADER = 'header',
      HOSTNAME = 'hostname',
      PATH = 'path',
      QUERY = 'query',
      SNI_HOSTNAME = 'sni_hostname',
    }
  }

  /** Parameters for the `listLoadBalancerPools` operation. */
  export interface ListLoadBalancerPoolsParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
  }

  /** Parameters for the `createLoadBalancerPool` operation. */
  export interface CreateLoadBalancerPoolParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The load balancing algorithm. The `least_connections` algorithm is only supported for load balancers that
     *  have `availability` with value `subnet` in the profile.
     */
    algorithm: CreateLoadBalancerPoolConstants.Algorithm | string;
    /** The health monitor of this pool.
     *
     *  If this pool has a member targeting a load balancer then:
     *
     *  - If the targeted load balancer has multiple subnets, this health monitor will be
     *    used to direct traffic to the available subnets.
     *  - The health checks spawned by this health monitor will be handled as any other
     *    traffic (that is, subject to the configuration of listeners and pools on the target
     *    load balancer).
     *  - This health monitor does not affect how pool member health is determined within the
     *    target load balancer.
     *
     *  For more information, see [Private Path network load balancer frequently asked
     *  questions](https://cloud.ibm.com/docs/vpc?topic=vpc-nlb-faqs#ppnlb-faqs).
     */
    healthMonitor: LoadBalancerPoolHealthMonitorPrototype;
    /** The protocol used for this load balancer pool. Load balancers in the `network` family support `tcp` and
     *  `udp` (if `udp_supported` is `true`). Load balancers in the
     *  `application` family support `tcp`, `http`, and `https`.
     */
    protocol: CreateLoadBalancerPoolConstants.Protocol | string;
    /** The failsafe policy to use for this pool.
     *
     *  If unspecified, the default failsafe policy action from the profile will be used.
     */
    failsafePolicy?: LoadBalancerPoolFailsafePolicyPrototype;
    /** The members for this load balancer pool. For load balancers in the `network` family, the same `port` and
     *  `target` tuple cannot be shared by a pool member of any other load balancer in the same VPC.
     */
    members?: LoadBalancerPoolMemberPrototype[];
    /** The name for this load balancer pool. The name must not be used by another pool for the load balancer. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The PROXY protocol setting for this pool:
     *  - `v1`: Enabled with version 1 (human-readable header format)
     *  - `v2`: Enabled with version 2 (binary header format)
     *  - `disabled`: Disabled
     *
     *  For load balancers in the `network` family, this property must be `disabled`.
     */
    proxyProtocol?: CreateLoadBalancerPoolConstants.ProxyProtocol | string;
    /** The session persistence of this pool. If specified, the load balancer must have
     *  `source_ip_session_persistence_supported` set to `true` in its profile.
     *
     *  If unspecified, session persistence will be disabled, and traffic will be distributed
     *  across members of the pool.
     */
    sessionPersistence?: LoadBalancerPoolSessionPersistencePrototype;
  }

  /** Constants for the `createLoadBalancerPool` operation. */
  export namespace CreateLoadBalancerPoolConstants {
    /** The load balancing algorithm. The `least_connections` algorithm is only supported for load balancers that have `availability` with value `subnet` in the profile. */
    export enum Algorithm {
      LEAST_CONNECTIONS = 'least_connections',
      ROUND_ROBIN = 'round_robin',
      WEIGHTED_ROUND_ROBIN = 'weighted_round_robin',
    }
    /** The protocol used for this load balancer pool. Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the `application` family support `tcp`, `http`, and `https`. */
    export enum Protocol {
      HTTP = 'http',
      HTTPS = 'https',
      TCP = 'tcp',
      UDP = 'udp',
    }
    /** The PROXY protocol setting for this pool: - `v1`: Enabled with version 1 (human-readable header format) - `v2`: Enabled with version 2 (binary header format) - `disabled`: Disabled For load balancers in the `network` family, this property must be `disabled`. */
    export enum ProxyProtocol {
      DISABLED = 'disabled',
      V1 = 'v1',
      V2 = 'v2',
    }
  }

  /** Parameters for the `deleteLoadBalancerPool` operation. */
  export interface DeleteLoadBalancerPoolParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    id: string;
  }

  /** Parameters for the `getLoadBalancerPool` operation. */
  export interface GetLoadBalancerPoolParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    id: string;
  }

  /** Parameters for the `updateLoadBalancerPool` operation. */
  export interface UpdateLoadBalancerPoolParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    id: string;
    /** The load balancing algorithm. The `least_connections` algorithm is only supported for load balancers that
     *  have `availability` with value `subnet` in the profile.
     */
    algorithm?: UpdateLoadBalancerPoolConstants.Algorithm | string;
    /** The failsafe policy for this load balancer pool. */
    failsafePolicy?: LoadBalancerPoolFailsafePolicyPatch;
    /** The health monitor of this pool.
     *
     *  If this pool has a member targeting a load balancer then:
     *
     *  - If the targeted load balancer has multiple subnets, this health monitor will be
     *    used to direct traffic to the available subnets.
     *  - The health checks spawned by this health monitor will be handled as any other
     *    traffic (that is, subject to the configuration of listeners and pools on the
     *    target load balancer).
     *  - This health monitor does not affect how pool member health is determined within
     *    the target load balancer.
     *
     *  For more information, see [Private Path network load balancer frequently asked
     *  questions](https://cloud.ibm.com/docs/vpc?topic=vpc-nlb-faqs#ppnlb-faqs).
     */
    healthMonitor?: LoadBalancerPoolHealthMonitorPatch;
    /** The name for this load balancer pool. The name must not be used by another pool for the load balancer. */
    name?: string;
    /** The protocol for this load balancer pool.
     *
     *  Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
     *  the `application` family support `tcp`, `http` and
     *  `https`.
     *
     *  If this pool is associated with a load balancer listener or a load balancer failsafe target pool, the specified
     *  protocol must match or be compatible with each other's protocol. At present, the compatible protocols are `http`
     *  and `https`.
     */
    protocol?: UpdateLoadBalancerPoolConstants.Protocol | string;
    /** The PROXY protocol setting for this pool:
     *  - `v1`: Enabled with version 1 (human-readable header format)
     *  - `v2`: Enabled with version 2 (binary header format)
     *  - `disabled`: Disabled
     *
     *  For load balancers in the `network` family, this property must be `disabled`.
     */
    proxyProtocol?: UpdateLoadBalancerPoolConstants.ProxyProtocol | string;
    /** The session persistence of this pool. */
    sessionPersistence?: LoadBalancerPoolSessionPersistencePatch;
  }

  /** Constants for the `updateLoadBalancerPool` operation. */
  export namespace UpdateLoadBalancerPoolConstants {
    /** The load balancing algorithm. The `least_connections` algorithm is only supported for load balancers that have `availability` with value `subnet` in the profile. */
    export enum Algorithm {
      LEAST_CONNECTIONS = 'least_connections',
      ROUND_ROBIN = 'round_robin',
      WEIGHTED_ROUND_ROBIN = 'weighted_round_robin',
    }
    /** The protocol for this load balancer pool. Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the `application` family support `tcp`, `http` and `https`. If this pool is associated with a load balancer listener or a load balancer failsafe target pool, the specified protocol must match or be compatible with each other's protocol. At present, the compatible protocols are `http` and `https`. */
    export enum Protocol {
      HTTP = 'http',
      HTTPS = 'https',
      TCP = 'tcp',
      UDP = 'udp',
    }
    /** The PROXY protocol setting for this pool: - `v1`: Enabled with version 1 (human-readable header format) - `v2`: Enabled with version 2 (binary header format) - `disabled`: Disabled For load balancers in the `network` family, this property must be `disabled`. */
    export enum ProxyProtocol {
      DISABLED = 'disabled',
      V1 = 'v1',
      V2 = 'v2',
    }
  }

  /** Parameters for the `listLoadBalancerPoolMembers` operation. */
  export interface ListLoadBalancerPoolMembersParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
  }

  /** Parameters for the `createLoadBalancerPoolMember` operation. */
  export interface CreateLoadBalancerPoolMemberParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
    /** The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on
     *  a listener with a single port. (If the traffic is received on a listener with a port range, the member will
     *  receive the traffic on the same port the listener received it on.)
     *
     *  This port will also be used for health checks unless the `port` property of
     *  `health_monitor` property is specified.
     *
     *  The port must be unique across all members for all pools associated with this pool's listener.
     *
     *  For load balancers in the `network` family, the same `port` and `target` tuple cannot be shared by a pool member
     *  of any other load balancer in the same VPC.
     */
    port: number;
    /** The pool member target.
     *
     *  If the load balancer has `route_mode` set to `true`, the member must be in a zone the load
     *  balancer has a subnet in.
     *
     *  For load balancers in the `network` family, the same `port` and `target` tuple cannot
     *  be shared by a pool member of any other load balancer in the same VPC.
     */
    target: LoadBalancerPoolMemberTargetPrototype;
    /** The weight of the server member.
     *
     *  If specified, the pool algorithm must be `weighted_round_robin` and the load balancer must be in the
     *  `application` family.
     *
     *  If unspecified, the weight will be `50` for load balancers in the `application` family.
     */
    weight?: number;
  }

  /** Parameters for the `replaceLoadBalancerPoolMembers` operation. */
  export interface ReplaceLoadBalancerPoolMembersParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
    /** The member prototype objects for this pool. */
    members: LoadBalancerPoolMemberPrototype[];
  }

  /** Parameters for the `deleteLoadBalancerPoolMember` operation. */
  export interface DeleteLoadBalancerPoolMemberParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
    /** The member identifier. */
    id: string;
  }

  /** Parameters for the `getLoadBalancerPoolMember` operation. */
  export interface GetLoadBalancerPoolMemberParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
    /** The member identifier. */
    id: string;
  }

  /** Parameters for the `updateLoadBalancerPoolMember` operation. */
  export interface UpdateLoadBalancerPoolMemberParams extends DefaultParams {
    /** The load balancer identifier. */
    loadBalancerId: string;
    /** The pool identifier. */
    poolId: string;
    /** The member identifier. */
    id: string;
    /** The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on
     *  a listener with a single port. (If the traffic is received on a listener with a port range, the member will
     *  receive the traffic on the same port the listener received it on.)
     *
     *  This port will also be used for health checks unless the `port` property of
     *  `health_monitor` property is specified.
     *
     *  The port must be unique across all members for all pools associated with this pool's listener.
     *
     *  For load balancers in the `network` family, the same `port` and `target` tuple cannot be shared by a pool member
     *  of any other load balancer in the same VPC.
     */
    port?: number;
    /** The pool member target.
     *
     *  If the load balancer has `route_mode` set to `true`, the member must be in a zone the load
     *  balancer has a subnet in.
     *
     *  For load balancers in the `network` family, the same `port` and `target` tuple cannot
     *  be shared by a pool member of any other load balancer in the same VPC.
     */
    target?: LoadBalancerPoolMemberTargetPrototype;
    /** The weight of the server member.
     *
     *  If specified, the pool algorithm must be `weighted_round_robin`.
     */
    weight?: number;
  }

  /** Parameters for the `listEndpointGateways` operation. */
  export interface ListEndpointGatewaysParams extends DefaultParams {
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `lifecycle_state` property matching one of the specified
     *  comma-separated values.
     */
    lifecycleState?: ListEndpointGatewaysConstants.LifecycleState[] | string[];
    /** Filters the collection to resources with a `vpc.id` property matching the specified identifier. */
    vpcId?: string;
    /** Filters the collection to resources with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to resources with a `vpc.name` property matching the exact specified name. */
    vpcName?: string;
    /** Filters the collection to endpoint gateways with an `allow_dns_resolution_binding` property matching the
     *  specified value.
     */
    allowDnsResolutionBinding?: boolean;
  }

  /** Constants for the `listEndpointGateways` operation. */
  export namespace ListEndpointGatewaysConstants {
    /** Filters the collection to resources with a `lifecycle_state` property matching one of the specified comma-separated values. */
    export enum LifecycleState {
      DELETING = 'deleting',
      FAILED = 'failed',
      PENDING = 'pending',
      STABLE = 'stable',
      SUSPENDED = 'suspended',
      UPDATING = 'updating',
      WAITING = 'waiting',
    }
  }

  /** Parameters for the `createEndpointGateway` operation. */
  export interface CreateEndpointGatewayParams extends DefaultParams {
    /** The target to use for this endpoint gateway. The target:
     *  - Must not already be the target of another endpoint gateway in the VPC
     *  - Must not have a service endpoint that duplicates or overlaps with any `service_endpoints`
     *    of another endpoint gateway in the VPC.
     */
    target: EndpointGatewayTargetPrototype;
    /** The VPC this endpoint gateway will reside in. */
    vpc: VPCIdentity;
    /** Indicates whether to allow DNS resolution for this endpoint gateway when the VPC this endpoint gateway
     *  resides in has a DNS resolution binding to a VPC with `dns.enable_hub` set to `true`.
     *
     *  Must be `true` if the VPC this endpoint gateway resides in has `dns.enable_hub` set to
     *  `true`.
     */
    allowDnsResolutionBinding?: boolean;
    /** The reserved IPs to bind to this endpoint gateway. At most one reserved IP per zone is allowed. */
    ips?: EndpointGatewayReservedIP[];
    /** The name for this endpoint gateway. The name must not be used by another endpoint gateway in the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** The security groups to use for this endpoint gateway. If unspecified, the VPC's default security group is
     *  used.
     */
    securityGroups?: SecurityGroupIdentity[];
  }

  /** Parameters for the `listEndpointGatewayIps` operation. */
  export interface ListEndpointGatewayIpsParams extends DefaultParams {
    /** The endpoint gateway identifier. */
    endpointGatewayId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to
     *  the name to sort in descending order. For example, the value `-created_at` sorts the collection by the
     *  `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending
     *  order.
     */
    sort?: ListEndpointGatewayIpsConstants.Sort | string;
  }

  /** Constants for the `listEndpointGatewayIps` operation. */
  export namespace ListEndpointGatewayIpsConstants {
    /** Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property in descending order, and the value `name` sorts it by the `name` property in ascending order. */
    export enum Sort {
      ADDRESS = 'address',
      CREATED_AT = 'created_at',
      NAME = 'name',
    }
  }

  /** Parameters for the `removeEndpointGatewayIp` operation. */
  export interface RemoveEndpointGatewayIpParams extends DefaultParams {
    /** The endpoint gateway identifier. */
    endpointGatewayId: string;
    /** The reserved IP identifier. */
    id: string;
  }

  /** Parameters for the `getEndpointGatewayIp` operation. */
  export interface GetEndpointGatewayIpParams extends DefaultParams {
    /** The endpoint gateway identifier. */
    endpointGatewayId: string;
    /** The reserved IP identifier. */
    id: string;
  }

  /** Parameters for the `addEndpointGatewayIp` operation. */
  export interface AddEndpointGatewayIpParams extends DefaultParams {
    /** The endpoint gateway identifier. */
    endpointGatewayId: string;
    /** The reserved IP identifier. */
    id: string;
  }

  /** Parameters for the `deleteEndpointGateway` operation. */
  export interface DeleteEndpointGatewayParams extends DefaultParams {
    /** The endpoint gateway identifier. */
    id: string;
  }

  /** Parameters for the `getEndpointGateway` operation. */
  export interface GetEndpointGatewayParams extends DefaultParams {
    /** The endpoint gateway identifier. */
    id: string;
  }

  /** Parameters for the `updateEndpointGateway` operation. */
  export interface UpdateEndpointGatewayParams extends DefaultParams {
    /** The endpoint gateway identifier. */
    id: string;
    /** Indicates whether to allow DNS resolution for this endpoint gateway when the VPC this endpoint gateway
     *  resides in has a DNS resolution binding to a VPC with `dns.enable_hub` set to `true`.
     *
     *  Must be `true` if the VPC this endpoint gateway resides in has `dns.enable_hub` set to
     *  `true`.
     */
    allowDnsResolutionBinding?: boolean;
    /** The name for this endpoint gateway. The name must not be used by another endpoint gateway in the VPC. */
    name?: string;
  }

  /** Parameters for the `listFlowLogCollectors` operation. */
  export interface ListFlowLogCollectorsParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
    /** Filters the collection to resources with a `name` property matching the exact specified name. */
    name?: string;
    /** Filters the collection to resources with a `vpc.id` property matching the specified identifier. */
    vpcId?: string;
    /** Filters the collection to resources with a `vpc.crn` property matching the specified CRN. */
    vpcCrn?: string;
    /** Filters the collection to resources with a `vpc.name` property matching the exact specified name. */
    vpcName?: string;
    /** Filters the collection to resources with a `target.id` property matching the specified identifier. */
    targetId?: string;
    /** Filters the collection to resources with a `target.resource_type` property matching the specified value. */
    targetResourceType?: string;
  }

  /** Parameters for the `createFlowLogCollector` operation. */
  export interface CreateFlowLogCollectorParams extends DefaultParams {
    /** The Cloud Object Storage bucket where the collected flows will be logged.
     *  The bucket must exist and an IAM service authorization must grant
     *  `IBM Cloud Flow Logs` resources of `VPC Infrastructure Services` writer
     *  access to the bucket. For more information, see [Creating a flow log
     *  collector](https://cloud.ibm.com/docs/vpc?topic=vpc-ordering-flow-log-collector).
     */
    storageBucket: LegacyCloudObjectStorageBucketIdentity;
    /** The target this collector will collect flow logs for.
     *
     *  If the target is an instance, subnet, or VPC, flow logs will not be collected for any
     *  instance network attachments, virtual network interfaces or instance network interfaces
     *  within the target that are themselves the target of a more specific flow log collector.
     *
     *  The target must not be a virtual network interface that is attached to a bare metal server
     *  network attachment or to a file share mount target.
     */
    target: FlowLogCollectorTargetPrototype;
    /** Indicates whether this collector will be active upon creation. */
    active?: boolean;
    /** The name for this flow log collector. The name must not be used by another flow log collector in the VPC. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
  }

  /** Parameters for the `deleteFlowLogCollector` operation. */
  export interface DeleteFlowLogCollectorParams extends DefaultParams {
    /** The flow log collector identifier. */
    id: string;
  }

  /** Parameters for the `getFlowLogCollector` operation. */
  export interface GetFlowLogCollectorParams extends DefaultParams {
    /** The flow log collector identifier. */
    id: string;
  }

  /** Parameters for the `updateFlowLogCollector` operation. */
  export interface UpdateFlowLogCollectorParams extends DefaultParams {
    /** The flow log collector identifier. */
    id: string;
    /** Indicates whether this collector is active. Updating to false deactivates the collector and updating to true
     *  activates the collector.
     */
    active?: boolean;
    /** The name for this flow log collector. The name must not be used by another flow log collector in the VPC. */
    name?: string;
  }

  /** Parameters for the `listPrivatePathServiceGateways` operation. */
  export interface ListPrivatePathServiceGatewaysParams extends DefaultParams {
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with a `resource_group.id` property matching the specified identifier. */
    resourceGroupId?: string;
  }

  /** Parameters for the `createPrivatePathServiceGateway` operation. */
  export interface CreatePrivatePathServiceGatewayParams extends DefaultParams {
    /** The load balancer for this private path service gateway. The load balancer must
     *  have `is_private_path` set to `true`.
     *
     *  The private path service gateway will reside in the same VPC as the specified load
     *  balancer.
     */
    loadBalancer: LoadBalancerIdentity;
    /** The fully qualified domain names for this private path service gateway. Any uppercase letters will be
     *  converted to lowercase.
     */
    serviceEndpoints: string[];
    /** The policy to use for bindings from accounts without an explicit account policy. */
    defaultAccessPolicy?: CreatePrivatePathServiceGatewayConstants.DefaultAccessPolicy | string;
    /** The name for this private path service gateway. The name must not be used by another private path service
     *  gateway in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resourceGroup?: ResourceGroupIdentity;
    /** Indicates whether this private path service gateway has zonal affinity.
     *  - `true`:  Traffic to the service from a zone the service resides in will remain in
     *             that zone.
     *  - `false`: Traffic to the service from a zone will be load balanced across all zones
     *             in the region the service resides in.
     */
    zonalAffinity?: boolean;
  }

  /** Constants for the `createPrivatePathServiceGateway` operation. */
  export namespace CreatePrivatePathServiceGatewayConstants {
    /** The policy to use for bindings from accounts without an explicit account policy. */
    export enum DefaultAccessPolicy {
      DENY = 'deny',
      PERMIT = 'permit',
      REVIEW = 'review',
    }
  }

  /** Parameters for the `deletePrivatePathServiceGateway` operation. */
  export interface DeletePrivatePathServiceGatewayParams extends DefaultParams {
    /** The private path service gateway identifier. */
    id: string;
  }

  /** Parameters for the `getPrivatePathServiceGateway` operation. */
  export interface GetPrivatePathServiceGatewayParams extends DefaultParams {
    /** The private path service gateway identifier. */
    id: string;
  }

  /** Parameters for the `updatePrivatePathServiceGateway` operation. */
  export interface UpdatePrivatePathServiceGatewayParams extends DefaultParams {
    /** The private path service gateway identifier. */
    id: string;
    /** The policy to use for bindings from accounts without an explicit account policy. */
    defaultAccessPolicy?: UpdatePrivatePathServiceGatewayConstants.DefaultAccessPolicy | string;
    /** The load balancer for this private path service gateway. The load balancer must
     *  have `is_private_path` set to `true`, and must be in the same VPC as the private
     *  path service gateway.
     */
    loadBalancer?: LoadBalancerIdentity;
    /** The name for this private path service gateway. The name must not be used by another private path service
     *  gateway in the VPC.
     */
    name?: string;
    /** Updating the value of `zonal_affinity` changes how traffic for existing and future endpoint gateway bindings
     *  will be routed:
     *  - `true`:  Traffic to the service from a zone the service resides in will remain in
     *             that zone.
     *  - `false`: Traffic to the service from a zone will be load balanced across all zones
     *             in the region the service resides in.
     */
    zonalAffinity?: boolean;
  }

  /** Constants for the `updatePrivatePathServiceGateway` operation. */
  export namespace UpdatePrivatePathServiceGatewayConstants {
    /** The policy to use for bindings from accounts without an explicit account policy. */
    export enum DefaultAccessPolicy {
      DENY = 'deny',
      PERMIT = 'permit',
      REVIEW = 'review',
    }
  }

  /** Parameters for the `listPrivatePathServiceGatewayAccountPolicies` operation. */
  export interface ListPrivatePathServiceGatewayAccountPoliciesParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to resources with an `account.id` property matching the specified identifier. */
    accountId?: string;
  }

  /** Parameters for the `createPrivatePathServiceGatewayAccountPolicy` operation. */
  export interface CreatePrivatePathServiceGatewayAccountPolicyParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
    /** The access policy for the account. Updating the access policy only affects pending and future endpoint
     *  gateway bindings.
     *  - permit: access will be permitted
     *  - deny: access will be denied
     *  - review: access will be manually reviewed
     *
     *  - Updating to `review` sets the status of future endpoint gateway bindings from
     *     this account to `pending`.
     *  - Updating to `permit` updates both the status of any `pending` and future endpoint
     *    gateway bindings from this account to `permitted`.
     *  - Updating to `deny` updates both the status of any `pending` and future endpoint
     *    gateway bindings from this account to `denied`.
     */
    accessPolicy: CreatePrivatePathServiceGatewayAccountPolicyConstants.AccessPolicy | string;
    /** The account for this access policy. The account must be unique across all account
     *  policies for this private path service gateway.
     */
    account: AccountIdentity;
  }

  /** Constants for the `createPrivatePathServiceGatewayAccountPolicy` operation. */
  export namespace CreatePrivatePathServiceGatewayAccountPolicyConstants {
    /** The access policy for the account. Updating the access policy only affects pending and future endpoint gateway bindings. - permit: access will be permitted - deny: access will be denied - review: access will be manually reviewed - Updating to `review` sets the status of future endpoint gateway bindings from this account to `pending`. - Updating to `permit` updates both the status of any `pending` and future endpoint gateway bindings from this account to `permitted`. - Updating to `deny` updates both the status of any `pending` and future endpoint gateway bindings from this account to `denied`. */
    export enum AccessPolicy {
      DENY = 'deny',
      PERMIT = 'permit',
      REVIEW = 'review',
    }
  }

  /** Parameters for the `deletePrivatePathServiceGatewayAccountPolicy` operation. */
  export interface DeletePrivatePathServiceGatewayAccountPolicyParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
    /** The account policy identifier. */
    id: string;
  }

  /** Parameters for the `getPrivatePathServiceGatewayAccountPolicy` operation. */
  export interface GetPrivatePathServiceGatewayAccountPolicyParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
    /** The account policy identifier. */
    id: string;
  }

  /** Parameters for the `updatePrivatePathServiceGatewayAccountPolicy` operation. */
  export interface UpdatePrivatePathServiceGatewayAccountPolicyParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
    /** The account policy identifier. */
    id: string;
    /** The access policy for the account. Updating the access policy only affects pending and future endpoint
     *  gateway bindings.
     *  - permit: access will be permitted
     *  - deny: access will be denied
     *  - review: access will be manually reviewed
     *
     *  - Updating to `review` sets the status of future endpoint gateway bindings from
     *     this account to `pending`.
     *  - Updating to `permit` updates both the status of any `pending` and future endpoint
     *    gateway bindings from this account to `permitted`.
     *  - Updating to `deny` updates both the status of any `pending` and future endpoint
     *    gateway bindings from this account to `denied`.
     */
    accessPolicy?: UpdatePrivatePathServiceGatewayAccountPolicyConstants.AccessPolicy | string;
  }

  /** Constants for the `updatePrivatePathServiceGatewayAccountPolicy` operation. */
  export namespace UpdatePrivatePathServiceGatewayAccountPolicyConstants {
    /** The access policy for the account. Updating the access policy only affects pending and future endpoint gateway bindings. - permit: access will be permitted - deny: access will be denied - review: access will be manually reviewed - Updating to `review` sets the status of future endpoint gateway bindings from this account to `pending`. - Updating to `permit` updates both the status of any `pending` and future endpoint gateway bindings from this account to `permitted`. - Updating to `deny` updates both the status of any `pending` and future endpoint gateway bindings from this account to `denied`. */
    export enum AccessPolicy {
      DENY = 'deny',
      PERMIT = 'permit',
      REVIEW = 'review',
    }
  }

  /** Parameters for the `listPrivatePathServiceGatewayEndpointGatewayBindings` operation. */
  export interface ListPrivatePathServiceGatewayEndpointGatewayBindingsParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
    /** A server-provided token determining what resource to start the page on. */
    start?: string;
    /** The number of resources to return on a page. */
    limit?: number;
    /** Filters the collection to endpoint gateway bindings with a `status` property matching the specified value. */
    status?: ListPrivatePathServiceGatewayEndpointGatewayBindingsConstants.Status | string;
    /** Filters the collection to resources with an `account.id` property matching the specified identifier. */
    accountId?: string;
  }

  /** Constants for the `listPrivatePathServiceGatewayEndpointGatewayBindings` operation. */
  export namespace ListPrivatePathServiceGatewayEndpointGatewayBindingsConstants {
    /** Filters the collection to endpoint gateway bindings with a `status` property matching the specified value. */
    export enum Status {
      ABANDONED = 'abandoned',
      DENIED = 'denied',
      EXPIRED = 'expired',
      PENDING = 'pending',
      PERMITTED = 'permitted',
    }
  }

  /** Parameters for the `getPrivatePathServiceGatewayEndpointGatewayBinding` operation. */
  export interface GetPrivatePathServiceGatewayEndpointGatewayBindingParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
    /** The endpoint gateway binding identifier. */
    id: string;
  }

  /** Parameters for the `denyPrivatePathServiceGatewayEndpointGatewayBinding` operation. */
  export interface DenyPrivatePathServiceGatewayEndpointGatewayBindingParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
    /** The endpoint gateway binding identifier. */
    id: string;
    /** Indicates whether this will become the access policy for any `pending` and future endpoint gateway bindings
     *  from the same account.
     *
     *  If set to `true`:
     *  - If the account has an existing access policy, that policy will be updated to `deny`.
     *    Otherwise, a new `deny` access policy will be created for the account.
     *  - All `pending` endpoint gateway bindings for the account will be denied.
     *
     *  If set to `false`:
     *  - No access policies will be created or updated
     *  - All `pending` endpoint gateway bindings for the account will remain `pending`.
     */
    setAccountPolicy?: boolean;
  }

  /** Parameters for the `permitPrivatePathServiceGatewayEndpointGatewayBinding` operation. */
  export interface PermitPrivatePathServiceGatewayEndpointGatewayBindingParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
    /** The endpoint gateway binding identifier. */
    id: string;
    /** Indicates whether this will become the access policy for any `pending` and future endpoint gateway bindings
     *  from the same account.
     *
     *  If set to `true`:
     *
     *  - If the account has an existing access policy, that policy will be updated to
     *    `permit`. Otherwise, a new `permit` access policy will be created for the account.
     *  - All `pending` endpoint gateway bindings for the account will be permitted.
     *
     *  If set to `false`:
     *
     *  - No access policies will be created or updated
     *  - All `pending` endpoint gateway bindings for the account will remain `pending`.
     */
    setAccountPolicy?: boolean;
  }

  /** Parameters for the `publishPrivatePathServiceGateway` operation. */
  export interface PublishPrivatePathServiceGatewayParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
  }

  /** Parameters for the `revokeAccountForPrivatePathServiceGateway` operation. */
  export interface RevokeAccountForPrivatePathServiceGatewayParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
    /** The account that will be revoked access to the private path service gateway. */
    account: AccountIdentity;
  }

  /** Parameters for the `unpublishPrivatePathServiceGateway` operation. */
  export interface UnpublishPrivatePathServiceGatewayParams extends DefaultParams {
    /** The private path service gateway identifier. */
    privatePathServiceGatewayId: string;
  }

  /*************************
   * model interfaces
   ************************/

  /**
   * Identifies an account by a unique property.
   */
  export interface AccountIdentity {
  }

  /**
   * AccountReference.
   */
  export interface AccountReference {
    /** The unique identifier for this account. */
    id: string;
    /** The resource type. */
    resource_type: AccountReference.Constants.ResourceType | string;
  }
  export namespace AccountReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        ACCOUNT = 'account',
      }
    }
  }

  /**
   * AddressPrefix.
   */
  export interface AddressPrefix {
    /** The CIDR block for this address prefix. */
    cidr: string;
    /** The date and time that this address prefix was created. */
    created_at: string;
    /** Indicates whether subnets exist with addresses from this address prefix. */
    has_subnets: boolean;
    /** The URL for this address prefix. */
    href: string;
    /** The unique identifier for this address prefix. */
    id: string;
    /** Indicates whether this is the default prefix for this zone in this VPC. If a default prefix was
     *  automatically created when the VPC was created, the prefix is automatically named using a hyphenated list of
     *  randomly-selected words, but may be changed.
     */
    is_default: boolean;
    /** The name for this address prefix. The name must not be used by another address prefix for the VPC. */
    name: string;
    /** The zone this address prefix resides in. */
    zone: ZoneReference;
  }

  /**
   * AddressPrefixCollection.
   */
  export interface AddressPrefixCollection {
    /** A page of address prefixes for the VPC. */
    address_prefixes: AddressPrefix[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * BackupPolicy.
   */
  export interface BackupPolicy {
    /** The date and time that the backup policy was created. */
    created_at: string;
    /** The CRN for this backup policy. */
    crn: string;
    /** The reasons for the current `health_state` (if any). */
    health_reasons: BackupPolicyHealthReason[];
    /** The health of this resource:
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle
     *     state. A resource with a lifecycle state of `failed` or `deleting` will have a
     *     health state of `inapplicable`. A `pending` resource may also have this state.
     */
    health_state: BackupPolicy.Constants.HealthState | string;
    /** The URL for this backup policy. */
    href: string;
    /** The unique identifier for this backup policy. */
    id: string;
    /** The date and time that the most recent job for this backup policy completed.
     *
     *  If absent, no job has yet completed for this backup policy.
     */
    last_job_completed_at?: string;
    /** The lifecycle state of the backup policy. */
    lifecycle_state: BackupPolicy.Constants.LifecycleState | string;
    /** The resource type this backup policy applies to. Resources that have both a matching type and a matching
     *  user tag will be subject to the backup policy.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    match_resource_type: BackupPolicy.Constants.MatchResourceType | string;
    /** The user tags this backup policy applies to. Resources that have both a matching user tag and a matching
     *  type will be subject to the backup policy.
     */
    match_user_tags: string[];
    /** The name for this backup policy. The name is unique across all backup policies in the region. */
    name: string;
    /** The plans for the backup policy. */
    plans: BackupPolicyPlanReference[];
    /** The resource group for this backup policy. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: BackupPolicy.Constants.ResourceType | string;
    /** The scope for this backup policy. */
    scope: BackupPolicyScope;
  }
  export namespace BackupPolicy {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the backup policy. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type this backup policy applies to. Resources that have both a matching type and a matching user tag will be subject to the backup policy. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum MatchResourceType {
        INSTANCE = 'instance',
        SHARE = 'share',
        VOLUME = 'volume',
      }
      /** The resource type. */
      export enum ResourceType {
        BACKUP_POLICY = 'backup_policy',
      }
    }
  }

  /**
   * BackupPolicyCollection.
   */
  export interface BackupPolicyCollection {
    /** A page of backup policies. */
    backup_policies: BackupPolicy[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * BackupPolicyHealthReason.
   */
  export interface BackupPolicyHealthReason {
    /** A reason code for this health state. */
    code: BackupPolicyHealthReason.Constants.Code | string;
    /** An explanation of the reason for this health state. */
    message: string;
    /** Link to documentation about the reason for this health state. */
    more_info?: string;
  }
  export namespace BackupPolicyHealthReason {
    export namespace Constants {
      /** A reason code for this health state. */
      export enum Code {
        MISSING_SERVICE_AUTHORIZATION_POLICIES = 'missing_service_authorization_policies',
      }
    }
  }

  /**
   * BackupPolicyJob.
   */
  export interface BackupPolicyJob {
    /** Indicates whether this backup policy job will be automatically deleted after it completes. At present, this
     *  is always `true`, but may be modifiable in the future.
     */
    auto_delete: boolean;
    /** If `auto_delete` is `true`, the days after completion that this backup policy job will be deleted. This
     *  value may be modifiable in the future.
     */
    auto_delete_after: number;
    /** The backup policy plan operated this backup policy job (may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     */
    backup_policy_plan: BackupPolicyPlanReference;
    /** The date and time that the backup policy job was completed.
     *
     *  If absent, the backup policy job has not yet completed.
     */
    completed_at?: string;
    /** The date and time that the backup policy job was created. */
    created_at: string;
    /** The URL for this backup policy job. */
    href: string;
    /** The unique identifier for this backup policy job. */
    id: string;
    /** The type of backup policy job.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    job_type: BackupPolicyJob.Constants.JobType | string;
    /** The resource type. */
    resource_type: BackupPolicyJob.Constants.ResourceType | string;
    /** The source this backup was created from (may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     */
    source: BackupPolicyJobSource;
    /** The status of the backup policy job.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: BackupPolicyJob.Constants.Status | string;
    /** The reasons for the current status (if any). */
    status_reasons: BackupPolicyJobStatusReason[];
    /** The snapshots operated on by this backup policy job (may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     */
    target_snapshots: BackupPolicyTargetSnapshot[];
  }
  export namespace BackupPolicyJob {
    export namespace Constants {
      /** The type of backup policy job. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum JobType {
        CREATION = 'creation',
        DELETION = 'deletion',
      }
      /** The resource type. */
      export enum ResourceType {
        BACKUP_POLICY_JOB = 'backup_policy_job',
      }
      /** The status of the backup policy job. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        FAILED = 'failed',
        RUNNING = 'running',
        SUCCEEDED = 'succeeded',
      }
    }
  }

  /**
   * BackupPolicyJobCollection.
   */
  export interface BackupPolicyJobCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of jobs for the backup policy. */
    jobs: BackupPolicyJob[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * The source this backup was created from (may be
   * [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
   */
  export interface BackupPolicyJobSource {
  }

  /**
   * BackupPolicyJobStatusReason.
   */
  export interface BackupPolicyJobStatusReason {
    /** A reason code for the status:
     *  - `internal_error`: Internal error (contact IBM support)
     *  - `snapshot_encryption_key_invalid`: The provided encryption key is unavailable
     *  - `snapshot_pending`: Cannot delete backup (snapshot) in the `pending` lifecycle state
     *  - `snapshot_source_unsupported`: The source access control mode does not support
     *    backups
     *  - `snapshot_rate_too_high`: The rate of backups for the resource is too high
     *  - `snapshot_share_limit`: The maximum limit for snapshots on this resource has been
     *    reached
     *  - `snapshot_source_unavailable`: The source data is not available (for example,
     *    because the source is still being created).
     *  - `snapshot_volume_limit`: The snapshot limit for the source volume has been reached
     *  - `source_volume_busy`: The source volume has `busy` set (after multiple retries)
     *  - `source_volume_too_large`: The source volume exceeds the [maximum supported
     *    size](https://cloud.ibm.com/docs/vpc?topic=vpc-snapshots-vpc-about&interface=api#snapshots-vpc-limitations)
     *  - `source_volume_unavailable`: The source volume is not attached to a running instance
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: BackupPolicyJobStatusReason.Constants.Code | string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace BackupPolicyJobStatusReason {
    export namespace Constants {
      /** A reason code for the status: - `internal_error`: Internal error (contact IBM support) - `snapshot_encryption_key_invalid`: The provided encryption key is unavailable - `snapshot_pending`: Cannot delete backup (snapshot) in the `pending` lifecycle state - `snapshot_source_unsupported`: The source access control mode does not support backups - `snapshot_rate_too_high`: The rate of backups for the resource is too high - `snapshot_share_limit`: The maximum limit for snapshots on this resource has been reached - `snapshot_source_unavailable`: The source data is not available (for example, because the source is still being created). - `snapshot_volume_limit`: The snapshot limit for the source volume has been reached - `source_volume_busy`: The source volume has `busy` set (after multiple retries) - `source_volume_too_large`: The source volume exceeds the [maximum supported size](https://cloud.ibm.com/docs/vpc?topic=vpc-snapshots-vpc-about&interface=api#snapshots-vpc-limitations) - `source_volume_unavailable`: The source volume is not attached to a running instance The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        SNAPSHOT_ENCRYPTION_KEY_INVALID = 'snapshot_encryption_key_invalid',
        SNAPSHOT_PENDING = 'snapshot_pending',
        SNAPSHOT_RATE_TOO_HIGH = 'snapshot_rate_too_high',
        SNAPSHOT_SHARE_LIMIT = 'snapshot_share_limit',
        SNAPSHOT_SOURCE_UNAVAILABLE = 'snapshot_source_unavailable',
        SNAPSHOT_SOURCE_UNSUPPORTED = 'snapshot_source_unsupported',
        SNAPSHOT_VOLUME_LIMIT = 'snapshot_volume_limit',
        SOURCE_VOLUME_BUSY = 'source_volume_busy',
        SOURCE_VOLUME_TOO_LARGE = 'source_volume_too_large',
        SOURCE_VOLUME_UNAVAILABLE = 'source_volume_unavailable',
      }
    }
  }

  /**
   * BackupPolicyPlan.
   */
  export interface BackupPolicyPlan {
    /** Indicates whether the plan is active. */
    active: boolean;
    /** The user tags to attach to backups (snapshots) created by this plan. */
    attach_user_tags: string[];
    clone_policy: BackupPolicyPlanClonePolicy;
    /** Indicates whether to copy the source's user tags to the created backups (snapshots). */
    copy_user_tags: boolean;
    /** The date and time that the backup policy plan was created. */
    created_at: string;
    /** The cron specification for the backup schedule. The backup policy jobs
     *  (which create and delete backups for this plan) will not start until this time, and may start for up to 90
     *  minutes after this time.
     *
     *  All backup schedules for plans in the same policy must be at least an hour apart.
     */
    cron_spec: string;
    deletion_trigger: BackupPolicyPlanDeletionTrigger;
    /** The URL for this backup policy plan. */
    href: string;
    /** The unique identifier for this backup policy plan. */
    id: string;
    /** The lifecycle state of this backup policy plan. */
    lifecycle_state: BackupPolicyPlan.Constants.LifecycleState | string;
    /** The name for this backup policy plan. The name is unique across all plans in the backup policy. */
    name: string;
    /** The policies for additional backups in remote regions. */
    remote_region_policies: BackupPolicyPlanRemoteRegionPolicy[];
    /** The resource type. */
    resource_type: BackupPolicyPlan.Constants.ResourceType | string;
  }
  export namespace BackupPolicyPlan {
    export namespace Constants {
      /** The lifecycle state of this backup policy plan. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        BACKUP_POLICY_PLAN = 'backup_policy_plan',
      }
    }
  }

  /**
   * BackupPolicyPlanClonePolicy.
   */
  export interface BackupPolicyPlanClonePolicy {
    /** The maximum number of recent snapshots (per source) that will keep clones. */
    max_snapshots: number;
    /** The zone this backup policy plan will create snapshot clones in. */
    zones: ZoneReference[];
  }

  /**
   * BackupPolicyPlanClonePolicyPatch.
   */
  export interface BackupPolicyPlanClonePolicyPatch {
    /** The maximum number of recent snapshots (per source) that will keep clones. */
    max_snapshots?: number;
    /** The zones this backup policy plan will create snapshot clones in. Updating this value does not change the
     *  clones for snapshots that have already been created by this plan.
     */
    zones?: ZoneIdentity[];
  }

  /**
   * BackupPolicyPlanClonePolicyPrototype.
   */
  export interface BackupPolicyPlanClonePolicyPrototype {
    /** The maximum number of recent snapshots (per source) that will keep clones. */
    max_snapshots?: number;
    /** The zone this backup policy plan will create snapshot clones in. */
    zones: ZoneIdentity[];
  }

  /**
   * BackupPolicyPlanCollection.
   */
  export interface BackupPolicyPlanCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of plans for the backup policy. */
    plans: BackupPolicyPlan[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * BackupPolicyPlanDeletionTrigger.
   */
  export interface BackupPolicyPlanDeletionTrigger {
    /** The maximum number of days to keep each backup after creation. */
    delete_after: number;
    /** The maximum number of recent backups to keep. If absent, there is no maximum. */
    delete_over_count?: number;
  }

  /**
   * BackupPolicyPlanDeletionTriggerPatch.
   */
  export interface BackupPolicyPlanDeletionTriggerPatch {
    /** The maximum number of days to keep each backup after creation. */
    delete_after?: number;
    /** The maximum number of recent backups to keep. Specify `null` to remove any existing maximum. */
    delete_over_count?: number;
  }

  /**
   * BackupPolicyPlanDeletionTriggerPrototype.
   */
  export interface BackupPolicyPlanDeletionTriggerPrototype {
    /** The maximum number of days to keep each backup after creation. */
    delete_after?: number;
    /** The maximum number of recent backups to keep. If unspecified, there will be no maximum. */
    delete_over_count?: number;
  }

  /**
   * BackupPolicyPlanPrototype.
   */
  export interface BackupPolicyPlanPrototype {
    /** Indicates whether the plan is active. */
    active?: boolean;
    /** User tags to attach to each backup (snapshot) created by this plan. If unspecified, no user tags will be
     *  attached.
     */
    attach_user_tags?: string[];
    clone_policy?: BackupPolicyPlanClonePolicyPrototype;
    /** Indicates whether to copy the source's user tags to the created backups (snapshots). */
    copy_user_tags?: boolean;
    /** The cron specification for the backup schedule. The backup policy jobs
     *  (which create and delete backups for this plan) will not start until this time, and may start for up to 90
     *  minutes after this time.
     *
     *  All backup schedules for plans in the same policy must be at least an hour apart.
     */
    cron_spec: string;
    deletion_trigger?: BackupPolicyPlanDeletionTriggerPrototype;
    /** The name for this backup policy plan. The name must not be used by another plan for the backup policy. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The policies for additional backups in remote regions. */
    remote_region_policies?: BackupPolicyPlanRemoteRegionPolicyPrototype[];
  }

  /**
   * BackupPolicyPlanReference.
   */
  export interface BackupPolicyPlanReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this backup policy plan. */
    href: string;
    /** The unique identifier for this backup policy plan. */
    id: string;
    /** The name for this backup policy plan. The name is unique across all plans in the backup policy. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: BackupPolicyPlanRemote;
    /** The resource type. */
    resource_type: BackupPolicyPlanReference.Constants.ResourceType | string;
  }
  export namespace BackupPolicyPlanReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        BACKUP_POLICY_PLAN = 'backup_policy_plan',
      }
    }
  }

  /**
   * If present, this property indicates that the resource associated with this reference is remote and therefore may
   * not be directly retrievable.
   */
  export interface BackupPolicyPlanRemote {
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /**
   * BackupPolicyPlanRemoteRegionPolicy.
   */
  export interface BackupPolicyPlanRemoteRegionPolicy {
    /** The region this backup policy plan will create backups in. */
    delete_over_count: number;
    /** The root key used to rewrap the data encryption key for the backup (snapshot). */
    encryption_key: EncryptionKeyReference;
    /** The region this backup policy plan will create backups in. */
    region: RegionReference;
  }

  /**
   * BackupPolicyPlanRemoteRegionPolicyPrototype.
   */
  export interface BackupPolicyPlanRemoteRegionPolicyPrototype {
    /** The region this backup policy plan will create backups in. */
    delete_over_count?: number;
    /** The root key to use to rewrap the data encryption key for the backup (snapshot).
     *
     *  If unspecified, the source's `encryption_key` will be used.
     *  The specified key may be in a different account, subject to IAM policies.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The region this backup policy plan will create backups in. */
    region: RegionIdentity;
  }

  /**
   * BackupPolicyPrototype.
   */
  export interface BackupPolicyPrototype {
    /** The resource type this backup policy will apply to. Resources that have both a matching type and a matching
     *  user tag will be subject to the backup policy.
     */
    match_resource_type: BackupPolicyPrototype.Constants.MatchResourceType | string;
    /** The user tags this backup policy will apply to. Resources that have both a matching user tag and a matching
     *  type will be subject to the backup policy.
     */
    match_user_tags: string[];
    /** The name for this backup policy. The name must not be used by another backup policy in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The prototype objects for backup plans to be created for this backup policy. */
    plans?: BackupPolicyPlanPrototype[];
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The scope to use for this backup policy.
     *
     *  If unspecified, the policy will be scoped to the account.
     */
    scope?: BackupPolicyScopePrototype;
  }
  export namespace BackupPolicyPrototype {
    export namespace Constants {
      /** The resource type this backup policy will apply to. Resources that have both a matching type and a matching user tag will be subject to the backup policy. */
      export enum MatchResourceType {
        INSTANCE = 'instance',
        SHARE = 'share',
        VOLUME = 'volume',
      }
    }
  }

  /**
   * The scope for this backup policy.
   */
  export interface BackupPolicyScope {
  }

  /**
   * The scope to use for this backup policy.
   *
   * If unspecified, the policy will be scoped to the account.
   */
  export interface BackupPolicyScopePrototype {
  }

  /**
   * BackupPolicyTargetSnapshot.
   */
  export interface BackupPolicyTargetSnapshot {
  }

  /**
   * BareMetalServer.
   */
  export interface BareMetalServer {
    /** The total bandwidth (in megabits per second) shared across the bare metal server network attachments or bare
     *  metal server network interfaces.
     */
    bandwidth: number;
    /** The resource from which this bare metal server is booted.
     *
     *  The resources supported by this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    boot_target: BareMetalServerBootTarget;
    /** The bare metal server CPU configuration. */
    cpu: BareMetalServerCPU;
    /** The date and time that the bare metal server was created. */
    created_at: string;
    /** The CRN for this bare metal server. */
    crn: string;
    /** The disks for this bare metal server, including any disks that are associated with the `boot_target`. */
    disks: BareMetalServerDisk[];
    /** Indicates whether secure boot is enabled. If enabled, the image must support secure boot or the server will
     *  fail to boot.
     */
    enable_secure_boot: boolean;
    /** Firmware information for the bare metal server. */
    firmware: BareMetalServerFirmware;
    /** The reasons for the current server `health_state` (if any):
     *  - `reservation_capacity_unavailable`: The reservation affinity pool has no
     *    available capacity.
     *  - `reservation_deleted`: The reservation affinity pool has a deleted reservation.
     *  - `reservation_expired`: The reservation affinity pool has an expired reservation.
     *  - `reservation_failed`: The reservation affinity pool has a failed reservation.
     *
     *  See [health status reasons](https://cloud.ibm.com/docs/vpc?topic=vpc-server-health-status-reasons) for details.
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    health_reasons: BareMetalServerHealthReason[];
    /** The health of this resource:
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle
     *     state. A resource with a lifecycle state of `failed` or `deleting` will have a
     *     health state of `inapplicable`. A `pending` resource may also have this state.
     */
    health_state: BareMetalServer.Constants.HealthState | string;
    /** The URL for this bare metal server. */
    href: string;
    /** The unique identifier for this bare metal server. */
    id: string;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: BareMetalServerLifecycleReason[];
    /** The lifecycle state of the bare metal server. */
    lifecycle_state: BareMetalServer.Constants.LifecycleState | string;
    /** The amount of memory, truncated to whole gibibytes. */
    memory: number;
    /** The name for this bare metal server. The name is unique across all bare metal servers in the region. */
    name: string;
    /** The network attachments for this bare metal server, including the primary network attachment. */
    network_attachments?: BareMetalServerNetworkAttachmentReference[];
    /** The network interfaces for this bare metal server, including the primary network interface.
     *
     *  If this bare metal server has network attachments, each network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface.
     */
    network_interfaces: NetworkInterfaceBareMetalServerContextReference[];
    /** The primary network attachment for this bare metal server. */
    primary_network_attachment?: BareMetalServerNetworkAttachmentReference;
    /** The primary network interface for this bare metal server.
     *
     *  If this bare metal server has network attachments, this primary network interface is
     *  a [read-only
     *  representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients)
     *  of the primary network attachment and its attached virtual network interface.
     */
    primary_network_interface: NetworkInterfaceBareMetalServerContextReference;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
     *  for this bare metal server.
     */
    profile: BareMetalServerProfileReference;
    /** The reservation used by this bare metal server. If absent, no reservation is in use. */
    reservation?: ReservationReference;
    reservation_affinity: BareMetalServerReservationAffinity;
    /** The resource group for this bare metal server. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: BareMetalServer.Constants.ResourceType | string;
    /** The status of this bare metal server:
     *  - `deleting`: server is undergoing deletion
     *  - `failed`: server is failed and not usable (see `status_reasons`)
     *  - `maintenance`: server is undergoing maintenance (not usable)
     *  - `pending`: server is being provisioned and not yet usable
     *  - `reinitializing`: server is reinitializing and not yet usable
     *  - `restarting`: server is restarting and not yet usable
     *  - `running`: server is powered on
     *  - `starting`: server is starting and not yet usable
     *  - `stopped`: server is powered off
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: BareMetalServer.Constants.Status | string;
    /** The reasons for the current status (if any). */
    status_reasons: BareMetalServerStatusReason[];
    trusted_platform_module: BareMetalServerTrustedPlatformModule;
    /** The VPC this bare metal server resides in. */
    vpc: VPCReference;
    /** The zone this bare metal server resides in. */
    zone: ZoneReference;
  }
  export namespace BareMetalServer {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the bare metal server. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        BARE_METAL_SERVER = 'bare_metal_server',
      }
      /** The status of this bare metal server: - `deleting`: server is undergoing deletion - `failed`: server is failed and not usable (see `status_reasons`) - `maintenance`: server is undergoing maintenance (not usable) - `pending`: server is being provisioned and not yet usable - `reinitializing`: server is reinitializing and not yet usable - `restarting`: server is restarting and not yet usable - `running`: server is powered on - `starting`: server is starting and not yet usable - `stopped`: server is powered off The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        DELETING = 'deleting',
        FAILED = 'failed',
        MAINTENANCE = 'maintenance',
        PENDING = 'pending',
        REINITIALIZING = 'reinitializing',
        RESTARTING = 'restarting',
        RUNNING = 'running',
        STARTING = 'starting',
        STOPPED = 'stopped',
      }
    }
  }

  /**
   * The resource from which this bare metal server is booted.
   *
   * The resources supported by this property may
   * [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
   */
  export interface BareMetalServerBootTarget {
  }

  /**
   * The bare metal server CPU configuration.
   */
  export interface BareMetalServerCPU {
    /** The CPU architecture.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    architecture: BareMetalServerCPU.Constants.Architecture | string;
    /** The total number of cores. */
    core_count: number;
    /** The total number of CPU sockets. */
    socket_count: number;
    /** The total number of hardware threads per core. */
    threads_per_core: number;
  }
  export namespace BareMetalServerCPU {
    export namespace Constants {
      /** The CPU architecture. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Architecture {
        AMD64 = 'amd64',
        S390X = 's390x',
      }
    }
  }

  /**
   * BareMetalServerCollection.
   */
  export interface BareMetalServerCollection {
    /** A page of bare metal servers. */
    bare_metal_servers: BareMetalServer[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * The bare metal server console access token information.
   */
  export interface BareMetalServerConsoleAccessToken {
    /** A URL safe single-use token used to access the console WebSocket. */
    access_token: string;
    /** The bare metal server console type for which this token may be used. */
    console_type: BareMetalServerConsoleAccessToken.Constants.ConsoleType | string;
    /** The date and time that the access token was created. */
    created_at: string;
    /** The date and time that the access token will expire. */
    expires_at: string;
    /** Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.
     *  This has no effect on VNC consoles.
     */
    force: boolean;
    /** The URL to access this bare metal server console. */
    href: string;
  }
  export namespace BareMetalServerConsoleAccessToken {
    export namespace Constants {
      /** The bare metal server console type for which this token may be used. */
      export enum ConsoleType {
        SERIAL = 'serial',
        VNC = 'vnc',
      }
    }
  }

  /**
   * BareMetalServerDisk.
   */
  export interface BareMetalServerDisk {
    /** The date and time that the disk was created. */
    created_at: string;
    /** The URL for this bare metal server disk. */
    href: string;
    /** The unique identifier for this bare metal server disk. */
    id: string;
    /** The disk attachment interface used:
     *  - `fcp`: Fiber Channel Protocol
     *  - `sata`: Serial Advanced Technology Attachment
     *  - `nvme`: Non-Volatile Memory Express
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    interface_type: BareMetalServerDisk.Constants.InterfaceType | string;
    /** The name for this bare metal server disk. The name is unique across all disks on the bare metal server. */
    name: string;
    /** The resource type. */
    resource_type: BareMetalServerDisk.Constants.ResourceType | string;
    /** The size of the disk in GB (gigabytes). */
    size: number;
  }
  export namespace BareMetalServerDisk {
    export namespace Constants {
      /** The disk attachment interface used: - `fcp`: Fiber Channel Protocol - `sata`: Serial Advanced Technology Attachment - `nvme`: Non-Volatile Memory Express The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum InterfaceType {
        FCP = 'fcp',
        NVME = 'nvme',
        SATA = 'sata',
      }
      /** The resource type. */
      export enum ResourceType {
        BARE_METAL_SERVER_DISK = 'bare_metal_server_disk',
      }
    }
  }

  /**
   * BareMetalServerDiskCollection.
   */
  export interface BareMetalServerDiskCollection {
    /** The disks for the bare metal server. */
    disks: BareMetalServerDisk[];
  }

  /**
   * Firmware information for the bare metal server.
   */
  export interface BareMetalServerFirmware {
    /** The type of update available.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    update: BareMetalServerFirmware.Constants.Update | string;
  }
  export namespace BareMetalServerFirmware {
    export namespace Constants {
      /** The type of update available. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Update {
        NONE = 'none',
        OPTIONAL = 'optional',
        REQUIRED = 'required',
      }
    }
  }

  /**
   * BareMetalServerHealthReason.
   */
  export interface BareMetalServerHealthReason {
    /** A reason code for this health state. */
    code: BareMetalServerHealthReason.Constants.Code | string;
    /** An explanation of the reason for this health state. */
    message: string;
    /** Link to documentation about the reason for this health state. */
    more_info?: string;
  }
  export namespace BareMetalServerHealthReason {
    export namespace Constants {
      /** A reason code for this health state. */
      export enum Code {
        RESERVATION_CAPACITY_UNAVAILABLE = 'reservation_capacity_unavailable',
        RESERVATION_DELETED = 'reservation_deleted',
        RESERVATION_EXPIRED = 'reservation_expired',
        RESERVATION_FAILED = 'reservation_failed',
      }
    }
  }

  /**
   * BareMetalServerInitialization.
   */
  export interface BareMetalServerInitialization {
    /** The image the bare metal server was provisioned from. */
    image: ImageReference;
    /** The public SSH keys used at initialization. */
    keys: KeyReference[];
    /** The user accounts that are created at initialization. There can be multiple account types distinguished by
     *  the `resource_type` property.
     */
    user_accounts: BareMetalServerInitializationUserAccount[];
  }

  /**
   * BareMetalServerInitializationPrototype.
   */
  export interface BareMetalServerInitializationPrototype {
    /** The image to be used when provisioning the bare metal server. */
    image: ImageIdentity;
    /** The public SSH keys to install on the bare metal server. Keys will be made available to the bare metal
     *  server as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as SSH authorized
     *  keys for the [default
     *  user](https://cloud.ibm.com/docs/vpc?topic=vpc-vsi_is_connecting_linux#determining-default-user-account).
     *
     *  For Windows images, at least one key must be specified, and one will be selected to encrypt the administrator
     *  password. Keys are optional for other images, but if no keys are specified, the bare metal server will be
     *  inaccessible unless the specified image provides another means of access.
     */
    keys: KeyIdentity[];
    /** User data to be made available when initializing the bare metal server.
     *
     *  If unspecified, no user data will be made available.
     */
    user_data?: string;
  }

  /**
   * BareMetalServerInitializationUserAccount.
   */
  export interface BareMetalServerInitializationUserAccount {
  }

  /**
   * BareMetalServerLifecycleReason.
   */
  export interface BareMetalServerLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: BareMetalServerLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace BareMetalServerLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * BareMetalServerNetworkAttachment.
   */
  export interface BareMetalServerNetworkAttachment {
    /** The date and time that the bare metal server network attachment was created. */
    created_at: string;
    /** The URL for this bare metal server network attachment. */
    href: string;
    /** The unique identifier for this bare metal server network attachment. */
    id: string;
    /** The network attachment's interface type:
     *  - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI attachment
     *    - Cannot directly use an IEEE 802.1Q tag.
     *  - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its
     *    array of `allowed_vlans`.
     *    - Must use an IEEE 802.1Q tag.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    interface_type: BareMetalServerNetworkAttachment.Constants.InterfaceType | string;
    /** The lifecycle state of the bare metal server network attachment. */
    lifecycle_state: BareMetalServerNetworkAttachment.Constants.LifecycleState | string;
    /** The name for this bare metal server network attachment. The name is unique across all network attachments
     *  for the bare metal server.
     */
    name: string;
    /** The port speed for this bare metal server network attachment in Mbps. */
    port_speed: number;
    /** The primary IP address of the virtual network interface for the bare metal server network attachment. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: BareMetalServerNetworkAttachment.Constants.ResourceType | string;
    /** The subnet of the virtual network interface for the bare metal server network attachment. */
    subnet: SubnetReference;
    /** The bare metal server network attachment type.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    type: BareMetalServerNetworkAttachment.Constants.Type | string;
    /** The virtual network interface for this bare metal server network attachment. */
    virtual_network_interface: VirtualNetworkInterfaceReferenceAttachmentContext;
  }
  export namespace BareMetalServerNetworkAttachment {
    export namespace Constants {
      /** The network attachment's interface type: - `pci`: a physical PCI device which can only be created or deleted when the bare metal server is stopped - Has an `allowed_vlans` property which controls the VLANs that will be permitted to use the PCI attachment - Cannot directly use an IEEE 802.1Q tag. - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array of `allowed_vlans`. - Must use an IEEE 802.1Q tag. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum InterfaceType {
        PCI = 'pci',
        VLAN = 'vlan',
      }
      /** The lifecycle state of the bare metal server network attachment. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        BARE_METAL_SERVER_NETWORK_ATTACHMENT = 'bare_metal_server_network_attachment',
      }
      /** The bare metal server network attachment type. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        PRIMARY = 'primary',
        SECONDARY = 'secondary',
      }
    }
  }

  /**
   * BareMetalServerNetworkAttachmentCollection.
   */
  export interface BareMetalServerNetworkAttachmentCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** The network attachments for the bare metal server. */
    network_attachments: BareMetalServerNetworkAttachment[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * BareMetalServerNetworkAttachmentPrototype.
   */
  export interface BareMetalServerNetworkAttachmentPrototype {
    /** The network attachment's interface type:
     *  - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI attachment
     *    - Cannot directly use an IEEE 802.1Q tag.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`
     *  - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its
     *    array of `allowed_vlans`.
     *    - Must use an IEEE 802.1Q tag.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type: BareMetalServerNetworkAttachmentPrototype.Constants.InterfaceType | string;
    /** The name for this bare metal server network attachment. Names must be unique within the bare metal server
     *  the network attachment resides in. If unspecified, the name will be a hyphenated list of randomly-selected
     *  words.
     */
    name?: string;
    /** A virtual network interface for the bare metal server network attachment. This can be
     *  specified using an existing virtual network interface, or a prototype object for a new
     *  virtual network interface.
     *
     *  If an existing virtual network interface is specified, it must not be the target of a flow
     *  log collector.
     */
    virtual_network_interface: BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterface;
  }
  export namespace BareMetalServerNetworkAttachmentPrototype {
    export namespace Constants {
      /** The network attachment's interface type: - `pci`: a physical PCI device which can only be created or deleted when the bare metal server is stopped - Has an `allowed_vlans` property which controls the VLANs that will be permitted to use the PCI attachment - Cannot directly use an IEEE 802.1Q tag. - Not supported on bare metal servers with a `cpu.architecture` of `s390x` - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array of `allowed_vlans`. - Must use an IEEE 802.1Q tag. - Not supported on bare metal servers with a `cpu.architecture` of `s390x`. */
      export enum InterfaceType {
        PCI = 'pci',
        VLAN = 'vlan',
      }
    }
  }

  /**
   * A virtual network interface for the bare metal server network attachment. This can be specified using an existing
   * virtual network interface, or a prototype object for a new virtual network interface.
   *
   * If an existing virtual network interface is specified, it must not be the target of a flow log collector.
   */
  export interface BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterface {
  }

  /**
   * BareMetalServerNetworkAttachmentReference.
   */
  export interface BareMetalServerNetworkAttachmentReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this bare metal server network attachment. */
    href: string;
    /** The unique identifier for this bare metal server network attachment. */
    id: string;
    /** The name for this bare metal server network attachment. The name is unique across all network attachments
     *  for the bare metal server.
     */
    name: string;
    /** The primary IP address of the virtual network interface for the bare metal server network attachment. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: BareMetalServerNetworkAttachmentReference.Constants.ResourceType | string;
    /** The subnet of the virtual network interface for the bare metal server network attachment. */
    subnet: SubnetReference;
    /** The virtual network interface for this bare metal server network attachment. */
    virtual_network_interface: VirtualNetworkInterfaceReferenceAttachmentContext;
  }
  export namespace BareMetalServerNetworkAttachmentReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        BARE_METAL_SERVER_NETWORK_ATTACHMENT = 'bare_metal_server_network_attachment',
      }
    }
  }

  /**
   * BareMetalServerNetworkInterface.
   */
  export interface BareMetalServerNetworkInterface {
    /** Indicates whether source IP spoofing is allowed on this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and source IP spoofing is managed
     *  on the attached virtual network interface.
     */
    allow_ip_spoofing: boolean;
    /** The date and time that the bare metal server network interface was created.
     *
     *  If this bare metal server has network attachments, this network interface was created as a [read-only
     *  representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) when its corresponding
     *  network attachment was created.
     */
    created_at: string;
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the bare metal server network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - `interface_type` must not be `hipersocket`.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and infrastructure NAT is managed
     *  on the attached virtual network interface.
     */
    enable_infrastructure_nat: boolean;
    /** The floating IPs associated with this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the floating IPs are associated
     *  with the attached virtual network interface.
     */
    floating_ips: FloatingIPReference[];
    /** The URL for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
    /** The unique identifier for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
    /** The interface type:
     *  - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
     *    within a `s390x` based system
     *  - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI interface
     *    - Cannot directly use an IEEE 802.1Q tag.
     *  - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its
     *    array of `allowed_vlans`.
     *    - Must use an IEEE 802.1Q tag.
     *    - Has its own security groups and does not inherit those of the PCI device through
     *      which traffic flows.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the interface type is that of
     *  the corresponding network attachment.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    interface_type: BareMetalServerNetworkInterface.Constants.InterfaceType | string;
    /** The MAC address of this bare metal server network interface. If the MAC address has not yet been selected,
     *  the value will be empty.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the MAC address is that of the
     *  attached virtual network interface.
     */
    mac_address: string;
    /** The name for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the name matches its
     *  corresponding network attachment.
     */
    name: string;
    /** The bare metal server network interface port speed in Mbps.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the port speed is that of its
     *  corresponding network attachment.
     */
    port_speed: number;
    /** The primary IP address of this bare metal server network interface. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: BareMetalServerNetworkInterface.Constants.ResourceType | string;
    /** The security groups targeting this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the security groups are
     *  associated with the attached virtual network interface.
     */
    security_groups: SecurityGroupReference[];
    /** The status of the bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a read-only representation of its
     *  corresponding network attachment and its attached virtual network interface, and the status is [computed from
     *  them](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients).
     */
    status: BareMetalServerNetworkInterface.Constants.Status | string;
    /** The associated subnet. */
    subnet: SubnetReference;
    /** The bare metal server network interface type.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the type is that of its
     *  corresponding network attachment.
     */
    type: BareMetalServerNetworkInterface.Constants.Type | string;
  }
  export namespace BareMetalServerNetworkInterface {
    export namespace Constants {
      /** The interface type: - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity within a `s390x` based system - `pci`: a physical PCI device which can only be created or deleted when the bare metal server is stopped - Has an `allowed_vlans` property which controls the VLANs that will be permitted to use the PCI interface - Cannot directly use an IEEE 802.1Q tag. - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array of `allowed_vlans`. - Must use an IEEE 802.1Q tag. - Has its own security groups and does not inherit those of the PCI device through which traffic flows. If this bare metal server has network attachments, this network interface is a [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding network attachment and its attached virtual network interface, and the interface type is that of the corresponding network attachment. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum InterfaceType {
        HIPERSOCKET = 'hipersocket',
        PCI = 'pci',
        VLAN = 'vlan',
      }
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
      /** The status of the bare metal server network interface. If this bare metal server has network attachments, this network interface is a read-only representation of its corresponding network attachment and its attached virtual network interface, and the status is [computed from them](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients). */
      export enum Status {
        AVAILABLE = 'available',
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
      }
      /** The bare metal server network interface type. If this bare metal server has network attachments, this network interface is a [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding network attachment and its attached virtual network interface, and the type is that of its corresponding network attachment. */
      export enum Type {
        PRIMARY = 'primary',
        SECONDARY = 'secondary',
      }
    }
  }

  /**
   * BareMetalServerNetworkInterfaceCollection.
   */
  export interface BareMetalServerNetworkInterfaceCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** The network interfaces for the bare metal server. */
    network_interfaces: BareMetalServerNetworkInterface[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * BareMetalServerNetworkInterfacePrototype.
   */
  export interface BareMetalServerNetworkInterfacePrototype {
    /** Indicates whether source IP spoofing is allowed on this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and source IP spoofing is managed
     *  on the attached virtual network interface.
     */
    allow_ip_spoofing?: boolean;
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the bare metal server network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - `interface_type` must not be `hipersocket`.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and infrastructure NAT is managed
     *  on the attached virtual network interface.
     */
    enable_infrastructure_nat?: boolean;
    /** The interface type:
     *  - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
     *    within a `s390x` based system
     *    - Not supported on bare metal servers with a `cpu.architecture` of `amd64`
     *  - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI interface
     *    - Cannot directly use an IEEE 802.1Q tag.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`
     *  - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its
     *    array of `allowed_vlans`.
     *    - Must use an IEEE 802.1Q tag.
     *    - Has its own security groups and does not inherit those of the PCI device through
     *      which traffic flows.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type: BareMetalServerNetworkInterfacePrototype.Constants.InterfaceType | string;
    /** The name for this bare metal server network interface. The name must not be used by another network
     *  interface on the bare metal server. If unspecified, the name will be a hyphenated list of randomly-selected
     *  words.
     */
    name?: string;
    /** The primary IP address to bind to the bare metal server network interface. This can be
     *  specified using an existing reserved IP, or a prototype object for a new reserved IP.
     *
     *  If an existing reserved IP or a prototype object with an address is specified, it must
     *  be available on the bare metal server network interface's subnet. Otherwise, an
     *  available address on the subnet will be automatically selected and reserved.
     */
    primary_ip?: NetworkInterfaceIPPrototype;
    /** The security groups to use for this bare metal server network interface. If unspecified, the VPC's default
     *  security group is used.
     */
    security_groups?: SecurityGroupIdentity[];
    /** The associated subnet. */
    subnet: SubnetIdentity;
  }
  export namespace BareMetalServerNetworkInterfacePrototype {
    export namespace Constants {
      /** The interface type: - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity within a `s390x` based system - Not supported on bare metal servers with a `cpu.architecture` of `amd64` - `pci`: a physical PCI device which can only be created or deleted when the bare metal server is stopped - Has an `allowed_vlans` property which controls the VLANs that will be permitted to use the PCI interface - Cannot directly use an IEEE 802.1Q tag. - Not supported on bare metal servers with a `cpu.architecture` of `s390x` - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array of `allowed_vlans`. - Must use an IEEE 802.1Q tag. - Has its own security groups and does not inherit those of the PCI device through which traffic flows. - Not supported on bare metal servers with a `cpu.architecture` of `s390x`. */
      export enum InterfaceType {
        HIPERSOCKET = 'hipersocket',
        PCI = 'pci',
        VLAN = 'vlan',
      }
    }
  }

  /**
   * BareMetalServerPrimaryNetworkAttachmentPrototype.
   */
  export interface BareMetalServerPrimaryNetworkAttachmentPrototype {
    /** The network attachment's interface type:
     *  - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI attachment
     *    - Cannot directly use an IEEE 802.1Q tag.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type?: BareMetalServerPrimaryNetworkAttachmentPrototype.Constants.InterfaceType | string;
    /** The name for this bare metal server network attachment. Names must be unique within the bare metal server
     *  the network attachment resides in. If unspecified, the name will be a hyphenated list of randomly-selected
     *  words.
     */
    name?: string;
    /** A virtual network interface for the bare metal server network attachment. This can be
     *  specified using an existing virtual network interface, or a prototype object for a new
     *  virtual network interface.
     *
     *  If an existing virtual network interface is specified, it must not be the target of a flow
     *  log collector.
     */
    virtual_network_interface: BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterface;
  }
  export namespace BareMetalServerPrimaryNetworkAttachmentPrototype {
    export namespace Constants {
      /** The network attachment's interface type: - `pci`: a physical PCI device which can only be created or deleted when the bare metal server is stopped - Has an `allowed_vlans` property which controls the VLANs that will be permitted to use the PCI attachment - Cannot directly use an IEEE 802.1Q tag. - Not supported on bare metal servers with a `cpu.architecture` of `s390x`. */
      export enum InterfaceType {
        PCI = 'pci',
      }
    }
  }

  /**
   * BareMetalServerPrimaryNetworkInterfacePrototype.
   */
  export interface BareMetalServerPrimaryNetworkInterfacePrototype {
    /** Indicates whether source IP spoofing is allowed on this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and source IP spoofing is managed
     *  on the attached virtual network interface.
     */
    allow_ip_spoofing?: boolean;
    /** The VLAN IDs allowed for `vlan` interfaces using this PCI interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the VLAN IDs match the
     *  `allow_vlans` of the corresponding network attachment.
     */
    allowed_vlans?: number[];
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the bare metal server network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - `interface_type` must not be `hipersocket`.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and infrastructure NAT is managed
     *  on the attached virtual network interface.
     */
    enable_infrastructure_nat?: boolean;
    /** The interface type:
     *  - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
     *    within a `s390x` based system.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `amd64`
     *  - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI interface
     *    - Cannot directly use an IEEE 802.1Q tag.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type?: BareMetalServerPrimaryNetworkInterfacePrototype.Constants.InterfaceType | string;
    /** The name for this bare metal server network interface. The name must not be used by another network
     *  interface on the bare metal server. If unspecified, the name will be a hyphenated list of randomly-selected
     *  words.
     */
    name?: string;
    /** The primary IP address to bind to the bare metal server network interface. This can be
     *  specified using an existing reserved IP, or a prototype object for a new reserved IP.
     *
     *  If an existing reserved IP or a prototype object with an address is specified, it must
     *  be available on the bare metal server network interface's subnet. Otherwise, an
     *  available address on the subnet will be automatically selected and reserved.
     */
    primary_ip?: NetworkInterfaceIPPrototype;
    /** The security groups to use for this bare metal server network interface. If unspecified, the VPC's default
     *  security group is used.
     */
    security_groups?: SecurityGroupIdentity[];
    /** The associated subnet. */
    subnet: SubnetIdentity;
  }
  export namespace BareMetalServerPrimaryNetworkInterfacePrototype {
    export namespace Constants {
      /** The interface type: - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity within a `s390x` based system. - Not supported on bare metal servers with a `cpu.architecture` of `amd64` - `pci`: a physical PCI device which can only be created or deleted when the bare metal server is stopped - Has an `allowed_vlans` property which controls the VLANs that will be permitted to use the PCI interface - Cannot directly use an IEEE 802.1Q tag. - Not supported on bare metal servers with a `cpu.architecture` of `s390x`. */
      export enum InterfaceType {
        HIPERSOCKET = 'hipersocket',
        PCI = 'pci',
      }
    }
  }

  /**
   * BareMetalServerProfile.
   */
  export interface BareMetalServerProfile {
    bandwidth: BareMetalServerProfileBandwidth;
    /** The console type configuration for a bare metal server with this profile. */
    console_types: BareMetalServerProfileConsoleTypes;
    cpu_architecture: BareMetalServerProfileCPUArchitecture;
    cpu_core_count: BareMetalServerProfileCPUCoreCount;
    cpu_socket_count: BareMetalServerProfileCPUSocketCount;
    /** The disks for a bare metal server with this profile. */
    disks: BareMetalServerProfileDisk[];
    /** The product family this bare metal server profile belongs to. */
    family: string;
    /** The URL for this bare metal server profile. */
    href: string;
    memory: BareMetalServerProfileMemory;
    /** The name for this bare metal server profile. */
    name: string;
    network_attachment_count: BareMetalServerProfileNetworkAttachmentCount;
    network_interface_count: BareMetalServerProfileNetworkInterfaceCount;
    os_architecture: BareMetalServerProfileOSArchitecture;
    reservation_terms: BareMetalServerProfileReservationTerms;
    /** The resource type. */
    resource_type: BareMetalServerProfile.Constants.ResourceType | string;
    /** The supported trusted platform module modes for this bare metal server profile. */
    supported_trusted_platform_module_modes: BareMetalServerProfileSupportedTrustedPlatformModuleModes;
    /** Indicates whether this profile supports virtual network interfaces. */
    virtual_network_interfaces_supported: BareMetalServerProfileVirtualNetworkInterfacesSupported;
  }
  export namespace BareMetalServerProfile {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        BARE_METAL_SERVER_PROFILE = 'bare_metal_server_profile',
      }
    }
  }

  /**
   * BareMetalServerProfileBandwidth.
   */
  export interface BareMetalServerProfileBandwidth {
  }

  /**
   * BareMetalServerProfileCPUArchitecture.
   */
  export interface BareMetalServerProfileCPUArchitecture {
    /** The default CPU architecture for a bare metal server with this profile. */
    default?: BareMetalServerProfileCPUArchitecture.Constants.Default | string;
    /** The type for this profile field. */
    type: BareMetalServerProfileCPUArchitecture.Constants.Type | string;
    /** The CPU architecture for a bare metal server with this profile. */
    value: BareMetalServerProfileCPUArchitecture.Constants.Value | string;
  }
  export namespace BareMetalServerProfileCPUArchitecture {
    export namespace Constants {
      /** The default CPU architecture for a bare metal server with this profile. */
      export enum Default {
        AMD64 = 'amd64',
        S390X = 's390x',
      }
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
      /** The CPU architecture for a bare metal server with this profile. */
      export enum Value {
        AMD64 = 'amd64',
        S390X = 's390x',
      }
    }
  }

  /**
   * BareMetalServerProfileCPUCoreCount.
   */
  export interface BareMetalServerProfileCPUCoreCount {
  }

  /**
   * BareMetalServerProfileCPUSocketCount.
   */
  export interface BareMetalServerProfileCPUSocketCount {
  }

  /**
   * BareMetalServerProfileCollection.
   */
  export interface BareMetalServerProfileCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of bare metal server profiles. */
    profiles: BareMetalServerProfile[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * The console type configuration for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileConsoleTypes {
    /** The type for this profile field. */
    type: BareMetalServerProfileConsoleTypes.Constants.Type | string;
    /** The console types for a bare metal server with this profile. */
    values: BareMetalServerProfileConsoleTypes.Constants.Values[] | string[];
  }
  export namespace BareMetalServerProfileConsoleTypes {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The console types for a bare metal server with this profile. */
      export enum Values {
        SERIAL = 'serial',
        VNC = 'vnc',
      }
    }
  }

  /**
   * Disks provided by this profile.
   */
  export interface BareMetalServerProfileDisk {
    quantity: BareMetalServerProfileDiskQuantity;
    size: BareMetalServerProfileDiskSize;
    supported_interface_types: BareMetalServerProfileDiskSupportedInterfaces;
  }

  /**
   * BareMetalServerProfileDiskQuantity.
   */
  export interface BareMetalServerProfileDiskQuantity {
  }

  /**
   * BareMetalServerProfileDiskSize.
   */
  export interface BareMetalServerProfileDiskSize {
  }

  /**
   * BareMetalServerProfileDiskSupportedInterfaces.
   */
  export interface BareMetalServerProfileDiskSupportedInterfaces {
    /** The default value for this profile field. */
    default: BareMetalServerProfileDiskSupportedInterfaces.Constants.Default | string;
    /** The type for this profile field. */
    type: BareMetalServerProfileDiskSupportedInterfaces.Constants.Type | string;
    /** The supported disk interfaces used for attaching the disk. */
    values: BareMetalServerProfileDiskSupportedInterfaces.Constants.Values[] | string[];
  }
  export namespace BareMetalServerProfileDiskSupportedInterfaces {
    export namespace Constants {
      /** The default value for this profile field. */
      export enum Default {
        FCP = 'fcp',
        NVME = 'nvme',
        SATA = 'sata',
      }
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The supported disk interfaces used for attaching the disk. */
      export enum Values {
        FCP = 'fcp',
        NVME = 'nvme',
        SATA = 'sata',
      }
    }
  }

  /**
   * Identifies a bare metal server profile by a unique property.
   */
  export interface BareMetalServerProfileIdentity {
  }

  /**
   * BareMetalServerProfileMemory.
   */
  export interface BareMetalServerProfileMemory {
  }

  /**
   * BareMetalServerProfileNetworkAttachmentCount.
   */
  export interface BareMetalServerProfileNetworkAttachmentCount {
  }

  /**
   * BareMetalServerProfileNetworkInterfaceCount.
   */
  export interface BareMetalServerProfileNetworkInterfaceCount {
  }

  /**
   * BareMetalServerProfileOSArchitecture.
   */
  export interface BareMetalServerProfileOSArchitecture {
    /** The default OS architecture for a bare metal server with this profile. */
    default: string;
    /** The type for this profile field. */
    type: BareMetalServerProfileOSArchitecture.Constants.Type | string;
    /** The supported OS architecture(s) for a bare metal server with this profile. */
    values: string[];
  }
  export namespace BareMetalServerProfileOSArchitecture {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * BareMetalServerProfileReference.
   */
  export interface BareMetalServerProfileReference {
    /** The URL for this bare metal server profile. */
    href: string;
    /** The name for this bare metal server profile. */
    name: string;
    /** The resource type. */
    resource_type: BareMetalServerProfileReference.Constants.ResourceType | string;
  }
  export namespace BareMetalServerProfileReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        BARE_METAL_SERVER_PROFILE = 'bare_metal_server_profile',
      }
    }
  }

  /**
   * BareMetalServerProfileReservationTerms.
   */
  export interface BareMetalServerProfileReservationTerms {
    /** The type for this profile field. */
    type: BareMetalServerProfileReservationTerms.Constants.Type | string;
    /** The supported committed use terms for a reservation using this profile. */
    values: BareMetalServerProfileReservationTerms.Constants.Values[] | string[];
  }
  export namespace BareMetalServerProfileReservationTerms {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The supported committed use terms for a reservation using this profile. */
      export enum Values {
        ONE_YEAR = 'one_year',
        THREE_YEAR = 'three_year',
      }
    }
  }

  /**
   * The supported trusted platform module modes for this bare metal server profile.
   */
  export interface BareMetalServerProfileSupportedTrustedPlatformModuleModes {
    /** The default trusted platform module for a bare metal server with this profile. */
    default?: BareMetalServerProfileSupportedTrustedPlatformModuleModes.Constants.Default | string;
    /** The type for this profile field. */
    type: BareMetalServerProfileSupportedTrustedPlatformModuleModes.Constants.Type | string;
    /** The supported trusted platform module modes. */
    values: BareMetalServerProfileSupportedTrustedPlatformModuleModes.Constants.Values[] | string[];
  }
  export namespace BareMetalServerProfileSupportedTrustedPlatformModuleModes {
    export namespace Constants {
      /** The default trusted platform module for a bare metal server with this profile. */
      export enum Default {
        DISABLED = 'disabled',
        TPM_2 = 'tpm_2',
      }
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The supported trusted platform module modes. */
      export enum Values {
        DISABLED = 'disabled',
        TPM_2 = 'tpm_2',
      }
    }
  }

  /**
   * Indicates whether this profile supports virtual network interfaces.
   */
  export interface BareMetalServerProfileVirtualNetworkInterfacesSupported {
    /** The type for this profile field. */
    type: BareMetalServerProfileVirtualNetworkInterfacesSupported.Constants.Type | string;
    /** The value for this profile field. */
    value: boolean;
  }
  export namespace BareMetalServerProfileVirtualNetworkInterfacesSupported {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * BareMetalServerPrototype.
   */
  export interface BareMetalServerPrototype {
    /** The total bandwidth (in megabits per second) shared across the bare metal server's network interfaces. The
     *  specified value must match one of the bandwidth values in the bare metal server's profile. If unspecified, the
     *  default value from the profile will be used.
     */
    bandwidth?: number;
    /** Indicates whether secure boot is enabled. If enabled, the image must support secure boot or the server will
     *  fail to boot.
     */
    enable_secure_boot?: boolean;
    initialization: BareMetalServerInitializationPrototype;
    /** The name for this bare metal server. The name must not be used by another bare metal server in the region.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     *
     *  The system hostname will be based on this name.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
     *  to use for this bare metal server.
     */
    profile: BareMetalServerProfileIdentity;
    reservation_affinity?: BareMetalServerReservationAffinityPrototype;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
    trusted_platform_module?: BareMetalServerTrustedPlatformModulePrototype;
    /** The VPC this bare metal server will reside in.
     *
     *  If specified, it must match the VPC for the subnets that the network attachments or
     *  network interfaces of the bare metal server are attached to.
     */
    vpc?: VPCIdentity;
    /** The zone this bare metal server will reside in. */
    zone: ZoneIdentity;
  }

  /**
   * BareMetalServerReservationAffinity.
   */
  export interface BareMetalServerReservationAffinity {
    /** The reservation affinity policy to use for this bare metal server:
     *  - `disabled`: Reservations will not be used
     *  - `manual`: Reservations in `pool` are available for use
     *  - `automatic`: Any reservations with an `affinity_policy` of `automatic`
     *    that have the same `profile` and `zone` as this bare metal server
     *    are available for use.
     */
    policy: BareMetalServerReservationAffinity.Constants.Policy | string;
    /** The pool of reservations available for use by this bare metal server when the `policy` is `manual`. This
     *  must be empty if the `policy` is `automatic` or
     *  `disabled`.
     */
    pool: ReservationReference[];
  }
  export namespace BareMetalServerReservationAffinity {
    export namespace Constants {
      /** The reservation affinity policy to use for this bare metal server: - `disabled`: Reservations will not be used - `manual`: Reservations in `pool` are available for use - `automatic`: Any reservations with an `affinity_policy` of `automatic` that have the same `profile` and `zone` as this bare metal server are available for use. */
      export enum Policy {
        AUTOMATIC = 'automatic',
        DISABLED = 'disabled',
        MANUAL = 'manual',
      }
    }
  }

  /**
   * BareMetalServerReservationAffinityPatch.
   */
  export interface BareMetalServerReservationAffinityPatch {
    /** The reservation affinity policy to use for this bare metal server:
     *  - `disabled`: Reservations will not be used
     *  - `manual`: Reservations in `pool` will be available for use
     *  - `automatic`: Any reservations with an `affinity_policy` of `automatic` that have the
     *    same `profile` and `zone` as this bare metal server are available for use.
     */
    policy?: BareMetalServerReservationAffinityPatch.Constants.Policy | string;
    /** The pool of reservations available for use by this bare metal server, replacing the existing pool of
     *  reservations.
     *
     *  Specified reservations must have a `status` of `active`, and have the same
     *  `profile` and `zone` as this bare metal server.
     *
     *  If `policy` is `manual`, `pool` must have one reservation. If `policy` is `disabled` or `automatic`, `pool` must
     *  be empty. If `policy` is `manual`, the `pool` must contain a reservation with available capacity.
     */
    pool?: ReservationIdentity[];
  }
  export namespace BareMetalServerReservationAffinityPatch {
    export namespace Constants {
      /** The reservation affinity policy to use for this bare metal server: - `disabled`: Reservations will not be used - `manual`: Reservations in `pool` will be available for use - `automatic`: Any reservations with an `affinity_policy` of `automatic` that have the same `profile` and `zone` as this bare metal server are available for use. */
      export enum Policy {
        AUTOMATIC = 'automatic',
        DISABLED = 'disabled',
        MANUAL = 'manual',
      }
    }
  }

  /**
   * BareMetalServerReservationAffinityPrototype.
   */
  export interface BareMetalServerReservationAffinityPrototype {
    /** The reservation affinity policy to use for this bare metal server:
     *  - `disabled`: Reservations will not be used
     *  - `manual`: Reservations in `pool` will be available for use
     *  - `automatic`: Any reservations with an `affinity_policy` of `automatic` that have the
     *    same `profile` and `zone` as this bare metal server are available for use.
     *
     *  The policy will default to `manual` if `pool` is not empty. Otherwise the policy will default to `automatic`.
     */
    policy?: BareMetalServerReservationAffinityPrototype.Constants.Policy | string;
    /** The pool of reservations available for use by this bare metal server.
     *
     *  Specified reservations must have a `status` of `active`, and have the same `profile` and `zone` as this bare
     *  metal server.
     *
     *  If `policy` is `manual`, `pool` must have one reservation. If `policy` is `disabled` or `automatic`, `pool` must
     *  be empty. If `policy` is `manual`, the `pool` must contain a reservation with available capacity.
     */
    pool?: ReservationIdentity[];
  }
  export namespace BareMetalServerReservationAffinityPrototype {
    export namespace Constants {
      /** The reservation affinity policy to use for this bare metal server: - `disabled`: Reservations will not be used - `manual`: Reservations in `pool` will be available for use - `automatic`: Any reservations with an `affinity_policy` of `automatic` that have the same `profile` and `zone` as this bare metal server are available for use. The policy will default to `manual` if `pool` is not empty. Otherwise the policy will default to `automatic`. */
      export enum Policy {
        AUTOMATIC = 'automatic',
        DISABLED = 'disabled',
        MANUAL = 'manual',
      }
    }
  }

  /**
   * BareMetalServerStatusReason.
   */
  export interface BareMetalServerStatusReason {
    /** The status reason code:
     *  - `cannot_reinitialize`: An error occurred while reinitializing bare metal server
     *  - `cannot_start`: Failed to start due to an internal error
     *  - `cannot_start_capacity`: Insufficient capacity within the selected zone
     *  - `cannot_start_compute`: An error occurred while allocating compute resources
     *  - `cannot_start_ip_address`: An error occurred while allocating an IP address
     *  - `cannot_start_network`: An error occurred while allocating network resources
     *  - `cannot_update_firmware`: An error occurred while updating bare metal server firmware
     *  - `cannot_start_reservation_capacity`: Failed to start because the reservation has
     *    insufficient capacity
     *  - `cannot_start_reservation_expired`: Failed to start because the reservation has
     *    expired
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: BareMetalServerStatusReason.Constants.Code | string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace BareMetalServerStatusReason {
    export namespace Constants {
      /** The status reason code: - `cannot_reinitialize`: An error occurred while reinitializing bare metal server - `cannot_start`: Failed to start due to an internal error - `cannot_start_capacity`: Insufficient capacity within the selected zone - `cannot_start_compute`: An error occurred while allocating compute resources - `cannot_start_ip_address`: An error occurred while allocating an IP address - `cannot_start_network`: An error occurred while allocating network resources - `cannot_update_firmware`: An error occurred while updating bare metal server firmware - `cannot_start_reservation_capacity`: Failed to start because the reservation has insufficient capacity - `cannot_start_reservation_expired`: Failed to start because the reservation has expired The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        CANNOT_REINITIALIZE = 'cannot_reinitialize',
        CANNOT_START = 'cannot_start',
        CANNOT_START_CAPACITY = 'cannot_start_capacity',
        CANNOT_START_COMPUTE = 'cannot_start_compute',
        CANNOT_START_IP_ADDRESS = 'cannot_start_ip_address',
        CANNOT_START_NETWORK = 'cannot_start_network',
        CANNOT_START_RESERVATION_CAPACITY = 'cannot_start_reservation_capacity',
        CANNOT_START_RESERVATION_EXPIRED = 'cannot_start_reservation_expired',
        CANNOT_UPDATE_FIRMWARE = 'cannot_update_firmware',
      }
    }
  }

  /**
   * BareMetalServerTrustedPlatformModule.
   */
  export interface BareMetalServerTrustedPlatformModule {
    /** Indicates whether the trusted platform module is enabled. */
    enabled: boolean;
    /** The trusted platform module (TPM) mode:
     *  - `disabled`: No TPM functionality
     *  - `tpm_2`: TPM 2.0
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    mode: BareMetalServerTrustedPlatformModule.Constants.Mode | string;
    /** The supported trusted platform module modes. */
    supported_modes: BareMetalServerTrustedPlatformModule.Constants.SupportedModes[] | string[];
  }
  export namespace BareMetalServerTrustedPlatformModule {
    export namespace Constants {
      /** The trusted platform module (TPM) mode: - `disabled`: No TPM functionality - `tpm_2`: TPM 2.0 The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Mode {
        DISABLED = 'disabled',
        TPM_2 = 'tpm_2',
      }
      /** The supported trusted platform module modes. */
      export enum SupportedModes {
        DISABLED = 'disabled',
        TPM_2 = 'tpm_2',
      }
    }
  }

  /**
   * BareMetalServerTrustedPlatformModulePatch.
   */
  export interface BareMetalServerTrustedPlatformModulePatch {
    /** The trusted platform module mode to use. The specified value must be listed in the bare metal server's
     *  `supported_modes`.
     *
     *  For the trusted platform module mode to be changed, the bare metal server `status` must be `stopped`.
     */
    mode?: BareMetalServerTrustedPlatformModulePatch.Constants.Mode | string;
  }
  export namespace BareMetalServerTrustedPlatformModulePatch {
    export namespace Constants {
      /** The trusted platform module mode to use. The specified value must be listed in the bare metal server's `supported_modes`. For the trusted platform module mode to be changed, the bare metal server `status` must be `stopped`. */
      export enum Mode {
        DISABLED = 'disabled',
        TPM_2 = 'tpm_2',
      }
    }
  }

  /**
   * BareMetalServerTrustedPlatformModulePrototype.
   */
  export interface BareMetalServerTrustedPlatformModulePrototype {
    /** The trusted platform module mode to use. The specified value must be listed in the bare metal server
     *  profile's `supported_trusted_platform_module_modes`.
     *
     *  If unspecified, the default trusted platform module mode from the profile will be used.
     */
    mode?: BareMetalServerTrustedPlatformModulePrototype.Constants.Mode | string;
  }
  export namespace BareMetalServerTrustedPlatformModulePrototype {
    export namespace Constants {
      /** The trusted platform module mode to use. The specified value must be listed in the bare metal server profile's `supported_trusted_platform_module_modes`. If unspecified, the default trusted platform module mode from the profile will be used. */
      export enum Mode {
        DISABLED = 'disabled',
        TPM_2 = 'tpm_2',
      }
    }
  }

  /**
   * Identifies a [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering by a unique
   * property.
   */
  export interface CatalogOfferingIdentity {
  }

  /**
   * Identifies a version of a
   * [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering by a unique property.
   */
  export interface CatalogOfferingVersionIdentity {
  }

  /**
   * Identifies a catalog offering version's billing plan by a unique property.
   */
  export interface CatalogOfferingVersionPlanIdentity {
  }

  /**
   * CatalogOfferingVersionPlanReference.
   */
  export interface CatalogOfferingVersionPlanReference {
    /** The CRN for this
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering version's billing plan.
     */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
  }

  /**
   * CatalogOfferingVersionReference.
   */
  export interface CatalogOfferingVersionReference {
    /** The CRN for this version of a
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering.
     */
    crn: string;
  }

  /**
   * Identifies a certificate instance by a unique property.
   */
  export interface CertificateInstanceIdentity {
  }

  /**
   * CertificateInstanceReference.
   */
  export interface CertificateInstanceReference {
    /** The CRN for this certificate instance. */
    crn: string;
  }

  /**
   * Identifies a Cloud Object Storage bucket by a unique property.
   */
  export interface CloudObjectStorageBucketIdentity {
  }

  /**
   * CloudObjectStorageBucketReference.
   */
  export interface CloudObjectStorageBucketReference {
    /** The CRN of this Cloud Object Storage bucket. */
    crn: string;
    /** The globally unique name of this Cloud Object Storage bucket. */
    name: string;
  }

  /**
   * CloudObjectStorageObjectReference.
   */
  export interface CloudObjectStorageObjectReference {
    /** The name of this Cloud Object Storage object. Names are unique within a Cloud Object Storage bucket. */
    name: string;
  }

  /**
   * ClusterNetwork.
   */
  export interface ClusterNetwork {
    /** The date and time that the cluster network was created. */
    created_at: string;
    /** The CRN for this cluster network. */
    crn: string;
    /** The URL for this cluster network. */
    href: string;
    /** The unique identifier for this cluster network. */
    id: string;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: ClusterNetworkLifecycleReason[];
    /** The lifecycle state of the cluster network. */
    lifecycle_state: ClusterNetwork.Constants.LifecycleState | string;
    /** The name for this cluster network. The name must not be used by another cluster network in the region. */
    name: string;
    /** The profile for this cluster network. */
    profile: ClusterNetworkProfileReference;
    /** The resource group for this cluster network. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: ClusterNetwork.Constants.ResourceType | string;
    /** The IP address ranges available for subnets for this cluster network. */
    subnet_prefixes: ClusterNetworkSubnetPrefix[];
    /** The VPC this cluster network resides in. */
    vpc: VPCReference;
    /** The zone this cluster network resides in. */
    zone: ZoneReference;
  }
  export namespace ClusterNetwork {
    export namespace Constants {
      /** The lifecycle state of the cluster network. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        CLUSTER_NETWORK = 'cluster_network',
      }
    }
  }

  /**
   * ClusterNetworkCollection.
   */
  export interface ClusterNetworkCollection {
    /** A page of cluster networks. */
    cluster_networks: ClusterNetwork[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * The associated cluster network subnet.
   */
  export interface ClusterNetworkInterface {
    /** Indicates whether source IP spoofing is allowed on this cluster network interface. If `false`, source IP
     *  spoofing is prevented on this cluster network interface. If `true`, source IP spoofing is allowed on this
     *  cluster network interface.
     */
    allow_ip_spoofing: boolean;
    /** Indicates whether this cluster network interface will be automatically deleted when `target` is deleted. */
    auto_delete: boolean;
    /** The date and time that the cluster network interface was created. */
    created_at: string;
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the virtual network interface,
     *    allowing the workload to perform any needed NAT operations.
     */
    enable_infrastructure_nat: boolean;
    /** The URL for this cluster network interface. */
    href: string;
    /** The unique identifier for this cluster network interface. */
    id: string;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: ClusterNetworkInterfaceLifecycleReason[];
    /** The lifecycle state of the cluster network interface. */
    lifecycle_state: ClusterNetworkInterface.Constants.LifecycleState | string;
    /** The MAC address of the cluster network interface. May be absent if `lifecycle_state` is `pending`. */
    mac_address?: string;
    /** The name for this cluster network interface. The name is unique across all interfaces in the cluster
     *  network.
     */
    name: string;
    /** The cluster network subnet reserved IP for this cluster network interface. */
    primary_ip: ClusterNetworkSubnetReservedIPReference;
    /** The resource type. */
    resource_type: ClusterNetworkInterface.Constants.ResourceType | string;
    subnet?: ClusterNetworkSubnetReference;
    /** The target of this cluster network interface.
     *
     *  If absent, this cluster network interface is not attached to a target.
     *
     *  The resources supported by this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    target?: ClusterNetworkInterfaceTarget;
    /** The VPC this cluster network interface resides in. */
    vpc: VPCReference;
    /** The zone this cluster network interface resides in. */
    zone: ZoneReference;
  }
  export namespace ClusterNetworkInterface {
    export namespace Constants {
      /** The lifecycle state of the cluster network interface. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        CLUSTER_NETWORK_INTERFACE = 'cluster_network_interface',
      }
    }
  }

  /**
   * ClusterNetworkInterfaceCollection.
   */
  export interface ClusterNetworkInterfaceCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of cluster network interfaces. */
    interfaces: ClusterNetworkInterface[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ClusterNetworkInterfaceLifecycleReason.
   */
  export interface ClusterNetworkInterfaceLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ClusterNetworkInterfaceLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace ClusterNetworkInterfaceLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * ClusterNetworkInterfacePrimaryIPPrototype.
   */
  export interface ClusterNetworkInterfacePrimaryIPPrototype {
  }

  /**
   * The associated cluster network subnet.
   */
  export interface ClusterNetworkInterfaceReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this cluster network interface. */
    href: string;
    /** The unique identifier for this cluster network interface. */
    id: string;
    /** The name for this cluster network interface. The name is unique across all interfaces in the cluster
     *  network.
     */
    name: string;
    /** The primary IP for this cluster network interface. */
    primary_ip: ClusterNetworkSubnetReservedIPReference;
    /** The resource type. */
    resource_type: ClusterNetworkInterfaceReference.Constants.ResourceType | string;
    subnet: ClusterNetworkSubnetReference;
  }
  export namespace ClusterNetworkInterfaceReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        CLUSTER_NETWORK_INTERFACE = 'cluster_network_interface',
      }
    }
  }

  /**
   * The target of this cluster network interface.
   *
   * If absent, this cluster network interface is not attached to a target.
   *
   * The resources supported by this property may
   * [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
   */
  export interface ClusterNetworkInterfaceTarget {
  }

  /**
   * ClusterNetworkLifecycleReason.
   */
  export interface ClusterNetworkLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ClusterNetworkLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace ClusterNetworkLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * ClusterNetworkProfile.
   */
  export interface ClusterNetworkProfile {
    /** The product family this cluster network profile belongs to.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    family: ClusterNetworkProfile.Constants.Family | string;
    /** The URL for this cluster network profile. */
    href: string;
    /** The globally unique name for this cluster network profile. */
    name: string;
    /** The resource type. */
    resource_type: ClusterNetworkProfile.Constants.ResourceType | string;
    /** The instance profiles that support this cluster network profile. */
    supported_instance_profiles: InstanceProfileReference[];
    /** Zones in this region that support this cluster network profile. */
    zones: ZoneReference[];
  }
  export namespace ClusterNetworkProfile {
    export namespace Constants {
      /** The product family this cluster network profile belongs to. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Family {
        VELA = 'vela',
      }
      /** The resource type. */
      export enum ResourceType {
        CLUSTER_NETWORK_PROFILE = 'cluster_network_profile',
      }
    }
  }

  /**
   * ClusterNetworkProfileCollection.
   */
  export interface ClusterNetworkProfileCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of cluster network profiles. */
    profiles: ClusterNetworkProfile[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Identifies an cluster network profile by a unique property.
   */
  export interface ClusterNetworkProfileIdentity {
  }

  /**
   * ClusterNetworkProfileReference.
   */
  export interface ClusterNetworkProfileReference {
    /** The URL for this cluster network profile. */
    href: string;
    /** The globally unique name for this cluster network profile. */
    name: string;
    /** The resource type. */
    resource_type: ClusterNetworkProfileReference.Constants.ResourceType | string;
  }
  export namespace ClusterNetworkProfileReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        CLUSTER_NETWORK_PROFILE = 'cluster_network_profile',
      }
    }
  }

  /**
   * ClusterNetworkReference.
   */
  export interface ClusterNetworkReference {
    /** The CRN for this cluster network. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this cluster network. */
    href: string;
    /** The unique identifier for this cluster network. */
    id: string;
    /** The name for this cluster network. The name must not be used by another cluster network in the region. */
    name: string;
    /** The resource type. */
    resource_type: ClusterNetworkReference.Constants.ResourceType | string;
  }
  export namespace ClusterNetworkReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        CLUSTER_NETWORK = 'cluster_network',
      }
    }
  }

  /**
   * ClusterNetworkSubnet.
   */
  export interface ClusterNetworkSubnet {
    /** The number of IPv4 addresses in this cluster network subnet that are not in use, and have not been reserved
     *  by the user or the provider.
     */
    available_ipv4_address_count: number;
    /** The date and time that the cluster network subnet was created. */
    created_at: string;
    /** The URL for this cluster network subnet. */
    href: string;
    /** The unique identifier for this cluster network subnet. */
    id: string;
    /** The IP version for this cluster network subnet.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    ip_version: ClusterNetworkSubnet.Constants.IpVersion | string;
    /** The IPv4 range of this cluster network subnet, expressed in CIDR format. */
    ipv4_cidr_block: string;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: ClusterNetworkSubnetLifecycleReason[];
    /** The lifecycle state of the cluster network subnet. */
    lifecycle_state: ClusterNetworkSubnet.Constants.LifecycleState | string;
    /** The name for this cluster network subnet. The name is unique across all cluster network subnets in the
     *  cluster network.
     */
    name: string;
    /** The resource type. */
    resource_type: ClusterNetworkSubnet.Constants.ResourceType | string;
    /** The total number of IPv4 addresses in this cluster network subnet.
     *
     *  Note: This is calculated as 2<sup>(32 - prefix length)</sup>. For example, the prefix length `/24` gives:<br>
     *  2<sup>(32 - 24)</sup> = 2<sup>8</sup> = 256 addresses.
     */
    total_ipv4_address_count: number;
  }
  export namespace ClusterNetworkSubnet {
    export namespace Constants {
      /** The IP version for this cluster network subnet. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The lifecycle state of the cluster network subnet. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        CLUSTER_NETWORK_SUBNET = 'cluster_network_subnet',
      }
    }
  }

  /**
   * ClusterNetworkSubnetCollection.
   */
  export interface ClusterNetworkSubnetCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of subnets for the cluster network. */
    subnets: ClusterNetworkSubnet[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Identifies a cluster network subnet by a unique property.
   */
  export interface ClusterNetworkSubnetIdentity {
  }

  /**
   * ClusterNetworkSubnetLifecycleReason.
   */
  export interface ClusterNetworkSubnetLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ClusterNetworkSubnetLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace ClusterNetworkSubnetLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * A range of addresses available for subnets for this cluster network.
   */
  export interface ClusterNetworkSubnetPrefix {
    /** The allocation policy for this subnet prefix:
     *  - `auto`: Subnets created by total count in this cluster network can use this prefix.
     */
    allocation_policy: ClusterNetworkSubnetPrefix.Constants.AllocationPolicy | string;
    /** The CIDR block for this prefix. */
    cidr: string;
  }
  export namespace ClusterNetworkSubnetPrefix {
    export namespace Constants {
      /** The allocation policy for this subnet prefix: - `auto`: Subnets created by total count in this cluster network can use this prefix. */
      export enum AllocationPolicy {
        AUTO = 'auto',
      }
    }
  }

  /**
   * ClusterNetworkSubnetPrefixPrototype.
   */
  export interface ClusterNetworkSubnetPrefixPrototype {
    /** The IPv4 range of the cluster network's subnet prefix, expressed in CIDR format.
     *
     *  The CIDR prefix length must be less than `/29` (at least 8 addresses).
     *
     *  If a range is specified that overlaps with address prefixes in the cluster network's VPC, the operating systems
     *  of any virtual server instances attaching to this cluster network must be [configured to avoid
     *  conflicts](https://cloud.ibm.com/docs/vpc?topic=vpc-planning-cluster-network#advanced-consideration).
     */
    cidr?: string;
  }

  /**
   * ClusterNetworkSubnetPrototype.
   */
  export interface ClusterNetworkSubnetPrototype {
    /** The IP version(s) to support for this cluster network subnet. */
    ip_version?: ClusterNetworkSubnetPrototype.Constants.IpVersion | string;
    /** The name for this cluster network subnet. The name must not be used by another cluster network subnet in the
     *  cluster network. Names starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }
  export namespace ClusterNetworkSubnetPrototype {
    export namespace Constants {
      /** The IP version(s) to support for this cluster network subnet. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
    }
  }

  /**
   * ClusterNetworkSubnetReference.
   */
  export interface ClusterNetworkSubnetReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this cluster network subnet. */
    href: string;
    /** The unique identifier for this cluster network subnet. */
    id: string;
    /** The name for this cluster network subnet. The name is unique across all cluster network subnets in the
     *  cluster network.
     */
    name: string;
    /** The resource type. */
    resource_type: ClusterNetworkSubnetReference.Constants.ResourceType | string;
  }
  export namespace ClusterNetworkSubnetReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        CLUSTER_NETWORK_SUBNET = 'cluster_network_subnet',
      }
    }
  }

  /**
   * ClusterNetworkSubnetReservedIP.
   */
  export interface ClusterNetworkSubnetReservedIP {
    /** The IP address.
     *
     *  If the address is pending allocation, the value will be `0.0.0.0`.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
    /** Indicates whether this cluster network subnet reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the cluster network subnet reserved IP is unbound.
     */
    auto_delete: boolean;
    /** The date and time that the cluster network subnet reserved IP was created. */
    created_at: string;
    /** The URL for this cluster network subnet reserved IP. */
    href: string;
    /** The unique identifier for this cluster network subnet reserved IP. */
    id: string;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: ClusterNetworkSubnetReservedIPLifecycleReason[];
    /** The lifecycle state of the cluster network subnet reserved IP. */
    lifecycle_state: ClusterNetworkSubnetReservedIP.Constants.LifecycleState | string;
    /** The name for this cluster network subnet reserved IP. The name is unique across all reserved IPs in a
     *  cluster network subnet.
     */
    name: string;
    /** The owner of the cluster network subnet reserved IP
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    owner: ClusterNetworkSubnetReservedIP.Constants.Owner | string;
    /** The resource type. */
    resource_type: ClusterNetworkSubnetReservedIP.Constants.ResourceType | string;
    /** The target this cluster network subnet reserved IP is bound to.
     *
     *  If absent, this cluster network subnet reserved IP is provider-owned or unbound.
     */
    target?: ClusterNetworkSubnetReservedIPTarget;
  }
  export namespace ClusterNetworkSubnetReservedIP {
    export namespace Constants {
      /** The lifecycle state of the cluster network subnet reserved IP. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The owner of the cluster network subnet reserved IP The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Owner {
        PROVIDER = 'provider',
        USER = 'user',
      }
      /** The resource type. */
      export enum ResourceType {
        CLUSTER_NETWORK_SUBNET_RESERVED_IP = 'cluster_network_subnet_reserved_ip',
      }
    }
  }

  /**
   * ClusterNetworkSubnetReservedIPCollection.
   */
  export interface ClusterNetworkSubnetReservedIPCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of reserved IPs for the cluster network subnet. */
    reserved_ips: ClusterNetworkSubnetReservedIP[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ClusterNetworkSubnetReservedIPLifecycleReason.
   */
  export interface ClusterNetworkSubnetReservedIPLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ClusterNetworkSubnetReservedIPLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace ClusterNetworkSubnetReservedIPLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * ClusterNetworkSubnetReservedIPReference.
   */
  export interface ClusterNetworkSubnetReservedIPReference {
    /** The IP address.
     *
     *  If the address is pending allocation, the value will be `0.0.0.0`.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this cluster network subnet reserved IP. */
    href: string;
    /** The unique identifier for this cluster network subnet reserved IP. */
    id: string;
    /** The name for this cluster network subnet reserved IP. The name is unique across all reserved IPs in a
     *  cluster network subnet.
     */
    name: string;
    /** The resource type. */
    resource_type: ClusterNetworkSubnetReservedIPReference.Constants.ResourceType | string;
  }
  export namespace ClusterNetworkSubnetReservedIPReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        CLUSTER_NETWORK_SUBNET_RESERVED_IP = 'cluster_network_subnet_reserved_ip',
      }
    }
  }

  /**
   * The target this cluster network subnet reserved IP is bound to.
   *
   * If absent, this cluster network subnet reserved IP is provider-owned or unbound.
   */
  export interface ClusterNetworkSubnetReservedIPTarget {
  }

  /**
   * Identifies a DNS instance by a unique property.
   */
  export interface DNSInstanceIdentity {
  }

  /**
   * DNSInstanceReferenceLoadBalancerDNSContext.
   */
  export interface DNSInstanceReferenceLoadBalancerDNSContext {
    /** The CRN for this DNS instance. */
    crn: string;
  }

  /**
   * A DNS server.
   */
  export interface DNSServer {
    /** The IP address.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
    /** If present, DHCP configuration for this zone will have this DNS server listed first. */
    zone_affinity?: ZoneReference;
  }

  /**
   * DNSServerPrototype.
   */
  export interface DNSServerPrototype {
    /** The DNS server IPv4 address. */
    address?: string;
    /** DHCP configuration for the specified zone will have this DNS server listed first. */
    zone_affinity?: ZoneIdentity;
  }

  /**
   * Identifies a DNS zone by a unique property.
   */
  export interface DNSZoneIdentity {
  }

  /**
   * DNSZoneReference.
   */
  export interface DNSZoneReference {
    id: string;
  }

  /**
   * DedicatedHost.
   */
  export interface DedicatedHost {
    /** The amount of memory in gibibytes that is currently available for instances. */
    available_memory: number;
    /** The available VCPU for the dedicated host. */
    available_vcpu: VCPU;
    /** The date and time that the dedicated host was created. */
    created_at: string;
    /** The CRN for this dedicated host. */
    crn: string;
    /** The disks for the dedicated host. */
    disks: DedicatedHostDisk[];
    /** The dedicated host group this dedicated host is in. */
    group: DedicatedHostGroupReference;
    /** The URL for this dedicated host. */
    href: string;
    /** The unique identifier for this dedicated host. */
    id: string;
    /** If set to true, instances can be placed on this dedicated host. */
    instance_placement_enabled: boolean;
    /** The instances that are allocated to this dedicated host. */
    instances: InstanceReference[];
    /** The lifecycle state of the dedicated host. */
    lifecycle_state: DedicatedHost.Constants.LifecycleState | string;
    /** The total amount of memory in gibibytes for this host. */
    memory: number;
    /** The name for this dedicated host. The name is unique across all dedicated hosts in the region. */
    name: string;
    /** The dedicated host NUMA configuration. */
    numa: DedicatedHostNUMA;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles) for this dedicated host. */
    profile: DedicatedHostProfileReference;
    /** Indicates whether this dedicated host is available for instance creation. */
    provisionable: boolean;
    /** The resource group for this dedicated host. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: DedicatedHost.Constants.ResourceType | string;
    /** The total number of sockets for this host. */
    socket_count: number;
    /** The administrative state of the dedicated host.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    state: DedicatedHost.Constants.State | string;
    /** The instance profiles usable by instances placed on this dedicated host. */
    supported_instance_profiles: InstanceProfileReference[];
    /** The total VCPU of the dedicated host. */
    vcpu: VCPU;
    /** The zone this dedicated host resides in. */
    zone: ZoneReference;
  }
  export namespace DedicatedHost {
    export namespace Constants {
      /** The lifecycle state of the dedicated host. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        DEDICATED_HOST = 'dedicated_host',
      }
      /** The administrative state of the dedicated host. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum State {
        AVAILABLE = 'available',
        DEGRADED = 'degraded',
        MIGRATING = 'migrating',
        UNAVAILABLE = 'unavailable',
      }
    }
  }

  /**
   * DedicatedHostCollection.
   */
  export interface DedicatedHostCollection {
    /** A page of dedicated hosts. */
    dedicated_hosts: DedicatedHost[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * DedicatedHostDisk.
   */
  export interface DedicatedHostDisk {
    /** The remaining space left for instance placement in GB (gigabytes). */
    available: number;
    /** The date and time that the disk was created. */
    created_at: string;
    /** The URL for this disk. */
    href: string;
    /** The unique identifier for this disk. */
    id: string;
    /** Instance disks that are on this dedicated host disk. */
    instance_disks: InstanceDiskReference[];
    /** The disk interface used for attaching the disk. */
    interface_type: DedicatedHostDisk.Constants.InterfaceType | string;
    /** The lifecycle state of this dedicated host disk. */
    lifecycle_state?: DedicatedHostDisk.Constants.LifecycleState | string;
    /** The name for this dedicated host disk. The name is unique across all disks on the dedicated host. */
    name: string;
    /** Indicates whether this dedicated host disk is available for instance disk creation. */
    provisionable: boolean;
    /** The resource type. */
    resource_type: DedicatedHostDisk.Constants.ResourceType | string;
    /** The size of the disk in GB (gigabytes). */
    size: number;
    /** The instance disk interfaces supported for this dedicated host disk.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    supported_instance_interface_types: DedicatedHostDisk.Constants.SupportedInstanceInterfaceTypes[] | string[];
  }
  export namespace DedicatedHostDisk {
    export namespace Constants {
      /** The disk interface used for attaching the disk. */
      export enum InterfaceType {
        NVME = 'nvme',
      }
      /** The lifecycle state of this dedicated host disk. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        DEDICATED_HOST_DISK = 'dedicated_host_disk',
      }
      /** The instance disk interfaces supported for this dedicated host disk. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum SupportedInstanceInterfaceTypes {
        NVME = 'nvme',
        VIRTIO_BLK = 'virtio_blk',
      }
    }
  }

  /**
   * DedicatedHostDiskCollection.
   */
  export interface DedicatedHostDiskCollection {
    /** The disks for the dedicated host. */
    disks: DedicatedHostDisk[];
  }

  /**
   * DedicatedHostGroup.
   */
  export interface DedicatedHostGroup {
    /** The dedicated host profile class for hosts in this group. */
    class: string;
    /** The date and time that the dedicated host group was created. */
    created_at: string;
    /** The CRN for this dedicated host group. */
    crn: string;
    /** The dedicated hosts that are in this dedicated host group. */
    dedicated_hosts: DedicatedHostReference[];
    /** The dedicated host profile family for hosts in this group. */
    family: DedicatedHostGroup.Constants.Family | string;
    /** The URL for this dedicated host group. */
    href: string;
    /** The unique identifier for this dedicated host group. */
    id: string;
    /** The name for this dedicated host group. The name is unique across all dedicated host groups in the region. */
    name: string;
    /** The resource group for this dedicated host group. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: DedicatedHostGroup.Constants.ResourceType | string;
    /** The instance profiles usable by instances placed on this dedicated host group. */
    supported_instance_profiles: InstanceProfileReference[];
    /** The zone this dedicated host group resides in. */
    zone: ZoneReference;
  }
  export namespace DedicatedHostGroup {
    export namespace Constants {
      /** The dedicated host profile family for hosts in this group. */
      export enum Family {
        BALANCED = 'balanced',
        COMPUTE = 'compute',
        MEMORY = 'memory',
      }
      /** The resource type. */
      export enum ResourceType {
        DEDICATED_HOST_GROUP = 'dedicated_host_group',
      }
    }
  }

  /**
   * DedicatedHostGroupCollection.
   */
  export interface DedicatedHostGroupCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of dedicated host groups. */
    groups: DedicatedHostGroup[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Identifies a dedicated host group by a unique property.
   */
  export interface DedicatedHostGroupIdentity {
  }

  /**
   * DedicatedHostGroupPrototypeDedicatedHostByZoneContext.
   */
  export interface DedicatedHostGroupPrototypeDedicatedHostByZoneContext {
    /** The name for this dedicated host group. The name must not be used by another dedicated host group in the
     *  region. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the host's resource group is used. */
    resource_group?: ResourceGroupIdentity;
  }

  /**
   * DedicatedHostGroupReference.
   */
  export interface DedicatedHostGroupReference {
    /** The CRN for this dedicated host group. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this dedicated host group. */
    href: string;
    /** The unique identifier for this dedicated host group. */
    id: string;
    /** The name for this dedicated host group. The name is unique across all dedicated host groups in the region. */
    name: string;
    /** The resource type. */
    resource_type: DedicatedHostGroupReference.Constants.ResourceType | string;
  }
  export namespace DedicatedHostGroupReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        DEDICATED_HOST_GROUP = 'dedicated_host_group',
      }
    }
  }

  /**
   * The dedicated host NUMA configuration.
   */
  export interface DedicatedHostNUMA {
    /** The total number of NUMA nodes for this dedicated host. */
    count: number;
    /** The NUMA nodes for this dedicated host. */
    nodes: DedicatedHostNUMANode[];
  }

  /**
   * The dedicated host NUMA node configuration.
   */
  export interface DedicatedHostNUMANode {
    /** The available VCPU for this NUMA node. */
    available_vcpu: number;
    /** The total VCPU capacity for this NUMA node. */
    vcpu: number;
  }

  /**
   * DedicatedHostProfile.
   */
  export interface DedicatedHostProfile {
    /** The product class this dedicated host profile belongs to. */
    class: string;
    /** The disks for a dedicated host with this profile. */
    disks: DedicatedHostProfileDisk[];
    /** The product family this dedicated host profile belongs to
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    family: DedicatedHostProfile.Constants.Family | string;
    /** The URL for this dedicated host. */
    href: string;
    memory: DedicatedHostProfileMemory;
    /** The globally unique name for this dedicated host profile. */
    name: string;
    socket_count: DedicatedHostProfileSocket;
    /** The status of the dedicated host profile:
     *  - `previous`: This dedicated host profile is an older revision, but remains provisionable
     *    and usable.
     *  - `current`: This dedicated host profile is the latest revision.
     *
     *  Revisions are indicated by the generation of a dedicated host profile. Refer to the [profile naming
     *  conventions](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles&interface=ui#profiles-naming-rule) for
     *  information on how generations are defined within a dedicated host profile.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: DedicatedHostProfile.Constants.Status | string;
    /** The instance profiles usable by instances placed on dedicated hosts with this profile. */
    supported_instance_profiles: InstanceProfileReference[];
    vcpu_architecture: DedicatedHostProfileVCPUArchitecture;
    vcpu_count: DedicatedHostProfileVCPU;
    vcpu_manufacturer: DedicatedHostProfileVCPUManufacturer;
  }
  export namespace DedicatedHostProfile {
    export namespace Constants {
      /** The product family this dedicated host profile belongs to The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Family {
        BALANCED = 'balanced',
        COMPUTE = 'compute',
        MEMORY = 'memory',
      }
      /** The status of the dedicated host profile: - `previous`: This dedicated host profile is an older revision, but remains provisionable and usable. - `current`: This dedicated host profile is the latest revision. Revisions are indicated by the generation of a dedicated host profile. Refer to the [profile naming conventions](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles&interface=ui#profiles-naming-rule) for information on how generations are defined within a dedicated host profile. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        CURRENT = 'current',
        PREVIOUS = 'previous',
      }
    }
  }

  /**
   * DedicatedHostProfileCollection.
   */
  export interface DedicatedHostProfileCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of dedicated host profiles. */
    profiles: DedicatedHostProfile[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Disks provided by this profile.
   */
  export interface DedicatedHostProfileDisk {
    interface_type: DedicatedHostProfileDiskInterface;
    /** The number of disks of this type for a dedicated host with this profile. */
    quantity: DedicatedHostProfileDiskQuantity;
    /** The size of the disk in GB (gigabytes). */
    size: DedicatedHostProfileDiskSize;
    supported_instance_interface_types: DedicatedHostProfileDiskSupportedInterfaces;
  }

  /**
   * DedicatedHostProfileDiskInterface.
   */
  export interface DedicatedHostProfileDiskInterface {
    /** The type for this profile field. */
    type: DedicatedHostProfileDiskInterface.Constants.Type | string;
    /** The interface of the disk for a dedicated host with this profile
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    value: DedicatedHostProfileDiskInterface.Constants.Value | string;
  }
  export namespace DedicatedHostProfileDiskInterface {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
      /** The interface of the disk for a dedicated host with this profile The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Value {
        NVME = 'nvme',
      }
    }
  }

  /**
   * The number of disks of this type for a dedicated host with this profile.
   */
  export interface DedicatedHostProfileDiskQuantity {
    /** The type for this profile field. */
    type: DedicatedHostProfileDiskQuantity.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace DedicatedHostProfileDiskQuantity {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The size of the disk in GB (gigabytes).
   */
  export interface DedicatedHostProfileDiskSize {
    /** The type for this profile field. */
    type: DedicatedHostProfileDiskSize.Constants.Type | string;
    /** The size of the disk in GB (gigabytes). */
    value: number;
  }
  export namespace DedicatedHostProfileDiskSize {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * DedicatedHostProfileDiskSupportedInterfaces.
   */
  export interface DedicatedHostProfileDiskSupportedInterfaces {
    /** The type for this profile field. */
    type: DedicatedHostProfileDiskSupportedInterfaces.Constants.Type | string;
    /** The instance disk interfaces supported for a dedicated host with this profile. */
    value: DedicatedHostProfileDiskSupportedInterfaces.Constants.Value[] | string[];
  }
  export namespace DedicatedHostProfileDiskSupportedInterfaces {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
      /** The instance disk interfaces supported for a dedicated host with this profile. */
      export enum Value {
        NVME = 'nvme',
        VIRTIO_BLK = 'virtio_blk',
      }
    }
  }

  /**
   * Identifies a dedicated host profile by a unique property.
   */
  export interface DedicatedHostProfileIdentity {
  }

  /**
   * DedicatedHostProfileMemory.
   */
  export interface DedicatedHostProfileMemory {
  }

  /**
   * DedicatedHostProfileReference.
   */
  export interface DedicatedHostProfileReference {
    /** The URL for this dedicated host. */
    href: string;
    /** The globally unique name for this dedicated host profile. */
    name: string;
  }

  /**
   * DedicatedHostProfileSocket.
   */
  export interface DedicatedHostProfileSocket {
  }

  /**
   * DedicatedHostProfileVCPU.
   */
  export interface DedicatedHostProfileVCPU {
  }

  /**
   * DedicatedHostProfileVCPUArchitecture.
   */
  export interface DedicatedHostProfileVCPUArchitecture {
    /** The type for this profile field. */
    type: DedicatedHostProfileVCPUArchitecture.Constants.Type | string;
    /** The VCPU architecture for a dedicated host with this profile. */
    value: DedicatedHostProfileVCPUArchitecture.Constants.Value | string;
  }
  export namespace DedicatedHostProfileVCPUArchitecture {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
      /** The VCPU architecture for a dedicated host with this profile. */
      export enum Value {
        AMD64 = 'amd64',
        S390X = 's390x',
      }
    }
  }

  /**
   * DedicatedHostProfileVCPUManufacturer.
   */
  export interface DedicatedHostProfileVCPUManufacturer {
    /** The type for this profile field. */
    type: DedicatedHostProfileVCPUManufacturer.Constants.Type | string;
    /** The VCPU manufacturer for a dedicated host with this profile. */
    value: DedicatedHostProfileVCPUManufacturer.Constants.Value | string;
  }
  export namespace DedicatedHostProfileVCPUManufacturer {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
      /** The VCPU manufacturer for a dedicated host with this profile. */
      export enum Value {
        AMD = 'amd',
        IBM = 'ibm',
        INTEL = 'intel',
      }
    }
  }

  /**
   * DedicatedHostPrototype.
   */
  export interface DedicatedHostPrototype {
    /** If set to true, instances can be placed on this dedicated host. */
    instance_placement_enabled?: boolean;
    /** The name for this dedicated host. The name must not be used by another dedicated host in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles) to use for this dedicated host. */
    profile: DedicatedHostProfileIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
  }

  /**
   * DedicatedHostReference.
   */
  export interface DedicatedHostReference {
    /** The CRN for this dedicated host. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this dedicated host. */
    href: string;
    /** The unique identifier for this dedicated host. */
    id: string;
    /** The name for this dedicated host. The name is unique across all dedicated hosts in the region. */
    name: string;
    /** The resource type. */
    resource_type: DedicatedHostReference.Constants.ResourceType | string;
  }
  export namespace DedicatedHostReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        DEDICATED_HOST = 'dedicated_host',
      }
    }
  }

  /**
   * DefaultNetworkACL.
   */
  export interface DefaultNetworkACL {
    /** The date and time that the network ACL was created. */
    created_at: string;
    /** The CRN for this network ACL. */
    crn: string;
    /** The URL for this network ACL. */
    href: string;
    /** The unique identifier for this network ACL. */
    id: string;
    /** The name of the default network ACL created for a VPC. The name will be a hyphenated list of
     *  randomly-selected words at creation, but may be changed.
     */
    name: string;
    /** The resource group for the default network ACL for a VPC. Set to the VPC's resource group at creation. */
    resource_group: ResourceGroupReference;
    /** The ordered rules for the default network ACL for a VPC. Defaults to two rules which allow ICMP, TCP and UDP
     *  inbound and outbound traffic, respectively. Rules for the default network ACL may be changed, added, or removed.
     */
    rules: NetworkACLRuleItem[];
    /** The subnets to which this network ACL is attached. */
    subnets: SubnetReference[];
    /** The VPC this network ACL resides in. */
    vpc: VPCReference;
  }

  /**
   * DefaultRoutingTable.
   */
  export interface DefaultRoutingTable {
    /** The filters specifying the resources that may create routes in this routing table.
     *
     *  The resources and types of filters supported by this property is expected to
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    accept_routes_from: ResourceFilter[];
    /** The ingress sources to advertise routes to. Routes in the table with `advertise` enabled will be advertised
     *  to these sources.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    advertise_routes_to: DefaultRoutingTable.Constants.AdvertiseRoutesTo[] | string[];
    /** The date and time that this routing table was created. */
    created_at: string;
    /** The CRN for this VPC routing table. */
    crn: string;
    /** The URL for this routing table. */
    href: string;
    /** The unique identifier for this routing table. */
    id: string;
    /** Indicates whether this is the default routing table for this VPC. */
    is_default: boolean;
    /** The lifecycle state of the routing table. */
    lifecycle_state: DefaultRoutingTable.Constants.LifecycleState | string;
    /** The name of the default routing table created for this VPC. The name will be a hyphenated list of
     *  randomly-selected words at creation, but may be changed.
     */
    name: string;
    /** The resource group for this routing table. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: DefaultRoutingTable.Constants.ResourceType | string;
    /** Indicates whether this routing table is used to route traffic that originates from
     *  [Direct Link](https://cloud.ibm.com/docs/dl) to this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     */
    route_direct_link_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from the internet.
     *
     *  Incoming traffic will be routed according to the routing table with two exceptions:
     *  - Traffic destined for IP addresses associated with public gateways will not be
     *    subject to routes in this routing table.
     *  - Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is
     *    an IP address in a subnet in the route's `zone` that is able to accept traffic.
     *    Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *    connection, the packet will be dropped.
     */
    route_internet_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from from [Transit
     *  Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     */
    route_transit_gateway_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from subnets in other zones in
     *  this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     */
    route_vpc_zone_ingress: boolean;
    /** The routes for the default routing table for this VPC. The table is created with no routes, but routes may
     *  be added, changed, or removed with a subsequent request.
     */
    routes: RouteReference[];
    /** The subnets to which this routing table is attached. */
    subnets: SubnetReference[];
  }
  export namespace DefaultRoutingTable {
    export namespace Constants {
      /** The ingress sources to advertise routes to. Routes in the table with `advertise` enabled will be advertised to these sources. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AdvertiseRoutesTo {
        DIRECT_LINK = 'direct_link',
        TRANSIT_GATEWAY = 'transit_gateway',
      }
      /** The lifecycle state of the routing table. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        ROUTING_TABLE = 'routing_table',
      }
    }
  }

  /**
   * DefaultSecurityGroup.
   */
  export interface DefaultSecurityGroup {
    /** The date and time that this security group was created. */
    created_at: string;
    /** The CRN for this security group. */
    crn: string;
    /** The URL for this security group. */
    href: string;
    /** The unique identifier for this security group. */
    id: string;
    /** The name for the default security group for a VPC. The name will be a hyphenated list of randomly-selected
     *  words at creation, but may changed.
     */
    name: string;
    /** The resource group for this security group. */
    resource_group: ResourceGroupReference;
    /** The rules for the default security group for a VPC. Defaults to allowing ICMP, TCP and UDP outbound traffic,
     *  and allowing ICMP, TCP and UDP inbound traffic from other interfaces in the VPC's default security group. Rules
     *  for the default security group may be changed, added or removed.
     */
    rules: SecurityGroupRule[];
    /** The targets for this security group. */
    targets: SecurityGroupTargetReference[];
    /** The VPC this security group resides in. */
    vpc: VPCReference;
  }

  /**
   * If present, this property indicates the referenced resource has been deleted, and provides some supplementary
   * information.
   */
  export interface Deleted {
    /** Link to documentation about deleted resources. */
    more_info: string;
  }

  /**
   * Identifies an encryption key by a unique property.
   */
  export interface EncryptionKeyIdentity {
  }

  /**
   * EncryptionKeyReference.
   */
  export interface EncryptionKeyReference {
    /** The CRN of the [Key Protect Root
     *  Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
     *  Services Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
     */
    crn: string;
  }

  /**
   * EndpointGateway.
   */
  export interface EndpointGateway {
    /** Indicates whether to allow DNS resolution for this endpoint gateway when the VPC this endpoint gateway
     *  resides in has a DNS resolution binding to a VPC with `dns.enable_hub` set to `true`.
     */
    allow_dns_resolution_binding: boolean;
    /** The date and time that the endpoint gateway was created. */
    created_at: string;
    /** The CRN for this endpoint gateway. */
    crn: string;
    /** The health of this resource:
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle
     *     state. A resource with a lifecycle state of `failed` or `deleting` will have a
     *     health state of `inapplicable`. A `pending` resource may also have this state.
     */
    health_state: EndpointGateway.Constants.HealthState | string;
    /** The URL for this endpoint gateway. */
    href: string;
    /** The unique identifier for this endpoint gateway. */
    id: string;
    /** The reserved IPs bound to this endpoint gateway. */
    ips: ReservedIPReference[];
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: EndpointGatewayLifecycleReason[];
    /** The lifecycle state of the endpoint gateway. */
    lifecycle_state: EndpointGateway.Constants.LifecycleState | string;
    /** The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC. */
    name: string;
    /** The resource group for this endpoint gateway. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: EndpointGateway.Constants.ResourceType | string;
    /** The security groups targeting this endpoint gateway. */
    security_groups: SecurityGroupReference[];
    /** Deprecated: The fully qualified domain name for the target service. The domain name may have a wildcard
     *  prefix.
     */
    service_endpoint?: string;
    /** The fully qualified domain names for the target service. A domain name may have a wildcard prefix. */
    service_endpoints: string[];
    /** The target for this endpoint gateway. */
    target: EndpointGatewayTarget;
    /** The VPC this endpoint gateway resides in. */
    vpc: VPCReference;
  }
  export namespace EndpointGateway {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the endpoint gateway. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        ENDPOINT_GATEWAY = 'endpoint_gateway',
      }
    }
  }

  /**
   * EndpointGatewayCollection.
   */
  export interface EndpointGatewayCollection {
    /** A page of endpoint gateways. */
    endpoint_gateways: EndpointGateway[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * EndpointGatewayLifecycleReason.
   */
  export interface EndpointGatewayLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `access_denied`: endpoint gateway access was denied
     *  - `access_expired`: endpoint gateway access has expired
     *  - `access_pending`: endpoint gateway access is pending
     *  - `dns_resolution_binding_pending`: the DNS resolution binding is being set up
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: EndpointGatewayLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace EndpointGatewayLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `access_denied`: endpoint gateway access was denied - `access_expired`: endpoint gateway access has expired - `access_pending`: endpoint gateway access is pending - `dns_resolution_binding_pending`: the DNS resolution binding is being set up - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        ACCESS_DENIED = 'access_denied',
        ACCESS_EXPIRED = 'access_expired',
        ACCESS_PENDING = 'access_pending',
        DNS_RESOLUTION_BINDING_PENDING = 'dns_resolution_binding_pending',
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * EndpointGatewayReferenceRemote.
   */
  export interface EndpointGatewayReferenceRemote {
    /** The CRN for this endpoint gateway. */
    crn: string;
    /** The URL for this endpoint gateway. */
    href: string;
    /** The unique identifier for this endpoint gateway. */
    id: string;
    /** The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: EndpointGatewayRemote;
    /** The resource type. */
    resource_type: EndpointGatewayReferenceRemote.Constants.ResourceType | string;
  }
  export namespace EndpointGatewayReferenceRemote {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        ENDPOINT_GATEWAY = 'endpoint_gateway',
      }
    }
  }

  /**
   * If present, this property indicates that the resource associated with this reference is remote and therefore may
   * not be directly retrievable.
   */
  export interface EndpointGatewayRemote {
    /** If present, this property indicates that the referenced resource is remote to this
     *  account, and identifies the owning account.
     */
    account?: AccountReference;
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /**
   * A reserved IP to bind to the endpoint gateway. This can be specified using an existing reserved IP, or a prototype
   * object for a new reserved IP. The reserved IP will be bound to the endpoint gateway to function as a virtual
   * private endpoint for the service.
   */
  export interface EndpointGatewayReservedIP {
  }

  /**
   * The target for this endpoint gateway.
   */
  export interface EndpointGatewayTarget {
    /** The target resource type for this endpoint gateway. */
    resource_type: EndpointGatewayTarget.Constants.ResourceType | string;
  }
  export namespace EndpointGatewayTarget {
    export namespace Constants {
      /** The target resource type for this endpoint gateway. */
      export enum ResourceType {
        PRIVATE_PATH_SERVICE_GATEWAY = 'private_path_service_gateway',
        PROVIDER_CLOUD_SERVICE = 'provider_cloud_service',
        PROVIDER_INFRASTRUCTURE_SERVICE = 'provider_infrastructure_service',
      }
    }
  }

  /**
   * The target to use for this endpoint gateway. The target:
   * - Must not already be the target of another endpoint gateway in the VPC
   * - Must not have a service endpoint that duplicates or overlaps with any `service_endpoints`
   *   of another endpoint gateway in the VPC.
   */
  export interface EndpointGatewayTargetPrototype {
    /** The target resource type for this endpoint gateway. */
    resource_type?: EndpointGatewayTargetPrototype.Constants.ResourceType | string;
  }
  export namespace EndpointGatewayTargetPrototype {
    export namespace Constants {
      /** The target resource type for this endpoint gateway. */
      export enum ResourceType {
        PRIVATE_PATH_SERVICE_GATEWAY = 'private_path_service_gateway',
        PROVIDER_CLOUD_SERVICE = 'provider_cloud_service',
        PROVIDER_INFRASTRUCTURE_SERVICE = 'provider_infrastructure_service',
      }
    }
  }

  /**
   * FloatingIP.
   */
  export interface FloatingIP {
    /** The globally unique IP address. */
    address: string;
    /** The date and time that the floating IP was created. */
    created_at: string;
    /** The CRN for this floating IP. */
    crn: string;
    /** The URL for this floating IP. */
    href: string;
    /** The unique identifier for this floating IP. */
    id: string;
    /** The name for this floating IP. The name is unique across all floating IPs in the region. */
    name: string;
    /** The resource group for this floating IP. */
    resource_group: ResourceGroupReference;
    /** The status of the floating IP.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: FloatingIP.Constants.Status | string;
    /** The target of this floating IP. */
    target?: FloatingIPTarget;
    /** The zone this floating IP resides in. */
    zone: ZoneReference;
  }
  export namespace FloatingIP {
    export namespace Constants {
      /** The status of the floating IP. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        AVAILABLE = 'available',
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
      }
    }
  }

  /**
   * FloatingIPCollection.
   */
  export interface FloatingIPCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of floating IPs. */
    floating_ips: FloatingIP[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * FloatingIPCollectionVirtualNetworkInterfaceContext.
   */
  export interface FloatingIPCollectionVirtualNetworkInterfaceContext {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of floating IPs bound to the virtual network interface specified by the identifier in the URL. */
    floating_ips: FloatingIPReference[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * FloatingIPPrototype.
   */
  export interface FloatingIPPrototype {
    /** The name for this floating IP. The name must not be used by another floating IP in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
  }

  /**
   * FloatingIPReference.
   */
  export interface FloatingIPReference {
    /** The globally unique IP address. */
    address: string;
    /** The CRN for this floating IP. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this floating IP. */
    href: string;
    /** The unique identifier for this floating IP. */
    id: string;
    /** The name for this floating IP. The name is unique across all floating IPs in the region. */
    name: string;
  }

  /**
   * The target of this floating IP.
   */
  export interface FloatingIPTarget {
  }

  /**
   * The target resource to bind this floating IP to, replacing any existing binding. The floating IP must not be
   * required by another resource, such as a public gateway.
   *
   * The target resource must not already have a floating IP bound to it if the target resource is:
   *
   * - an instance network interface
   * - a bare metal server network interface with `enable_infrastructure_nat` set to `true`
   * - a virtual network interface with `enable_infrastructure_nat` set to `true`
   *
   * Specify `null` to remove an existing binding.
   */
  export interface FloatingIPTargetPatch {
  }

  /**
   * The target resource to bind this floating IP to.
   *
   * The target resource must not already have a floating IP bound to it if the target resource is:
   *
   * - an instance network interface
   * - a bare metal server network interface with `enable_infrastructure_nat` set to `true`
   * - a virtual network interface with `enable_infrastructure_nat` set to `true`.
   */
  export interface FloatingIPTargetPrototype {
  }

  /**
   * FloatingIPUnpaginatedCollection.
   */
  export interface FloatingIPUnpaginatedCollection {
    /** The floating IPs. */
    floating_ips: FloatingIP[];
  }

  /**
   * FlowLogCollector.
   */
  export interface FlowLogCollector {
    /** Indicates whether this collector is active. */
    active: boolean;
    /** Indicates whether this flow log collector will be automatically deleted when `target` is deleted. At
     *  present, this is always `true`, but may be modifiable in the future.
     */
    auto_delete: boolean;
    /** The date and time that the flow log collector was created. */
    created_at: string;
    /** The CRN for this flow log collector. */
    crn: string;
    /** The URL for this flow log collector. */
    href: string;
    /** The unique identifier for this flow log collector. */
    id: string;
    /** The lifecycle state of the flow log collector. */
    lifecycle_state: FlowLogCollector.Constants.LifecycleState | string;
    /** The name for this flow log collector. The name is unique across all flow log collectors in the VPC. */
    name: string;
    /** The resource group for this flow log collector. */
    resource_group: ResourceGroupReference;
    /** The Cloud Object Storage bucket where the collected flows are logged. For more
     *  information, see [Viewing flow log
     *  objects](https://cloud.ibm.com/docs/vpc?topic=vpc-fl-analyze).
     */
    storage_bucket: LegacyCloudObjectStorageBucketReference;
    /** The target this collector is collecting flow logs for.
     *
     *  - If the target is an instance network attachment, flow logs will be collected
     *    for that instance network attachment.
     *  - If the target is an instance network interface, flow logs will be collected
     *    for that instance network interface.
     *  - If the target is a virtual network interface, flow logs will be collected for the
     *    virtual network interface's `target` resource if the resource is an instance network
     *    attachment, unless the target resource is itself the target of a flow log collector.
     *  - If the target is a virtual server instance, flow logs will be collected
     *    for all network attachments or network interfaces on that instance.
     *  - If the target is a subnet, flow logs will be collected
     *    for all instance network interfaces and virtual network interfaces
     *    attached to that subnet.
     *  - If the target is a VPC, flow logs will be collected for all instance network
     *    interfaces and virtual network interfaces  attached to all subnets within that VPC.
     *
     *  If the target is an instance, subnet, or VPC, flow logs will not be collected
     *  for any instance network attachments or instance network interfaces within the target
     *  that are themselves the target of a more specific flow log collector.
     */
    target: FlowLogCollectorTarget;
    /** The VPC this flow log collector resides in. */
    vpc: VPCReference;
  }
  export namespace FlowLogCollector {
    export namespace Constants {
      /** The lifecycle state of the flow log collector. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
    }
  }

  /**
   * FlowLogCollectorCollection.
   */
  export interface FlowLogCollectorCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of flow log collectors. */
    flow_log_collectors: FlowLogCollector[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * The target this collector is collecting flow logs for.
   *
   * - If the target is an instance network attachment, flow logs will be collected
   *   for that instance network attachment.
   * - If the target is an instance network interface, flow logs will be collected
   *   for that instance network interface.
   * - If the target is a virtual network interface, flow logs will be collected for the
   *   virtual network interface's `target` resource if the resource is an instance network
   *   attachment, unless the target resource is itself the target of a flow log collector.
   * - If the target is a virtual server instance, flow logs will be collected
   *   for all network attachments or network interfaces on that instance.
   * - If the target is a subnet, flow logs will be collected
   *   for all instance network interfaces and virtual network interfaces
   *   attached to that subnet.
   * - If the target is a VPC, flow logs will be collected for all instance network
   *   interfaces and virtual network interfaces  attached to all subnets within that VPC.
   *
   * If the target is an instance, subnet, or VPC, flow logs will not be collected for any instance network attachments
   * or instance network interfaces within the target that are themselves the target of a more specific flow log
   * collector.
   */
  export interface FlowLogCollectorTarget {
  }

  /**
   * The target this collector will collect flow logs for.
   *
   * If the target is an instance, subnet, or VPC, flow logs will not be collected for any instance network attachments,
   * virtual network interfaces or instance network interfaces within the target that are themselves the target of a
   * more specific flow log collector.
   *
   * The target must not be a virtual network interface that is attached to a bare metal server network attachment or to
   * a file share mount target.
   */
  export interface FlowLogCollectorTargetPrototype {
  }

  /**
   * IKEPolicy.
   */
  export interface IKEPolicy {
    /** The authentication algorithm.
     *
     *  The `md5` and `sha1` algorithms have been deprecated.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    authentication_algorithm: IKEPolicy.Constants.AuthenticationAlgorithm | string;
    /** The VPN gateway connections that use this IKE policy. */
    connections: VPNGatewayConnectionReference[];
    /** The date and time that this IKE policy was created. */
    created_at: string;
    /** The Diffie-Hellman group
     *
     *  Groups `2` and `5` have been deprecated.
     */
    dh_group: number;
    /** The encryption algorithm.
     *
     *  The `triple_des` algorithm has been deprecated.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    encryption_algorithm: IKEPolicy.Constants.EncryptionAlgorithm | string;
    /** The URL for this IKE policy. */
    href: string;
    /** The unique identifier for this IKE policy. */
    id: string;
    /** The IKE protocol version. */
    ike_version: number;
    /** The key lifetime in seconds. */
    key_lifetime: number;
    /** The name for this IKE policy. The name is unique across all IKE policies in the region. */
    name: string;
    /** The IKE negotiation mode.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    negotiation_mode: IKEPolicy.Constants.NegotiationMode | string;
    /** The resource group for this IKE policy. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: IKEPolicy.Constants.ResourceType | string;
  }
  export namespace IKEPolicy {
    export namespace Constants {
      /** The authentication algorithm. The `md5` and `sha1` algorithms have been deprecated. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AuthenticationAlgorithm {
        MD5 = 'md5',
        SHA1 = 'sha1',
        SHA256 = 'sha256',
        SHA384 = 'sha384',
        SHA512 = 'sha512',
      }
      /** The encryption algorithm. The `triple_des` algorithm has been deprecated. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum EncryptionAlgorithm {
        AES128 = 'aes128',
        AES192 = 'aes192',
        AES256 = 'aes256',
        TRIPLE_DES = 'triple_des',
      }
      /** The IKE negotiation mode. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum NegotiationMode {
        MAIN = 'main',
      }
      /** The resource type. */
      export enum ResourceType {
        IKE_POLICY = 'ike_policy',
      }
    }
  }

  /**
   * IKEPolicyCollection.
   */
  export interface IKEPolicyCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of IKE policies. */
    ike_policies: IKEPolicy[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * IKEPolicyConnectionCollection.
   */
  export interface IKEPolicyConnectionCollection {
    /** A page of VPN gateway connections that use the IKE policy specified by the identifier in the URL. */
    connections: VPNGatewayConnection[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * IKEPolicyReference.
   */
  export interface IKEPolicyReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this IKE policy. */
    href: string;
    /** The unique identifier for this IKE policy. */
    id: string;
    /** The name for this IKE policy. The name is unique across all IKE policies in the region. */
    name: string;
    /** The resource type. */
    resource_type: IKEPolicyReference.Constants.ResourceType | string;
  }
  export namespace IKEPolicyReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        IKE_POLICY = 'ike_policy',
      }
    }
  }

  /**
   * IP.
   */
  export interface IP {
    /** The IP address.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * IPsecPolicy.
   */
  export interface IPsecPolicy {
    /** The authentication algorithm
     *
     *  The `md5` and `sha1` algorithms have been deprecated
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    authentication_algorithm: IPsecPolicy.Constants.AuthenticationAlgorithm | string;
    /** The VPN gateway connections that use this IPsec policy. */
    connections: VPNGatewayConnectionReference[];
    /** The date and time that this IPsec policy was created. */
    created_at: string;
    /** The encapsulation mode used.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    encapsulation_mode: IPsecPolicy.Constants.EncapsulationMode | string;
    /** The encryption algorithm
     *
     *  The `triple_des` algorithm has been deprecated
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    encryption_algorithm: IPsecPolicy.Constants.EncryptionAlgorithm | string;
    /** The URL for this IPsec policy. */
    href: string;
    /** The unique identifier for this IPsec policy. */
    id: string;
    /** The key lifetime in seconds. */
    key_lifetime: number;
    /** The name for this IPsec policy. The name is unique across all IPsec policies in the region. */
    name: string;
    /** The Perfect Forward Secrecy group
     *
     *  Groups `group_2` and `group_5` have been deprecated
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    pfs: IPsecPolicy.Constants.Pfs | string;
    /** The resource group for this IPsec policy. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: IPsecPolicy.Constants.ResourceType | string;
    /** The transform protocol used.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    transform_protocol: IPsecPolicy.Constants.TransformProtocol | string;
  }
  export namespace IPsecPolicy {
    export namespace Constants {
      /** The authentication algorithm The `md5` and `sha1` algorithms have been deprecated The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AuthenticationAlgorithm {
        DISABLED = 'disabled',
        MD5 = 'md5',
        SHA1 = 'sha1',
        SHA256 = 'sha256',
        SHA384 = 'sha384',
        SHA512 = 'sha512',
      }
      /** The encapsulation mode used. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum EncapsulationMode {
        TUNNEL = 'tunnel',
      }
      /** The encryption algorithm The `triple_des` algorithm has been deprecated The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum EncryptionAlgorithm {
        AES128 = 'aes128',
        AES128GCM16 = 'aes128gcm16',
        AES192 = 'aes192',
        AES192GCM16 = 'aes192gcm16',
        AES256 = 'aes256',
        AES256GCM16 = 'aes256gcm16',
        TRIPLE_DES = 'triple_des',
      }
      /** The Perfect Forward Secrecy group Groups `group_2` and `group_5` have been deprecated The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Pfs {
        DISABLED = 'disabled',
        GROUP_14 = 'group_14',
        GROUP_15 = 'group_15',
        GROUP_16 = 'group_16',
        GROUP_17 = 'group_17',
        GROUP_18 = 'group_18',
        GROUP_19 = 'group_19',
        GROUP_2 = 'group_2',
        GROUP_20 = 'group_20',
        GROUP_21 = 'group_21',
        GROUP_22 = 'group_22',
        GROUP_23 = 'group_23',
        GROUP_24 = 'group_24',
        GROUP_31 = 'group_31',
        GROUP_5 = 'group_5',
      }
      /** The resource type. */
      export enum ResourceType {
        IPSEC_POLICY = 'ipsec_policy',
      }
      /** The transform protocol used. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum TransformProtocol {
        ESP = 'esp',
      }
    }
  }

  /**
   * IPsecPolicyCollection.
   */
  export interface IPsecPolicyCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of IPsec policies. */
    ipsec_policies: IPsecPolicy[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * IPsecPolicyConnectionCollection.
   */
  export interface IPsecPolicyConnectionCollection {
    /** A page of VPN gateway connections that use the IPsec policy specified by the identifier in the URL. */
    connections: VPNGatewayConnection[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * IPsecPolicyReference.
   */
  export interface IPsecPolicyReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this IPsec policy. */
    href: string;
    /** The unique identifier for this IPsec policy. */
    id: string;
    /** The name for this IPsec policy. The name is unique across all IPsec policies in the region. */
    name: string;
    /** The resource type. */
    resource_type: IPsecPolicyReference.Constants.ResourceType | string;
  }
  export namespace IPsecPolicyReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        IPSEC_POLICY = 'ipsec_policy',
      }
    }
  }

  /**
   * Image.
   */
  export interface Image {
    catalog_offering: ImageCatalogOffering;
    /** The date and time that the image was created. */
    created_at: string;
    /** The CRN for this image. */
    crn: string;
    /** The deprecation date and time (UTC) for this image.
     *
     *  If absent, no deprecation date and time has been set.
     */
    deprecation_at?: string;
    /** The type of encryption used on the image. */
    encryption: Image.Constants.Encryption | string;
    /** The key that will be used to encrypt volumes created from this image (unless an
     *  alternate `encryption_key` is specified at volume creation).
     *
     *  This property will be present for images with an `encryption` type of `user_managed`.
     */
    encryption_key?: EncryptionKeyReference;
    /** Details for the stored image file. */
    file: ImageFile;
    /** The URL for this image. */
    href: string;
    /** The unique identifier for this image. */
    id: string;
    /** The minimum size (in gigabytes) of a volume onto which this image may be provisioned.
     *
     *  This property may be absent if the image has a `status` of `pending` or `failed`.
     */
    minimum_provisioned_size?: number;
    /** The name for this image. The name is unique across all images in the region. */
    name: string;
    /** The obsolescence date and time (UTC) for this image.
     *
     *  If absent, no obsolescence date and time has been set.
     */
    obsolescence_at?: string;
    /** The operating system included in this image. */
    operating_system: OperatingSystem;
    /** The owner type of this image: - `user`: Owned by this account - `provider`: Owned by a different account. */
    owner_type: Image.Constants.OwnerType | string;
    /** The resource group for this image. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: Image.Constants.ResourceType | string;
    /** The volume used to create this image (this may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     *  If absent, this image was not created from a volume.
     */
    source_volume?: VolumeReference;
    /** The status of this image:
     *  - available: image can be used (provisionable)
     *  - deleting: image is being deleted, and can no longer be used to provision new
     *    resources
     *  - deprecated: image is administratively slated to become `obsolete`
     *  - failed: image is corrupt or did not pass validation
     *  - obsolete: image administratively set to not be used for new resources
     *  - pending: image is being imported and is not yet `available`
     *  - unusable: image cannot be used (see `status_reasons[]` for possible remediation)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: Image.Constants.Status | string;
    status_reasons: ImageStatusReason[];
    /** The user data format for this image:
     *  - `cloud_init`: `user_data` will be interpreted according to the cloud-init standard
     *  - `esxi_kickstart`: `user_data` will be interpreted as a VMware ESXi installation script
     *  - `ipxe`: `user_data` will be interpreted as a single URL to an iPXE script or as the
     *    text of an iPXE script
     *
     *  The value for this property is inherited from `operating_system.user_data_format`.
     */
    user_data_format: Image.Constants.UserDataFormat | string;
    /** The visibility of this image. - `private`: Visible only to this account - `public`: Visible to all accounts. */
    visibility: Image.Constants.Visibility | string;
  }
  export namespace Image {
    export namespace Constants {
      /** The type of encryption used on the image. */
      export enum Encryption {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
      /** The owner type of this image: - `user`: Owned by this account - `provider`: Owned by a different account. */
      export enum OwnerType {
        PROVIDER = 'provider',
        USER = 'user',
      }
      /** The resource type. */
      export enum ResourceType {
        IMAGE = 'image',
      }
      /** The status of this image: - available: image can be used (provisionable) - deleting: image is being deleted, and can no longer be used to provision new resources - deprecated: image is administratively slated to become `obsolete` - failed: image is corrupt or did not pass validation - obsolete: image administratively set to not be used for new resources - pending: image is being imported and is not yet `available` - unusable: image cannot be used (see `status_reasons[]` for possible remediation) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        AVAILABLE = 'available',
        DELETING = 'deleting',
        DEPRECATED = 'deprecated',
        FAILED = 'failed',
        OBSOLETE = 'obsolete',
        PENDING = 'pending',
        UNUSABLE = 'unusable',
      }
      /** The user data format for this image: - `cloud_init`: `user_data` will be interpreted according to the cloud-init standard - `esxi_kickstart`: `user_data` will be interpreted as a VMware ESXi installation script - `ipxe`: `user_data` will be interpreted as a single URL to an iPXE script or as the text of an iPXE script The value for this property is inherited from `operating_system.user_data_format`. */
      export enum UserDataFormat {
        CLOUD_INIT = 'cloud_init',
        ESXI_KICKSTART = 'esxi_kickstart',
        IPXE = 'ipxe',
      }
      /** The visibility of this image. - `private`: Visible only to this account - `public`: Visible to all accounts. */
      export enum Visibility {
        PRIVATE = 'private',
        PUBLIC = 'public',
      }
    }
  }

  /**
   * ImageCatalogOffering.
   */
  export interface ImageCatalogOffering {
    /** Indicates whether this image is managed as part of a
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering. If an image is managed,
     *  accounts with access to that catalog can specify the image's catalog offering version CRN to provision virtual
     *  server instances using the image.
     */
    managed: boolean;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering version associated with this image.
     *
     *  If absent, this image is not associated with a cloud catalog offering.
     */
    version?: CatalogOfferingVersionReference;
  }

  /**
   * ImageCollection.
   */
  export interface ImageCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of images. */
    images: Image[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ImageExportJob.
   */
  export interface ImageExportJob {
    /** The date and time that the image export job was completed.
     *
     *  If absent, the export job has not yet completed.
     */
    completed_at?: string;
    /** The date and time that the image export job was created. */
    created_at: string;
    /** A base64-encoded, encrypted representation of the key that was used to encrypt the data for the exported
     *  image. This key can be unwrapped with the image's `encryption_key` root key using either Key Protect or Hyper
     *  Protect Crypto Services.
     *
     *  If absent, the export job is for an unencrypted image.
     */
    encrypted_data_key?: string;
    /** The format of the exported image. */
    format: ImageExportJob.Constants.Format | string;
    /** The URL for this image export job. */
    href: string;
    /** The unique identifier for this image export job. */
    id: string;
    /** The name for this image export job. The name must not be used by another export job for the image. Changing
     *  the name will not affect the exported image name,
     *  `storage_object.name`, or `storage_href` values.
     */
    name: string;
    /** The resource type. */
    resource_type: ImageExportJob.Constants.ResourceType | string;
    /** The date and time that the image export job started running.
     *
     *  If absent, the export job has not yet started.
     */
    started_at?: string;
    /** The status of this image export job:
     *  - `deleting`: Export job is being deleted
     *  - `failed`: Export job could not be completed successfully
     *  - `queued`: Export job is queued
     *  - `running`: Export job is in progress
     *  - `succeeded`: Export job was completed successfully
     *
     *  The exported image object is automatically deleted for `failed` jobs.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: ImageExportJob.Constants.Status | string;
    /** The reasons for the current status (if any). */
    status_reasons: ImageExportJobStatusReason[];
    /** The Cloud Object Storage bucket of the exported image object. */
    storage_bucket: CloudObjectStorageBucketReference;
    /** The Cloud Object Storage location of the exported image object. The object at this location will not exist
     *  until the job completes successfully. The exported image object is not managed by the IBM VPC service, and may
     *  be removed or replaced with a different object by any user or service with IAM authorization to the storage
     *  bucket.
     */
    storage_href: string;
    /** The Cloud Object Storage object for the exported image. This object will not exist until
     *  the job completes successfully. The exported image object is not managed by the IBM VPC
     *  service, and may be removed or replaced with a different object by any user or service
     *  with IAM authorization to the storage bucket.
     */
    storage_object: CloudObjectStorageObjectReference;
  }
  export namespace ImageExportJob {
    export namespace Constants {
      /** The format of the exported image. */
      export enum Format {
        QCOW2 = 'qcow2',
        VHD = 'vhd',
      }
      /** The resource type. */
      export enum ResourceType {
        IMAGE_EXPORT_JOB = 'image_export_job',
      }
      /** The status of this image export job: - `deleting`: Export job is being deleted - `failed`: Export job could not be completed successfully - `queued`: Export job is queued - `running`: Export job is in progress - `succeeded`: Export job was completed successfully The exported image object is automatically deleted for `failed` jobs. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        DELETING = 'deleting',
        FAILED = 'failed',
        QUEUED = 'queued',
        RUNNING = 'running',
        SUCCEEDED = 'succeeded',
      }
    }
  }

  /**
   * ImageExportJobStatusReason.
   */
  export interface ImageExportJobStatusReason {
    /** A snake case string succinctly identifying the status reason.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ImageExportJobStatusReason.Constants.Code | string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace ImageExportJobStatusReason {
    export namespace Constants {
      /** A snake case string succinctly identifying the status reason. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        CANNOT_ACCESS_STORAGE_BUCKET = 'cannot_access_storage_bucket',
        INTERNAL_ERROR = 'internal_error',
      }
    }
  }

  /**
   * ImageExportJobUnpaginatedCollection.
   */
  export interface ImageExportJobUnpaginatedCollection {
    /** The export jobs for the image. */
    export_jobs: ImageExportJob[];
  }

  /**
   * ImageFile.
   */
  export interface ImageFile {
    /** Checksums for this image file.
     *
     *  This property may be absent if the associated image has a `status` of `pending` or
     *  `failed`.
     */
    checksums?: ImageFileChecksums;
    /** The size of the stored image file rounded up to the next gigabyte.
     *
     *  This property may be absent if the associated image has a `status` of `pending` or
     *  `failed`.
     */
    size?: number;
  }

  /**
   * ImageFileChecksums.
   */
  export interface ImageFileChecksums {
    /** The SHA256 fingerprint of the image file, in hexadecimal. */
    sha256?: string;
  }

  /**
   * ImageFilePrototype.
   */
  export interface ImageFilePrototype {
    /** The Cloud Object Storage location of the image file.
     *
     *  The image file format is specified by the file's extension, which must be either
     *  `qcow2` or `vhd`.
     */
    href: string;
  }

  /**
   * Identifies an image by a unique property.
   */
  export interface ImageIdentity {
  }

  /**
   * ImagePrototype.
   */
  export interface ImagePrototype {
    /** The deprecation date and time to set for this image.
     *
     *  The date and time must not be in the past, and must be earlier than `obsolescence_at`
     *  (if `obsolescence_at` is set).
     *
     *  If unspecified, no deprecation date and time will be set.
     *
     *  If the deprecation date and time is reached while the image has a status of `pending`, the image's status will
     *  transition to `deprecated` upon its successful creation (or
     *  `obsolete` if the obsolescence date and time was also reached).
     */
    deprecation_at?: string;
    /** The name for this image. The name must not be used by another image in the region. Names starting with
     *  `ibm-` are reserved for system-provided images, and are not allowed. If unspecified, the name will be a
     *  hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The obsolescence date and time to set for this image.
     *
     *  The date and time must not be in the past, and must be later than `deprecation_at` (if
     *  `deprecation_at` is set).
     *
     *  If unspecified, no obsolescence date and time will be set.
     *
     *  If the obsolescence date and time is reached while the image has a status of
     *  `pending`, the image's status will transition to `obsolete` upon its successful creation.
     */
    obsolescence_at?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
  }

  /**
   * ImageReference.
   */
  export interface ImageReference {
    /** The CRN for this image. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this image. */
    href: string;
    /** The unique identifier for this image. */
    id: string;
    /** The name for this image. The name is unique across all images in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: ImageRemoteContextImageReference;
    /** The resource type. */
    resource_type: ImageReference.Constants.ResourceType | string;
  }
  export namespace ImageReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        IMAGE = 'image',
      }
    }
  }

  /**
   * If present, this property indicates that the resource associated with this reference is remote and therefore may
   * not be directly retrievable.
   */
  export interface ImageRemoteContextImageReference {
    /** If present, this property indicates that the referenced resource is remote to this
     *  account, and identifies the owning account.
     */
    account?: AccountReference;
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /**
   * ImageStatusReason.
   */
  export interface ImageStatusReason {
    /** A reason code for the status:
     *  - `encrypted_data_key_invalid`: image cannot be decrypted with the specified
     *    `encryption_key`
     *  - `encryption_key_deleted`: image unusable because its `encryption_key` was deleted
     *  - `encryption_key_disabled`: image unusable until its `encryption_key` is re-enabled
     *  - `image_data_corrupted`: image data is corrupt, or is not in the specified format
     *  - `image_provisioned_size_unsupported`: image requires a boot volume size greater
     *    than the maximum supported value
     *  - `image_request_in_progress`: image operation is in progress (such as an import from
     *     Cloud Object Storage)
     *  - `image_request_queued`: image request has been accepted but the requested
     *    operation has not started
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ImageStatusReason.Constants.Code | string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace ImageStatusReason {
    export namespace Constants {
      /** A reason code for the status: - `encrypted_data_key_invalid`: image cannot be decrypted with the specified `encryption_key` - `encryption_key_deleted`: image unusable because its `encryption_key` was deleted - `encryption_key_disabled`: image unusable until its `encryption_key` is re-enabled - `image_data_corrupted`: image data is corrupt, or is not in the specified format - `image_provisioned_size_unsupported`: image requires a boot volume size greater than the maximum supported value - `image_request_in_progress`: image operation is in progress (such as an import from Cloud Object Storage) - `image_request_queued`: image request has been accepted but the requested operation has not started The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        ENCRYPTED_DATA_KEY_INVALID = 'encrypted_data_key_invalid',
        ENCRYPTION_KEY_DELETED = 'encryption_key_deleted',
        ENCRYPTION_KEY_DISABLED = 'encryption_key_disabled',
        IMAGE_DATA_CORRUPTED = 'image_data_corrupted',
        IMAGE_PROVISIONED_SIZE_UNSUPPORTED = 'image_provisioned_size_unsupported',
        IMAGE_REQUEST_IN_PROGRESS = 'image_request_in_progress',
        IMAGE_REQUEST_QUEUED = 'image_request_queued',
      }
    }
  }

  /**
   * Instance.
   */
  export interface Instance {
    /** The availability policy for this virtual server instance. */
    availability_policy: InstanceAvailabilityPolicy;
    /** The total bandwidth (in megabits per second) shared across the instance network attachments or instance
     *  network interfaces and storage volumes of the virtual server instance.
     */
    bandwidth: number;
    /** Boot volume attachment. */
    boot_volume_attachment: VolumeAttachmentReferenceInstanceContext;
    /** If present, this virtual server instance was provisioned from a
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user).
     */
    catalog_offering?: InstanceCatalogOffering;
    /** If present, the cluster network that this virtual server instance resides in. */
    cluster_network?: ClusterNetworkReference;
    /** The cluster network attachments for this virtual server instance.
     *
     *  The cluster network attachments are ordered for consistent instance configuration.
     */
    cluster_network_attachments: InstanceClusterNetworkAttachmentReference[];
    /** The confidential compute mode for this virtual server instance. */
    confidential_compute_mode: Instance.Constants.ConfidentialComputeMode | string;
    /** The date and time that the virtual server instance was created. */
    created_at: string;
    /** The CRN for this virtual server instance. */
    crn: string;
    /** If present, the dedicated host this virtual server instance has been placed on. */
    dedicated_host?: DedicatedHostReference;
    /** The instance disks for this virtual server instance. */
    disks: InstanceDisk[];
    /** Indicates whether secure boot is enabled for this virtual server instance. */
    enable_secure_boot: boolean;
    /** The virtual server instance GPU configuration. */
    gpu?: InstanceGPU;
    /** The reasons for the current `health_state` (if any). */
    health_reasons: InstanceHealthReason[];
    /** The health of this resource:
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle
     *     state. A resource with a lifecycle state of `failed` or `deleting` will have a
     *     health state of `inapplicable`. A `pending` resource may also have this state.
     */
    health_state: Instance.Constants.HealthState | string;
    /** The URL for this virtual server instance. */
    href: string;
    /** The unique identifier for this virtual server instance. */
    id: string;
    /** The image the virtual server instance was provisioned from. */
    image?: ImageReference;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: InstanceLifecycleReason[];
    /** The lifecycle state of the virtual server instance. */
    lifecycle_state: Instance.Constants.LifecycleState | string;
    /** The amount of memory, truncated to whole gibibytes.
     *
     *  The maximum limit for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    memory: number;
    /** The metadata service configuration. */
    metadata_service: InstanceMetadataService;
    /** The name for this virtual server instance. The name is unique across all virtual server instances in the
     *  region.
     */
    name: string;
    /** The network attachments for this virtual server instance, including the primary network attachment. */
    network_attachments: InstanceNetworkAttachmentReference[];
    /** The network interfaces for this instance, including the primary network interface.
     *
     *  If this instance has network attachments, each network interface is a [read-only
     *  representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding
     *  network attachment and its attached virtual network interface.
     */
    network_interfaces: NetworkInterfaceInstanceContextReference[];
    /** The number of NUMA nodes this virtual server instance is provisioned on.
     *
     *  This property will be absent if the instance's `status` is not `running`.
     */
    numa_count?: number;
    /** The placement restrictions for the virtual server instance. */
    placement_target?: InstancePlacementTarget;
    /** The primary network attachment for this virtual server instance. */
    primary_network_attachment?: InstanceNetworkAttachmentReference;
    /** The primary network interface for this virtual server instance.
     *
     *  If this instance has network attachments, this primary network interface is a
     *  [read-only
     *  representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients)
     *  of the primary network attachment and its attached virtual network interface.
     */
    primary_network_interface: NetworkInterfaceInstanceContextReference;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) for this virtual server instance. */
    profile: InstanceProfileReference;
    /** The reservation used by this virtual server instance.
     *
     *  If absent, no reservation is in use.
     */
    reservation?: ReservationReference;
    reservation_affinity: InstanceReservationAffinity;
    /** The resource group for this instance. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: Instance.Constants.ResourceType | string;
    /** Indicates whether the state of the virtual server instance permits a start request. */
    startable: boolean;
    /** The status of the virtual server instance.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: Instance.Constants.Status | string;
    /** The reasons for the current status (if any). */
    status_reasons: InstanceStatusReason[];
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance network attachments or
     *  instance network interfaces.
     */
    total_network_bandwidth: number;
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An
     *  increase in this value will result in a corresponding decrease to
     *  `total_network_bandwidth`.
     */
    total_volume_bandwidth: number;
    /** The virtual server instance VCPU configuration. */
    vcpu: InstanceVCPU;
    /** The volume attachments for this virtual server instance, including the boot volume attachment. */
    volume_attachments: VolumeAttachmentReferenceInstanceContext[];
    /** The VPC this virtual server instance resides in. */
    vpc: VPCReference;
    /** The zone this virtual server instance resides in. */
    zone: ZoneReference;
  }
  export namespace Instance {
    export namespace Constants {
      /** The confidential compute mode for this virtual server instance. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the virtual server instance. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        INSTANCE = 'instance',
      }
      /** The status of the virtual server instance. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        RESTARTING = 'restarting',
        RUNNING = 'running',
        STARTING = 'starting',
        STOPPED = 'stopped',
        STOPPING = 'stopping',
      }
    }
  }

  /**
   * InstanceAction.
   */
  export interface InstanceAction {
    /** Deprecated: The date and time that the action was completed. */
    completed_at?: string;
    /** The date and time that the action was created. */
    created_at: string;
    /** If set to true, the action will be forced immediately, and all queued actions deleted. Ignored for the start
     *  action.
     */
    force?: boolean;
    /** Deprecated: The URL for this instance action. */
    href: string;
    /** Deprecated: The identifier for this instance action. */
    id: string;
    /** Deprecated: The date and time that the action was started. */
    started_at?: string;
    /** Deprecated: The current status of this action. */
    status: InstanceAction.Constants.Status | string;
    /** The type of action. */
    type: InstanceAction.Constants.Type | string;
  }
  export namespace InstanceAction {
    export namespace Constants {
      /** The current status of this action. */
      export enum Status {
        COMPLETED = 'completed',
        FAILED = 'failed',
        PENDING = 'pending',
        RUNNING = 'running',
      }
      /** The type of action. */
      export enum Type {
        REBOOT = 'reboot',
        START = 'start',
        STOP = 'stop',
      }
    }
  }

  /**
   * InstanceAvailabilityPolicy.
   */
  export interface InstanceAvailabilityPolicy {
    /** The action to perform if the compute host experiences a failure:
     *  - `restart`: Automatically restart the virtual server instance after host failure
     *  - `stop`: Leave the virtual server instance stopped after host failure
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    host_failure: InstanceAvailabilityPolicy.Constants.HostFailure | string;
  }
  export namespace InstanceAvailabilityPolicy {
    export namespace Constants {
      /** The action to perform if the compute host experiences a failure: - `restart`: Automatically restart the virtual server instance after host failure - `stop`: Leave the virtual server instance stopped after host failure The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum HostFailure {
        RESTART = 'restart',
        STOP = 'stop',
      }
    }
  }

  /**
   * InstanceAvailabilityPolicyPatch.
   */
  export interface InstanceAvailabilityPolicyPatch {
    /** The action to perform if the compute host experiences a failure.
     *  - `restart`: Automatically restart the virtual server instance after host failure
     *  - `stop`: Leave the virtual server instance stopped after host failure.
     */
    host_failure?: InstanceAvailabilityPolicyPatch.Constants.HostFailure | string;
  }
  export namespace InstanceAvailabilityPolicyPatch {
    export namespace Constants {
      /** The action to perform if the compute host experiences a failure. - `restart`: Automatically restart the virtual server instance after host failure - `stop`: Leave the virtual server instance stopped after host failure. */
      export enum HostFailure {
        RESTART = 'restart',
        STOP = 'stop',
      }
    }
  }

  /**
   * InstanceAvailabilityPolicyPrototype.
   */
  export interface InstanceAvailabilityPolicyPrototype {
    /** The action to perform if the compute host experiences a failure.
     *  - `restart`: Automatically restart the virtual server instance after host failure
     *  - `stop`: Leave the virtual server instance stopped after host failure.
     */
    host_failure?: InstanceAvailabilityPolicyPrototype.Constants.HostFailure | string;
  }
  export namespace InstanceAvailabilityPolicyPrototype {
    export namespace Constants {
      /** The action to perform if the compute host experiences a failure. - `restart`: Automatically restart the virtual server instance after host failure - `stop`: Leave the virtual server instance stopped after host failure. */
      export enum HostFailure {
        RESTART = 'restart',
        STOP = 'stop',
      }
    }
  }

  /**
   * InstanceCatalogOffering.
   */
  export interface InstanceCatalogOffering {
    /** The billing plan used for the catalog offering version.
     *
     *  If absent, no billing plan is in use (free).
     */
    plan?: CatalogOfferingVersionPlanReference;
    /** The catalog offering version this virtual server instance was provisioned from.
     *
     *  The catalog offering version is not managed by the IBM VPC service, and may no longer
     *  exist, or may refer to a different image CRN than the `image.crn` for this virtual
     *  server instance. However, all images associated with a catalog offering version will
     *  have the same checksum, and therefore will have the same data.
     */
    version: CatalogOfferingVersionReference;
  }

  /**
   * The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering or offering version to
   * use when provisioning this virtual server instance.
   *
   * If an offering is specified, the latest version of that offering will be used.
   *
   * The specified offering or offering version may be in a different account, subject to IAM policies.
   */
  export interface InstanceCatalogOfferingPrototype {
    /** The billing plan to use for the catalog offering version. If unspecified, no billing
     *  plan will be used (free). Must be specified for catalog offering versions that require
     *  a billing plan to be used.
     */
    plan?: CatalogOfferingVersionPlanIdentity;
  }

  /**
   * InstanceClusterNetworkAttachment.
   */
  export interface InstanceClusterNetworkAttachment {
    /** The instance cluster network attachment that is immediately before. If absent, this is the
     *  last instance cluster network attachment.
     */
    before?: InstanceClusterNetworkAttachmentBefore;
    /** The cluster network interface for this instance cluster network attachment. */
    cluster_network_interface: ClusterNetworkInterfaceReference;
    /** The URL for this instance cluster network attachment. */
    href: string;
    /** The unique identifier for this instance cluster network attachment. */
    id: string;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: InstanceClusterNetworkAttachmentLifecycleReason[];
    /** The lifecycle state of the instance cluster network attachment. */
    lifecycle_state: InstanceClusterNetworkAttachment.Constants.LifecycleState | string;
    /** The name for this instance cluster network attachment. The name is unique across all network attachments for
     *  the instance.
     */
    name: string;
    /** The resource type. */
    resource_type: InstanceClusterNetworkAttachment.Constants.ResourceType | string;
  }
  export namespace InstanceClusterNetworkAttachment {
    export namespace Constants {
      /** The lifecycle state of the instance cluster network attachment. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_CLUSTER_NETWORK_ATTACHMENT = 'instance_cluster_network_attachment',
      }
    }
  }

  /**
   * The instance cluster network attachment that is immediately before. If absent, this is the last instance cluster
   * network attachment.
   */
  export interface InstanceClusterNetworkAttachmentBefore {
    /** The URL for this instance cluster network attachment. */
    href: string;
    /** The unique identifier for this instance cluster network attachment. */
    id: string;
    /** The name for this instance cluster network attachment. The name is unique across all network attachments for
     *  the instance.
     */
    name: string;
    /** The resource type. */
    resource_type: InstanceClusterNetworkAttachmentBefore.Constants.ResourceType | string;
  }
  export namespace InstanceClusterNetworkAttachmentBefore {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_CLUSTER_NETWORK_ATTACHMENT = 'instance_cluster_network_attachment',
      }
    }
  }

  /**
   * The instance cluster network attachment to insert this instance cluster network attachment immediately before.
   *
   * If unspecified, this instance cluster network attachment will be inserted after all existing instance cluster
   * network attachments.
   */
  export interface InstanceClusterNetworkAttachmentBeforePrototype {
  }

  /**
   * InstanceClusterNetworkAttachmentCollection.
   */
  export interface InstanceClusterNetworkAttachmentCollection {
    /** A page of ordered cluster network attachments (sorted based on the `before` property) for the instance. A
     *  cluster network attachment represents a device to which a cluster network interface is attached.
     */
    cluster_network_attachments: InstanceClusterNetworkAttachment[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * InstanceClusterNetworkAttachmentLifecycleReason.
   */
  export interface InstanceClusterNetworkAttachmentLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: InstanceClusterNetworkAttachmentLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace InstanceClusterNetworkAttachmentLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * A cluster network interface for the instance cluster network attachment. This can be specified using an existing
   * cluster network interface that does not already have a `target`, or a prototype object for a new cluster network
   * interface.
   *
   * This instance must reside in the same VPC as the specified cluster network interface. The cluster network interface
   * must reside in the same cluster network as the
   * `cluster_network_interface` of any other `cluster_network_attachments` for this instance.
   */
  export interface InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterface {
  }

  /**
   * InstanceClusterNetworkAttachmentPrototypeInstanceContext.
   */
  export interface InstanceClusterNetworkAttachmentPrototypeInstanceContext {
    /** A cluster network interface for the instance cluster network attachment. This can be
     *  specified using an existing cluster network interface that does not already have a `target`,
     *  or a prototype object for a new cluster network interface.
     *
     *  This instance must reside in the same VPC as the specified cluster network interface. The
     *  cluster network interface must reside in the same cluster network as the
     *  `cluster_network_interface` of any other `cluster_network_attachments` for this instance.
     */
    cluster_network_interface: InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterface;
    /** The name for this cluster network attachment. Names must be unique within the instance the cluster network
     *  attachment resides in. If unspecified, the name will be a hyphenated list of randomly-selected words. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
  }

  /**
   * InstanceClusterNetworkAttachmentReference.
   */
  export interface InstanceClusterNetworkAttachmentReference {
    /** The URL for this instance cluster network attachment. */
    href: string;
    /** The unique identifier for this instance cluster network attachment. */
    id: string;
    /** The name for this instance cluster network attachment. The name is unique across all network attachments for
     *  the instance.
     */
    name: string;
    /** The resource type. */
    resource_type: InstanceClusterNetworkAttachmentReference.Constants.ResourceType | string;
  }
  export namespace InstanceClusterNetworkAttachmentReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_CLUSTER_NETWORK_ATTACHMENT = 'instance_cluster_network_attachment',
      }
    }
  }

  /**
   * InstanceCollection.
   */
  export interface InstanceCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of virtual server instances. */
    instances: Instance[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * The instance console access token information.
   */
  export interface InstanceConsoleAccessToken {
    /** A URL safe single-use token used to access the console WebSocket. */
    access_token: string;
    /** The instance console type for which this token may be used. */
    console_type: InstanceConsoleAccessToken.Constants.ConsoleType | string;
    /** The date and time that the access token was created. */
    created_at: string;
    /** The date and time that the access token will expire. */
    expires_at: string;
    /** Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.
     *  This has no effect on VNC consoles.
     */
    force: boolean;
    /** The URL to access this instance console. */
    href: string;
  }
  export namespace InstanceConsoleAccessToken {
    export namespace Constants {
      /** The instance console type for which this token may be used. */
      export enum ConsoleType {
        SERIAL = 'serial',
        VNC = 'vnc',
      }
    }
  }

  /**
   * InstanceDefaultTrustedProfilePrototype.
   */
  export interface InstanceDefaultTrustedProfilePrototype {
    /** If set to `true`, the system will create a link to the specified `target` trusted profile during instance
     *  creation. Regardless of whether a link is created by the system or manually using the IAM Identity service, it
     *  will be automatically deleted when the instance is deleted.
     */
    auto_link?: boolean;
    /** The default IAM trusted profile to use for this virtual server instance. */
    target: TrustedProfileIdentity;
  }

  /**
   * InstanceDisk.
   */
  export interface InstanceDisk {
    /** The date and time that the disk was created. */
    created_at: string;
    /** The URL for this instance disk. */
    href: string;
    /** The unique identifier for this instance disk. */
    id: string;
    /** The disk interface used for attaching the disk.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    interface_type: InstanceDisk.Constants.InterfaceType | string;
    /** The name for this instance disk. The name is unique across all disks on the instance. */
    name: string;
    /** The resource type. */
    resource_type: InstanceDisk.Constants.ResourceType | string;
    /** The size of the disk in GB (gigabytes). */
    size: number;
  }
  export namespace InstanceDisk {
    export namespace Constants {
      /** The disk interface used for attaching the disk. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum InterfaceType {
        NVME = 'nvme',
        VIRTIO_BLK = 'virtio_blk',
      }
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_DISK = 'instance_disk',
      }
    }
  }

  /**
   * InstanceDiskCollection.
   */
  export interface InstanceDiskCollection {
    /** The disks for the instance. */
    disks: InstanceDisk[];
  }

  /**
   * InstanceDiskReference.
   */
  export interface InstanceDiskReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance disk. */
    href: string;
    /** The unique identifier for this instance disk. */
    id: string;
    /** The name for this instance disk. The name is unique across all disks on the instance. */
    name: string;
    /** The resource type. */
    resource_type: InstanceDiskReference.Constants.ResourceType | string;
  }
  export namespace InstanceDiskReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_DISK = 'instance_disk',
      }
    }
  }

  /**
   * The virtual server instance GPU configuration.
   */
  export interface InstanceGPU {
    /** The number of GPUs assigned to the instance. */
    count: number;
    /** The GPU manufacturer.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    manufacturer: InstanceGPU.Constants.Manufacturer | string;
    /** The overall amount of GPU memory in GiB (gibibytes). */
    memory: number;
    /** The GPU model. */
    model: string;
  }
  export namespace InstanceGPU {
    export namespace Constants {
      /** The GPU manufacturer. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Manufacturer {
        INTEL = 'intel',
        NVIDIA = 'nvidia',
      }
    }
  }

  /**
   * InstanceGroup.
   */
  export interface InstanceGroup {
    /** The port used for new load balancer pool members created by this instance group.
     *
     *  This property will be present if and only if `load_balancer_pool` is present.
     */
    application_port?: number;
    /** The date and time that the instance group was created. */
    created_at: string;
    /** The CRN for this instance group. */
    crn: string;
    /** The URL for this instance group. */
    href: string;
    /** The unique identifier for this instance group. */
    id: string;
    /** The template used to create new instances for this group. */
    instance_template: InstanceTemplateReference;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: InstanceGroupLifecycleReason[];
    /** The lifecycle state of the instance group. */
    lifecycle_state: InstanceGroup.Constants.LifecycleState | string;
    /** If present, the load balancer pool this instance group manages. A pool member will
     *  be created for each instance created by this group.
     */
    load_balancer_pool?: LoadBalancerPoolReference;
    /** The managers for the instance group. */
    managers: InstanceGroupManagerReference[];
    /** The number of instances in the instance group. */
    membership_count: number;
    /** The name for this instance group. The name is unique across all instance groups in the region. */
    name: string;
    resource_group: ResourceGroupReference;
    /** The status of the instance group
     *  - `deleting`: Group is being deleted
     *  - `healthy`: Group has `membership_count` instances
     *  - `scaling`: Instances in the group are being created or deleted to reach
     *               `membership_count`
     *  - `unhealthy`: Group is unable to reach `membership_count` instances
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: InstanceGroup.Constants.Status | string;
    /** The subnets to use when creating new instances. */
    subnets: SubnetReference[];
    /** The date and time that the instance group was updated. */
    updated_at: string;
    /** The VPC the instance group resides in. */
    vpc: VPCReference;
  }
  export namespace InstanceGroup {
    export namespace Constants {
      /** The lifecycle state of the instance group. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The status of the instance group - `deleting`: Group is being deleted - `healthy`: Group has `membership_count` instances - `scaling`: Instances in the group are being created or deleted to reach `membership_count` - `unhealthy`: Group is unable to reach `membership_count` instances The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        DELETING = 'deleting',
        HEALTHY = 'healthy',
        SCALING = 'scaling',
        UNHEALTHY = 'unhealthy',
      }
    }
  }

  /**
   * InstanceGroupCollection.
   */
  export interface InstanceGroupCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of instance groups. */
    instance_groups: InstanceGroup[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * InstanceGroupLifecycleReason.
   */
  export interface InstanceGroupLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: InstanceGroupLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace InstanceGroupLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * InstanceGroupManager.
   */
  export interface InstanceGroupManager {
    /** The date and time that the instance group manager was created. */
    created_at: string;
    /** The URL for this instance group manager. */
    href: string;
    /** The unique identifier for this instance group manager. */
    id: string;
    /** Indicates whether this manager will control the instance group. */
    management_enabled: boolean;
    /** The name for this instance group manager. The name is unique across all managers for the instance group. */
    name: string;
    /** The date and time that the instance group manager was updated. */
    updated_at: string;
  }

  /**
   * InstanceGroupManagerAction.
   */
  export interface InstanceGroupManagerAction {
    /** Indicates whether this scheduled action will be automatically deleted after it has completed and
     *  `auto_delete_timeout` hours have passed.
     */
    auto_delete: boolean;
    /** If `auto_delete` is `true`, and this scheduled action has finished, the hours after which it will be
     *  automatically deleted. If the value is `0`, the action will be deleted once it has finished.
     */
    auto_delete_timeout: number;
    /** The date and time that the instance group manager action was created. */
    created_at: string;
    /** The URL for this instance group manager action. */
    href: string;
    /** The unique identifier for this instance group manager action. */
    id: string;
    /** The name for this instance group manager action. The name is unique across all actions for the instance
     *  group manager.
     */
    name: string;
    /** The resource type. */
    resource_type: InstanceGroupManagerAction.Constants.ResourceType | string;
    /** The status of the instance group action
     *  - `active`: Action is ready to be run
     *  - `completed`: Action was completed successfully
     *  - `failed`: Action could not be completed successfully
     *  - `incompatible`: Action parameters are not compatible with the group or manager
     *  - `omitted`: Action was not applied because this action's manager was disabled
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: InstanceGroupManagerAction.Constants.Status | string;
    /** The date and time that the instance group manager action was updated. */
    updated_at: string;
  }
  export namespace InstanceGroupManagerAction {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_GROUP_MANAGER_ACTION = 'instance_group_manager_action',
      }
      /** The status of the instance group action - `active`: Action is ready to be run - `completed`: Action was completed successfully - `failed`: Action could not be completed successfully - `incompatible`: Action parameters are not compatible with the group or manager - `omitted`: Action was not applied because this action's manager was disabled The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        ACTIVE = 'active',
        COMPLETED = 'completed',
        FAILED = 'failed',
        INCOMPATIBLE = 'incompatible',
        OMITTED = 'omitted',
      }
    }
  }

  /**
   * InstanceGroupManagerActionGroupPatch.
   */
  export interface InstanceGroupManagerActionGroupPatch {
    /** The desired number of instance group members at the scheduled time. */
    membership_count?: number;
  }

  /**
   * InstanceGroupManagerActionManagerPatch.
   */
  export interface InstanceGroupManagerActionManagerPatch {
    /** The desired maximum number of instance group members at the scheduled time. */
    max_membership_count?: number;
    /** The desired minimum number of instance group members at the scheduled time. */
    min_membership_count?: number;
  }

  /**
   * InstanceGroupManagerActionPrototype.
   */
  export interface InstanceGroupManagerActionPrototype {
    /** The name for this instance group manager action. The name must not be used by another action for the
     *  instance group manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /**
   * InstanceGroupManagerActionReference.
   */
  export interface InstanceGroupManagerActionReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance group manager action. */
    href: string;
    /** The unique identifier for this instance group manager action. */
    id: string;
    /** The name for this instance group manager action. The name is unique across all actions for the instance
     *  group manager.
     */
    name: string;
    /** The resource type. */
    resource_type: InstanceGroupManagerActionReference.Constants.ResourceType | string;
  }
  export namespace InstanceGroupManagerActionReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_GROUP_MANAGER_ACTION = 'instance_group_manager_action',
      }
    }
  }

  /**
   * InstanceGroupManagerActionsCollection.
   */
  export interface InstanceGroupManagerActionsCollection {
    /** A page of actions for the instance group manager. */
    actions: InstanceGroupManagerAction[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * InstanceGroupManagerCollection.
   */
  export interface InstanceGroupManagerCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A page of managers for the instance group. */
    managers: InstanceGroupManager[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * InstanceGroupManagerPolicy.
   */
  export interface InstanceGroupManagerPolicy {
    /** The date and time that the instance group manager policy was created. */
    created_at: string;
    /** The URL for this instance group manager policy. */
    href: string;
    /** The unique identifier for this instance group manager policy. */
    id: string;
    /** The name for this instance group manager policy. The name is unique across all policies for the instance
     *  group manager.
     */
    name: string;
    /** The date and time that the instance group manager policy was updated. */
    updated_at: string;
  }

  /**
   * InstanceGroupManagerPolicyCollection.
   */
  export interface InstanceGroupManagerPolicyCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of policies for the instance group manager. */
    policies: InstanceGroupManagerPolicy[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * InstanceGroupManagerPolicyPrototype.
   */
  export interface InstanceGroupManagerPolicyPrototype {
    /** The name for this instance group manager policy. The name must not be used by another policy for the
     *  instance group manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /**
   * InstanceGroupManagerPolicyReference.
   */
  export interface InstanceGroupManagerPolicyReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance group manager policy. */
    href: string;
    /** The unique identifier for this instance group manager policy. */
    id: string;
    /** The name for this instance group manager policy. The name is unique across all policies for the instance
     *  group manager.
     */
    name: string;
  }

  /**
   * InstanceGroupManagerPrototype.
   */
  export interface InstanceGroupManagerPrototype {
    /** Indicates whether this manager will control the instance group. */
    management_enabled?: boolean;
    /** The name for this instance group manager. The name must not be used by another manager for the instance
     *  group. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /**
   * InstanceGroupManagerReference.
   */
  export interface InstanceGroupManagerReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance group manager. */
    href: string;
    /** The unique identifier for this instance group manager. */
    id: string;
    /** The name for this instance group manager. The name is unique across all managers for the instance group. */
    name: string;
  }

  /**
   * InstanceGroupManagerScheduledActionGroup.
   */
  export interface InstanceGroupManagerScheduledActionGroup {
    /** The desired number of instance group members at the scheduled time. */
    membership_count: number;
  }

  /**
   * InstanceGroupManagerScheduledActionGroupPrototype.
   */
  export interface InstanceGroupManagerScheduledActionGroupPrototype {
    /** The desired number of instance group members at the scheduled time. */
    membership_count: number;
  }

  /**
   * InstanceGroupManagerScheduledActionManager.
   */
  export interface InstanceGroupManagerScheduledActionManager {
  }

  /**
   * InstanceGroupManagerScheduledActionManagerPrototype.
   */
  export interface InstanceGroupManagerScheduledActionManagerPrototype {
  }

  /**
   * InstanceGroupMembership.
   */
  export interface InstanceGroupMembership {
    /** The date and time that the instance group manager policy was created. */
    created_at: string;
    /** If set to true, when deleting the membership the instance will also be deleted. */
    delete_instance_on_membership_delete: boolean;
    /** The URL for this instance group membership. */
    href: string;
    /** The unique identifier for this instance group membership. */
    id: string;
    instance: InstanceReference;
    instance_template: InstanceTemplateReference;
    /** The name for this instance group membership. The name is unique across all memberships for the instance
     *  group.
     */
    name: string;
    pool_member?: LoadBalancerPoolMemberReference;
    /** The status of the instance group membership
     *  - `deleting`: Membership is deleting dependent resources
     *  - `failed`: Membership was unable to maintain dependent resources
     *  - `healthy`: Membership is active and serving in the group
     *  - `pending`: Membership is waiting for dependent resources
     *  - `unhealthy`: Membership has unhealthy dependent resources
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: InstanceGroupMembership.Constants.Status | string;
    /** The date and time that the instance group membership was updated. */
    updated_at: string;
  }
  export namespace InstanceGroupMembership {
    export namespace Constants {
      /** The status of the instance group membership - `deleting`: Membership is deleting dependent resources - `failed`: Membership was unable to maintain dependent resources - `healthy`: Membership is active and serving in the group - `pending`: Membership is waiting for dependent resources - `unhealthy`: Membership has unhealthy dependent resources The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        DELETING = 'deleting',
        FAILED = 'failed',
        HEALTHY = 'healthy',
        PENDING = 'pending',
        UNHEALTHY = 'unhealthy',
      }
    }
  }

  /**
   * InstanceGroupMembershipCollection.
   */
  export interface InstanceGroupMembershipCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A page of memberships for the instance group. */
    memberships: InstanceGroupMembership[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * InstanceGroupReference.
   */
  export interface InstanceGroupReference {
    /** The CRN for this instance group. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance group. */
    href: string;
    /** The unique identifier for this instance group. */
    id: string;
    /** The name for this instance group. The name is unique across all instance groups in the region. */
    name: string;
  }

  /**
   * InstanceHealthReason.
   */
  export interface InstanceHealthReason {
    /** A reason code for this health state:
     *  - `reservation_capacity_unavailable`: The reservation affinity pool has no
     *    available capacity.
     *  - `reservation_deleted`: The reservation affinity pool has a deleted reservation.
     *  - `reservation_expired`: The reservation affinity pool has an expired reservation.
     *  - `reservation_failed`: The reservation affinity pool has a failed reservation.
     *
     *  See [health status reasons](https://cloud.ibm.com/docs/vpc?topic=vpc-server-health-status-reasons) for details.
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: InstanceHealthReason.Constants.Code | string;
    /** An explanation of the reason for this health state. */
    message: string;
    /** Link to documentation about the reason for this health state. */
    more_info?: string;
  }
  export namespace InstanceHealthReason {
    export namespace Constants {
      /** A reason code for this health state: - `reservation_capacity_unavailable`: The reservation affinity pool has no available capacity. - `reservation_deleted`: The reservation affinity pool has a deleted reservation. - `reservation_expired`: The reservation affinity pool has an expired reservation. - `reservation_failed`: The reservation affinity pool has a failed reservation. See [health status reasons](https://cloud.ibm.com/docs/vpc?topic=vpc-server-health-status-reasons) for details. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        RESERVATION_CAPACITY_UNAVAILABLE = 'reservation_capacity_unavailable',
        RESERVATION_DELETED = 'reservation_deleted',
        RESERVATION_EXPIRED = 'reservation_expired',
        RESERVATION_FAILED = 'reservation_failed',
      }
    }
  }

  /**
   * InstanceInitialization.
   */
  export interface InstanceInitialization {
    /** The default trusted profile configuration specified at virtual server instance
     *  creation. If absent, no default trusted profile was specified.
     */
    default_trusted_profile?: InstanceInitializationDefaultTrustedProfile;
    /** The public SSH keys used at instance initialization. */
    keys: KeyReference[];
    password?: InstanceInitializationPassword;
  }

  /**
   * InstanceInitializationDefaultTrustedProfile.
   */
  export interface InstanceInitializationDefaultTrustedProfile {
    /** If set to `true`, the system created a link to the specified `target` trusted profile during instance
     *  creation. Regardless of whether a link was created by the system or manually using the IAM Identity service, it
     *  will be automatically deleted when the instance is deleted.
     */
    auto_link: boolean;
    /** The default IAM trusted profile to use for this virtual server instance. */
    target: TrustedProfileReference;
  }

  /**
   * InstanceInitializationPassword.
   */
  export interface InstanceInitializationPassword {
    /** The administrator password at initialization, encrypted using `encryption_key`, and returned base64-encoded. */
    encrypted_password: string;
    /** The public SSH key used to encrypt the administrator password. */
    encryption_key: KeyIdentityByFingerprint;
  }

  /**
   * InstanceLifecycleReason.
   */
  export interface InstanceLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `failed_registration`: the instance's registration to Resource Controller has
     *    failed. Delete the instance and provision it again. If the problem persists,
     *    contact IBM Support.
     *  - `internal_error`: internal error (contact IBM support)
     *  - `pending_registration`: the instance's registration to Resource Controller is
     *    being processed.
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: InstanceLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace InstanceLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `failed_registration`: the instance's registration to Resource Controller has failed. Delete the instance and provision it again. If the problem persists, contact IBM Support. - `internal_error`: internal error (contact IBM support) - `pending_registration`: the instance's registration to Resource Controller is being processed. - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        FAILED_REGISTRATION = 'failed_registration',
        INTERNAL_ERROR = 'internal_error',
        PENDING_REGISTRATION = 'pending_registration',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * The metadata service configuration.
   */
  export interface InstanceMetadataService {
    /** Indicates whether the metadata service endpoint is available to the virtual server instance. */
    enabled: boolean;
    /** The communication protocol to use for the metadata service endpoint. Applies only when the metadata service
     *  is enabled.
     *  - `http`: HTTP protocol (unencrypted)
     *  - `https`: HTTP Secure protocol.
     */
    protocol: InstanceMetadataService.Constants.Protocol | string;
    /** The hop limit (IP time to live) for IP response packets from the metadata service. Applies only when the
     *  metadata service is enabled.
     */
    response_hop_limit: number;
  }
  export namespace InstanceMetadataService {
    export namespace Constants {
      /** The communication protocol to use for the metadata service endpoint. Applies only when the metadata service is enabled. - `http`: HTTP protocol (unencrypted) - `https`: HTTP Secure protocol. */
      export enum Protocol {
        HTTP = 'http',
        HTTPS = 'https',
      }
    }
  }

  /**
   * The metadata service configuration.
   */
  export interface InstanceMetadataServicePatch {
    /** Indicates whether the metadata service endpoint will be available to the virtual server instance. */
    enabled?: boolean;
    /** The communication protocol to use for the metadata service endpoint. Applies only when the metadata service
     *  is enabled.
     *  - `http`: HTTP protocol (unencrypted)
     *  - `https`: HTTP Secure protocol.
     */
    protocol?: InstanceMetadataServicePatch.Constants.Protocol | string;
    /** The hop limit (IP time to live) for IP response packets from the metadata service. Applies only when the
     *  metadata service is enabled.
     */
    response_hop_limit?: number;
  }
  export namespace InstanceMetadataServicePatch {
    export namespace Constants {
      /** The communication protocol to use for the metadata service endpoint. Applies only when the metadata service is enabled. - `http`: HTTP protocol (unencrypted) - `https`: HTTP Secure protocol. */
      export enum Protocol {
        HTTP = 'http',
        HTTPS = 'https',
      }
    }
  }

  /**
   * The metadata service configuration.
   */
  export interface InstanceMetadataServicePrototype {
    /** Indicates whether the metadata service endpoint will be available to the virtual server instance. */
    enabled?: boolean;
    /** The communication protocol to use for the metadata service endpoint. Applies only when the metadata service
     *  is enabled.
     *  - `http`: HTTP protocol (unencrypted)
     *  - `https`: HTTP Secure protocol.
     */
    protocol?: InstanceMetadataServicePrototype.Constants.Protocol | string;
    /** The hop limit (IP time to live) for IP response packets from the metadata service. Applies only when the
     *  metadata service is enabled.
     */
    response_hop_limit?: number;
  }
  export namespace InstanceMetadataServicePrototype {
    export namespace Constants {
      /** The communication protocol to use for the metadata service endpoint. Applies only when the metadata service is enabled. - `http`: HTTP protocol (unencrypted) - `https`: HTTP Secure protocol. */
      export enum Protocol {
        HTTP = 'http',
        HTTPS = 'https',
      }
    }
  }

  /**
   * InstanceNetworkAttachment.
   */
  export interface InstanceNetworkAttachment {
    /** The date and time that the instance network attachment was created. */
    created_at: string;
    /** The URL for this instance network attachment. */
    href: string;
    /** The unique identifier for this instance network attachment. */
    id: string;
    /** The lifecycle state of the instance network attachment. */
    lifecycle_state: InstanceNetworkAttachment.Constants.LifecycleState | string;
    /** The name for this instance network attachment. The name is unique across all network attachments for the
     *  instance.
     */
    name: string;
    /** The port speed for this instance network attachment in Mbps. */
    port_speed: number;
    /** The primary IP address of the virtual network interface for the instance network attachment. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: InstanceNetworkAttachment.Constants.ResourceType | string;
    /** The subnet of the virtual network interface for the instance network attachment. */
    subnet: SubnetReference;
    /** The instance network attachment type. */
    type: InstanceNetworkAttachment.Constants.Type | string;
    /** The virtual network interface for this instance network attachment. */
    virtual_network_interface: VirtualNetworkInterfaceReferenceAttachmentContext;
  }
  export namespace InstanceNetworkAttachment {
    export namespace Constants {
      /** The lifecycle state of the instance network attachment. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_NETWORK_ATTACHMENT = 'instance_network_attachment',
      }
      /** The instance network attachment type. */
      export enum Type {
        PRIMARY = 'primary',
        SECONDARY = 'secondary',
      }
    }
  }

  /**
   * InstanceNetworkAttachmentCollection.
   */
  export interface InstanceNetworkAttachmentCollection {
    /** The network attachments for the instance. */
    network_attachments: InstanceNetworkAttachment[];
  }

  /**
   * InstanceNetworkAttachmentPrototype.
   */
  export interface InstanceNetworkAttachmentPrototype {
    /** The name for this network attachment. Names must be unique within the instance the network attachment
     *  resides in. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** A virtual network interface for the instance network attachment. This can be specified
     *  using an existing virtual network interface, or a prototype object for a new virtual
     *  network interface.
     *
     *  If an existing virtual network interface is specified, `enable_infrastructure_nat` must be
     *  `true`.
     */
    virtual_network_interface: InstanceNetworkAttachmentPrototypeVirtualNetworkInterface;
  }

  /**
   * A virtual network interface for the instance network attachment. This can be specified using an existing virtual
   * network interface, or a prototype object for a new virtual network interface.
   *
   * If an existing virtual network interface is specified, `enable_infrastructure_nat` must be
   * `true`.
   */
  export interface InstanceNetworkAttachmentPrototypeVirtualNetworkInterface {
  }

  /**
   * InstanceNetworkAttachmentReference.
   */
  export interface InstanceNetworkAttachmentReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance network attachment. */
    href: string;
    /** The unique identifier for this instance network attachment. */
    id: string;
    /** The name for this instance network attachment. The name is unique across all network attachments for the
     *  instance.
     */
    name: string;
    /** The primary IP address of the virtual network interface for the instance network attachment. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: InstanceNetworkAttachmentReference.Constants.ResourceType | string;
    /** The subnet of the virtual network interface for the instance network attachment. */
    subnet: SubnetReference;
    /** The virtual network interface for this instance network attachment. */
    virtual_network_interface: VirtualNetworkInterfaceReferenceAttachmentContext;
  }
  export namespace InstanceNetworkAttachmentReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_NETWORK_ATTACHMENT = 'instance_network_attachment',
      }
    }
  }

  /**
   * The profile to use for this virtual server instance. Any disks associated with the current profile will be deleted,
   * and any disks associated with the requested profile will be created.
   *
   * For the profile to be changed, the instance `status` must be `stopping` or `stopped`. In addition, the requested
   * profile must:
   * - Be compatible with any `placement_target` constraints. For example, if the
   *   instance is placed on a dedicated host, the requested profile `family` must be
   *   the same as the dedicated host `family`.
   * - Have the same `vcpu.architecture`.
   * - Support the number of network attachments or network interfaces the instance
   *   currently has.
   */
  export interface InstancePatchProfile {
  }

  /**
   * InstancePlacementTarget.
   */
  export interface InstancePlacementTarget {
  }

  /**
   * InstancePlacementTargetPatch.
   */
  export interface InstancePlacementTargetPatch {
  }

  /**
   * InstancePlacementTargetPrototype.
   */
  export interface InstancePlacementTargetPrototype {
  }

  /**
   * InstanceProfile.
   */
  export interface InstanceProfile {
    bandwidth: InstanceProfileBandwidth;
    cluster_network_attachment_count: InstanceProfileClusterNetworkAttachmentCount;
    confidential_compute_modes: InstanceProfileSupportedConfidentialComputeModes;
    /** The disks for an instance with this profile. */
    disks: InstanceProfileDisk[];
    /** The product family this virtual server instance profile belongs to. */
    family: string;
    gpu_count?: InstanceProfileGPU;
    gpu_manufacturer?: InstanceProfileGPUManufacturer;
    gpu_memory?: InstanceProfileGPUMemory;
    gpu_model?: InstanceProfileGPUModel;
    /** The URL for this virtual server instance profile. */
    href: string;
    memory: InstanceProfileMemory;
    /** The globally unique name for this virtual server instance profile. */
    name: string;
    network_attachment_count: InstanceProfileNetworkAttachmentCount;
    network_interface_count: InstanceProfileNetworkInterfaceCount;
    numa_count?: InstanceProfileNUMACount;
    os_architecture: InstanceProfileOSArchitecture;
    port_speed: InstanceProfilePortSpeed;
    reservation_terms: InstanceProfileReservationTerms;
    /** The resource type. */
    resource_type: InstanceProfile.Constants.ResourceType | string;
    secure_boot_modes: InstanceProfileSupportedSecureBootModes;
    /** The status of the instance profile:
     *  - `previous`:  This instance profile is an older revision, but remains provisionable and
     *    usable.
     *  - `current`:  This profile is the latest revision.
     *
     *  Revisions are indicated by the generation of an instance profile. Refer to the [profile naming
     *  conventions](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles&interface=ui#profiles-naming-rule) for
     *  information on how generations are defined within an instance profile.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: InstanceProfile.Constants.Status | string;
    /** The cluster network profiles that support this instance profile. */
    supported_cluster_network_profiles: ClusterNetworkProfileReference[];
    total_volume_bandwidth: InstanceProfileVolumeBandwidth;
    vcpu_architecture: InstanceProfileVCPUArchitecture;
    vcpu_count: InstanceProfileVCPU;
    vcpu_manufacturer: InstanceProfileVCPUManufacturer;
  }
  export namespace InstanceProfile {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_PROFILE = 'instance_profile',
      }
      /** The status of the instance profile: - `previous`:  This instance profile is an older revision, but remains provisionable and usable. - `current`:  This profile is the latest revision. Revisions are indicated by the generation of an instance profile. Refer to the [profile naming conventions](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles&interface=ui#profiles-naming-rule) for information on how generations are defined within an instance profile. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        CURRENT = 'current',
        PREVIOUS = 'previous',
      }
    }
  }

  /**
   * InstanceProfileBandwidth.
   */
  export interface InstanceProfileBandwidth {
  }

  /**
   * InstanceProfileClusterNetworkAttachmentCount.
   */
  export interface InstanceProfileClusterNetworkAttachmentCount {
  }

  /**
   * InstanceProfileCollection.
   */
  export interface InstanceProfileCollection {
    /** A page of virtual server instance profiles. */
    profiles: InstanceProfile[];
  }

  /**
   * Disks provided by this profile.
   */
  export interface InstanceProfileDisk {
    quantity: InstanceProfileDiskQuantity;
    size: InstanceProfileDiskSize;
    supported_interface_types: InstanceProfileDiskSupportedInterfaces;
  }

  /**
   * InstanceProfileDiskQuantity.
   */
  export interface InstanceProfileDiskQuantity {
  }

  /**
   * InstanceProfileDiskSize.
   */
  export interface InstanceProfileDiskSize {
  }

  /**
   * InstanceProfileDiskSupportedInterfaces.
   */
  export interface InstanceProfileDiskSupportedInterfaces {
    /** The disk interface used for attaching the disk.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    default: InstanceProfileDiskSupportedInterfaces.Constants.Default | string;
    /** The type for this profile field. */
    type: InstanceProfileDiskSupportedInterfaces.Constants.Type | string;
    /** The supported disk interfaces used for attaching the disk. */
    values: InstanceProfileDiskSupportedInterfaces.Constants.Values[] | string[];
  }
  export namespace InstanceProfileDiskSupportedInterfaces {
    export namespace Constants {
      /** The disk interface used for attaching the disk. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Default {
        NVME = 'nvme',
        VIRTIO_BLK = 'virtio_blk',
      }
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The supported disk interfaces used for attaching the disk. */
      export enum Values {
        NVME = 'nvme',
        VIRTIO_BLK = 'virtio_blk',
      }
    }
  }

  /**
   * InstanceProfileGPU.
   */
  export interface InstanceProfileGPU {
  }

  /**
   * InstanceProfileGPUManufacturer.
   */
  export interface InstanceProfileGPUManufacturer {
    /** The type for this profile field. */
    type: InstanceProfileGPUManufacturer.Constants.Type | string;
    /** The possible GPU manufacturer(s) for an instance with this profile. */
    values: InstanceProfileGPUManufacturer.Constants.Values[] | string[];
  }
  export namespace InstanceProfileGPUManufacturer {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The possible GPU manufacturer(s) for an instance with this profile. */
      export enum Values {
        INTEL = 'intel',
        NVIDIA = 'nvidia',
      }
    }
  }

  /**
   * InstanceProfileGPUMemory.
   */
  export interface InstanceProfileGPUMemory {
  }

  /**
   * InstanceProfileGPUModel.
   */
  export interface InstanceProfileGPUModel {
    /** The type for this profile field. */
    type: InstanceProfileGPUModel.Constants.Type | string;
    /** The possible GPU model(s) for an instance with this profile. */
    values: string[];
  }
  export namespace InstanceProfileGPUModel {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * Identifies an instance profile by a unique property.
   */
  export interface InstanceProfileIdentity {
  }

  /**
   * InstanceProfileMemory.
   */
  export interface InstanceProfileMemory {
  }

  /**
   * InstanceProfileNUMACount.
   */
  export interface InstanceProfileNUMACount {
  }

  /**
   * InstanceProfileNetworkAttachmentCount.
   */
  export interface InstanceProfileNetworkAttachmentCount {
  }

  /**
   * InstanceProfileNetworkInterfaceCount.
   */
  export interface InstanceProfileNetworkInterfaceCount {
  }

  /**
   * InstanceProfileOSArchitecture.
   */
  export interface InstanceProfileOSArchitecture {
    /** The default OS architecture for an instance with this profile. */
    default: string;
    /** The type for this profile field. */
    type: InstanceProfileOSArchitecture.Constants.Type | string;
    /** The supported OS architecture(s) for an instance with this profile. */
    values: string[];
  }
  export namespace InstanceProfileOSArchitecture {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * InstanceProfilePortSpeed.
   */
  export interface InstanceProfilePortSpeed {
  }

  /**
   * InstanceProfileReference.
   */
  export interface InstanceProfileReference {
    /** The URL for this virtual server instance profile. */
    href: string;
    /** The globally unique name for this virtual server instance profile. */
    name: string;
    /** The resource type. */
    resource_type: InstanceProfileReference.Constants.ResourceType | string;
  }
  export namespace InstanceProfileReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_PROFILE = 'instance_profile',
      }
    }
  }

  /**
   * InstanceProfileReservationTerms.
   */
  export interface InstanceProfileReservationTerms {
    /** The type for this profile field. */
    type: InstanceProfileReservationTerms.Constants.Type | string;
    /** The supported committed use terms for a reservation using this profile. */
    values: InstanceProfileReservationTerms.Constants.Values[] | string[];
  }
  export namespace InstanceProfileReservationTerms {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The supported committed use terms for a reservation using this profile. */
      export enum Values {
        ONE_YEAR = 'one_year',
        THREE_YEAR = 'three_year',
      }
    }
  }

  /**
   * InstanceProfileSupportedConfidentialComputeModes.
   */
  export interface InstanceProfileSupportedConfidentialComputeModes {
    /** The default confidential compute mode for this profile. */
    default: InstanceProfileSupportedConfidentialComputeModes.Constants.Default | string;
    /** The type for this profile field. */
    type: InstanceProfileSupportedConfidentialComputeModes.Constants.Type | string;
    /** The supported confidential compute modes. */
    values: InstanceProfileSupportedConfidentialComputeModes.Constants.Values[] | string[];
  }
  export namespace InstanceProfileSupportedConfidentialComputeModes {
    export namespace Constants {
      /** The default confidential compute mode for this profile. */
      export enum Default {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The supported confidential compute modes. */
      export enum Values {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceProfileSupportedSecureBootModes.
   */
  export interface InstanceProfileSupportedSecureBootModes {
    /** The default secure boot mode for this profile. */
    default: boolean;
    /** The type for this profile field. */
    type: InstanceProfileSupportedSecureBootModes.Constants.Type | string;
    /** The supported `enable_secure_boot` values for an instance using this profile. */
    values: boolean[];
  }
  export namespace InstanceProfileSupportedSecureBootModes {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * InstanceProfileVCPU.
   */
  export interface InstanceProfileVCPU {
  }

  /**
   * InstanceProfileVCPUArchitecture.
   */
  export interface InstanceProfileVCPUArchitecture {
    /** The type for this profile field. */
    type: InstanceProfileVCPUArchitecture.Constants.Type | string;
    /** The VCPU architecture for an instance with this profile. */
    value: InstanceProfileVCPUArchitecture.Constants.Value | string;
  }
  export namespace InstanceProfileVCPUArchitecture {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
      /** The VCPU architecture for an instance with this profile. */
      export enum Value {
        AMD64 = 'amd64',
        S390X = 's390x',
      }
    }
  }

  /**
   * InstanceProfileVCPUManufacturer.
   */
  export interface InstanceProfileVCPUManufacturer {
    /** The type for this profile field. */
    type: InstanceProfileVCPUManufacturer.Constants.Type | string;
    /** The VCPU manufacturer for an instance with this profile. */
    value: InstanceProfileVCPUManufacturer.Constants.Value | string;
  }
  export namespace InstanceProfileVCPUManufacturer {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
      /** The VCPU manufacturer for an instance with this profile. */
      export enum Value {
        AMD = 'amd',
        IBM = 'ibm',
        INTEL = 'intel',
      }
    }
  }

  /**
   * InstanceProfileVolumeBandwidth.
   */
  export interface InstanceProfileVolumeBandwidth {
  }

  /**
   * InstancePrototype.
   */
  export interface InstancePrototype {
    /** The availability policy to use for this virtual server instance. */
    availability_policy?: InstanceAvailabilityPolicyPrototype;
    /** The cluster network attachments to create for this virtual server instance. A cluster network attachment
     *  represents a device that is connected to a cluster network. The number of network attachments must match one of
     *  the values from the instance profile's `cluster_network_attachment_count` before the instance can be started.
     */
    cluster_network_attachments?: InstanceClusterNetworkAttachmentPrototypeInstanceContext[];
    /** The confidential compute mode to use for this virtual server instance.
     *
     *  If unspecified, the default confidential compute mode from the profile will be used.
     */
    confidential_compute_mode?: InstancePrototype.Constants.ConfidentialComputeMode | string;
    /** The default trusted profile configuration to use for this virtual server instance
     *
     *  This property's value is used when provisioning the virtual server instance, but not
     *  subsequently managed. Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization)
     *  property.
     */
    default_trusted_profile?: InstanceDefaultTrustedProfilePrototype;
    /** Indicates whether secure boot is enabled for this virtual server instance.
     *
     *  If unspecified, the default secure boot mode from the profile will be used.
     */
    enable_secure_boot?: boolean;
    /** The public SSH keys for this virtual server instance. Keys will be made available to the virtual server
     *  instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as SSH
     *  authorized keys for the [default
     *  user](https://cloud.ibm.com/docs/vpc?topic=vpc-vsi_is_connecting_linux#determining-default-user-account).
     *
     *  For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the
     *  administrator password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for
     *  other images, but if no keys are specified, the instance will be inaccessible unless the specified image
     *  provides another means of access.
     *
     *  This property's value is used when provisioning the virtual server instance, but not subsequently managed.
     *  Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
     */
    keys?: KeyIdentity[];
    /** The metadata service configuration. */
    metadata_service?: InstanceMetadataServicePrototype;
    /** The name for this virtual server instance. The name must not be used by another virtual server instance in
     *  the region. If unspecified, the name will be a hyphenated list of randomly-selected words.
     *
     *  The system hostname will be based on this name.
     */
    name?: string;
    /** The placement restrictions to use for the virtual server instance.
     *
     *  If specified, `reservation_affinity.policy` must be `disabled`.
     */
    placement_target?: InstancePlacementTargetPrototype;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this
     *  virtual server instance.
     *
     *  If unspecified, `bx2-2x8` will be used, but this default value is expected to change
     *  in the future.
     */
    profile?: InstanceProfileIdentity;
    reservation_affinity?: InstanceReservationAffinityPrototype;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An
     *  increase in this value will result in a corresponding decrease to
     *  `total_network_bandwidth`.
     */
    total_volume_bandwidth?: number;
    /** [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the
     *  virtual server instance.
     */
    user_data?: string;
    /** The additional volume attachments to create for the virtual server instance. */
    volume_attachments?: VolumeAttachmentPrototype[];
    /** The VPC this virtual server instance will reside in.
     *
     *  If specified, it must match the VPC for the subnets of the instance network
     *  attachments or instance network interfaces.
     */
    vpc?: VPCIdentity;
  }
  export namespace InstancePrototype {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceReference.
   */
  export interface InstanceReference {
    /** The CRN for this virtual server instance. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this virtual server instance. */
    href: string;
    /** The unique identifier for this virtual server instance. */
    id: string;
    /** The name for this virtual server instance. The name is unique across all virtual server instances in the
     *  region.
     */
    name: string;
  }

  /**
   * InstanceReservationAffinity.
   */
  export interface InstanceReservationAffinity {
    /** The reservation affinity policy to use for this virtual server instance:
     *  - `automatic`: Any reservations with an `affinity_policy` of `automatic`
     *    that have the same `profile` and `zone` as this virtual server instance
     *    are available for use.
     *  - `disabled`: Reservations will not be used
     *  - `manual`: Reservations in `pool` are available for use.
     */
    policy: InstanceReservationAffinity.Constants.Policy | string;
    /** The pool of reservations available for use by this virtual server instance when the `policy` is `manual`.
     *  This must be empty if the `policy` is `automatic` or
     *  `disabled`.
     */
    pool: ReservationReference[];
  }
  export namespace InstanceReservationAffinity {
    export namespace Constants {
      /** The reservation affinity policy to use for this virtual server instance: - `automatic`: Any reservations with an `affinity_policy` of `automatic` that have the same `profile` and `zone` as this virtual server instance are available for use. - `disabled`: Reservations will not be used - `manual`: Reservations in `pool` are available for use. */
      export enum Policy {
        AUTOMATIC = 'automatic',
        DISABLED = 'disabled',
        MANUAL = 'manual',
      }
    }
  }

  /**
   * InstanceReservationAffinityPatch.
   */
  export interface InstanceReservationAffinityPatch {
    /** The reservation affinity policy to use for this virtual server instance:
     *  - `automatic`: Any reservations with an `affinity_policy` of `automatic`
     *    that have the same `profile` and `zone` as this virtual server instance
     *    are available for use.
     *  - `disabled`: Reservations will not be used
     *  - `manual`: Reservations in `pool` will be available for use
     *
     *  The policy must be `disabled` if `placement_target` is set.
     */
    policy?: InstanceReservationAffinityPatch.Constants.Policy | string;
    /** The pool of reservations available for use by this virtual server instance, replacing the existing pool of
     *  reservations.
     *
     *  Specified reservations must have a `status` of `active`, and have the same `profile` and `zone` as this virtual
     *  server instance.
     *
     *  If `policy` is `manual`, `pool` must have one reservation. If `policy` is `disabled` or `automatic`, `pool` must
     *  be empty. If `policy` is `manual`, the `pool` must contain a reservation with available capacity.
     */
    pool?: ReservationIdentity[];
  }
  export namespace InstanceReservationAffinityPatch {
    export namespace Constants {
      /** The reservation affinity policy to use for this virtual server instance: - `automatic`: Any reservations with an `affinity_policy` of `automatic` that have the same `profile` and `zone` as this virtual server instance are available for use. - `disabled`: Reservations will not be used - `manual`: Reservations in `pool` will be available for use The policy must be `disabled` if `placement_target` is set. */
      export enum Policy {
        AUTOMATIC = 'automatic',
        DISABLED = 'disabled',
        MANUAL = 'manual',
      }
    }
  }

  /**
   * InstanceReservationAffinityPrototype.
   */
  export interface InstanceReservationAffinityPrototype {
    /** The reservation affinity policy to use for this virtual server instance:
     *  - `disabled`: Reservations will not be used
     *  - `manual`: Reservations in `pool` will be available for use
     *  - `automatic`: Reservations with an `affinity_policy` of `automatic` that have the same
     *    `profile` and `zone` as this virtual server instance will be available for use.
     *
     *  The policy will default to `manual` if `pool` is not empty. The policy will default to
     *  `disabled` if a `placement_target` is set. The policy will default to `automatic` in all other cases.
     *
     *  The policy must be `disabled` if `placement_target` is specified.
     */
    policy?: InstanceReservationAffinityPrototype.Constants.Policy | string;
    /** The pool of reservations available for use by this virtual server instance.
     *
     *  Specified reservations must have a `status` of `active`, and have the same `profile` and `zone` as this virtual
     *  server instance.
     *
     *  If `policy` is `manual`, `pool` must be specified with one reservation. If `policy` is `disabled` or `automatic`
     *  and `pool` is specified, it must be empty. If `policy` is `manual`, the `pool` must contain a reservation with
     *  available capacity.
     */
    pool?: ReservationIdentity[];
  }
  export namespace InstanceReservationAffinityPrototype {
    export namespace Constants {
      /** The reservation affinity policy to use for this virtual server instance: - `disabled`: Reservations will not be used - `manual`: Reservations in `pool` will be available for use - `automatic`: Reservations with an `affinity_policy` of `automatic` that have the same `profile` and `zone` as this virtual server instance will be available for use. The policy will default to `manual` if `pool` is not empty. The policy will default to `disabled` if a `placement_target` is set. The policy will default to `automatic` in all other cases. The policy must be `disabled` if `placement_target` is specified. */
      export enum Policy {
        AUTOMATIC = 'automatic',
        DISABLED = 'disabled',
        MANUAL = 'manual',
      }
    }
  }

  /**
   * InstanceStatusReason.
   */
  export interface InstanceStatusReason {
    /** A snake case string succinctly identifying the status reason.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: InstanceStatusReason.Constants.Code | string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace InstanceStatusReason {
    export namespace Constants {
      /** A snake case string succinctly identifying the status reason. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        CANNOT_START = 'cannot_start',
        CANNOT_START_CAPACITY = 'cannot_start_capacity',
        CANNOT_START_COMPUTE = 'cannot_start_compute',
        CANNOT_START_IP_ADDRESS = 'cannot_start_ip_address',
        CANNOT_START_NETWORK = 'cannot_start_network',
        CANNOT_START_PLACEMENT_GROUP = 'cannot_start_placement_group',
        CANNOT_START_RESERVATION_CAPACITY = 'cannot_start_reservation_capacity',
        CANNOT_START_RESERVATION_EXPIRED = 'cannot_start_reservation_expired',
        CANNOT_START_STORAGE = 'cannot_start_storage',
        ENCRYPTION_KEY_DELETED = 'encryption_key_deleted',
        STOPPED_BY_HOST_FAILURE = 'stopped_by_host_failure',
        STOPPED_FOR_IMAGE_CREATION = 'stopped_for_image_creation',
      }
    }
  }

  /**
   * InstanceTemplate.
   */
  export interface InstanceTemplate {
    /** The availability policy to use for this virtual server instance. */
    availability_policy?: InstanceAvailabilityPolicyPrototype;
    /** The cluster network attachments to create for this virtual server instance. A cluster network attachment
     *  represents a device that is connected to a cluster network. The number of network attachments must match one of
     *  the values from the instance profile's `cluster_network_attachment_count` before the instance can be started.
     */
    cluster_network_attachments?: InstanceClusterNetworkAttachmentPrototypeInstanceContext[];
    /** The confidential compute mode to use for this virtual server instance.
     *
     *  If unspecified, the default confidential compute mode from the profile will be used.
     */
    confidential_compute_mode?: InstanceTemplate.Constants.ConfidentialComputeMode | string;
    /** The date and time that the instance template was created. */
    created_at: string;
    /** The CRN for this instance template. */
    crn: string;
    /** The default trusted profile configuration to use for this virtual server instance
     *
     *  This property's value is used when provisioning the virtual server instance, but not
     *  subsequently managed. Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization)
     *  property.
     */
    default_trusted_profile?: InstanceDefaultTrustedProfilePrototype;
    /** Indicates whether secure boot is enabled for this virtual server instance.
     *
     *  If unspecified, the default secure boot mode from the profile will be used.
     */
    enable_secure_boot?: boolean;
    /** The URL for this instance template. */
    href: string;
    /** The unique identifier for this instance template. */
    id: string;
    /** The public SSH keys for this virtual server instance. Keys will be made available to the virtual server
     *  instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as SSH
     *  authorized keys for the [default
     *  user](https://cloud.ibm.com/docs/vpc?topic=vpc-vsi_is_connecting_linux#determining-default-user-account).
     *
     *  For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the
     *  administrator password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for
     *  other images, but if no keys are specified, the instance will be inaccessible unless the specified image
     *  provides another means of access.
     *
     *  This property's value is used when provisioning the virtual server instance, but not subsequently managed.
     *  Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
     */
    keys?: KeyIdentity[];
    /** The metadata service configuration. */
    metadata_service?: InstanceMetadataServicePrototype;
    /** The name for this instance template. The name is unique across all instance templates in the region. */
    name: string;
    /** The placement restrictions to use for the virtual server instance.
     *
     *  If specified, `reservation_affinity.policy` must be `disabled`.
     */
    placement_target?: InstancePlacementTargetPrototype;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this
     *  virtual server instance.
     *
     *  If unspecified, `bx2-2x8` will be used, but this default value is expected to change
     *  in the future.
     */
    profile?: InstanceProfileIdentity;
    reservation_affinity?: InstanceReservationAffinityPrototype;
    /** The resource group for this instance template. */
    resource_group: ResourceGroupReference;
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An
     *  increase in this value will result in a corresponding decrease to
     *  `total_network_bandwidth`.
     */
    total_volume_bandwidth?: number;
    /** [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the
     *  virtual server instance.
     */
    user_data?: string;
    /** The additional volume attachments to create for the virtual server instance. */
    volume_attachments?: VolumeAttachmentPrototype[];
    /** The VPC this virtual server instance will reside in.
     *
     *  If specified, it must match the VPC for the subnets of the instance network
     *  attachments or instance network interfaces.
     */
    vpc?: VPCIdentity;
  }
  export namespace InstanceTemplate {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplateCollection.
   */
  export interface InstanceTemplateCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of instance templates. */
    templates: InstanceTemplate[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Identifies an instance template by a unique property.
   */
  export interface InstanceTemplateIdentity {
  }

  /**
   * InstanceTemplatePrototype.
   */
  export interface InstanceTemplatePrototype {
    /** The availability policy to use for this virtual server instance. */
    availability_policy?: InstanceAvailabilityPolicyPrototype;
    /** The cluster network attachments to create for this virtual server instance. A cluster network attachment
     *  represents a device that is connected to a cluster network. The number of network attachments must match one of
     *  the values from the instance profile's `cluster_network_attachment_count` before the instance can be started.
     */
    cluster_network_attachments?: InstanceClusterNetworkAttachmentPrototypeInstanceContext[];
    /** The confidential compute mode to use for this virtual server instance.
     *
     *  If unspecified, the default confidential compute mode from the profile will be used.
     */
    confidential_compute_mode?: InstanceTemplatePrototype.Constants.ConfidentialComputeMode | string;
    /** The default trusted profile configuration to use for this virtual server instance
     *
     *  This property's value is used when provisioning the virtual server instance, but not
     *  subsequently managed. Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization)
     *  property.
     */
    default_trusted_profile?: InstanceDefaultTrustedProfilePrototype;
    /** Indicates whether secure boot is enabled for this virtual server instance.
     *
     *  If unspecified, the default secure boot mode from the profile will be used.
     */
    enable_secure_boot?: boolean;
    /** The public SSH keys for this virtual server instance. Keys will be made available to the virtual server
     *  instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as SSH
     *  authorized keys for the [default
     *  user](https://cloud.ibm.com/docs/vpc?topic=vpc-vsi_is_connecting_linux#determining-default-user-account).
     *
     *  For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the
     *  administrator password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for
     *  other images, but if no keys are specified, the instance will be inaccessible unless the specified image
     *  provides another means of access.
     *
     *  This property's value is used when provisioning the virtual server instance, but not subsequently managed.
     *  Accordingly, it is reflected as an [instance
     *  initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
     */
    keys?: KeyIdentity[];
    /** The metadata service configuration. */
    metadata_service?: InstanceMetadataServicePrototype;
    /** The name for this instance template. The name must not be used by another instance template in the region.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The placement restrictions to use for the virtual server instance.
     *
     *  If specified, `reservation_affinity.policy` must be `disabled`.
     */
    placement_target?: InstancePlacementTargetPrototype;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this
     *  virtual server instance.
     *
     *  If unspecified, `bx2-2x8` will be used, but this default value is expected to change
     *  in the future.
     */
    profile?: InstanceProfileIdentity;
    reservation_affinity?: InstanceReservationAffinityPrototype;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An
     *  increase in this value will result in a corresponding decrease to
     *  `total_network_bandwidth`.
     */
    total_volume_bandwidth?: number;
    /** [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the
     *  virtual server instance.
     */
    user_data?: string;
    /** The additional volume attachments to create for the virtual server instance. */
    volume_attachments?: VolumeAttachmentPrototype[];
    /** The VPC this virtual server instance will reside in.
     *
     *  If specified, it must match the VPC for the subnets of the instance network
     *  attachments or instance network interfaces.
     */
    vpc?: VPCIdentity;
  }
  export namespace InstanceTemplatePrototype {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplateReference.
   */
  export interface InstanceTemplateReference {
    /** The CRN for this instance template. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance template. */
    href: string;
    /** The unique identifier for this instance template. */
    id: string;
    /** The name for this instance template. The name is unique across all instance templates in the region. */
    name: string;
  }

  /**
   * The virtual server instance VCPU configuration.
   */
  export interface InstanceVCPU {
    /** The VCPU architecture.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    architecture: InstanceVCPU.Constants.Architecture | string;
    /** The number of VCPUs assigned. */
    count: number;
    /** The VCPU manufacturer.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    manufacturer: InstanceVCPU.Constants.Manufacturer | string;
  }
  export namespace InstanceVCPU {
    export namespace Constants {
      /** The VCPU architecture. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Architecture {
        AMD64 = 'amd64',
        S390X = 's390x',
      }
      /** The VCPU manufacturer. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Manufacturer {
        AMD = 'amd',
        IBM = 'ibm',
        INTEL = 'intel',
      }
    }
  }

  /**
   * Key.
   */
  export interface Key {
    /** The date and time that the key was created. */
    created_at: string;
    /** The CRN for this key. */
    crn: string;
    /** The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm
     *  (always `SHA256`).
     */
    fingerprint: string;
    /** The URL for this key. */
    href: string;
    /** The unique identifier for this key. */
    id: string;
    /** The length of this key (in bits). */
    length: number;
    /** The name for this key. The name must not be used by another key in the region. If unspecified, the name will
     *  be a hyphenated list of randomly-selected words.
     */
    name: string;
    /** The public SSH key, consisting of two space-separated fields: the algorithm name, and the base64-encoded
     *  key.
     */
    public_key: string;
    /** The resource group for this key. */
    resource_group: ResourceGroupReference;
    /** The crypto-system for this key.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    type: Key.Constants.Type | string;
  }
  export namespace Key {
    export namespace Constants {
      /** The crypto-system for this key. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        ED25519 = 'ed25519',
        RSA = 'rsa',
      }
    }
  }

  /**
   * KeyCollection.
   */
  export interface KeyCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of keys. */
    keys: Key[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Identifies a key by a unique property.
   */
  export interface KeyIdentity {
  }

  /**
   * KeyReference.
   */
  export interface KeyReference {
    /** The CRN for this key. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm
     *  (always `SHA256`).
     */
    fingerprint: string;
    /** The URL for this key. */
    href: string;
    /** The unique identifier for this key. */
    id: string;
    /** The name for this key. The name is unique across all keys in the region. */
    name: string;
  }

  /**
   * Identifies a Cloud Object Storage bucket by a unique property.
   */
  export interface LegacyCloudObjectStorageBucketIdentity {
  }

  /**
   * LegacyCloudObjectStorageBucketReference.
   */
  export interface LegacyCloudObjectStorageBucketReference {
    /** The globally unique name of this Cloud Object Storage bucket. */
    name: string;
  }

  /**
   * LoadBalancer.
   */
  export interface LoadBalancer {
    /** The access mode for this load balancer:
     *  - `private`: reachable from within its VPC, at IP addresses in `private_ips`
     *  - `private_path`: reachable through an endpoint gateway
     *  - `public`: reachable from the internet at the IP addresses in `public_ips`.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    access_mode: LoadBalancer.Constants.AccessMode | string;
    /** The load balancer pool members attached to this load balancer. */
    attached_load_balancer_pool_members: LoadBalancerPoolMemberReference[];
    /** The availability of this load balancer:
     *  - `subnet`: remains available if at least one zone that the load balancer's subnets reside
     *    in is available
     *  - `region`: remains available if at least one zone in the region is available.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    availability: LoadBalancer.Constants.Availability | string;
    /** The date and time that this load balancer was created. */
    created_at: string;
    /** The CRN for this load balancer. */
    crn: string;
    /** The DNS configuration for this load balancer.
     *
     *  If absent, DNS `A` records for this load balancer's `hostname` property will be added to
     *  the public DNS zone `lb.appdomain.cloud`.
     *
     *  Not supported by private path load balancers.
     */
    dns?: LoadBalancerDNS;
    /** The supported `failsafe_policy.action` values for this load balancer's pools. */
    failsafe_policy_actions: LoadBalancer.Constants.FailsafePolicyActions[] | string[];
    /** Fully qualified domain name assigned to this load balancer. */
    hostname: string;
    /** The URL for this load balancer. */
    href: string;
    /** The unique identifier for this load balancer. */
    id: string;
    /** Indicates whether this load balancer supports instance groups. */
    instance_groups_supported: boolean;
    /** Indicates whether this is a private path load balancer. */
    is_private_path: boolean;
    /** The type of this load balancer, public or private. */
    is_public: boolean;
    /** The listeners of this load balancer. */
    listeners: LoadBalancerListenerReference[];
    /** The logging configuration for this load balancer. */
    logging: LoadBalancerLogging;
    /** The name for this load balancer. The name is unique across all load balancers in the VPC. */
    name: string;
    /** The operating status of this load balancer.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    operating_status: LoadBalancer.Constants.OperatingStatus | string;
    /** The pools of this load balancer. */
    pools: LoadBalancerPoolReference[];
    /** The private IP addresses assigned to this load balancer.
     *
     *  Will be empty if `is_private` is `false`.
     */
    private_ips: ReservedIPReference[];
    /** The profile for this load balancer. */
    profile: LoadBalancerProfileReference;
    /** The provisioning status of this load balancer:
     *  - `active`: The load balancer is running.
     *  - `create_pending`: The load balancer is being created.
     *  - `delete_pending`: The load balancer is being deleted.
     *  - `maintenance_pending`: The load balancer is unavailable due to an internal
     *                            error (contact IBM support).
     *  - `migrate_pending`: The load balancer is migrating to the requested configuration.
     *                        Performance may be degraded.
     *  - `update_pending`: The load balancer is being updated
     *      to the requested configuration.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    provisioning_status: LoadBalancer.Constants.ProvisioningStatus | string;
    /** The public IP addresses assigned to this load balancer.
     *
     *  Will be empty if `is_public` is `false`.
     */
    public_ips: IP[];
    /** The resource group for this load balancer. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: LoadBalancer.Constants.ResourceType | string;
    /** Indicates whether [route mode](https://cloud.ibm.com/docs/vpc?topic=vpc-nlb-vnf&interface=ui) is enabled for
     *  this load balancer.
     *
     *  At present, public load balancers are not supported with route mode enabled.
     */
    route_mode: boolean;
    /** The security groups targeting this load balancer.
     *
     *  If empty, all inbound and outbound traffic is allowed.
     */
    security_groups: SecurityGroupReference[];
    /** Indicates whether this load balancer supports security groups. */
    security_groups_supported: boolean;
    /** Indicates whether this load balancer supports source IP session persistence. */
    source_ip_session_persistence_supported: boolean;
    /** The subnets this load balancer is provisioned in.
     *
     *  All subnets will be in the same VPC.
     */
    subnets: SubnetReference[];
    /** Indicates whether this load balancer supports UDP. */
    udp_supported: boolean;
  }
  export namespace LoadBalancer {
    export namespace Constants {
      /** The access mode for this load balancer: - `private`: reachable from within its VPC, at IP addresses in `private_ips` - `private_path`: reachable through an endpoint gateway - `public`: reachable from the internet at the IP addresses in `public_ips`. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AccessMode {
        PRIVATE = 'private',
        PRIVATE_PATH = 'private_path',
        PUBLIC = 'public',
      }
      /** The availability of this load balancer: - `subnet`: remains available if at least one zone that the load balancer's subnets reside in is available - `region`: remains available if at least one zone in the region is available. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Availability {
        REGION = 'region',
        SUBNET = 'subnet',
      }
      /** The supported `failsafe_policy.action` values for this load balancer's pools. */
      export enum FailsafePolicyActions {
        BYPASS = 'bypass',
        DROP = 'drop',
        FAIL = 'fail',
        FORWARD = 'forward',
      }
      /** The operating status of this load balancer. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum OperatingStatus {
        OFFLINE = 'offline',
        ONLINE = 'online',
      }
      /** The provisioning status of this load balancer: - `active`: The load balancer is running. - `create_pending`: The load balancer is being created. - `delete_pending`: The load balancer is being deleted. - `maintenance_pending`: The load balancer is unavailable due to an internal error (contact IBM support). - `migrate_pending`: The load balancer is migrating to the requested configuration. Performance may be degraded. - `update_pending`: The load balancer is being updated to the requested configuration. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum ProvisioningStatus {
        ACTIVE = 'active',
        CREATE_PENDING = 'create_pending',
        DELETE_PENDING = 'delete_pending',
        FAILED = 'failed',
        MAINTENANCE_PENDING = 'maintenance_pending',
        MIGRATE_PENDING = 'migrate_pending',
        UPDATE_PENDING = 'update_pending',
      }
      /** The resource type. */
      export enum ResourceType {
        LOAD_BALANCER = 'load_balancer',
      }
    }
  }

  /**
   * LoadBalancerCollection.
   */
  export interface LoadBalancerCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A page of load balancers. */
    load_balancers: LoadBalancer[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * The DNS configuration for this load balancer.
   *
   * If absent, DNS `A` records for this load balancer's `hostname` property will be added to the public DNS zone
   * `lb.appdomain.cloud`.
   *
   * Not supported by private path load balancers.
   */
  export interface LoadBalancerDNS {
    /** The DNS instance associated with this load balancer. */
    instance: DNSInstanceReferenceLoadBalancerDNSContext;
    /** The DNS zone associated with this load balancer. */
    zone: DNSZoneReference;
  }

  /**
   * The DNS configuration for this load balancer.
   *
   * Specify `null` to remove the existing DNS configuration, which will remove all DNS `A` records for this load
   * balancer that had been added to `zone`, and add equivalent `A` records to the public DNS zone `lb.appdomain.cloud`.
   *
   * Not supported by private path load balancers.
   */
  export interface LoadBalancerDNSPatch {
    /** The DNS instance to associate with this load balancer.
     *
     *  The specified instance may be in a different region or account, subject to IAM
     *  policies.
     */
    instance?: DNSInstanceIdentity;
    /** The DNS zone to associate with this load balancer.
     *
     *  The specified zone may be in a different region or account, subject to IAM policies.
     */
    zone?: DNSZoneIdentity;
  }

  /**
   * The DNS configuration for this load balancer.
   *
   * If unspecified, DNS `A` records for this load balancer's `hostname` property will be added to the public DNS zone
   * `lb.appdomain.cloud`. Otherwise, those DNS `A` records will be added to the specified `zone`.
   *
   * Not supported by private path load balancers.
   */
  export interface LoadBalancerDNSPrototype {
    /** The DNS instance to associate with this load balancer.
     *
     *  The specified instance may be in a different region or account, subject to IAM
     *  policies.
     */
    instance: DNSInstanceIdentity;
    /** The DNS zone to associate with this load balancer.
     *
     *  The specified zone may be in a different region or account, subject to IAM policies.
     */
    zone: DNSZoneIdentity;
  }

  /**
   * Identifies a load balancer by a unique property.
   */
  export interface LoadBalancerIdentity {
  }

  /**
   * LoadBalancerListener.
   */
  export interface LoadBalancerListener {
    /** If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load
     *  balancers in the `application` family (otherwise always `false`). Additional restrictions:
     *  - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
     *    match the `accept_proxy_protocol` value of the `https_redirect` listener.
     *  - If this listener is the target of another listener's `https_redirect`, its
     *    `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
     */
    accept_proxy_protocol: boolean;
    /** The certificate instance used for SSL termination.
     *
     *  If absent, this listener is not using a certificate instance.
     */
    certificate_instance?: CertificateInstanceReference;
    /** The concurrent connection limit for the listener. If reached, incoming connections may be queued or
     *  rejected.
     *
     *  This property will be present for load balancers in the `application` family.
     */
    connection_limit?: number;
    /** The date and time that this listener was created. */
    created_at: string;
    /** The default pool for this listener. If absent, this listener has no default pool.
     *
     *  If `https_redirect` is set, the default pool will not be used.
     */
    default_pool?: LoadBalancerPoolReference;
    /** The URL for this load balancer listener. */
    href: string;
    /** If present, the target listener that requests are redirected to if none of the listener's `policies` match. */
    https_redirect?: LoadBalancerListenerHTTPSRedirect;
    /** The unique identifier for this load balancer listener. */
    id: string;
    /** The idle connection timeout of the listener in seconds.
     *
     *  This property will be present for load balancers in the `application` family.
     */
    idle_connection_timeout?: number;
    /** The policies for this listener. */
    policies?: LoadBalancerListenerPolicyReference[];
    /** The listener port number, or the inclusive lower bound of the port range. */
    port: number;
    /** The inclusive upper bound of the range of ports used by this listener. */
    port_max: number;
    /** The inclusive lower bound of the range of ports used by this listener. */
    port_min: number;
    /** The listener protocol.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    protocol: LoadBalancerListener.Constants.Protocol | string;
    /** The provisioning status of this listener
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    provisioning_status: LoadBalancerListener.Constants.ProvisioningStatus | string;
  }
  export namespace LoadBalancerListener {
    export namespace Constants {
      /** The listener protocol. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Protocol {
        HTTP = 'http',
        HTTPS = 'https',
        TCP = 'tcp',
        UDP = 'udp',
      }
      /** The provisioning status of this listener The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum ProvisioningStatus {
        ACTIVE = 'active',
        CREATE_PENDING = 'create_pending',
        DELETE_PENDING = 'delete_pending',
        FAILED = 'failed',
        UPDATE_PENDING = 'update_pending',
      }
    }
  }

  /**
   * LoadBalancerListenerCollection.
   */
  export interface LoadBalancerListenerCollection {
    /** The listeners for the load balancer. */
    listeners: LoadBalancerListener[];
  }

  /**
   * The default pool for this listener. If `https_redirect` is set, the default pool will not be used. The specified
   * pool must:
   *
   * - Belong to this load balancer
   * - Have the same `protocol` as this listener, or have a compatible protocol.
   *   At present, the compatible protocols are `http` and `https`.
   * - Not already be the `default_pool` for another listener
   *
   * Specify `null` to remove an existing default pool.
   */
  export interface LoadBalancerListenerDefaultPoolPatch {
  }

  /**
   * LoadBalancerListenerHTTPSRedirect.
   */
  export interface LoadBalancerListenerHTTPSRedirect {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    listener: LoadBalancerListenerReference;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /**
   * LoadBalancerListenerHTTPSRedirectPatch.
   */
  export interface LoadBalancerListenerHTTPSRedirectPatch {
    /** The HTTP status code for this redirect. */
    http_status_code?: number;
    /** The target listener.
     *
     *  The target listener must be in this load balancer, and must not be the same as the
     *  listener in the URL.
     */
    listener?: LoadBalancerListenerIdentity;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /**
   * LoadBalancerListenerHTTPSRedirectPrototype.
   */
  export interface LoadBalancerListenerHTTPSRedirectPrototype {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    /** The target listener.
     *
     *  The target listener must be in this load balancer, and must not be the same as the
     *  listener in the URL.
     */
    listener: LoadBalancerListenerIdentity;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /**
   * Identifies a load balancer listener by a unique property.
   */
  export interface LoadBalancerListenerIdentity {
  }

  /**
   * LoadBalancerListenerPolicy.
   */
  export interface LoadBalancerListenerPolicy {
    /** The policy action:
     *  - `forward_to_listener`: Requests will be forwarded to the specified `target`
     *    listener
     *  - `forward_to_pool`: Requests will be forwarded to the specified `target` pool
     *  - `https_redirect`: Requests will be redirected to the specified `target` listener.
     *    The listener must have a `protocol` of `http`, and the target listener must have a
     *    `protocol` of `https`
     *  - `redirect`: Requests will be redirected to the specified `target.url`
     *  - `reject`: Requests will be rejected with a `403` status code
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    action: LoadBalancerListenerPolicy.Constants.Action | string;
    /** The date and time that this policy was created. */
    created_at: string;
    /** The URL for this load balancer policy. */
    href: string;
    /** The unique identifier for this load balancer policy. */
    id: string;
    /** The name for this load balancer listener policy. The name is unique across all policies for the load
     *  balancer listener.
     */
    name: string;
    /** Priority of the policy. The priority is unique across all policies for this load balancer listener. Lower
     *  value indicates higher priority.
     */
    priority: number;
    /** The provisioning status of this policy
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    provisioning_status: LoadBalancerListenerPolicy.Constants.ProvisioningStatus | string;
    /** The rules for this policy. */
    rules: LoadBalancerListenerPolicyRuleReference[];
    /** - If `action` is `forward_to_listener`, specify a `LoadBalancerListenerIdentity`
     *  - If `action` is `forward_to_pool`, specify a `LoadBalancerPoolIdentity`
     *  - If `action` is `https_redirect`, the response is a
     *  `LoadBalancerListenerPolicyHTTPSRedirect`
     *  - If `action` is `redirect`, the response is a `LoadBalancerListenerPolicyRedirectURL`.
     */
    target?: LoadBalancerListenerPolicyTarget;
  }
  export namespace LoadBalancerListenerPolicy {
    export namespace Constants {
      /** The policy action: - `forward_to_listener`: Requests will be forwarded to the specified `target` listener - `forward_to_pool`: Requests will be forwarded to the specified `target` pool - `https_redirect`: Requests will be redirected to the specified `target` listener. The listener must have a `protocol` of `http`, and the target listener must have a `protocol` of `https` - `redirect`: Requests will be redirected to the specified `target.url` - `reject`: Requests will be rejected with a `403` status code The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Action {
        FORWARD_TO_LISTENER = 'forward_to_listener',
        FORWARD_TO_POOL = 'forward_to_pool',
        HTTPS_REDIRECT = 'https_redirect',
        REDIRECT = 'redirect',
        REJECT = 'reject',
      }
      /** The provisioning status of this policy The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum ProvisioningStatus {
        ACTIVE = 'active',
        CREATE_PENDING = 'create_pending',
        DELETE_PENDING = 'delete_pending',
        FAILED = 'failed',
        UPDATE_PENDING = 'update_pending',
      }
    }
  }

  /**
   * LoadBalancerListenerPolicyCollection.
   */
  export interface LoadBalancerListenerPolicyCollection {
    /** The policies for the load balancer listener. */
    policies: LoadBalancerListenerPolicy[];
  }

  /**
   * LoadBalancerListenerPolicyPrototype.
   */
  export interface LoadBalancerListenerPolicyPrototype {
    /** The policy action:
     *  - `forward_to_listener`: Requests will be forwarded to the specified
     *    `target` listener.
     *  - `forward_to_pool`: Requests will be forwarded to the specified `target` pool.
     *  - `https_redirect`: Requests will be redirected to the specified `target.listener`.
     *     This listener must have a `protocol` of `http`, and the target listener must
     *     have a `protocol` of `https`.
     *  - `redirect`: Requests will be redirected to the specified `target.url`
     *  - `reject`: Requests will be rejected with a `403` status code.
     */
    action: LoadBalancerListenerPolicyPrototype.Constants.Action | string;
    /** The name for this policy. The name must not be used by another policy for the load balancer listener. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** Priority of the policy. The priority is unique across all policies for this load balancer listener. Lower
     *  value indicates higher priority.
     */
    priority: number;
    /** The rule prototype objects for this policy. */
    rules?: LoadBalancerListenerPolicyRulePrototype[];
    /** - If `action` is `forward_to_listener`, specify a `LoadBalancerListenerIdentity` in this
     *    load balancer to forward to.
     *  - If `action` is `forward_to_pool`, use `LoadBalancerPoolIdentity` to specify a pool in
     *    this load balancer to forward to.
     *  - If `action` is `https_redirect`, use
     *    `LoadBalancerListenerPolicyHTTPSRedirectPrototype` to specify a listener on this
     *    load balancer to redirect to.
     *  - If `action` is `redirect`, use `LoadBalancerListenerPolicyRedirectURLPrototype`to
     *    specify a URL to redirect to.
     */
    target?: LoadBalancerListenerPolicyTargetPrototype;
  }
  export namespace LoadBalancerListenerPolicyPrototype {
    export namespace Constants {
      /** The policy action: - `forward_to_listener`: Requests will be forwarded to the specified `target` listener. - `forward_to_pool`: Requests will be forwarded to the specified `target` pool. - `https_redirect`: Requests will be redirected to the specified `target.listener`. This listener must have a `protocol` of `http`, and the target listener must have a `protocol` of `https`. - `redirect`: Requests will be redirected to the specified `target.url` - `reject`: Requests will be rejected with a `403` status code. */
      export enum Action {
        FORWARD_TO_LISTENER = 'forward_to_listener',
        FORWARD_TO_POOL = 'forward_to_pool',
        HTTPS_REDIRECT = 'https_redirect',
        REDIRECT = 'redirect',
        REJECT = 'reject',
      }
    }
  }

  /**
   * LoadBalancerListenerPolicyReference.
   */
  export interface LoadBalancerListenerPolicyReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this load balancer policy. */
    href: string;
    /** The unique identifier for this load balancer policy. */
    id: string;
    /** The name for this load balancer listener policy. The name is unique across all policies for the load
     *  balancer listener.
     */
    name: string;
  }

  /**
   * LoadBalancerListenerPolicyRule.
   */
  export interface LoadBalancerListenerPolicyRule {
    /** The condition for the rule.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    condition: LoadBalancerListenerPolicyRule.Constants.Condition | string;
    /** The date and time that this rule was created. */
    created_at: string;
    /** The field to match for this rule. If `condition` is not `matches_regex`, the value is percent-encoded. */
    field?: string;
    /** The URL for this load balancer listener policy rule. */
    href: string;
    /** The unique identifier for this load balancer listener policy rule. */
    id: string;
    /** The provisioning status of this rule
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    provisioning_status: LoadBalancerListenerPolicyRule.Constants.ProvisioningStatus | string;
    /** The type of the rule. Body rules are applied to form-encoded request bodies using the
     *  `UTF-8` character set.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    type: LoadBalancerListenerPolicyRule.Constants.Type | string;
    /** The value to be matched for the rule condition.
     *
     *  If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
     */
    value: string;
  }
  export namespace LoadBalancerListenerPolicyRule {
    export namespace Constants {
      /** The condition for the rule. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Condition {
        CONTAINS = 'contains',
        EQUALS = 'equals',
        MATCHES_REGEX = 'matches_regex',
      }
      /** The provisioning status of this rule The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum ProvisioningStatus {
        ACTIVE = 'active',
        CREATE_PENDING = 'create_pending',
        DELETE_PENDING = 'delete_pending',
        FAILED = 'failed',
        UPDATE_PENDING = 'update_pending',
      }
      /** The type of the rule. Body rules are applied to form-encoded request bodies using the `UTF-8` character set. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        BODY = 'body',
        HEADER = 'header',
        HOSTNAME = 'hostname',
        PATH = 'path',
        QUERY = 'query',
        SNI_HOSTNAME = 'sni_hostname',
      }
    }
  }

  /**
   * LoadBalancerListenerPolicyRuleCollection.
   */
  export interface LoadBalancerListenerPolicyRuleCollection {
    /** The rules for the load balancer listener policy. */
    rules: LoadBalancerListenerPolicyRule[];
  }

  /**
   * LoadBalancerListenerPolicyRulePrototype.
   */
  export interface LoadBalancerListenerPolicyRulePrototype {
    /** The condition for the rule. */
    condition: LoadBalancerListenerPolicyRulePrototype.Constants.Condition | string;
    /** The field to match for this rule.
     *  - If the `type` is `header`, this property must be specified.
     *  - If the `type` is `body` or `query`, this property may be specified.
     *  - For all other types, this property must not be specified.
     */
    field?: string;
    /** The content the rule applies to:
     *  - `body`: The UTF-8 form-encoded HTTP request body
     *  - `header`: The HTTP header
     *  - `hostname`: The fully-qualified domain name of the server specified in the Host
     *    HTTP request header
     *  - `path`: The path of the HTTP request
     *  - `query`: The query of the HTTP request URL
     *  - `sni_hostname`: The fully-qualified domain name of the server provided in the
     *    "server name indicator" extension during TLS negotiation
     *
     *  - For listeners with `protocol` `http` or `https`, any type may be specified.
     *  - For listeners with `protocol` `tcp`, only type `sni_hostname` may be specified.
     */
    type: LoadBalancerListenerPolicyRulePrototype.Constants.Type | string;
    /** The value to be matched for the rule condition.
     *
     *  If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
     */
    value: string;
  }
  export namespace LoadBalancerListenerPolicyRulePrototype {
    export namespace Constants {
      /** The condition for the rule. */
      export enum Condition {
        CONTAINS = 'contains',
        EQUALS = 'equals',
        MATCHES_REGEX = 'matches_regex',
      }
      /** The content the rule applies to: - `body`: The UTF-8 form-encoded HTTP request body - `header`: The HTTP header - `hostname`: The fully-qualified domain name of the server specified in the Host HTTP request header - `path`: The path of the HTTP request - `query`: The query of the HTTP request URL - `sni_hostname`: The fully-qualified domain name of the server provided in the "server name indicator" extension during TLS negotiation - For listeners with `protocol` `http` or `https`, any type may be specified. - For listeners with `protocol` `tcp`, only type `sni_hostname` may be specified. */
      export enum Type {
        BODY = 'body',
        HEADER = 'header',
        HOSTNAME = 'hostname',
        PATH = 'path',
        QUERY = 'query',
        SNI_HOSTNAME = 'sni_hostname',
      }
    }
  }

  /**
   * LoadBalancerListenerPolicyRuleReference.
   */
  export interface LoadBalancerListenerPolicyRuleReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this load balancer listener policy rule. */
    href: string;
    /** The unique identifier for this load balancer listener policy rule. */
    id: string;
  }

  /**
   * - If `action` is `forward_to_listener`, specify a `LoadBalancerListenerIdentity`
   * - If `action` is `forward_to_pool`, specify a `LoadBalancerPoolIdentity`
   * - If `action` is `https_redirect`, the response is a
   * `LoadBalancerListenerPolicyHTTPSRedirect`
   * - If `action` is `redirect`, the response is a `LoadBalancerListenerPolicyRedirectURL`.
   */
  export interface LoadBalancerListenerPolicyTarget {
  }

  /**
   * - If `action` is `forward_to_listener`, specify a `LoadBalancerListenerIdentity` for a
   *   listener in this load balancer.
   * - If `action` is `forward_to_pool`, specify a `LoadBalancerPoolIdentity` for a pool in
   *   this load balancer.
   * - If `action` is `https_redirect`, specify a
   *   `LoadBalancerListenerPolicyHTTPSRedirectPatch` for a listener in this load balancer
   *   with a `protocol` of `https`.
   * - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPatch`.
   */
  export interface LoadBalancerListenerPolicyTargetPatch {
  }

  /**
   * - If `action` is `forward_to_listener`, specify a `LoadBalancerListenerIdentity` in this
   *   load balancer to forward to.
   * - If `action` is `forward_to_pool`, use `LoadBalancerPoolIdentity` to specify a pool in
   *   this load balancer to forward to.
   * - If `action` is `https_redirect`, use
   *   `LoadBalancerListenerPolicyHTTPSRedirectPrototype` to specify a listener on this
   *   load balancer to redirect to.
   * - If `action` is `redirect`, use `LoadBalancerListenerPolicyRedirectURLPrototype`to
   *   specify a URL to redirect to.
   */
  export interface LoadBalancerListenerPolicyTargetPrototype {
  }

  /**
   * LoadBalancerListenerPrototypeLoadBalancerContext.
   */
  export interface LoadBalancerListenerPrototypeLoadBalancerContext {
    /** If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load
     *  balancers in the `application` family (otherwise always `false`). Additional restrictions:
     *  - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
     *    match the `accept_proxy_protocol` value of the `https_redirect` listener.
     *  - If this listener is the target of another listener's `https_redirect`, its
     *    `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
     */
    accept_proxy_protocol?: boolean;
    /** The certificate instance to use for SSL termination. The listener must have a `protocol` of `https`. */
    certificate_instance?: CertificateInstanceIdentity;
    /** The concurrent connection limit for the listener. If reached, incoming connections may be queued or
     *  rejected.
     *
     *  Supported for load balancers in the `application` family.
     *
     *  If unspecified, the limit will be `15000` for load balancers in the `application` family.
     */
    connection_limit?: number;
    /** The default pool for this listener.  If `https_redirect` is specified,
     *  the default pool will not be used. If specified, the pool must:
     *
     *  - Belong to this load balancer.
     *  - Have the same `protocol` as this listener, or have a compatible protocol.
     *    At present, the compatible protocols are `http` and `https`.
     *  - Not already be the `default_pool` for another listener.
     *
     *  If unspecified, this listener will be created with no default pool, but one may be
     *  subsequently set.
     */
    default_pool?: LoadBalancerPoolIdentityByName;
    /** The target listener that requests will be redirected to if none of the listener's
     *  `policies` match.
     *
     *  If specified, this listener must have a `protocol` of `http`, and the target
     *  listener must have a `protocol` of `https`.
     */
    https_redirect?: LoadBalancerListenerHTTPSRedirectPrototype;
    /** The idle connection timeout of the listener in seconds.
     *
     *  Supported for load balancers in the `application` family.
     *
     *  If unspecified, the timeout will be `50` for load balancers in the `application` family.
     */
    idle_connection_timeout?: number;
    /** The listener port number. Each listener in the load balancer must have a non-overlapping port range and
     *  `protocol` combination. Protocol values of `tcp`, `http` and `https` share the TCP port space.
     *
     *  If `port_min` is also specified, `port` must have the same value as `port_min`.
     */
    port?: number;
    /** The inclusive upper bound of the range of ports used by this listener. Must not be less than `port_min`.
     *
     *  Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
     *  `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must
     *  be `65535`.
     *
     *  The specified port range must not overlap with port ranges used by other listeners for this load balancer using
     *  the same protocol. Protocol values of `tcp`, `http` and
     *  `https` share the TCP port space.
     */
    port_max?: number;
    /** The inclusive lower bound of the range of ports used by this listener. Must not be greater than `port_max`.
     *
     *  If specified, `port_max` must also be specified, and must not be smaller. If unspecified, `port_max` must also
     *  be unspecified.
     *
     *  If `port` is also specified, `port_min` must have the same value as `port`.
     *
     *  Only network load balancers with `route_mode`, `is_public` or `is_private_path` set to
     *  `true` support different values for `port_min` and `port_max`. If `route_mode` is set to `true`, the value must
     *  be `1`.
     *
     *  The specified port range must not overlap with port ranges used by other listeners for this load balancer using
     *  the same protocol. Protocol values of `tcp`, `http` and
     *  `https` share the TCP port space.
     */
    port_min?: number;
    /** The listener protocol. Each listener in the load balancer must have a non-overlapping port range and
     *  `protocol` combination.
     *
     *  Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in
     *  the `application` family support `tcp`, `http` and
     *  `https`.
     *
     *  Additional restrictions:
     *  - If `default_pool` is set, the pool's protocol must match, or be compatible with
     *    the listener's protocol. At present, the compatible protocols are `http` and
     *    `https`.
     *  - If `https_redirect` is set, the protocol must be `http`.
     */
    protocol: LoadBalancerListenerPrototypeLoadBalancerContext.Constants.Protocol | string;
  }
  export namespace LoadBalancerListenerPrototypeLoadBalancerContext {
    export namespace Constants {
      /** The listener protocol. Each listener in the load balancer must have a non-overlapping port range and `protocol` combination. Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the `application` family support `tcp`, `http` and `https`. Additional restrictions: - If `default_pool` is set, the pool's protocol must match, or be compatible with the listener's protocol. At present, the compatible protocols are `http` and `https`. - If `https_redirect` is set, the protocol must be `http`. */
      export enum Protocol {
        HTTP = 'http',
        HTTPS = 'https',
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * LoadBalancerListenerReference.
   */
  export interface LoadBalancerListenerReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this load balancer listener. */
    href: string;
    /** The unique identifier for this load balancer listener. */
    id: string;
  }

  /**
   * LoadBalancerLogging.
   */
  export interface LoadBalancerLogging {
    /** The datapath logging configuration for this load balancer. */
    datapath: LoadBalancerLoggingDatapath;
  }

  /**
   * The datapath logging configuration for this load balancer.
   */
  export interface LoadBalancerLoggingDatapath {
    /** Indicates whether datapath logging is active for this load balancer. */
    active: boolean;
  }

  /**
   * The datapath logging configuration for this load balancer.
   */
  export interface LoadBalancerLoggingDatapathPatch {
    /** Indicates whether datapath logging will be active for this load balancer. */
    active?: boolean;
  }

  /**
   * The datapath logging configuration for this load balancer.
   */
  export interface LoadBalancerLoggingDatapathPrototype {
    /** Indicates whether datapath logging will be active for this load balancer. */
    active?: boolean;
  }

  /**
   * LoadBalancerLoggingPatch.
   */
  export interface LoadBalancerLoggingPatch {
    /** The datapath logging configuration for this load balancer. */
    datapath?: LoadBalancerLoggingDatapathPatch;
  }

  /**
   * LoadBalancerLoggingPrototype.
   */
  export interface LoadBalancerLoggingPrototype {
    /** The datapath logging configuration for this load balancer. */
    datapath?: LoadBalancerLoggingDatapathPrototype;
  }

  /**
   * LoadBalancerPool.
   */
  export interface LoadBalancerPool {
    /** The load balancing algorithm.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    algorithm: LoadBalancerPool.Constants.Algorithm | string;
    /** The date and time that this pool was created. */
    created_at: string;
    failsafe_policy: LoadBalancerPoolFailsafePolicy;
    /** The health monitor of this pool.
     *
     *  If this pool has a member targeting a load balancer then:
     *
     *  - If the targeted load balancer has multiple subnets, this health monitor is used to
     *    direct traffic to the available subnets.
     *  - The health checks spawned by this health monitor is handled as any other traffic
     *    (that is, subject to the configuration of listeners and pools on the target load
     *    balancer).
     *  - This health monitor does not affect how pool member health is determined within the
     *    target load balancer.
     *
     *  For more information, see [Private Path network load balancer frequently asked
     *  questions](https://cloud.ibm.com/docs/vpc?topic=vpc-nlb-faqs#ppnlb-faqs).
     */
    health_monitor: LoadBalancerPoolHealthMonitor;
    /** The URL for this load balancer pool. */
    href: string;
    /** The unique identifier for this load balancer pool. */
    id: string;
    /** The instance group that is managing this pool. */
    instance_group?: InstanceGroupReference;
    /** The backend server members of the pool. */
    members?: LoadBalancerPoolMemberReference[];
    /** The name for this load balancer pool. The name is unique across all pools for the load balancer. */
    name: string;
    /** The protocol for this load balancer pool.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    protocol: LoadBalancerPool.Constants.Protocol | string;
    /** The provisioning status of this pool
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    provisioning_status: LoadBalancerPool.Constants.ProvisioningStatus | string;
    /** The PROXY protocol setting for this pool:
     *  - `v1`: Enabled with version 1 (human-readable header format)
     *  - `v2`: Enabled with version 2 (binary header format)
     *  - `disabled`: Disabled
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    proxy_protocol: LoadBalancerPool.Constants.ProxyProtocol | string;
    /** The session persistence of this pool.
     *
     *  If absent, session persistence will be disabled, and traffic will be distributed
     *  across backend server members of the pool.
     */
    session_persistence?: LoadBalancerPoolSessionPersistence;
  }
  export namespace LoadBalancerPool {
    export namespace Constants {
      /** The load balancing algorithm. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Algorithm {
        LEAST_CONNECTIONS = 'least_connections',
        ROUND_ROBIN = 'round_robin',
        WEIGHTED_ROUND_ROBIN = 'weighted_round_robin',
      }
      /** The protocol for this load balancer pool. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Protocol {
        HTTP = 'http',
        HTTPS = 'https',
        TCP = 'tcp',
        UDP = 'udp',
      }
      /** The provisioning status of this pool The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum ProvisioningStatus {
        ACTIVE = 'active',
        CREATE_PENDING = 'create_pending',
        DELETE_PENDING = 'delete_pending',
        FAILED = 'failed',
        UPDATE_PENDING = 'update_pending',
      }
      /** The PROXY protocol setting for this pool: - `v1`: Enabled with version 1 (human-readable header format) - `v2`: Enabled with version 2 (binary header format) - `disabled`: Disabled The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum ProxyProtocol {
        DISABLED = 'disabled',
        V1 = 'v1',
        V2 = 'v2',
      }
    }
  }

  /**
   * LoadBalancerPoolCollection.
   */
  export interface LoadBalancerPoolCollection {
    /** The pools for the load balancer. */
    pools: LoadBalancerPool[];
  }

  /**
   * LoadBalancerPoolFailsafePolicy.
   */
  export interface LoadBalancerPoolFailsafePolicy {
    /** A load balancer failsafe policy action:
     *  - `bypass`: Bypasses the members and sends requests directly to their destination IPs.
     *  - `drop`: Drops requests.
     *  - `fail`: Fails requests with an HTTP `503` status code.
     *  - `forward`: Forwards requests to the `target` pool.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    action: LoadBalancerPoolFailsafePolicy.Constants.Action | string;
    /** The healthy member count at which the failsafe policy action will be triggered. At present, this is always
     *  `0`, but may be modifiable in the future.
     */
    healthy_member_threshold_count: number;
    /** If `action` is `forward`, the target pool to forward to.
     *
     *  If `action` is not `forward`, this property will be absent.
     *
     *  The targets supported by this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    target?: LoadBalancerPoolReference;
  }
  export namespace LoadBalancerPoolFailsafePolicy {
    export namespace Constants {
      /** A load balancer failsafe policy action: - `bypass`: Bypasses the members and sends requests directly to their destination IPs. - `drop`: Drops requests. - `fail`: Fails requests with an HTTP `503` status code. - `forward`: Forwards requests to the `target` pool. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Action {
        BYPASS = 'bypass',
        DROP = 'drop',
        FAIL = 'fail',
        FORWARD = 'forward',
      }
    }
  }

  /**
   * The failsafe policy for this load balancer pool.
   */
  export interface LoadBalancerPoolFailsafePolicyPatch {
    /** A load balancer failsafe policy action:
     *  - `bypass`: Bypasses the members and sends requests directly to their destination IPs. If specified, this load
     *  balancer must have `route_mode` enabled.
     *  - `drop`: Drops requests. If specified, the pool protocol must be `tcp`.
     *  - `fail`: Fails requests with an HTTP `503` status code. If specified, the pool protocol must be `http` or
     *  `https`.
     *  - `forward`: Forwards requests to the `target` pool. If specified, the pool protocol must be `http` or `https`.
     *
     *  The specified value must be listed in the `failsafe_policy_actions` for this pool's load balancer.
     */
    action?: LoadBalancerPoolFailsafePolicyPatch.Constants.Action | string;
    /** The failsafe target pool to forward to.
     *
     *  The specified pool must:
     *  - Belong to this load balancer
     *  - Have the same `protocol` as this pool, or have a compatible protocol.
     *    At present, the compatible protocols are `http` and `https`.
     *  - Not have a `failsafe_policy.action` of `forward` or `bypass`.
     *
     *  If specified, `action` must be `forward`.
     *
     *  Specify `null` to remove an existing failsafe target pool.
     */
    target?: LoadBalancerPoolFailsafePolicyTargetPatch;
  }
  export namespace LoadBalancerPoolFailsafePolicyPatch {
    export namespace Constants {
      /** A load balancer failsafe policy action: - `bypass`: Bypasses the members and sends requests directly to their destination IPs. If specified, this load balancer must have `route_mode` enabled. - `drop`: Drops requests. If specified, the pool protocol must be `tcp`. - `fail`: Fails requests with an HTTP `503` status code. If specified, the pool protocol must be `http` or `https`. - `forward`: Forwards requests to the `target` pool. If specified, the pool protocol must be `http` or `https`. The specified value must be listed in the `failsafe_policy_actions` for this pool's load balancer. */
      export enum Action {
        BYPASS = 'bypass',
        DROP = 'drop',
        FAIL = 'fail',
        FORWARD = 'forward',
      }
    }
  }

  /**
   * LoadBalancerPoolFailsafePolicyPrototype.
   */
  export interface LoadBalancerPoolFailsafePolicyPrototype {
    /** A load balancer failsafe policy action:
     *  - `bypass`: Bypasses the members and sends requests directly to their destination IPs. If specified, this load
     *  balancer must have `route_mode` enabled.
     *  - `drop`: Drops requests. If specified, the pool protocol must be `tcp`.
     *  - `fail`: Fails requests with an HTTP `503` status code. If specified, the pool protocol must be `http` or
     *  `https`.
     *  - `forward`: Forwards requests to the `target` pool. If specified, the pool protocol must be `http` or `https`.
     *
     *  The specified value must be listed in the `failsafe_policy_actions` for this pool's load balancer.
     */
    action?: LoadBalancerPoolFailsafePolicyPrototype.Constants.Action | string;
    /** The failsafe target pool to forward to.
     *
     *  The specified pool must:
     *  - Belong to this load balancer
     *  - Have the same `protocol` as this pool, or have a compatible protocol.
     *    At present, the compatible protocols are `http` and `https`.
     *  - Have a `failsafe_policy.action` of `fail` or `drop`
     *
     *  If specified, `action` must be `forward`.
     */
    target?: LoadBalancerPoolIdentity;
  }
  export namespace LoadBalancerPoolFailsafePolicyPrototype {
    export namespace Constants {
      /** A load balancer failsafe policy action: - `bypass`: Bypasses the members and sends requests directly to their destination IPs. If specified, this load balancer must have `route_mode` enabled. - `drop`: Drops requests. If specified, the pool protocol must be `tcp`. - `fail`: Fails requests with an HTTP `503` status code. If specified, the pool protocol must be `http` or `https`. - `forward`: Forwards requests to the `target` pool. If specified, the pool protocol must be `http` or `https`. The specified value must be listed in the `failsafe_policy_actions` for this pool's load balancer. */
      export enum Action {
        BYPASS = 'bypass',
        DROP = 'drop',
        FAIL = 'fail',
        FORWARD = 'forward',
      }
    }
  }

  /**
   * The failsafe target pool to forward to.
   *
   * The specified pool must:
   * - Belong to this load balancer
   * - Have the same `protocol` as this pool, or have a compatible protocol.
   *   At present, the compatible protocols are `http` and `https`.
   * - Not have a `failsafe_policy.action` of `forward` or `bypass`.
   *
   * If specified, `action` must be `forward`.
   *
   * Specify `null` to remove an existing failsafe target pool.
   */
  export interface LoadBalancerPoolFailsafePolicyTargetPatch {
  }

  /**
   * LoadBalancerPoolHealthMonitor.
   */
  export interface LoadBalancerPoolHealthMonitor {
    /** The seconds to wait between health checks. */
    delay: number;
    /** The health check max retries. */
    max_retries: number;
    /** The health check port.
     *
     *  If present, this overrides the pool member port values.
     */
    port?: number;
    /** The seconds to wait for a response to a health check. */
    timeout: number;
    /** The protocol type used for health checks.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    type: LoadBalancerPoolHealthMonitor.Constants.Type | string;
  }
  export namespace LoadBalancerPoolHealthMonitor {
    export namespace Constants {
      /** The protocol type used for health checks. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        HTTP = 'http',
        HTTPS = 'https',
        TCP = 'tcp',
      }
    }
  }

  /**
   * LoadBalancerPoolHealthMonitorPatch.
   */
  export interface LoadBalancerPoolHealthMonitorPatch {
    /** The seconds to wait between health checks.  Must be greater than `timeout`. */
    delay: number;
    /** The health check max retries. */
    max_retries: number;
    /** The health check port.
     *
     *  If set, this overrides the pool member port values.
     *
     *  Specify `null` to remove an existing health check port.
     */
    port?: number;
    /** The seconds to wait for a response to a health check.  Must be less than `delay`. */
    timeout: number;
    /** The protocol type to use for health checks. */
    type: LoadBalancerPoolHealthMonitorPatch.Constants.Type | string;
    /** The health check URL path.  If specified, `type` must be `http` or `https`.
     *
     *  Must be in the format of an [origin-form request target](https://tools.ietf.org/html/rfc7230#section-5.3.1).
     *
     *  Specify `null` to remove a url_path.
     */
    url_path?: string;
  }
  export namespace LoadBalancerPoolHealthMonitorPatch {
    export namespace Constants {
      /** The protocol type to use for health checks. */
      export enum Type {
        HTTP = 'http',
        HTTPS = 'https',
        TCP = 'tcp',
      }
    }
  }

  /**
   * LoadBalancerPoolHealthMonitorPrototype.
   */
  export interface LoadBalancerPoolHealthMonitorPrototype {
    /** The seconds to wait between health checks.  Must be greater than `timeout`. */
    delay: number;
    /** The health check max retries. */
    max_retries: number;
    /** The health check port.
     *
     *  If specified, this overrides the pool member port values.
     */
    port?: number;
    /** The seconds to wait for a response to a health check.  Must be less than `delay`. */
    timeout: number;
    /** The protocol type to use for health checks. */
    type: LoadBalancerPoolHealthMonitorPrototype.Constants.Type | string;
  }
  export namespace LoadBalancerPoolHealthMonitorPrototype {
    export namespace Constants {
      /** The protocol type to use for health checks. */
      export enum Type {
        HTTP = 'http',
        HTTPS = 'https',
        TCP = 'tcp',
      }
    }
  }

  /**
   * Identifies a load balancer pool by a unique property.
   */
  export interface LoadBalancerPoolIdentity {
  }

  /**
   * LoadBalancerPoolIdentityByName.
   */
  export interface LoadBalancerPoolIdentityByName {
    /** The name for this load balancer pool. The name is unique across all pools for the load balancer. */
    name: string;
  }

  /**
   * LoadBalancerPoolMember.
   */
  export interface LoadBalancerPoolMember {
    /** The date and time that this member was created. */
    created_at: string;
    /** Health of the server member in the pool.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    health: LoadBalancerPoolMember.Constants.Health | string;
    /** The URL for this load balancer pool member. */
    href: string;
    /** The unique identifier for this load balancer pool member. */
    id: string;
    /** The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on
     *  a listener with a single port. (If the traffic is received on a listener with a port range, the member will
     *  receive the traffic on the same port the listener received it on.)
     *
     *  This port will also be used for health checks unless the `port` property of
     *  `health_monitor` property is specified.
     */
    port: number;
    /** The provisioning status of this member
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    provisioning_status: LoadBalancerPoolMember.Constants.ProvisioningStatus | string;
    /** The pool member target. */
    target: LoadBalancerPoolMemberTarget;
    /** The weight of the server member.
     *
     *  This property will be present if the pool algorithm is `weighted_round_robin`.
     */
    weight?: number;
  }
  export namespace LoadBalancerPoolMember {
    export namespace Constants {
      /** Health of the server member in the pool. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Health {
        FAULTED = 'faulted',
        OK = 'ok',
        UNKNOWN = 'unknown',
      }
      /** The provisioning status of this member The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum ProvisioningStatus {
        ACTIVE = 'active',
        CREATE_PENDING = 'create_pending',
        DELETE_PENDING = 'delete_pending',
        FAILED = 'failed',
        UPDATE_PENDING = 'update_pending',
      }
    }
  }

  /**
   * LoadBalancerPoolMemberCollection.
   */
  export interface LoadBalancerPoolMemberCollection {
    /** The members for the load balancer pool. */
    members: LoadBalancerPoolMember[];
  }

  /**
   * LoadBalancerPoolMemberPrototype.
   */
  export interface LoadBalancerPoolMemberPrototype {
    /** The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on
     *  a listener with a single port. (If the traffic is received on a listener with a port range, the member will
     *  receive the traffic on the same port the listener received it on.)
     *
     *  This port will also be used for health checks unless the `port` property of
     *  `health_monitor` property is specified.
     *
     *  The port must be unique across all members for all pools associated with this pool's listener.
     *
     *  For load balancers in the `network` family, the same `port` and `target` tuple cannot be shared by a pool member
     *  of any other load balancer in the same VPC.
     */
    port: number;
    /** The pool member target.
     *
     *  If the load balancer has `route_mode` set to `true`, the member must be in a zone the load
     *  balancer has a subnet in.
     *
     *  For load balancers in the `network` family, the same `port` and `target` tuple cannot
     *  be shared by a pool member of any other load balancer in the same VPC.
     */
    target: LoadBalancerPoolMemberTargetPrototype;
    /** The weight of the server member.
     *
     *  If specified, the pool algorithm must be `weighted_round_robin` and the load balancer must be in the
     *  `application` family.
     *
     *  If unspecified, the weight will be `50` for load balancers in the `application` family.
     */
    weight?: number;
  }

  /**
   * LoadBalancerPoolMemberReference.
   */
  export interface LoadBalancerPoolMemberReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this load balancer pool member. */
    href: string;
    /** The unique identifier for this load balancer pool member. */
    id: string;
  }

  /**
   * The pool member target.
   */
  export interface LoadBalancerPoolMemberTarget {
  }

  /**
   * The pool member target.
   *
   * If the load balancer has `route_mode` set to `true`, the member must be in a zone the load balancer has a subnet
   * in.
   *
   * For load balancers in the `network` family, the same `port` and `target` tuple cannot be shared by a pool member of
   * any other load balancer in the same VPC.
   */
  export interface LoadBalancerPoolMemberTargetPrototype {
  }

  /**
   * LoadBalancerPoolPrototypeLoadBalancerContext.
   */
  export interface LoadBalancerPoolPrototypeLoadBalancerContext {
    /** The load balancing algorithm. The `least_connections` algorithm is only supported for load balancers that
     *  have `availability` with value `subnet` in the profile.
     */
    algorithm: LoadBalancerPoolPrototypeLoadBalancerContext.Constants.Algorithm | string;
    /** The health monitor of this pool.
     *
     *  If this pool has a member targeting a load balancer then:
     *
     *  - If the targeted load balancer has multiple subnets, this health monitor will be
     *    used to direct traffic to the available subnets.
     *  - The health checks spawned by this health monitor will be handled as any other
     *    traffic (that is, subject to the configuration of listeners and pools on the target
     *    load balancer).
     *  - This health monitor does not affect how pool member health is determined within the
     *    target load balancer.
     *
     *  For more information, see [Private Path network load balancer frequently asked
     *  questions](https://cloud.ibm.com/docs/vpc?topic=vpc-nlb-faqs#ppnlb-faqs).
     */
    health_monitor: LoadBalancerPoolHealthMonitorPrototype;
    /** The members for this load balancer pool. For load balancers in the `network` family, the same `port` and
     *  `target` tuple cannot be shared by a pool member of any other load balancer in the same VPC.
     */
    members?: LoadBalancerPoolMemberPrototype[];
    /** The name for this load balancer pool. The name must not be used by another pool for the load balancer. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The protocol used for this load balancer pool. Load balancers in the `network` family support `tcp` and
     *  `udp` (if `udp_supported` is `true`). Load balancers in the
     *  `application` family support `tcp`, `http`, and `https`.
     */
    protocol: LoadBalancerPoolPrototypeLoadBalancerContext.Constants.Protocol | string;
    /** The PROXY protocol setting for this pool:
     *  - `v1`: Enabled with version 1 (human-readable header format)
     *  - `v2`: Enabled with version 2 (binary header format)
     *  - `disabled`: Disabled
     *
     *  For load balancers in the `network` family, this property must be `disabled`.
     */
    proxy_protocol?: LoadBalancerPoolPrototypeLoadBalancerContext.Constants.ProxyProtocol | string;
    /** The session persistence of this pool. If specified, the load balancer must have
     *  `source_ip_session_persistence_supported` set to `true` in its profile.
     *
     *  If unspecified, session persistence will be disabled, and traffic will be distributed
     *  across members of the pool.
     */
    session_persistence?: LoadBalancerPoolSessionPersistencePrototype;
  }
  export namespace LoadBalancerPoolPrototypeLoadBalancerContext {
    export namespace Constants {
      /** The load balancing algorithm. The `least_connections` algorithm is only supported for load balancers that have `availability` with value `subnet` in the profile. */
      export enum Algorithm {
        LEAST_CONNECTIONS = 'least_connections',
        ROUND_ROBIN = 'round_robin',
        WEIGHTED_ROUND_ROBIN = 'weighted_round_robin',
      }
      /** The protocol used for this load balancer pool. Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the `application` family support `tcp`, `http`, and `https`. */
      export enum Protocol {
        HTTP = 'http',
        HTTPS = 'https',
        TCP = 'tcp',
        UDP = 'udp',
      }
      /** The PROXY protocol setting for this pool: - `v1`: Enabled with version 1 (human-readable header format) - `v2`: Enabled with version 2 (binary header format) - `disabled`: Disabled For load balancers in the `network` family, this property must be `disabled`. */
      export enum ProxyProtocol {
        DISABLED = 'disabled',
        V1 = 'v1',
        V2 = 'v2',
      }
    }
  }

  /**
   * LoadBalancerPoolReference.
   */
  export interface LoadBalancerPoolReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this load balancer pool. */
    href: string;
    /** The unique identifier for this load balancer pool. */
    id: string;
    /** The name for this load balancer pool. The name is unique across all pools for the load balancer. */
    name: string;
  }

  /**
   * LoadBalancerPoolSessionPersistence.
   */
  export interface LoadBalancerPoolSessionPersistence {
    /** The session persistence cookie name. */
    cookie_name?: string;
    /** The session persistence type.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    type: LoadBalancerPoolSessionPersistence.Constants.Type | string;
  }
  export namespace LoadBalancerPoolSessionPersistence {
    export namespace Constants {
      /** The session persistence type. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        APP_COOKIE = 'app_cookie',
        HTTP_COOKIE = 'http_cookie',
        SOURCE_IP = 'source_ip',
      }
    }
  }

  /**
   * The session persistence configuration. Specify `null` to remove any existing session persistence configuration.
   */
  export interface LoadBalancerPoolSessionPersistencePatch {
    /** The session persistence cookie name. Names starting with `IBM` are not allowed.
     *
     *  If specified, the session persistence type must be `app_cookie`.
     */
    cookie_name?: string;
    /** The session persistence type.
     *
     *  If `http_cookie` or `app_cookie` is specified, the pool protocol must be `http` or
     *  `https`.
     */
    type?: LoadBalancerPoolSessionPersistencePatch.Constants.Type | string;
  }
  export namespace LoadBalancerPoolSessionPersistencePatch {
    export namespace Constants {
      /** The session persistence type. If `http_cookie` or `app_cookie` is specified, the pool protocol must be `http` or `https`. */
      export enum Type {
        APP_COOKIE = 'app_cookie',
        HTTP_COOKIE = 'http_cookie',
        SOURCE_IP = 'source_ip',
      }
    }
  }

  /**
   * LoadBalancerPoolSessionPersistencePrototype.
   */
  export interface LoadBalancerPoolSessionPersistencePrototype {
    /** The session persistence cookie name. Names starting with `IBM` are not allowed.
     *
     *  If specified, the session persistence type must be `app_cookie`.
     */
    cookie_name?: string;
    /** The session persistence type.
     *
     *  If `http_cookie` or `app_cookie` is specified, the pool protocol must be `http` or
     *  `https`.
     */
    type: LoadBalancerPoolSessionPersistencePrototype.Constants.Type | string;
  }
  export namespace LoadBalancerPoolSessionPersistencePrototype {
    export namespace Constants {
      /** The session persistence type. If `http_cookie` or `app_cookie` is specified, the pool protocol must be `http` or `https`. */
      export enum Type {
        APP_COOKIE = 'app_cookie',
        HTTP_COOKIE = 'http_cookie',
        SOURCE_IP = 'source_ip',
      }
    }
  }

  /**
   * LoadBalancerProfile.
   */
  export interface LoadBalancerProfile {
    access_modes: LoadBalancerProfileAccessModes;
    availability: LoadBalancerProfileAvailability;
    failsafe_policy_actions: LoadBalancerProfileFailsafePolicyActions;
    /** The product family this load balancer profile belongs to.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    family: LoadBalancerProfile.Constants.Family | string;
    /** The URL for this load balancer profile. */
    href: string;
    instance_groups_supported: LoadBalancerProfileInstanceGroupsSupported;
    /** Indicates which logging type(s) are supported for a load balancer with this profile. */
    logging_supported: LoadBalancerProfileLoggingSupported;
    /** The globally unique name for this load balancer profile. */
    name: string;
    route_mode_supported: LoadBalancerProfileRouteModeSupported;
    security_groups_supported: LoadBalancerProfileSecurityGroupsSupported;
    source_ip_session_persistence_supported: LoadBalancerProfileSourceIPSessionPersistenceSupported;
    /** The load balancer profiles that load balancers with this profile can target. */
    targetable_load_balancer_profiles: LoadBalancerProfileReference[];
    udp_supported: LoadBalancerProfileUDPSupported;
  }
  export namespace LoadBalancerProfile {
    export namespace Constants {
      /** The product family this load balancer profile belongs to. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Family {
        APPLICATION = 'application',
        NETWORK = 'network',
      }
    }
  }

  /**
   * LoadBalancerProfileAccessModes.
   */
  export interface LoadBalancerProfileAccessModes {
    /** The type for this profile field. */
    type: LoadBalancerProfileAccessModes.Constants.Type | string;
    /** The access modes supported by load balancers with this profile. */
    values: LoadBalancerProfileAccessModes.Constants.Values[] | string[];
  }
  export namespace LoadBalancerProfileAccessModes {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The access modes supported by load balancers with this profile. */
      export enum Values {
        PRIVATE = 'private',
        PRIVATE_PATH = 'private_path',
        PUBLIC = 'public',
      }
    }
  }

  /**
   * LoadBalancerProfileAvailability.
   */
  export interface LoadBalancerProfileAvailability {
  }

  /**
   * LoadBalancerProfileCollection.
   */
  export interface LoadBalancerProfileCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of load balancer profiles. */
    profiles: LoadBalancerProfile[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * LoadBalancerProfileFailsafePolicyActions.
   */
  export interface LoadBalancerProfileFailsafePolicyActions {
  }

  /**
   * Identifies a load balancer profile by a unique property.
   */
  export interface LoadBalancerProfileIdentity {
  }

  /**
   * LoadBalancerProfileInstanceGroupsSupported.
   */
  export interface LoadBalancerProfileInstanceGroupsSupported {
  }

  /**
   * Indicates which logging type(s) are supported for a load balancer with this profile.
   */
  export interface LoadBalancerProfileLoggingSupported {
    /** The type for this profile field. */
    type: LoadBalancerProfileLoggingSupported.Constants.Type | string;
    /** The supported logging type(s) for a load balancer with this profile. */
    value: string[];
  }
  export namespace LoadBalancerProfileLoggingSupported {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * LoadBalancerProfileReference.
   */
  export interface LoadBalancerProfileReference {
    /** The product family this load balancer profile belongs to.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    family: LoadBalancerProfileReference.Constants.Family | string;
    /** The URL for this load balancer profile. */
    href: string;
    /** The globally unique name for this load balancer profile. */
    name: string;
  }
  export namespace LoadBalancerProfileReference {
    export namespace Constants {
      /** The product family this load balancer profile belongs to. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Family {
        APPLICATION = 'application',
        NETWORK = 'network',
      }
    }
  }

  /**
   * LoadBalancerProfileRouteModeSupported.
   */
  export interface LoadBalancerProfileRouteModeSupported {
  }

  /**
   * LoadBalancerProfileSecurityGroupsSupported.
   */
  export interface LoadBalancerProfileSecurityGroupsSupported {
  }

  /**
   * LoadBalancerProfileSourceIPSessionPersistenceSupported.
   */
  export interface LoadBalancerProfileSourceIPSessionPersistenceSupported {
  }

  /**
   * LoadBalancerProfileUDPSupported.
   */
  export interface LoadBalancerProfileUDPSupported {
  }

  /**
   * LoadBalancerReference.
   */
  export interface LoadBalancerReference {
    /** The CRN for this load balancer. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this load balancer. */
    href: string;
    /** The unique identifier for this load balancer. */
    id: string;
    /** The name for this load balancer. The name is unique across all load balancers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: LoadBalancerReference.Constants.ResourceType | string;
  }
  export namespace LoadBalancerReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        LOAD_BALANCER = 'load_balancer',
      }
    }
  }

  /**
   * LoadBalancerStatistics.
   */
  export interface LoadBalancerStatistics {
    /** Number of active connections of this load balancer. */
    active_connections: number;
    /** Current connection rate (connections per second) of this load balancer. */
    connection_rate: number;
    /** Total number of data processed (bytes) of this load balancer within current calendar month. */
    data_processed_this_month: number;
    /** Current throughput (Mbps) of this load balancer. */
    throughput: number;
  }

  /**
   * NetworkACL.
   */
  export interface NetworkACL {
    /** The date and time that the network ACL was created. */
    created_at: string;
    /** The CRN for this network ACL. */
    crn: string;
    /** The URL for this network ACL. */
    href: string;
    /** The unique identifier for this network ACL. */
    id: string;
    /** The name for this network ACL. The name is unique across all network ACLs for the VPC. */
    name: string;
    /** The resource group for this network ACL. */
    resource_group: ResourceGroupReference;
    /** The ordered rules for this network ACL. If no rules exist, no traffic will be allowed. */
    rules: NetworkACLRuleItem[];
    /** The subnets to which this network ACL is attached. */
    subnets: SubnetReference[];
    /** The VPC this network ACL resides in. */
    vpc: VPCReference;
  }

  /**
   * NetworkACLCollection.
   */
  export interface NetworkACLCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A page of network ACLs. */
    network_acls: NetworkACL[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Identifies a network ACL by a unique property.
   */
  export interface NetworkACLIdentity {
  }

  /**
   * NetworkACLPrototype.
   */
  export interface NetworkACLPrototype {
    /** The name for this network ACL. The name must not be used by another network ACL for the VPC. If unspecified,
     *  the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The VPC this network ACL will reside in. */
    vpc: VPCIdentity;
  }

  /**
   * NetworkACLReference.
   */
  export interface NetworkACLReference {
    /** The CRN for this network ACL. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this network ACL. */
    href: string;
    /** The unique identifier for this network ACL. */
    id: string;
    /** The name for this network ACL. The name is unique across all network ACLs for the VPC. */
    name: string;
  }

  /**
   * NetworkACLRule.
   */
  export interface NetworkACLRule {
    /** The action to perform for a packet matching the rule. */
    action: NetworkACLRule.Constants.Action | string;
    /** The rule that this rule is immediately before. If absent, this is the last rule. */
    before?: NetworkACLRuleReference;
    /** The date and time that the rule was created. */
    created_at: string;
    /** The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination
     *  addresses.
     */
    destination: string;
    /** The direction of traffic to match. */
    direction: NetworkACLRule.Constants.Direction | string;
    /** The URL for this network ACL rule. */
    href: string;
    /** The unique identifier for this network ACL rule. */
    id: string;
    /** The IP version for this rule. */
    ip_version: NetworkACLRule.Constants.IpVersion | string;
    /** The name for this network ACL rule. The name is unique across all rules for the network ACL. */
    name: string;
    /** The name of the network protocol.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    protocol: NetworkACLRule.Constants.Protocol | string;
    /** The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses. */
    source: string;
  }
  export namespace NetworkACLRule {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Protocol {
        ALL = 'all',
        ICMP = 'icmp',
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * The rule to move this rule immediately before.
   *
   * Specify `null` to move this rule after all existing rules.
   */
  export interface NetworkACLRuleBeforePatch {
  }

  /**
   * The rule to insert this rule immediately before.
   *
   * If unspecified, this rule will be inserted after all existing rules.
   */
  export interface NetworkACLRuleBeforePrototype {
  }

  /**
   * NetworkACLRuleCollection.
   */
  export interface NetworkACLRuleCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of ordered rules (sorted based on the `before` property) for the network ACL. */
    rules: NetworkACLRuleItem[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * NetworkACLRuleItem.
   */
  export interface NetworkACLRuleItem {
    /** The action to perform for a packet matching the rule. */
    action: NetworkACLRuleItem.Constants.Action | string;
    /** The rule that this rule is immediately before. In a rule collection, this always
     *  refers to the next item in the collection. If absent, this is the last rule.
     */
    before?: NetworkACLRuleReference;
    /** The date and time that the rule was created. */
    created_at: string;
    /** The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination
     *  addresses.
     */
    destination: string;
    /** The direction of traffic to match. */
    direction: NetworkACLRuleItem.Constants.Direction | string;
    /** The URL for this network ACL rule. */
    href: string;
    /** The unique identifier for this network ACL rule. */
    id: string;
    /** The IP version for this rule. */
    ip_version: NetworkACLRuleItem.Constants.IpVersion | string;
    /** The name for this network ACL rule. The name is unique across all rules for the network ACL. */
    name: string;
    /** The name of the network protocol.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    protocol: NetworkACLRuleItem.Constants.Protocol | string;
    /** The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses. */
    source: string;
  }
  export namespace NetworkACLRuleItem {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Protocol {
        ALL = 'all',
        ICMP = 'icmp',
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * NetworkACLRulePrototype.
   */
  export interface NetworkACLRulePrototype {
    /** The action to perform for a packet matching the rule. */
    action: NetworkACLRulePrototype.Constants.Action | string;
    /** The rule to insert this rule immediately before.
     *
     *  If unspecified, this rule will be inserted after all existing rules.
     */
    before?: NetworkACLRuleBeforePrototype;
    /** The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination
     *  addresses.
     */
    destination: string;
    /** The direction of traffic to match. */
    direction: NetworkACLRulePrototype.Constants.Direction | string;
    /** The IP version for this rule. */
    ip_version?: NetworkACLRulePrototype.Constants.IpVersion | string;
    /** The name for this network ACL rule. The name must not be used by another rule for the network ACL. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The name of the network protocol. */
    protocol: NetworkACLRulePrototype.Constants.Protocol | string;
    /** The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses. */
    source: string;
  }
  export namespace NetworkACLRulePrototype {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ALL = 'all',
        ICMP = 'icmp',
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * NetworkACLRulePrototypeNetworkACLContext.
   */
  export interface NetworkACLRulePrototypeNetworkACLContext {
    /** The action to perform for a packet matching the rule. */
    action: NetworkACLRulePrototypeNetworkACLContext.Constants.Action | string;
    /** The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination
     *  addresses.
     */
    destination: string;
    /** The direction of traffic to match. */
    direction: NetworkACLRulePrototypeNetworkACLContext.Constants.Direction | string;
    /** The IP version for this rule. */
    ip_version?: NetworkACLRulePrototypeNetworkACLContext.Constants.IpVersion | string;
    /** The name for this network ACL rule. The name must not be used by another rule for the network ACL. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The name of the network protocol. */
    protocol: NetworkACLRulePrototypeNetworkACLContext.Constants.Protocol | string;
    /** The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses. */
    source: string;
  }
  export namespace NetworkACLRulePrototypeNetworkACLContext {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ALL = 'all',
        ICMP = 'icmp',
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * NetworkACLRuleReference.
   */
  export interface NetworkACLRuleReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this network ACL rule. */
    href: string;
    /** The unique identifier for this network ACL rule. */
    id: string;
    /** The name for this network ACL rule. The name is unique across all rules for the network ACL. */
    name: string;
  }

  /**
   * NetworkInterface.
   */
  export interface NetworkInterface {
    /** Indicates whether source IP spoofing is allowed on this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and source IP spoofing is managed
     *  on the attached virtual network interface.
     */
    allow_ip_spoofing: boolean;
    /** The date and time that the instance network interface was created.
     *
     *  If this instance has network attachments, this network interface was created as a [read-only
     *  representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) when its corresponding
     *  network attachment was created.
     */
    created_at: string;
    /** The floating IPs associated with this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the floating IPs are associated
     *  with the attached virtual network interface.
     */
    floating_ips: FloatingIPReference[];
    /** The URL for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
    /** The unique identifier for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
    /** The name for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the name matches its
     *  corresponding network attachment.
     */
    name: string;
    /** The instance network interface port speed in Mbps.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the port speed is that of its
     *  corresponding network attachment.
     */
    port_speed: number;
    /** The primary IP address of this instance network interface. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: NetworkInterface.Constants.ResourceType | string;
    /** The security groups targeting this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a [read-only
     *  representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding
     *  network attachment and its attached virtual network interface, and the security groups are associated with the
     *  attached virtual network interface.
     */
    security_groups: SecurityGroupReference[];
    /** The status of the instance network interface.
     *
     *  If this instance has network attachments, this network interface is a read-only representation of its
     *  corresponding network attachment and its attached virtual network interface, and the status is [computed from
     *  them](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients).
     */
    status: NetworkInterface.Constants.Status | string;
    /** The associated subnet. */
    subnet: SubnetReference;
    /** The instance network interface type.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the type is that of its
     *  corresponding network attachment.
     */
    type: NetworkInterface.Constants.Type | string;
  }
  export namespace NetworkInterface {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
      /** The status of the instance network interface. If this instance has network attachments, this network interface is a read-only representation of its corresponding network attachment and its attached virtual network interface, and the status is [computed from them](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients). */
      export enum Status {
        AVAILABLE = 'available',
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
      }
      /** The instance network interface type. If this instance has network attachments, this network interface is a [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding network attachment and its attached virtual network interface, and the type is that of its corresponding network attachment. */
      export enum Type {
        PRIMARY = 'primary',
        SECONDARY = 'secondary',
      }
    }
  }

  /**
   * NetworkInterfaceBareMetalServerContextReference.
   */
  export interface NetworkInterfaceBareMetalServerContextReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
    /** The unique identifier for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
    /** The name for this bare metal server network interface. */
    name: string;
    /** The primary IP address of this bare metal server network interface. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: NetworkInterfaceBareMetalServerContextReference.Constants.ResourceType | string;
    /** The associated subnet. */
    subnet: SubnetReference;
  }
  export namespace NetworkInterfaceBareMetalServerContextReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
    }
  }

  /**
   * NetworkInterfaceIPPrototype.
   */
  export interface NetworkInterfaceIPPrototype {
  }

  /**
   * NetworkInterfaceInstanceContextReference.
   */
  export interface NetworkInterfaceInstanceContextReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
    /** The unique identifier for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
    /** The name for this instance network interface. */
    name: string;
    /** The primary IP address of this instance network interface. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: NetworkInterfaceInstanceContextReference.Constants.ResourceType | string;
    /** The associated subnet. */
    subnet: SubnetReference;
  }
  export namespace NetworkInterfaceInstanceContextReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
    }
  }

  /**
   * NetworkInterfacePrototype.
   */
  export interface NetworkInterfacePrototype {
    /** Indicates whether source IP spoofing is allowed on this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and source IP spoofing is managed
     *  on the attached virtual network interface.
     */
    allow_ip_spoofing?: boolean;
    /** The name for the instance network interface. The name must not be used by another network interface on the
     *  virtual server instance. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The primary IP address to bind to the instance network interface. This can be
     *  specified using an existing reserved IP, or a prototype object for a new reserved IP.
     *
     *  If an existing reserved IP or a prototype object with an address is specified, it must
     *  be available on the instance network interface's subnet. Otherwise, an
     *  available address on the subnet will be automatically selected and reserved.
     */
    primary_ip?: NetworkInterfaceIPPrototype;
    /** The security groups to use for this instance network interface. If unspecified, the VPC's default security
     *  group is used.
     */
    security_groups?: SecurityGroupIdentity[];
    /** The associated subnet. */
    subnet: SubnetIdentity;
  }

  /**
   * NetworkInterfaceUnpaginatedCollection.
   */
  export interface NetworkInterfaceUnpaginatedCollection {
    /** The network interfaces for the instance. */
    network_interfaces: NetworkInterface[];
  }

  /**
   * OperatingSystem.
   */
  export interface OperatingSystem {
    /** Users may create new images with this operating system. */
    allow_user_image_creation: boolean;
    /** The operating system architecture. */
    architecture: string;
    /** Images with this operating system can only be used on dedicated hosts or dedicated host groups. */
    dedicated_host_only: boolean;
    /** A unique, display-friendly name for the operating system. */
    display_name: string;
    /** The software family for this operating system. */
    family: string;
    /** The URL for this operating system. */
    href: string;
    /** The globally unique name for this operating system. */
    name: string;
    /** The user data format for this operating system:
     *  - `cloud_init`: `user_data` will be interpreted according to the cloud-init standard
     *  - `esxi_kickstart`: `user_data` will be interpreted as a VMware ESXi installation script
     *  - `ipxe`: `user_data` will be interpreted as a single URL to an iPXE script or as the
     *    text of an iPXE script.
     */
    user_data_format: OperatingSystem.Constants.UserDataFormat | string;
    /** The vendor of the operating system. */
    vendor: string;
    /** The major release version of this operating system. */
    version: string;
  }
  export namespace OperatingSystem {
    export namespace Constants {
      /** The user data format for this operating system: - `cloud_init`: `user_data` will be interpreted according to the cloud-init standard - `esxi_kickstart`: `user_data` will be interpreted as a VMware ESXi installation script - `ipxe`: `user_data` will be interpreted as a single URL to an iPXE script or as the text of an iPXE script. */
      export enum UserDataFormat {
        CLOUD_INIT = 'cloud_init',
        ESXI_KICKSTART = 'esxi_kickstart',
        IPXE = 'ipxe',
      }
    }
  }

  /**
   * OperatingSystemCollection.
   */
  export interface OperatingSystemCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of operating systems. */
    operating_systems: OperatingSystem[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Identifies an operating system by a unique property.
   */
  export interface OperatingSystemIdentity {
  }

  /**
   * PageLink.
   */
  export interface PageLink {
    /** The URL for a page of resources. */
    href: string;
  }

  /**
   * PlacementGroup.
   */
  export interface PlacementGroup {
    /** The date and time that the placement group was created. */
    created_at: string;
    /** The CRN for this placement group. */
    crn: string;
    /** The URL for this placement group. */
    href: string;
    /** The unique identifier for this placement group. */
    id: string;
    /** The lifecycle state of the placement group. */
    lifecycle_state: PlacementGroup.Constants.LifecycleState | string;
    /** The name for this placement group. The name is unique across all placement groups in the region. */
    name: string;
    /** The resource group for this placement group. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: PlacementGroup.Constants.ResourceType | string;
    /** The strategy for this placement group:
     *  - `host_spread`: place on different compute hosts
     *  - `power_spread`: place on compute hosts that use different power sources
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    strategy: PlacementGroup.Constants.Strategy | string;
  }
  export namespace PlacementGroup {
    export namespace Constants {
      /** The lifecycle state of the placement group. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        PLACEMENT_GROUP = 'placement_group',
      }
      /** The strategy for this placement group: - `host_spread`: place on different compute hosts - `power_spread`: place on compute hosts that use different power sources The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Strategy {
        HOST_SPREAD = 'host_spread',
        POWER_SPREAD = 'power_spread',
      }
    }
  }

  /**
   * PlacementGroupCollection.
   */
  export interface PlacementGroupCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of placement groups. */
    placement_groups: PlacementGroup[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * PrivatePathServiceGateway.
   */
  export interface PrivatePathServiceGateway {
    /** The date and time that the private path service gateway was created. */
    created_at: string;
    /** The CRN for this private path service gateway. */
    crn: string;
    /** The policy to use for bindings from accounts without an explicit account policy. */
    default_access_policy: PrivatePathServiceGateway.Constants.DefaultAccessPolicy | string;
    /** Indicates whether endpoint gateway bindings will be automatically deleted after
     *  `endpoint_gateway_binding_auto_delete_timeout` hours have passed. At present, this is always `true`, but may be
     *  modifiable in the future.
     */
    endpoint_gateway_binding_auto_delete: boolean;
    /** If `endpoint_gateway_binding_auto_delete` is `true`, the hours after which endpoint gateway bindings will be
     *  automatically deleted. If the value is `0`, `abandoned` endpoint gateway bindings will be deleted immediately.
     *  At present, this is always set to `0`. This value may be modifiable in the future.
     */
    endpoint_gateway_binding_auto_delete_timeout: number;
    /** The number of active endpoint gateways using this private path service gateway. */
    endpoint_gateway_count: number;
    /** The URL for this private path service gateway. */
    href: string;
    /** The unique identifier for this private path service gateway. */
    id: string;
    /** The lifecycle state of the private path service gateway. */
    lifecycle_state: PrivatePathServiceGateway.Constants.LifecycleState | string;
    /** The load balancer for this private path service gateway. */
    load_balancer: LoadBalancerReference;
    /** The name for this private path service gateway. The name is unique across all private path service gateways
     *  in the VPC.
     */
    name: string;
    /** Indicates the availability of this private path service gateway
     *  - `true`: Any account can request access to this private path service gateway.
     *  - `false`: Access is restricted to the account that created this private path service gateway.
     */
    published: boolean;
    /** The resource group for this private path service gateway. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: PrivatePathServiceGateway.Constants.ResourceType | string;
    /** The fully qualified domain names for this private path service gateway. The domains are used for endpoint
     *  gateways to connect to the service and are configured in the VPC for each endpoint gateway.
     */
    service_endpoints: string[];
    /** The VPC this private path service gateway resides in. */
    vpc: VPCReference;
    /** Indicates whether this private path service gateway has zonal affinity.
     *  - `true`:  Traffic to the service from a zone the service resides in will remain in
     *             that zone.
     *  - `false`: Traffic to the service from a zone will be load balanced across all zones
     *             in the region the service resides in.
     */
    zonal_affinity: boolean;
  }
  export namespace PrivatePathServiceGateway {
    export namespace Constants {
      /** The policy to use for bindings from accounts without an explicit account policy. */
      export enum DefaultAccessPolicy {
        DENY = 'deny',
        PERMIT = 'permit',
        REVIEW = 'review',
      }
      /** The lifecycle state of the private path service gateway. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        PRIVATE_PATH_SERVICE_GATEWAY = 'private_path_service_gateway',
      }
    }
  }

  /**
   * PrivatePathServiceGatewayAccountPolicy.
   */
  export interface PrivatePathServiceGatewayAccountPolicy {
    /** The access policy for the account:
     *  - permit: access will be permitted
     *  - deny:  access will be denied
     *  - review: access will be manually reviewed
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    access_policy: PrivatePathServiceGatewayAccountPolicy.Constants.AccessPolicy | string;
    /** The account for this access policy. */
    account: AccountReference;
    /** The date and time that the account policy was created. */
    created_at: string;
    /** The URL for this account policy. */
    href: string;
    /** The unique identifier for this account policy. */
    id: string;
    /** The resource type. */
    resource_type: PrivatePathServiceGatewayAccountPolicy.Constants.ResourceType | string;
  }
  export namespace PrivatePathServiceGatewayAccountPolicy {
    export namespace Constants {
      /** The access policy for the account: - permit: access will be permitted - deny:  access will be denied - review: access will be manually reviewed The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AccessPolicy {
        DENY = 'deny',
        PERMIT = 'permit',
        REVIEW = 'review',
      }
      /** The resource type. */
      export enum ResourceType {
        PRIVATE_PATH_SERVICE_GATEWAY_ACCOUNT_POLICY = 'private_path_service_gateway_account_policy',
      }
    }
  }

  /**
   * PrivatePathServiceGatewayAccountPolicyCollection.
   */
  export interface PrivatePathServiceGatewayAccountPolicyCollection {
    /** A page of account policies for the private path service gateway. */
    account_policies: PrivatePathServiceGatewayAccountPolicy[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * PrivatePathServiceGatewayCollection.
   */
  export interface PrivatePathServiceGatewayCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of private path service gateways. */
    private_path_service_gateways: PrivatePathServiceGateway[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * PrivatePathServiceGatewayEndpointGatewayBinding.
   */
  export interface PrivatePathServiceGatewayEndpointGatewayBinding {
    /** The account that created the endpoint gateway. */
    account: AccountReference;
    /** The date and time that the endpoint gateway binding was created. */
    created_at: string;
    /** The expiration date and time for the endpoint gateway binding. At binding creation, this property will be
     *  set to 14 days after the creation time, and will remain while the `status` of the binding is `pending`. If the
     *  date and time are reached while the binding is still `pending`, the binding will transition to `expired`.
     *
     *  This property will be present if the `status` is `pending` or `expired`.
     */
    expiration_at?: string;
    /** The URL for this endpoint gateway binding. */
    href: string;
    /** The unique identifier for this endpoint gateway binding. */
    id: string;
    /** The lifecycle state of the endpoint gateway binding. */
    lifecycle_state: PrivatePathServiceGatewayEndpointGatewayBinding.Constants.LifecycleState | string;
    /** The resource type. */
    resource_type: PrivatePathServiceGatewayEndpointGatewayBinding.Constants.ResourceType | string;
    /** The status of the endpoint gateway binding:
     *  - `abandoned`: endpoint gateway binding is inactive, awaiting deletion.
     *  - `denied`: endpoint gateway binding was denied
     *  - `expired`: endpoint gateway binding has expired
     *  - `pending`: endpoint gateway binding is awaiting review
     *  - `permitted`: endpoint gateway binding was permitted
     *
     *  An endpoint gateway binding will be automatically deleted when its associated endpoint gateway is deleted.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: PrivatePathServiceGatewayEndpointGatewayBinding.Constants.Status | string;
  }
  export namespace PrivatePathServiceGatewayEndpointGatewayBinding {
    export namespace Constants {
      /** The lifecycle state of the endpoint gateway binding. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        PRIVATE_PATH_SERVICE_GATEWAY_ENDPOINT_GATEWAY_BINDING = 'private_path_service_gateway_endpoint_gateway_binding',
      }
      /** The status of the endpoint gateway binding: - `abandoned`: endpoint gateway binding is inactive, awaiting deletion. - `denied`: endpoint gateway binding was denied - `expired`: endpoint gateway binding has expired - `pending`: endpoint gateway binding is awaiting review - `permitted`: endpoint gateway binding was permitted An endpoint gateway binding will be automatically deleted when its associated endpoint gateway is deleted. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        ABANDONED = 'abandoned',
        DENIED = 'denied',
        EXPIRED = 'expired',
        PENDING = 'pending',
        PERMITTED = 'permitted',
      }
    }
  }

  /**
   * PrivatePathServiceGatewayEndpointGatewayBindingCollection.
   */
  export interface PrivatePathServiceGatewayEndpointGatewayBindingCollection {
    /** A page of endpoint gateway bindings for the private path service gateway. */
    endpoint_gateway_bindings: PrivatePathServiceGatewayEndpointGatewayBinding[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * If present, this property indicates that the resource associated with this reference is remote and therefore may
   * not be directly retrievable.
   */
  export interface PrivatePathServiceGatewayRemote {
    /** If present, this property indicates that the referenced resource is remote to this
     *  account, and identifies the owning account.
     */
    account?: AccountReference;
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /**
   * PublicGateway.
   */
  export interface PublicGateway {
    /** The date and time that the public gateway was created. */
    created_at: string;
    /** The CRN for this public gateway. */
    crn: string;
    /** The floating IP bound to this public gateway. */
    floating_ip: PublicGatewayFloatingIp;
    /** The URL for this public gateway. */
    href: string;
    /** The unique identifier for this public gateway. */
    id: string;
    /** The name for this public gateway. The name is unique across all public gateways in the VPC. */
    name: string;
    /** The resource group for this public gateway. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: PublicGateway.Constants.ResourceType | string;
    /** The status of this public gateway. */
    status: PublicGateway.Constants.Status | string;
    /** The VPC this public gateway resides in. */
    vpc: VPCReference;
    /** The zone this public gateway resides in. */
    zone: ZoneReference;
  }
  export namespace PublicGateway {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        PUBLIC_GATEWAY = 'public_gateway',
      }
      /** The status of this public gateway. */
      export enum Status {
        AVAILABLE = 'available',
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
      }
    }
  }

  /**
   * PublicGatewayCollection.
   */
  export interface PublicGatewayCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of public gateways. */
    public_gateways: PublicGateway[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * PublicGatewayFloatingIPPrototype.
   */
  export interface PublicGatewayFloatingIPPrototype {
  }

  /**
   * The floating IP bound to this public gateway.
   */
  export interface PublicGatewayFloatingIp {
    /** The globally unique IP address. */
    address: string;
    /** The CRN for this floating IP. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this floating IP. */
    href: string;
    /** The unique identifier for this floating IP. */
    id: string;
    /** The name for this floating IP. The name is unique across all floating IPs in the region. */
    name: string;
  }

  /**
   * Identifies a public gateway by a unique property.
   */
  export interface PublicGatewayIdentity {
  }

  /**
   * PublicGatewayReference.
   */
  export interface PublicGatewayReference {
    /** The CRN for this public gateway. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this public gateway. */
    href: string;
    /** The unique identifier for this public gateway. */
    id: string;
    /** The name for this public gateway. The name is unique across all public gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: PublicGatewayReference.Constants.ResourceType | string;
  }
  export namespace PublicGatewayReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        PUBLIC_GATEWAY = 'public_gateway',
      }
    }
  }

  /**
   * Region.
   */
  export interface Region {
    /** The API endpoint for this region. */
    endpoint: string;
    /** The URL for this region. */
    href: string;
    /** The globally unique name for this region. */
    name: string;
    /** The availability status of this region.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: Region.Constants.Status | string;
  }
  export namespace Region {
    export namespace Constants {
      /** The availability status of this region. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        AVAILABLE = 'available',
        UNAVAILABLE = 'unavailable',
      }
    }
  }

  /**
   * RegionCollection.
   */
  export interface RegionCollection {
    /** The regions for the account. */
    regions: Region[];
  }

  /**
   * Identifies a region by a unique property.
   */
  export interface RegionIdentity {
  }

  /**
   * RegionReference.
   */
  export interface RegionReference {
    /** The URL for this region. */
    href: string;
    /** The globally unique name for this region. */
    name: string;
  }

  /**
   * Reservation.
   */
  export interface Reservation {
    /** The affinity policy to use for this reservation:
     *  - `automatic`: The reservation will be automatically selected
     *  - `restricted`: The reservation must be manually requested
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    affinity_policy: Reservation.Constants.AffinityPolicy | string;
    /** The capacity configuration for this reservation
     *
     *  If absent, this reservation has no assigned capacity.
     */
    capacity?: ReservationCapacity;
    /** The committed use configuration for this reservation.
     *
     *  If absent, this reservation has no commitment for use.
     */
    committed_use?: ReservationCommittedUse;
    /** The date and time that the reservation was created. */
    created_at: string;
    /** The CRN for this reservation. */
    crn: string;
    /** The URL for this reservation. */
    href: string;
    /** The unique identifier for this reservation. */
    id: string;
    /** The lifecycle state of this reservation. */
    lifecycle_state: Reservation.Constants.LifecycleState | string;
    /** The name for this reservation. The name is unique across all reservations in the region. */
    name: string;
    /** The [instance profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) or
     *  [bare metal server
     *  profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
     *  for this reservation.
     */
    profile: ReservationProfile;
    /** The resource group for this reservation. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: Reservation.Constants.ResourceType | string;
    /** The status of the reservation.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: Reservation.Constants.Status | string;
    /** The reasons for the current status (if any). */
    status_reasons: ReservationStatusReason[];
    /** The zone for this reservation. */
    zone: ZoneReference;
  }
  export namespace Reservation {
    export namespace Constants {
      /** The affinity policy to use for this reservation: - `automatic`: The reservation will be automatically selected - `restricted`: The reservation must be manually requested The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AffinityPolicy {
        AUTOMATIC = 'automatic',
        RESTRICTED = 'restricted',
      }
      /** The lifecycle state of this reservation. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        RESERVATION = 'reservation',
      }
      /** The status of the reservation. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        ACTIVATING = 'activating',
        ACTIVE = 'active',
        DEACTIVATING = 'deactivating',
        EXPIRED = 'expired',
        FAILED = 'failed',
        INACTIVE = 'inactive',
      }
    }
  }

  /**
   * The capacity configuration for this reservation
   *
   * If absent, this reservation has no assigned capacity.
   */
  export interface ReservationCapacity {
    /** The amount allocated to this capacity reservation. */
    allocated: number;
    /** The amount of this capacity reservation available for new attachments. */
    available: number;
    /** The status of the capacity reservation:
     *  - `allocating`: The capacity reservation is being allocated for use
     *  - `allocated`: The total capacity of the reservation has been allocated for use
     *  - `degraded`: The capacity reservation has been allocated for use, but some of the
     *    capacity is not available. See [capacity status
     *    reasons](https://cloud.ibm.com/docs/vpc?topic=vpc-reserved-capacity-status-reasons)
     *    for more information.
     *  - `unallocated`: The capacity reservation is not allocated for use
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: ReservationCapacity.Constants.Status | string;
    /** The total amount of this capacity reservation. */
    total: number;
    /** The amount of this capacity reservation used by existing attachments. */
    used: number;
  }
  export namespace ReservationCapacity {
    export namespace Constants {
      /** The status of the capacity reservation: - `allocating`: The capacity reservation is being allocated for use - `allocated`: The total capacity of the reservation has been allocated for use - `degraded`: The capacity reservation has been allocated for use, but some of the capacity is not available. See [capacity status reasons](https://cloud.ibm.com/docs/vpc?topic=vpc-reserved-capacity-status-reasons) for more information. - `unallocated`: The capacity reservation is not allocated for use The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        ALLOCATED = 'allocated',
        ALLOCATING = 'allocating',
        DEGRADED = 'degraded',
        UNALLOCATED = 'unallocated',
      }
    }
  }

  /**
   * The capacity reservation configuration to use.
   *
   * The configuration can only be changed for reservations with a `status` of `inactive`.
   */
  export interface ReservationCapacityPatch {
    /** The total amount to use for this capacity reservation. */
    total?: number;
  }

  /**
   * The capacity reservation configuration to use.
   */
  export interface ReservationCapacityPrototype {
    /** The total amount to use for this capacity reservation. */
    total: number;
  }

  /**
   * ReservationCollection.
   */
  export interface ReservationCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of reservations. */
    reservations: Reservation[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * The committed use reservation configuration.
   */
  export interface ReservationCommittedUse {
    /** The expiration date and time for this committed use reservation.
     *
     *  This property will be absent if the reservation has a `status` of `inactive`.
     */
    expiration_at?: string;
    /** The policy to apply when the committed use term expires:
     *  - `release`: Release any available capacity and let the reservation expire.
     *  - `renew`: Renew for another term, provided the term remains listed in the
     *    `reservation_terms` for the profile. Otherwise, let the reservation expire.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    expiration_policy: ReservationCommittedUse.Constants.ExpirationPolicy | string;
    /** The term for this committed use reservation:
     *  - `one_year`: 1 year
     *  - `three_year`: 3 years
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    term: string;
  }
  export namespace ReservationCommittedUse {
    export namespace Constants {
      /** The policy to apply when the committed use term expires: - `release`: Release any available capacity and let the reservation expire. - `renew`: Renew for another term, provided the term remains listed in the `reservation_terms` for the profile. Otherwise, let the reservation expire. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum ExpirationPolicy {
        RELEASE = 'release',
        RENEW = 'renew',
      }
    }
  }

  /**
   * ReservationCommittedUsePatch.
   */
  export interface ReservationCommittedUsePatch {
    /** The policy to apply when the committed use term expires:
     *  - `release`: Release any available capacity and let the reservation expire.
     *  - `renew`: Renew for another term, provided the term remains listed in the
     *    `reservation_terms` for the profile. Otherwise, let the reservation expire.
     */
    expiration_policy?: ReservationCommittedUsePatch.Constants.ExpirationPolicy | string;
    /** The term for this committed use reservation:
     *  - `one_year`: 1 year
     *  - `three_year`: 3 years
     *
     *  The specified value must be listed in the `reservation_terms` in the profile for this reservation. The term can
     *  only be changed for a reservation with a `status` of
     *  `inactive`.
     */
    term?: string;
  }
  export namespace ReservationCommittedUsePatch {
    export namespace Constants {
      /** The policy to apply when the committed use term expires: - `release`: Release any available capacity and let the reservation expire. - `renew`: Renew for another term, provided the term remains listed in the `reservation_terms` for the profile. Otherwise, let the reservation expire. */
      export enum ExpirationPolicy {
        RELEASE = 'release',
        RENEW = 'renew',
      }
    }
  }

  /**
   * ReservationCommittedUsePrototype.
   */
  export interface ReservationCommittedUsePrototype {
    /** The policy to apply when the committed use term expires:
     *  - `release`: Release any available capacity and let the reservation expire.
     *  - `renew`: Renew for another term, provided the term remains listed in the
     *    `reservation_terms` for the profile. Otherwise, let the reservation expire.
     */
    expiration_policy?: ReservationCommittedUsePrototype.Constants.ExpirationPolicy | string;
    /** The term for this committed use reservation:
     *  - `one_year`: 1 year
     *  - `three_year`: 3 years
     *
     *  The specified value must be listed in the `reservation_terms` in the profile for this reservation.
     */
    term: string;
  }
  export namespace ReservationCommittedUsePrototype {
    export namespace Constants {
      /** The policy to apply when the committed use term expires: - `release`: Release any available capacity and let the reservation expire. - `renew`: Renew for another term, provided the term remains listed in the `reservation_terms` for the profile. Otherwise, let the reservation expire. */
      export enum ExpirationPolicy {
        RELEASE = 'release',
        RENEW = 'renew',
      }
    }
  }

  /**
   * Identifies a reservation by a unique property.
   */
  export interface ReservationIdentity {
  }

  /**
   * The [instance profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) or
   * [bare metal server profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile) for this
   * reservation.
   */
  export interface ReservationProfile {
  }

  /**
   * The [instance profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) or
   * [bare metal server profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile) to use for this
   * reservation.
   */
  export interface ReservationProfilePatch {
    /** The globally unique name of the profile. */
    name?: string;
    /** The resource type of the profile. */
    resource_type?: ReservationProfilePatch.Constants.ResourceType | string;
  }
  export namespace ReservationProfilePatch {
    export namespace Constants {
      /** The resource type of the profile. */
      export enum ResourceType {
        BARE_METAL_SERVER_PROFILE = 'bare_metal_server_profile',
        INSTANCE_PROFILE = 'instance_profile',
      }
    }
  }

  /**
   * The [instance profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) or
   * [bare metal server profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile) to use for this
   * reservation.
   */
  export interface ReservationProfilePrototype {
    /** The globally unique name of the profile. */
    name: string;
    /** The resource type of the profile. */
    resource_type: ReservationProfilePrototype.Constants.ResourceType | string;
  }
  export namespace ReservationProfilePrototype {
    export namespace Constants {
      /** The resource type of the profile. */
      export enum ResourceType {
        BARE_METAL_SERVER_PROFILE = 'bare_metal_server_profile',
        INSTANCE_PROFILE = 'instance_profile',
      }
    }
  }

  /**
   * ReservationReference.
   */
  export interface ReservationReference {
    /** The CRN for this reservation. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this reservation. */
    href: string;
    /** The unique identifier for this reservation. */
    id: string;
    /** The name for this reservation. The name is unique across all reservations in the region. */
    name: string;
    /** The resource type. */
    resource_type: ReservationReference.Constants.ResourceType | string;
  }
  export namespace ReservationReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        RESERVATION = 'reservation',
      }
    }
  }

  /**
   * ReservationStatusReason.
   */
  export interface ReservationStatusReason {
    /** A snake case string succinctly identifying the status reason.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ReservationStatusReason.Constants.Code | string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace ReservationStatusReason {
    export namespace Constants {
      /** A snake case string succinctly identifying the status reason. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        CANNOT_ACTIVATE_NO_CAPACITY_AVAILABLE = 'cannot_activate_no_capacity_available',
        CANNOT_RENEW_UNSUPPORTED_PROFILE_TERM = 'cannot_renew_unsupported_profile_term',
      }
    }
  }

  /**
   * ReservedIP.
   */
  export interface ReservedIP {
    /** The IP address.
     *
     *  If the address has not yet been selected, the value will be `0.0.0.0`.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound.
     */
    auto_delete: boolean;
    /** The date and time that the reserved IP was created. */
    created_at: string;
    /** The URL for this reserved IP. */
    href: string;
    /** The unique identifier for this reserved IP. */
    id: string;
    /** The lifecycle state of the reserved IP. */
    lifecycle_state: ReservedIP.Constants.LifecycleState | string;
    /** The name for this reserved IP. The name is unique across all reserved IPs in a subnet. */
    name: string;
    /** The owner of the reserved IP.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    owner: ReservedIP.Constants.Owner | string;
    /** The resource type. */
    resource_type: ReservedIP.Constants.ResourceType | string;
    /** The target this reserved IP is bound to.
     *
     *  If absent, this reserved IP is provider-owned or unbound.
     *
     *  The resources supported by this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    target?: ReservedIPTarget;
  }
  export namespace ReservedIP {
    export namespace Constants {
      /** The lifecycle state of the reserved IP. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The owner of the reserved IP. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Owner {
        PROVIDER = 'provider',
        USER = 'user',
      }
      /** The resource type. */
      export enum ResourceType {
        SUBNET_RESERVED_IP = 'subnet_reserved_ip',
      }
    }
  }

  /**
   * ReservedIPCollection.
   */
  export interface ReservedIPCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of reserved IPs in the subnet. */
    reserved_ips: ReservedIP[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ReservedIPCollectionBareMetalServerNetworkInterfaceContext.
   */
  export interface ReservedIPCollectionBareMetalServerNetworkInterfaceContext {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of reserved IPs bound to the bare metal server network interface. */
    ips: ReservedIP[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ReservedIPCollectionEndpointGatewayContext.
   */
  export interface ReservedIPCollectionEndpointGatewayContext {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of reserved IPs bound to the endpoint gateway. */
    ips: ReservedIP[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ReservedIPCollectionInstanceNetworkInterfaceContext.
   */
  export interface ReservedIPCollectionInstanceNetworkInterfaceContext {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of reserved IPs bound to the instance network interface. */
    ips: ReservedIP[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ReservedIPCollectionVirtualNetworkInterfaceContext.
   */
  export interface ReservedIPCollectionVirtualNetworkInterfaceContext {
    /** A link to the first page of resources. */
    first: PageLink;
    /** A page of reserved IPs bound to the virtual network interface specified by the identifier in the URL. */
    ips: ReservedIPReference[];
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ReservedIPReference.
   */
  export interface ReservedIPReference {
    /** The IP address.
     *
     *  If the address has not yet been selected, the value will be `0.0.0.0`.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this reserved IP. */
    href: string;
    /** The unique identifier for this reserved IP. */
    id: string;
    /** The name for this reserved IP. The name is unique across all reserved IPs in a subnet. */
    name: string;
    /** The resource type. */
    resource_type: ReservedIPReference.Constants.ResourceType | string;
  }
  export namespace ReservedIPReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SUBNET_RESERVED_IP = 'subnet_reserved_ip',
      }
    }
  }

  /**
   * The target this reserved IP is bound to.
   *
   * If absent, this reserved IP is provider-owned or unbound.
   *
   * The resources supported by this property may
   * [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
   */
  export interface ReservedIPTarget {
  }

  /**
   * The target to bind this reserved IP to.  The target must be in the same VPC.
   *
   * The following targets are supported:
   * - An endpoint gateway not already bound to a reserved IP in the subnet's zone.
   * - A virtual network interface.
   *
   * If unspecified, the reserved IP will be created unbound.
   */
  export interface ReservedIPTargetPrototype {
  }

  /**
   * Identifies one or more resources according to the specified filter property.
   */
  export interface ResourceFilter {
    /** The resource type. */
    resource_type?: string;
  }

  /**
   * The resource group to use. If unspecified, the account's [default resource
   * group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
   */
  export interface ResourceGroupIdentity {
  }

  /**
   * ResourceGroupReference.
   */
  export interface ResourceGroupReference {
    /** The URL for this resource group. */
    href: string;
    /** The unique identifier for this resource group. */
    id: string;
    /** The name for this resource group. */
    name: string;
  }

  /**
   * Route.
   */
  export interface Route {
    /** The action to perform with a packet matching the route:
     *  - `delegate`: delegate to system-provided routes
     *  - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
     *  - `deliver`: deliver the packet to the specified `next_hop`
     *  - `drop`: drop the packet
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    action: Route.Constants.Action | string;
    /** Indicates whether this route will be advertised to the ingress sources specified by the
     *  `advertise_routes_to` routing table property.
     */
    advertise: boolean;
    /** The date and time that the route was created. */
    created_at: string;
    /** If present, the resource that created the route. Routes with this property present cannot
     *  be directly deleted. All routes with an `origin` of `service` will have this property set,
     *  and future `origin` values may also have this property set.
     */
    creator?: RouteCreator;
    /** The destination CIDR of the route. */
    destination: string;
    /** The URL for this route. */
    href: string;
    /** The unique identifier for this route. */
    id: string;
    /** The lifecycle state of the route. */
    lifecycle_state: Route.Constants.LifecycleState | string;
    /** The name for this route. The name is unique across all routes in the routing table. */
    name: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to.  For
     *  other `action` values, its `address` will be `0.0.0.0`.
     */
    next_hop: RouteNextHop;
    /** The origin of this route:
     *  - `service`: route was directly created by a service
     *  - `user`: route was directly created by a user
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    origin: Route.Constants.Origin | string;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority: number;
    /** The zone the route applies to.
     *
     *  If subnets are attached to the route's routing table, egress traffic from those
     *  subnets in this zone will be subject to this route. If this route's routing table
     *  has any of `route_direct_link_ingress`, `route_internet_ingress`,
     *  `route_transit_gateway_ingress` or `route_vpc_zone_ingress`  set to`true`, traffic
     *  from those ingress sources arriving in this zone will be subject to this route.
     */
    zone: ZoneReference;
  }
  export namespace Route {
    export namespace Constants {
      /** The action to perform with a packet matching the route: - `delegate`: delegate to system-provided routes - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes - `deliver`: deliver the packet to the specified `next_hop` - `drop`: drop the packet The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Action {
        DELEGATE = 'delegate',
        DELEGATE_VPC = 'delegate_vpc',
        DELIVER = 'deliver',
        DROP = 'drop',
      }
      /** The lifecycle state of the route. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The origin of this route: - `service`: route was directly created by a service - `user`: route was directly created by a user The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Origin {
        SERVICE = 'service',
        USER = 'user',
      }
    }
  }

  /**
   * RouteCollection.
   */
  export interface RouteCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of routes in the VPC routing table. */
    routes: Route[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * RouteCollectionVPCContext.
   */
  export interface RouteCollectionVPCContext {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of routes in the VPC default routing table. */
    routes: Route[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * If present, the resource that created the route. Routes with this property present cannot be directly deleted. All
   * routes with an `origin` of `service` will have this property set, and future `origin` values may also have this
   * property set.
   */
  export interface RouteCreator {
  }

  /**
   * RouteNextHop.
   */
  export interface RouteNextHop {
  }

  /**
   * If `action` is `deliver`, the next hop that packets will be delivered to (must not be
   * `0.0.0.0`). For other `action` values, specify `0.0.0.0` or remove it by specifying
   * `null`.
   *
   * At most two routes per `zone` in a table can have the same `destination` and `priority`, and only when each route
   * has an `action` of `deliver` and `next_hop` is an IP address.
   */
  export interface RouteNextHopPatch {
  }

  /**
   * If `action` is `deliver`, the next hop that packets will be delivered to (must not be
   * `0.0.0.0`). For other `action` values, it must be omitted or specified as `0.0.0.0`.
   *
   * At most two routes per `zone` in a table can have the same `destination` and `priority`, and only when each route
   * has an `action` of `deliver` and `next_hop` is an IP address.
   */
  export interface RouteNextHopPrototype {
  }

  /**
   * RoutePrototype.
   */
  export interface RoutePrototype {
    /** The action to perform with a packet matching the route:
     *  - `delegate`: delegate to system-provided routes
     *  - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
     *  - `deliver`: deliver the packet to the specified `next_hop`
     *  - `drop`: drop the packet.
     */
    action?: RoutePrototype.Constants.Action | string;
    /** Indicates whether this route will be advertised to the ingress sources specified by the
     *  `advertise_routes_to` routing table property.
     *
     *  All routes in a routing table with the same `destination` and `zone` must have the same
     *  `advertise` value.
     */
    advertise?: boolean;
    /** The destination CIDR of the route. The host identifier in the CIDR must be zero.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and
     *  `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
     */
    destination: string;
    /** The name for this route. The name must not be used by another route in the routing table. Names starting
     *  with `ibm-` are reserved for system-provided routes, and are not allowed. If unspecified, the name will be a
     *  hyphenated list of randomly-selected words.
     */
    name?: string;
    /** If `action` is `deliver`, the next hop that packets will be delivered to (must not be
     *  `0.0.0.0`). For other `action` values, it must be omitted or specified as `0.0.0.0`.
     *
     *  At most two routes per `zone` in a table can have the same `destination` and `priority`,
     *  and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
     */
    next_hop?: RouteNextHopPrototype;
    /** The priority of this route. Smaller values have higher priority.
     *
     *  If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
     *  priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
     *  distributed between them.
     */
    priority?: number;
    /** The zone to apply the route to.
     *
     *  If subnets are attached to the route's routing table, egress traffic from those
     *  subnets in this zone will be subject to this route. If this route's routing table
     *  has any of `route_direct_link_ingress`, `route_internet_ingress`,
     *  `route_transit_gateway_ingress` or `route_vpc_zone_ingress`  set to`true`, traffic
     *  from those ingress sources arriving in this zone will be subject to this route.
     */
    zone: ZoneIdentity;
  }
  export namespace RoutePrototype {
    export namespace Constants {
      /** The action to perform with a packet matching the route: - `delegate`: delegate to system-provided routes - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes - `deliver`: deliver the packet to the specified `next_hop` - `drop`: drop the packet. */
      export enum Action {
        DELEGATE = 'delegate',
        DELEGATE_VPC = 'delegate_vpc',
        DELIVER = 'deliver',
        DROP = 'drop',
      }
    }
  }

  /**
   * RouteReference.
   */
  export interface RouteReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this route. */
    href: string;
    /** The unique identifier for this route. */
    id: string;
    /** The name for this route. The name is unique across all routes in the routing table. */
    name: string;
  }

  /**
   * RoutingTable.
   */
  export interface RoutingTable {
    /** The filters specifying the resources that may create routes in this routing table.
     *
     *  The resources and types of filters supported by this property is expected to
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    accept_routes_from: ResourceFilter[];
    /** The ingress sources to advertise routes to. Routes in the table with `advertise` enabled will be advertised
     *  to these sources.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    advertise_routes_to: RoutingTable.Constants.AdvertiseRoutesTo[] | string[];
    /** The date and time that this routing table was created. */
    created_at: string;
    /** The CRN for this VPC routing table. */
    crn: string;
    /** The URL for this routing table. */
    href: string;
    /** The unique identifier for this routing table. */
    id: string;
    /** Indicates whether this is the default routing table for this VPC. */
    is_default: boolean;
    /** The lifecycle state of the routing table. */
    lifecycle_state: RoutingTable.Constants.LifecycleState | string;
    /** The name for this routing table. The name is unique across all routing tables for the VPC. */
    name: string;
    /** The resource group for this routing table. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: RoutingTable.Constants.ResourceType | string;
    /** Indicates whether this routing table is used to route traffic that originates from
     *  [Direct Link](https://cloud.ibm.com/docs/dl) to this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     */
    route_direct_link_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from the internet.
     *
     *  Incoming traffic will be routed according to the routing table with two exceptions:
     *  - Traffic destined for IP addresses associated with public gateways will not be
     *    subject to routes in this routing table.
     *  - Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is
     *    an IP address in a subnet in the route's `zone` that is able to accept traffic.
     *    Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *    connection, the packet will be dropped.
     */
    route_internet_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from from [Transit
     *  Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     */
    route_transit_gateway_ingress: boolean;
    /** Indicates whether this routing table is used to route traffic that originates from subnets in other zones in
     *  this VPC.
     *
     *  Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
     *  `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
     *  able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
     *  connection, the packet will be dropped.
     */
    route_vpc_zone_ingress: boolean;
    /** The routes for this routing table. */
    routes: RouteReference[];
    /** The subnets to which this routing table is attached. */
    subnets: SubnetReference[];
  }
  export namespace RoutingTable {
    export namespace Constants {
      /** The ingress sources to advertise routes to. Routes in the table with `advertise` enabled will be advertised to these sources. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AdvertiseRoutesTo {
        DIRECT_LINK = 'direct_link',
        TRANSIT_GATEWAY = 'transit_gateway',
      }
      /** The lifecycle state of the routing table. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        ROUTING_TABLE = 'routing_table',
      }
    }
  }

  /**
   * RoutingTableCollection.
   */
  export interface RoutingTableCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of routing tables. */
    routing_tables: RoutingTable[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Identifies a routing table by a unique property.
   */
  export interface RoutingTableIdentity {
  }

  /**
   * RoutingTableReference.
   */
  export interface RoutingTableReference {
    /** The CRN for this VPC routing table. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this routing table. */
    href: string;
    /** The unique identifier for this routing table. */
    id: string;
    /** The name for this routing table. The name is unique across all routing tables for the VPC. */
    name: string;
    /** The resource type. */
    resource_type: RoutingTableReference.Constants.ResourceType | string;
  }
  export namespace RoutingTableReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        ROUTING_TABLE = 'routing_table',
      }
    }
  }

  /**
   * SecurityGroup.
   */
  export interface SecurityGroup {
    /** The date and time that this security group was created. */
    created_at: string;
    /** The CRN for this security group. */
    crn: string;
    /** The URL for this security group. */
    href: string;
    /** The unique identifier for this security group. */
    id: string;
    /** The name for this security group. The name is unique across all security groups for the VPC. */
    name: string;
    /** The resource group for this security group. */
    resource_group: ResourceGroupReference;
    /** The rules for this security group. If no rules exist, no traffic will be allowed. */
    rules: SecurityGroupRule[];
    /** The targets for this security group. */
    targets: SecurityGroupTargetReference[];
    /** The VPC this security group resides in. */
    vpc: VPCReference;
  }

  /**
   * SecurityGroupCollection.
   */
  export interface SecurityGroupCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of security groups. */
    security_groups: SecurityGroup[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Identifies a security group by a unique property.
   */
  export interface SecurityGroupIdentity {
  }

  /**
   * SecurityGroupReference.
   */
  export interface SecurityGroupReference {
    /** The CRN for this security group. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this security group. */
    href: string;
    /** The unique identifier for this security group. */
    id: string;
    /** The name for this security group. The name is unique across all security groups for the VPC. */
    name: string;
  }

  /**
   * SecurityGroupRule.
   */
  export interface SecurityGroupRule {
    /** The direction of traffic to allow. */
    direction: SecurityGroupRule.Constants.Direction | string;
    /** The URL for this security group rule. */
    href: string;
    /** The unique identifier for this security group rule. */
    id: string;
    /** The IP version to allow. The format of `local.address`, `remote.address`,
     *  `local.cidr_block` or `remote.cidr_block` must match this property, if they are used.
     *
     *  If `remote` references a security group, then this rule only applies to IP addresses in that group matching this
     *  IP version.
     */
    ip_version: SecurityGroupRule.Constants.IpVersion | string;
    /** The local IP address or range of local IP addresses to which this rule will allow inbound
     *  traffic (or from which, for outbound traffic). A CIDR block of `0.0.0.0/0` allows traffic
     *  to all local IP addresses (or from all local IP addresses, for outbound rules).
     */
    local: SecurityGroupRuleLocal;
    /** The name of the network protocol to allow.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    protocol: SecurityGroupRule.Constants.Protocol | string;
    /** The remote IP addresses or security groups from which this rule allows traffic (or to
     *  which, for outbound rules). A CIDR block of `0.0.0.0/0` allows traffic from any source
     *  (or to any destination, for outbound rules).
     */
    remote: SecurityGroupRuleRemote;
  }
  export namespace SecurityGroupRule {
    export namespace Constants {
      /** The direction of traffic to allow. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version to allow. The format of `local.address`, `remote.address`, `local.cidr_block` or `remote.cidr_block` must match this property, if they are used. If `remote` references a security group, then this rule only applies to IP addresses in that group matching this IP version. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol to allow. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Protocol {
        ALL = 'all',
        ICMP = 'icmp',
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * SecurityGroupRuleCollection.
   */
  export interface SecurityGroupRuleCollection {
    /** The rules for the security group. */
    rules: SecurityGroupRule[];
  }

  /**
   * The local IP address or range of local IP addresses to which this rule will allow inbound traffic (or from which,
   * for outbound traffic). A CIDR block of `0.0.0.0/0` allows traffic to all local IP addresses (or from all local IP
   * addresses, for outbound rules).
   */
  export interface SecurityGroupRuleLocal {
  }

  /**
   * The local IP address or range of local IP addresses to which this rule will allow inbound traffic (or from which,
   * for outbound traffic). Can be specified as an IP address or a CIDR block.
   *
   * Specify a CIDR block of `0.0.0.0/0` to allow traffic to all local IP addresses (or from all local IP addresses, for
   * outbound rules).
   */
  export interface SecurityGroupRuleLocalPatch {
  }

  /**
   * The local IP address or range of local IP addresses to which this rule will allow inbound traffic (or from which,
   * for outbound traffic).
   *
   * If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic to all local IP addresses (or from all
   * local IP addresses, for outbound rules).
   */
  export interface SecurityGroupRuleLocalPrototype {
  }

  /**
   * SecurityGroupRulePrototype.
   */
  export interface SecurityGroupRulePrototype {
    /** The direction of traffic to allow. */
    direction: SecurityGroupRulePrototype.Constants.Direction | string;
    /** The IP version to allow. The format of `local.address`, `remote.address`,
     *  `local.cidr_block` or `remote.cidr_block` must match this property, if they are used.
     *
     *  If `remote` references a security group, then this rule only applies to IP addresses in that group matching this
     *  IP version.
     */
    ip_version?: SecurityGroupRulePrototype.Constants.IpVersion | string;
    /** The local IP address or range of local IP addresses to which this rule will allow inbound
     *  traffic (or from which, for outbound traffic).
     *
     *  If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic to all local IP
     *  addresses (or from all local IP addresses, for outbound rules).
     */
    local?: SecurityGroupRuleLocalPrototype;
    /** The name of the network protocol to allow. */
    protocol: SecurityGroupRulePrototype.Constants.Protocol | string;
    /** The remote IP addresses or security groups from which this rule will allow traffic (or to
     *  which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
     *  security group within the VPC.
     *
     *  If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source
     *  (or to any destination, for outbound rules).
     */
    remote?: SecurityGroupRuleRemotePrototype;
  }
  export namespace SecurityGroupRulePrototype {
    export namespace Constants {
      /** The direction of traffic to allow. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version to allow. The format of `local.address`, `remote.address`, `local.cidr_block` or `remote.cidr_block` must match this property, if they are used. If `remote` references a security group, then this rule only applies to IP addresses in that group matching this IP version. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol to allow. */
      export enum Protocol {
        ALL = 'all',
        ICMP = 'icmp',
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * The remote IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). A
   * CIDR block of `0.0.0.0/0` allows traffic from any source
   * (or to any destination, for outbound rules).
   */
  export interface SecurityGroupRuleRemote {
  }

  /**
   * The remote IP addresses or security groups from which this rule will allow traffic (or to which, for outbound
   * rules). Can be specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` will
   * allow traffic from any source (or to any destination, for outbound rules).
   */
  export interface SecurityGroupRuleRemotePatch {
  }

  /**
   * The remote IP addresses or security groups from which this rule will allow traffic (or to which, for outbound
   * rules). Can be specified as an IP address, a CIDR block, or a security group within the VPC.
   *
   * If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source
   * (or to any destination, for outbound rules).
   */
  export interface SecurityGroupRuleRemotePrototype {
  }

  /**
   * SecurityGroupTargetCollection.
   */
  export interface SecurityGroupTargetCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of targets for the security group. */
    targets: SecurityGroupTargetReference[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * A target of this security group.
   *
   * The resources supported by this property may
   * [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
   */
  export interface SecurityGroupTargetReference {
  }

  /**
   * Share.
   */
  export interface Share {
    /** The access control mode for the share:
     *
     *  - `security_group`: The security groups on the virtual network interface for a mount
     *    target control access to the mount target.
     *  - `vpc`: All clients in the VPC for a mount target have access to the mount target.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    access_control_mode: Share.Constants.AccessControlMode | string;
    /** The accessor binding role of this file share:
     *  - `none`: This file share is not participating in access with another file share
     *  - `origin`: This file share is the origin for one or more file shares
     *    (which may be in other accounts)
     *  - `accessor`: This file share is providing access to another file share
     *    (which may be in another account).
     */
    accessor_binding_role: Share.Constants.AccessorBindingRole | string;
    /** The accessor bindings for this file share. Each accessor binding identifies a resource (possibly in another
     *  account) with access to this file share's data and its snapshots.
     */
    accessor_bindings: ShareAccessorBindingReference[];
    /** The transit encryption modes allowed for this share:
     *  - `none`: Not encrypted in transit.
     *  - `user_managed`: Encrypted in transit using an instance identity certificate.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    allowed_transit_encryption_modes: Share.Constants.AllowedTransitEncryptionModes[] | string[];
    /** The date and time that the file share is created. */
    created_at: string;
    /** The CRN for this file share. */
    crn: string;
    /** The type of encryption used for this file share. */
    encryption: Share.Constants.Encryption | string;
    /** The key used to encrypt this file share.
     *
     *  This property will be present if `encryption` is `user_managed`.
     */
    encryption_key?: EncryptionKeyReference;
    /** The URL for this file share. */
    href: string;
    /** The unique identifier for this file share. */
    id: string;
    /** The maximum input/output operations per second (IOPS) for the file share. In addition, each client accessing
     *  the share will be restricted to 48,000 IOPS.
     *
     *  The maximum IOPS for a share may increase in the future.
     */
    iops: number;
    /** The latest job associated with this file share.
     *
     *  This property will be absent if no jobs have been created for this file share.
     */
    latest_job?: ShareJob;
    /** Information about the latest synchronization for this file share.
     *
     *  This property will be present when the `replication_role` is `replica` and at least
     *  one replication sync has been completed.
     */
    latest_sync?: ShareLatestSync;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: ShareLifecycleReason[];
    /** The lifecycle state of the file share. */
    lifecycle_state: Share.Constants.LifecycleState | string;
    /** The mount targets for the file share. */
    mount_targets: ShareMountTargetReference[];
    /** The name for this share. The name is unique across all shares in the region. */
    name: string;
    /** The origin share this accessor share is referring to.
     *
     *  This property will be present when the `accessor_binding_role` is `accessor`.
     */
    origin_share?: ShareReference;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) for this file share. */
    profile: ShareProfileReference;
    /** The replica file share for this source file share.
     *
     *  This property will be present when the `replication_role` is `source`.
     */
    replica_share?: ShareReference;
    /** The cron specification for the file share replication schedule.
     *
     *  This property will be present when the `replication_role` is `replica`.
     */
    replication_cron_spec?: string;
    /** The replication role of the file share:
     *  - `none`: This share is not participating in replication.
     *  - `replica`: This share is a replication target.
     *  - `source`: This share is a replication source.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    replication_role: Share.Constants.ReplicationRole | string;
    /** The replication status of the file share:
     *  - `active`: This share is actively participating in replication, and the replica's data is up-to-date with the
     *  replication schedule.
     *  - `degraded`: This is share is participating in replication, but the replica's data has fallen behind the
     *  replication schedule.
     *  - `failover_pending`: This share is performing a replication failover.
     *  - `initializing`: This share is initializing replication.
     *  - `none`: This share is not participating in replication.
     *  - `split_pending`: This share is performing a replication split.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    replication_status: Share.Constants.ReplicationStatus | string;
    /** The reasons for the current replication status (if any). */
    replication_status_reasons: ShareReplicationStatusReason[];
    /** The resource group for this file share. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: Share.Constants.ResourceType | string;
    /** The size of the file share (in gigabytes), excluding share snapshots.
     *
     *  The maximum size for a share may increase in the future.
     */
    size: number;
    /** The total number of snapshots for this share. */
    snapshot_count: number;
    /** The total size (in gigabytes) of snapshots used for this file share. */
    snapshot_size: number;
    /** The source file share for this replica file share.
     *
     *  This property will be present when the `replication_role` is `replica`.
     */
    source_share?: ShareReference;
    /** The snapshot this share was created from.
     *
     *  This property will be present when the share was created from a snapshot.
     *
     *  The resources supported by this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the
     *  future.
     */
    source_snapshot?: ShareSourceSnapshot;
    /** Tags for this resource. */
    user_tags: string[];
    /** The zone this file share resides in. */
    zone: ZoneReference;
  }
  export namespace Share {
    export namespace Constants {
      /** The access control mode for the share: - `security_group`: The security groups on the virtual network interface for a mount target control access to the mount target. - `vpc`: All clients in the VPC for a mount target have access to the mount target. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AccessControlMode {
        SECURITY_GROUP = 'security_group',
        VPC = 'vpc',
      }
      /** The accessor binding role of this file share: - `none`: This file share is not participating in access with another file share - `origin`: This file share is the origin for one or more file shares (which may be in other accounts) - `accessor`: This file share is providing access to another file share (which may be in another account). */
      export enum AccessorBindingRole {
        ACCESSOR = 'accessor',
        NONE = 'none',
        ORIGIN = 'origin',
      }
      /** The transit encryption modes allowed for this share: - `none`: Not encrypted in transit. - `user_managed`: Encrypted in transit using an instance identity certificate. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AllowedTransitEncryptionModes {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
      /** The type of encryption used for this file share. */
      export enum Encryption {
        PROVIDER_MANAGED = 'provider_managed',
        USER_MANAGED = 'user_managed',
      }
      /** The lifecycle state of the file share. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The replication role of the file share: - `none`: This share is not participating in replication. - `replica`: This share is a replication target. - `source`: This share is a replication source. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum ReplicationRole {
        NONE = 'none',
        REPLICA = 'replica',
        SOURCE = 'source',
      }
      /** The replication status of the file share: - `active`: This share is actively participating in replication, and the replica's data is up-to-date with the replication schedule. - `degraded`: This is share is participating in replication, but the replica's data has fallen behind the replication schedule. - `failover_pending`: This share is performing a replication failover. - `initializing`: This share is initializing replication. - `none`: This share is not participating in replication. - `split_pending`: This share is performing a replication split. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum ReplicationStatus {
        ACTIVE = 'active',
        DEGRADED = 'degraded',
        FAILOVER_PENDING = 'failover_pending',
        INITIALIZING = 'initializing',
        NONE = 'none',
        SPLIT_PENDING = 'split_pending',
      }
      /** The resource type. */
      export enum ResourceType {
        SHARE = 'share',
      }
    }
  }

  /**
   * ShareAccessorBinding.
   */
  export interface ShareAccessorBinding {
    /** The accessor for this share accessor binding. */
    accessor: ShareAccessorBindingAccessor;
    /** The date and time that the share accessor binding was created. */
    created_at: string;
    /** The URL for this share accessor binding. */
    href: string;
    /** The unique identifier for this share accessor binding. */
    id: string;
    /** The lifecycle state of the file share accessor binding. */
    lifecycle_state: ShareAccessorBinding.Constants.LifecycleState | string;
    /** The resource type. */
    resource_type: ShareAccessorBinding.Constants.ResourceType | string;
  }
  export namespace ShareAccessorBinding {
    export namespace Constants {
      /** The lifecycle state of the file share accessor binding. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        SHARE_ACCESSOR_BINDING = 'share_accessor_binding',
      }
    }
  }

  /**
   * The accessor for this share accessor binding.
   */
  export interface ShareAccessorBindingAccessor {
  }

  /**
   * ShareAccessorBindingCollection.
   */
  export interface ShareAccessorBindingCollection {
    /** A page of accessor bindings for the share. */
    accessor_bindings: ShareAccessorBinding[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ShareAccessorBindingReference.
   */
  export interface ShareAccessorBindingReference {
    /** The URL for this share accessor binding. */
    href: string;
    /** The unique identifier for this share accessor binding. */
    id: string;
    /** The resource type. */
    resource_type: ShareAccessorBindingReference.Constants.ResourceType | string;
  }
  export namespace ShareAccessorBindingReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SHARE_ACCESSOR_BINDING = 'share_accessor_binding',
      }
    }
  }

  /**
   * ShareCollection.
   */
  export interface ShareCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of file shares. */
    shares: Share[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Identifies a file share by a unique property.
   */
  export interface ShareIdentity {
  }

  /**
   * ShareInitialOwner.
   */
  export interface ShareInitialOwner {
    /** The initial group identifier for the file share. */
    gid?: number;
    /** The initial user identifier for the file share. */
    uid?: number;
  }

  /**
   * ShareJob.
   */
  export interface ShareJob {
    /** The status of the file share job:
     *  - `cancelled`: This job has been cancelled.
     *  - `failed`: This job has failed.
     *  - `queued`: This job is queued.
     *  - `running`: This job is running.
     *  - `succeeded`: This job completed successfully.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: ShareJob.Constants.Status | string;
    /** The reasons for the file share job status (if any). */
    status_reasons: ShareJobStatusReason[];
    /** The type of the file share job:
     *  - `replication_failover`: This is a share replication failover job.
     *  - `replication_init`: This is a share replication is initialization job.
     *  - `replication_split`: This is a share replication split job.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    type: ShareJob.Constants.Type | string;
  }
  export namespace ShareJob {
    export namespace Constants {
      /** The status of the file share job: - `cancelled`: This job has been cancelled. - `failed`: This job has failed. - `queued`: This job is queued. - `running`: This job is running. - `succeeded`: This job completed successfully. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        CANCELLED = 'cancelled',
        FAILED = 'failed',
        QUEUED = 'queued',
        RUNNING = 'running',
        SUCCEEDED = 'succeeded',
      }
      /** The type of the file share job: - `replication_failover`: This is a share replication failover job. - `replication_init`: This is a share replication is initialization job. - `replication_split`: This is a share replication split job. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        REPLICATION_FAILOVER = 'replication_failover',
        REPLICATION_INIT = 'replication_init',
        REPLICATION_SPLIT = 'replication_split',
      }
    }
  }

  /**
   * ShareJobStatusReason.
   */
  export interface ShareJobStatusReason {
    /** A snake case string succinctly identifying the status reason.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ShareJobStatusReason.Constants.Code | string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace ShareJobStatusReason {
    export namespace Constants {
      /** A snake case string succinctly identifying the status reason. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        CANNOT_INITIALIZE_REPLICATION = 'cannot_initialize_replication',
        CANNOT_REACH_REPLICA_SHARE = 'cannot_reach_replica_share',
        CANNOT_REACH_SOURCE_SHARE = 'cannot_reach_source_share',
      }
    }
  }

  /**
   * Information about the latest synchronization for this file share.
   *
   * This property will be present when the `replication_role` is `replica` and at least one replication sync has been
   * completed.
   */
  export interface ShareLatestSync {
    /** The completed date and time of last synchronization between the replica share and its source. */
    completed_at: string;
    /** The data transferred (in bytes) in the last synchronization between the replica and its source. */
    data_transferred: number;
    /** The start date and time of last synchronization between the replica share and its source. */
    started_at: string;
  }

  /**
   * ShareLifecycleReason.
   */
  export interface ShareLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `origin_share_access_revoked`: The resource has been revoked by the share owner
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ShareLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace ShareLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `origin_share_access_revoked`: The resource has been revoked by the share owner - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        ORIGIN_SHARE_ACCESS_REVOKED = 'origin_share_access_revoked',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * ShareMountTarget.
   */
  export interface ShareMountTarget {
    /** The access control mode for the share:
     *
     *  - `security_group`: The security groups on the virtual network interface for a mount
     *    target control access to the mount target.
     *  - `vpc`: All clients in the VPC for a mount target have access to the mount target.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    access_control_mode: ShareMountTarget.Constants.AccessControlMode | string;
    /** The date and time that the share mount target was created. */
    created_at: string;
    /** The URL for this share mount target. */
    href: string;
    /** The unique identifier for this share mount target. */
    id: string;
    /** The lifecycle state of the mount target. */
    lifecycle_state: ShareMountTarget.Constants.LifecycleState | string;
    /** The mount path for the share.  The server component of the mount path may be either an IP address or a fully
     *  qualified domain name.
     *
     *  This property will be absent if the `lifecycle_state` of the mount target is
     *  'pending', `failed`, or `deleting`.
     *
     *  If the share's `access_control_mode` is:
     *
     *  - `security_group`: The IP address used in the mount path is the `primary_ip`
     *    address of the virtual network interface for this share mount target.
     *  - `vpc`: The fully-qualified domain name used in the mount path is an address that
     *    resolves to the share mount target.
     */
    mount_path?: string;
    /** The name for this share mount target. The name is unique across all mount targets for the file share. */
    name: string;
    /** The primary IP address of the virtual network interface for the share mount target.
     *
     *  Absent if `access_control_mode` is `vpc`.
     */
    primary_ip?: ReservedIPReference;
    /** The resource type. */
    resource_type: ShareMountTarget.Constants.ResourceType | string;
    /** The subnet of the virtual network interface for the share mount target.
     *
     *  Absent if `access_control_mode` is `vpc`.
     */
    subnet?: SubnetReference;
    /** The transit encryption mode for this share mount target:
     *  - `none`: Not encrypted in transit
     *  - `user_managed`: Encrypted in transit using an instance identity certificate
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    transit_encryption: ShareMountTarget.Constants.TransitEncryption | string;
    /** The virtual network interface for this file share mount target.
     *
     *  This property will be present when the `access_control_mode` is `security_group`.
     */
    virtual_network_interface?: VirtualNetworkInterfaceReferenceAttachmentContext;
    /** If `access_control_mode` is:
     *
     *  - `security_group`: The VPC for the virtual network interface for this share mount
     *    target
     *  - `vpc`: The VPC in which clients can mount the file share using this share
     *    mount target.
     */
    vpc: VPCReference;
  }
  export namespace ShareMountTarget {
    export namespace Constants {
      /** The access control mode for the share: - `security_group`: The security groups on the virtual network interface for a mount target control access to the mount target. - `vpc`: All clients in the VPC for a mount target have access to the mount target. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AccessControlMode {
        SECURITY_GROUP = 'security_group',
        VPC = 'vpc',
      }
      /** The lifecycle state of the mount target. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        SHARE_MOUNT_TARGET = 'share_mount_target',
      }
      /** The transit encryption mode for this share mount target: - `none`: Not encrypted in transit - `user_managed`: Encrypted in transit using an instance identity certificate The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum TransitEncryption {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
    }
  }

  /**
   * ShareMountTargetCollection.
   */
  export interface ShareMountTargetCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A page of mount targets for the share. */
    mount_targets: ShareMountTarget[];
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ShareMountTargetPrototype.
   */
  export interface ShareMountTargetPrototype {
    /** The name for this share mount target. The name must not be used by another mount target for the file share.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The transit encryption mode to use for this share mount target:
     *  - `none`: Not encrypted in transit.
     *  - `user_managed`: Encrypted in transit using an instance identity certificate.  The
     *                    `access_control_mode` for the share must be `security_group`.
     *
     *  The specified value must be listed in the share's
     *  `allowed_transit_encryption_modes`.
     */
    transit_encryption?: ShareMountTargetPrototype.Constants.TransitEncryption | string;
  }
  export namespace ShareMountTargetPrototype {
    export namespace Constants {
      /** The transit encryption mode to use for this share mount target: - `none`: Not encrypted in transit. - `user_managed`: Encrypted in transit using an instance identity certificate.  The `access_control_mode` for the share must be `security_group`. The specified value must be listed in the share's `allowed_transit_encryption_modes`. */
      export enum TransitEncryption {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
    }
  }

  /**
   * ShareMountTargetReference.
   */
  export interface ShareMountTargetReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this share mount target. */
    href: string;
    /** The unique identifier for this share mount target. */
    id: string;
    /** The name for this share mount target. The name is unique across all mount targets for the file share. */
    name: string;
    /** The resource type. */
    resource_type: ShareMountTargetReference.Constants.ResourceType | string;
  }
  export namespace ShareMountTargetReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SHARE_MOUNT_TARGET = 'share_mount_target',
      }
    }
  }

  /**
   * ShareMountTargetVirtualNetworkInterfacePrototype.
   */
  export interface ShareMountTargetVirtualNetworkInterfacePrototype {
  }

  /**
   * ShareProfile.
   */
  export interface ShareProfile {
    /** The permitted capacity range (in gigabytes) for a share with this profile. */
    capacity: ShareProfileCapacity;
    /** The product family this share profile belongs to.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    family: ShareProfile.Constants.Family | string;
    /** The URL for this share profile. */
    href: string;
    /** The permitted IOPS range for a share with this profile. */
    iops: ShareProfileIOPS;
    /** The globally unique name for this share profile. */
    name: string;
    /** The resource type. */
    resource_type: ShareProfile.Constants.ResourceType | string;
  }
  export namespace ShareProfile {
    export namespace Constants {
      /** The product family this share profile belongs to. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Family {
        DEFINED_PERFORMANCE = 'defined_performance',
      }
      /** The resource type. */
      export enum ResourceType {
        SHARE_PROFILE = 'share_profile',
      }
    }
  }

  /**
   * ShareProfileCapacity.
   */
  export interface ShareProfileCapacity {
  }

  /**
   * ShareProfileCollection.
   */
  export interface ShareProfileCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of share profiles. */
    profiles: ShareProfile[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ShareProfileIOPS.
   */
  export interface ShareProfileIOPS {
  }

  /**
   * Identifies a share profile by a unique property.
   */
  export interface ShareProfileIdentity {
  }

  /**
   * ShareProfileReference.
   */
  export interface ShareProfileReference {
    /** The URL for this share profile. */
    href: string;
    /** The globally unique name for this share profile. */
    name: string;
    /** The resource type. */
    resource_type: ShareProfileReference.Constants.ResourceType | string;
  }
  export namespace ShareProfileReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SHARE_PROFILE = 'share_profile',
      }
    }
  }

  /**
   * SharePrototype.
   */
  export interface SharePrototype {
    /** The transit encryption modes to allow for this share. If unspecified:
     *  - If share mount targets are specified, and those share mount targets all specify a
     *    `transit_encryption` of `user_managed`, then only `user_managed` will be allowed.
     *  - Otherwise, all `transit_encryption` modes will be allowed.
     */
    allowed_transit_encryption_modes?: SharePrototype.Constants.AllowedTransitEncryptionModes[] | string[];
    /** The mount targets for the file share. Each mount target must be in a unique VPC. */
    mount_targets?: ShareMountTargetPrototype[];
    /** The name for this share. The name must not be used by another share in the region. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** Configuration for a replica file share to create and associate with this file share. If
     *  unspecified, a replica may be subsequently added by creating a new file share with a
     *  `source_share` referencing this file share.
     */
    replica_share?: SharePrototypeShareContext;
    /** Tags for this resource. */
    user_tags?: string[];
  }
  export namespace SharePrototype {
    export namespace Constants {
      /** The transit encryption modes to allow for this share. If unspecified: - If share mount targets are specified, and those share mount targets all specify a `transit_encryption` of `user_managed`, then only `user_managed` will be allowed. - Otherwise, all `transit_encryption` modes will be allowed. */
      export enum AllowedTransitEncryptionModes {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
    }
  }

  /**
   * Configuration for a replica file share to create and associate with this file share. If unspecified, a replica may
   * be subsequently added by creating a new file share with a
   * `source_share` referencing this file share.
   */
  export interface SharePrototypeShareContext {
    /** The transit encryption modes to allow for this share. If unspecified:
     *  - If share mount targets are specified, and those share mount targets all specify a
     *    `transit_encryption` of `user_managed`, then only `user_managed` will be allowed.
     *  - Otherwise, all `transit_encryption` modes will be allowed.
     */
    allowed_transit_encryption_modes?: SharePrototypeShareContext.Constants.AllowedTransitEncryptionModes[] | string[];
    /** The maximum input/output operations per second (IOPS) for the file share.
     *
     *  If the share profile has an `iops.type` of `dependent` or `fixed`, this property is system-managed and must not
     *  be specified. Otherwise, the specified value must be within the `iops` range of the share profile as supported
     *  by the share's specified size.
     */
    iops?: number;
    /** The mount targets for this replica file share. Each mount target must be in a unique VPC.
     *
     *  A replica's mount targets must be mounted read-only.
     */
    mount_targets?: ShareMountTargetPrototype[];
    /** The name for this share. The name must not be used by another share in the region. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) to use
     *  for this file share. The profile must support the share's specified IOPS and size.
     */
    profile: ShareProfileIdentity;
    /** The cron specification for the file share replication schedule.
     *
     *  Replication of a share can be scheduled to occur at most once every 15 minutes.
     */
    replication_cron_spec: string;
    /** The resource group to use. If unspecified, the resource group from the source share will be used. */
    resource_group?: ResourceGroupIdentity;
    /** Tags for this resource. */
    user_tags?: string[];
    /** The zone this replica file share will reside in. For a replica share in the same
     *  region as the source share, this must be a different zone from the source share.
     */
    zone: ZoneIdentity;
  }
  export namespace SharePrototypeShareContext {
    export namespace Constants {
      /** The transit encryption modes to allow for this share. If unspecified: - If share mount targets are specified, and those share mount targets all specify a `transit_encryption` of `user_managed`, then only `user_managed` will be allowed. - Otherwise, all `transit_encryption` modes will be allowed. */
      export enum AllowedTransitEncryptionModes {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
    }
  }

  /**
   * ShareReference.
   */
  export interface ShareReference {
    /** The CRN for this file share. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this file share. */
    href: string;
    /** The unique identifier for this file share. */
    id: string;
    /** The name for this share. The name is unique across all shares in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: ShareRemote;
    /** The resource type. */
    resource_type: ShareReference.Constants.ResourceType | string;
  }
  export namespace ShareReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SHARE = 'share',
      }
    }
  }

  /**
   * If present, this property indicates that the resource associated with this reference is remote and therefore may
   * not be directly retrievable.
   */
  export interface ShareRemote {
    /** If present, this property indicates that the referenced resource is remote to this
     *  account, and identifies the owning account.
     */
    account?: AccountReference;
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /**
   * ShareReplicationStatusReason.
   */
  export interface ShareReplicationStatusReason {
    /** A snake case string succinctly identifying the status reason.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ShareReplicationStatusReason.Constants.Code | string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace ShareReplicationStatusReason {
    export namespace Constants {
      /** A snake case string succinctly identifying the status reason. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        CANNOT_INITIALIZE_REPLICATION = 'cannot_initialize_replication',
        CANNOT_REACH_REPLICA_SHARE = 'cannot_reach_replica_share',
        CANNOT_REACH_SOURCE_SHARE = 'cannot_reach_source_share',
      }
    }
  }

  /**
   * ShareSnapshot.
   */
  export interface ShareSnapshot {
    /** If present, the backup policy plan which created this share snapshot. */
    backup_policy_plan?: BackupPolicyPlanReference;
    /** The date and time the data capture for this share snapshot was completed.
     *
     *  If absent, this snapshot's data has not yet been captured.
     */
    captured_at?: string;
    /** The date and time that the share snapshot was created. */
    created_at: string;
    /** The CRN for this share snapshot. */
    crn: string;
    /** The fingerprint for this share snapshot. Only snapshots with identical data will have the same fingerprint.
     *  This snapshot will also be available as a subdirectory named identically to this fingerprint in the share's
     *  `.snapshot` directory.
     */
    fingerprint: string;
    /** The URL for this share snapshot. */
    href: string;
    /** The unique identifier for this share snapshot. */
    id: string;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: ShareSnapshotLifecycleReason[];
    /** The lifecycle state of this share snapshot
     *  - `pending`: The share snapshot is being provisioned and is not yet usable. A
     *    snapshot on a replica share will remain `pending` until the next replication sync
     *    completes.
     *  - `deleting`: The share snapshot is being deleted.
     *  - `failed`: The share snapshot is irrecoverably unusable.
     *  - `stable`: The share snapshot is stable and ready for use.
     *  - `updating`: The share snapshot is being updated.
     *  - `suspended`: The share snapshot is not currently usable (see `lifecycle_reasons`).
     */
    lifecycle_state: ShareSnapshot.Constants.LifecycleState | string;
    /** The minimum size of a share created from this snapshot. When a snapshot is created, this will be set to the
     *  size of the `source_share`.
     */
    minimum_size: number;
    /** The name for this share snapshot. The name is unique across all snapshots for the file share. */
    name: string;
    /** The resource group for this share snapshot. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: ShareSnapshot.Constants.ResourceType | string;
    /** The status of the share snapshot:
     *  - `available`: The share snapshot is available for use.
     *  - `failed`: The share snapshot is irrecoverably unusable.
     *  - `pending`: The share snapshot is being provisioned and is not yet usable. A
     *    snapshot on a replica share will remain `pending` until the next replication sync
     *    completes.
     *  - `unusable`: The share snapshot is not currently usable (see `status_reasons`)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: ShareSnapshot.Constants.Status | string;
    /** The reasons for the current status (if any). */
    status_reasons: ShareSnapshotStatusReason[];
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this share snapshot. */
    user_tags: string[];
    /** The zone this share snapshot resides in. */
    zone: ZoneReference;
  }
  export namespace ShareSnapshot {
    export namespace Constants {
      /** The lifecycle state of this share snapshot - `pending`: The share snapshot is being provisioned and is not yet usable. A snapshot on a replica share will remain `pending` until the next replication sync completes. - `deleting`: The share snapshot is being deleted. - `failed`: The share snapshot is irrecoverably unusable. - `stable`: The share snapshot is stable and ready for use. - `updating`: The share snapshot is being updated. - `suspended`: The share snapshot is not currently usable (see `lifecycle_reasons`). */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        SHARE_SNAPSHOT = 'share_snapshot',
      }
      /** The status of the share snapshot: - `available`: The share snapshot is available for use. - `failed`: The share snapshot is irrecoverably unusable. - `pending`: The share snapshot is being provisioned and is not yet usable. A snapshot on a replica share will remain `pending` until the next replication sync completes. - `unusable`: The share snapshot is not currently usable (see `status_reasons`) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        AVAILABLE = 'available',
        FAILED = 'failed',
        PENDING = 'pending',
        UNUSABLE = 'unusable',
      }
    }
  }

  /**
   * ShareSnapshotCollection.
   */
  export interface ShareSnapshotCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of share snapshots. */
    snapshots?: ShareSnapshot[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * ShareSnapshotLifecycleReason.
   */
  export interface ShareSnapshotLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ShareSnapshotLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace ShareSnapshotLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * ShareSnapshotStatusReason.
   */
  export interface ShareSnapshotStatusReason {
    /** A reason code for the status:
     *  - `encryption_key_deleted`: Share snapshot is unusable because its
     *   `encryption_key` was deleted
     *  - `internal_error`: Internal error (contact IBM support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: ShareSnapshotStatusReason.Constants.Code | string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace ShareSnapshotStatusReason {
    export namespace Constants {
      /** A reason code for the status: - `encryption_key_deleted`: Share snapshot is unusable because its `encryption_key` was deleted - `internal_error`: Internal error (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        ENCRYPTION_KEY_DELETED = 'encryption_key_deleted',
      }
    }
  }

  /**
   * ShareSourceSnapshot.
   */
  export interface ShareSourceSnapshot {
  }

  /**
   * ShareSourceSnapshotPrototype.
   */
  export interface ShareSourceSnapshotPrototype {
  }

  /**
   * Snapshot.
   */
  export interface Snapshot {
    /** If present, the backup policy plan which created this snapshot. */
    backup_policy_plan?: BackupPolicyPlanReference;
    /** Indicates if a boot volume attachment can be created with a volume created from this snapshot. */
    bootable: boolean;
    /** The date and time the data capture for this snapshot was completed.
     *
     *  If absent, this snapshot's data has not yet been captured. Additionally, this property may be absent for
     *  snapshots created before 1 January 2022.
     */
    captured_at?: string;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering inherited from the snapshot's source. If a virtual server instance is
     *  provisioned with a `source_snapshot` specifying this snapshot, the virtual server
     *  instance will use this snapshot's catalog offering, including its pricing plan.
     *
     *  If absent, this snapshot is not associated with a catalog offering.
     */
    catalog_offering?: SnapshotCatalogOffering;
    /** Clones for this snapshot. */
    clones: SnapshotClone[];
    /** The copies of this snapshot. */
    copies: SnapshotCopiesItem[];
    /** The date and time that this snapshot was created. */
    created_at: string;
    /** The CRN of this snapshot. */
    crn: string;
    /** Deprecated: Indicates whether this snapshot can be deleted. This value will always be `true`. */
    deletable: boolean;
    /** The type of encryption used on the source volume. */
    encryption: Snapshot.Constants.Encryption | string;
    /** The root key used to wrap the data encryption key for the source volume.
     *
     *  This property will be present for volumes with an `encryption` type of
     *  `user_managed`.
     */
    encryption_key?: EncryptionKeyReference;
    /** The URL for this snapshot. */
    href: string;
    /** The unique identifier for this snapshot. */
    id: string;
    /** The lifecycle state of this snapshot. */
    lifecycle_state: Snapshot.Constants.LifecycleState | string;
    /** The minimum capacity of a volume created from this snapshot. When a snapshot is created, this will be set to
     *  the capacity of the `source_volume`.
     */
    minimum_capacity: number;
    /** The name for this snapshot. The name is unique across all snapshots in the region. */
    name: string;
    /** The operating system included in this snapshot. */
    operating_system?: OperatingSystem;
    /** Indicates the progress (as a percentage) of storing this snapshot. Only stored snapshots can be used for
     *  restoration.
     */
    progress: number;
    /** The resource group for this snapshot. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: Snapshot.Constants.ResourceType | string;
    /** The [service tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) prefixed with `is.snapshot:`
     *  associated with this snapshot.
     */
    service_tags: string[];
    /** The size of this snapshot rounded up to the next gigabyte. */
    size: number;
    /** If present, the snapshot consistency group which created this snapshot. */
    snapshot_consistency_group?: SnapshotConsistencyGroupReference;
    /** If present, the image from which the data on this snapshot was most directly provisioned. */
    source_image?: ImageReference;
    /** If present, the source snapshot this snapshot was created from. */
    source_snapshot?: SnapshotSourceSnapshot;
    /** The source volume this snapshot was created from (may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     */
    source_volume: VolumeReference;
    /** The [storage
     *  generation](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles&interface=api#using-api-iops-profiles):
     *  - `1`: The first storage generation
     *  - `2`: The second storage generation
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    storage_generation: number;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot. */
    user_tags: string[];
  }
  export namespace Snapshot {
    export namespace Constants {
      /** The type of encryption used on the source volume. */
      export enum Encryption {
        PROVIDER_MANAGED = 'provider_managed',
        USER_MANAGED = 'user_managed',
      }
      /** The lifecycle state of this snapshot. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UNUSABLE = 'unusable',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        SNAPSHOT = 'snapshot',
      }
    }
  }

  /**
   * SnapshotCatalogOffering.
   */
  export interface SnapshotCatalogOffering {
    /** The billing plan associated with the catalog offering version.
     *
     *  If absent, no billing plan is associated with the catalog offering version
     *  (free).
     */
    plan?: CatalogOfferingVersionPlanReference;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering version contained in this snapshot.
     */
    version: CatalogOfferingVersionReference;
  }

  /**
   * SnapshotClone.
   */
  export interface SnapshotClone {
    /** Indicates whether this snapshot clone is available for use. */
    available: boolean;
    /** The date and time that this snapshot clone was created. */
    created_at: string;
    /** The zone this snapshot clone resides in. */
    zone: ZoneReference;
  }

  /**
   * SnapshotCloneCollection.
   */
  export interface SnapshotCloneCollection {
    /** The clones for the snapshot. */
    clones: SnapshotClone[];
  }

  /**
   * SnapshotClonePrototype.
   */
  export interface SnapshotClonePrototype {
    /** The zone this snapshot clone will reside in. Must be in the same region as the snapshot. */
    zone: ZoneIdentity;
  }

  /**
   * SnapshotCollection.
   */
  export interface SnapshotCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of snapshots. */
    snapshots: Snapshot[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * SnapshotConsistencyGroup.
   */
  export interface SnapshotConsistencyGroup {
    /** If present, the backup policy plan which created this snapshot consistency group. */
    backup_policy_plan?: BackupPolicyPlanReference;
    /** The date and time that this snapshot consistency group was created. */
    created_at: string;
    /** The CRN of this snapshot consistency group. */
    crn: string;
    /** Indicates whether deleting the snapshot consistency group will also delete the snapshots in the group. */
    delete_snapshots_on_delete: boolean;
    /** The URL for this snapshot consistency group. */
    href: string;
    /** The unique identifier for this snapshot consistency group. */
    id: string;
    /** The lifecycle state of this snapshot consistency group. */
    lifecycle_state: SnapshotConsistencyGroup.Constants.LifecycleState | string;
    /** The name for this snapshot consistency group. The name is unique across all snapshot consistency groups in
     *  the region.
     */
    name: string;
    /** The resource group for this snapshot consistency group. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: SnapshotConsistencyGroup.Constants.ResourceType | string;
    /** The [service tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot
     *  consistency group. Each tag is prefixed with
     *  [is.instance:](https://cloud.ibm.com/docs/vpc?topic=vpc-snapshots-vpc-faqs).
     */
    service_tags: string[];
    /** The member snapshots that are data-consistent with respect to captured time. (may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     */
    snapshots: SnapshotReference[];
  }
  export namespace SnapshotConsistencyGroup {
    export namespace Constants {
      /** The lifecycle state of this snapshot consistency group. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        SNAPSHOT_CONSISTENCY_GROUP = 'snapshot_consistency_group',
      }
    }
  }

  /**
   * SnapshotConsistencyGroupCollection.
   */
  export interface SnapshotConsistencyGroupCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of snapshot consistency groups. */
    snapshot_consistency_groups: SnapshotConsistencyGroup[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * SnapshotConsistencyGroupPrototype.
   */
  export interface SnapshotConsistencyGroupPrototype {
    /** Indicates whether deleting the snapshot consistency group will also delete the snapshots in the group. */
    delete_snapshots_on_delete?: boolean;
    /** The name for this snapshot consistency group. The name must be unique across all snapshot consistency groups
     *  in the region.
     *
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
  }

  /**
   * SnapshotConsistencyGroupReference.
   */
  export interface SnapshotConsistencyGroupReference {
    /** The CRN of this snapshot consistency group. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this snapshot consistency group. */
    href: string;
    /** The unique identifier for this snapshot consistency group. */
    id: string;
    /** The name for this snapshot consistency group. The name is unique across all snapshot consistency groups in
     *  the region.
     */
    name: string;
    /** The resource type. */
    resource_type: SnapshotConsistencyGroupReference.Constants.ResourceType | string;
  }
  export namespace SnapshotConsistencyGroupReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SNAPSHOT_CONSISTENCY_GROUP = 'snapshot_consistency_group',
      }
    }
  }

  /**
   * SnapshotCopiesItem.
   */
  export interface SnapshotCopiesItem {
    /** The CRN for the copied snapshot. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for the copied snapshot. */
    href: string;
    /** The unique identifier for the copied snapshot. */
    id: string;
    /** The name for the copied snapshot. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: SnapshotRemote;
    /** The resource type. */
    resource_type: SnapshotCopiesItem.Constants.ResourceType | string;
  }
  export namespace SnapshotCopiesItem {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SNAPSHOT = 'snapshot',
      }
    }
  }

  /**
   * Identifies a snapshot by a unique property.
   */
  export interface SnapshotIdentity {
  }

  /**
   * SnapshotPrototype.
   */
  export interface SnapshotPrototype {
    /** Clones to create for this snapshot. */
    clones?: SnapshotClonePrototype[];
    /** The name for this snapshot. The name must not be used by another snapshot in the region. If unspecified, the
     *  name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot. */
    user_tags?: string[];
  }

  /**
   * SnapshotPrototypeSnapshotConsistencyGroupContext.
   */
  export interface SnapshotPrototypeSnapshotConsistencyGroupContext {
    /** The name for this snapshot. The name must not be used by another snapshot in the region. If unspecified, the
     *  name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The volume to create this snapshot from. */
    source_volume: VolumeIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot. */
    user_tags?: string[];
  }

  /**
   * SnapshotReference.
   */
  export interface SnapshotReference {
    /** The CRN of this snapshot. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this snapshot. */
    href: string;
    /** The unique identifier for this snapshot. */
    id: string;
    /** The name for this snapshot. The name is unique across all snapshots in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: SnapshotRemote;
    /** The resource type. */
    resource_type: SnapshotReference.Constants.ResourceType | string;
  }
  export namespace SnapshotReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SNAPSHOT = 'snapshot',
      }
    }
  }

  /**
   * If present, this property indicates that the resource associated with this reference is remote and therefore may
   * not be directly retrievable.
   */
  export interface SnapshotRemote {
    /** If present, this property indicates that the referenced resource is remote to this
     *  account, and identifies the owning account.
     */
    account?: AccountReference;
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /**
   * If present, the source snapshot this snapshot was created from.
   */
  export interface SnapshotSourceSnapshot {
    /** The CRN of the source snapshot. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for the source snapshot. */
    href: string;
    /** The unique identifier for the source snapshot. */
    id: string;
    /** The name for the source snapshot. The name is unique across all snapshots in the source snapshot's native
     *  region.
     */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: SnapshotRemote;
    /** The resource type. */
    resource_type: SnapshotSourceSnapshot.Constants.ResourceType | string;
  }
  export namespace SnapshotSourceSnapshot {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SNAPSHOT = 'snapshot',
      }
    }
  }

  /**
   * Subnet.
   */
  export interface Subnet {
    /** The number of IPv4 addresses in this subnet that are not in-use, and have not been reserved by the user or
     *  the provider.
     */
    available_ipv4_address_count: number;
    /** The date and time that the subnet was created. */
    created_at: string;
    /** The CRN for this subnet. */
    crn: string;
    /** The URL for this subnet. */
    href: string;
    /** The unique identifier for this subnet. */
    id: string;
    /** The IP version(s) supported by this subnet. */
    ip_version: Subnet.Constants.IpVersion | string;
    /** The IPv4 range of the subnet, expressed in CIDR format. */
    ipv4_cidr_block: string;
    /** The name for this subnet. The name is unique across all subnets in the VPC. */
    name: string;
    /** The network ACL for this subnet. */
    network_acl: NetworkACLReference;
    /** The public gateway to use for internet-bound traffic for this subnet. */
    public_gateway?: PublicGatewayReference;
    /** The resource group for this subnet. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: Subnet.Constants.ResourceType | string;
    /** The routing table for this subnet. */
    routing_table: RoutingTableReference;
    /** The status of the subnet.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: Subnet.Constants.Status | string;
    /** The total number of IPv4 addresses in this subnet.
     *
     *  Note: This is calculated as 2<sup>(32 - prefix length)</sup>. For example, the prefix length `/24` gives:<br>
     *  2<sup>(32 - 24)</sup> = 2<sup>8</sup> = 256 addresses.
     */
    total_ipv4_address_count: number;
    /** The VPC this subnet resides in. */
    vpc: VPCReference;
    /** The zone this subnet resides in. */
    zone: ZoneReference;
  }
  export namespace Subnet {
    export namespace Constants {
      /** The IP version(s) supported by this subnet. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The resource type. */
      export enum ResourceType {
        SUBNET = 'subnet',
      }
      /** The status of the subnet. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        AVAILABLE = 'available',
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
      }
    }
  }

  /**
   * SubnetCollection.
   */
  export interface SubnetCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of subnets. */
    subnets: Subnet[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * Identifies a subnet by a unique property.
   */
  export interface SubnetIdentity {
  }

  /**
   * SubnetPrototype.
   */
  export interface SubnetPrototype {
    /** The IP version(s) to support for this subnet. */
    ip_version?: SubnetPrototype.Constants.IpVersion | string;
    /** The name for this subnet. The name must not be used by another subnet in the VPC. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The network ACL to use for this subnet. */
    network_acl?: NetworkACLIdentity;
    /** The public gateway to use for internet-bound traffic for this subnet. If
     *  unspecified, the subnet will not be attached to a public gateway.
     */
    public_gateway?: PublicGatewayIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The routing table to use for this subnet. If unspecified, the default routing table
     *  for the VPC is used. The routing table properties `route_direct_link_ingress`,
     *  `route_internet_ingress`, `route_transit_gateway_ingress`, and
     *  `route_vpc_zone_ingress` must be `false`.
     */
    routing_table?: RoutingTableIdentity;
    /** The VPC the subnet will reside in. */
    vpc: VPCIdentity;
  }
  export namespace SubnetPrototype {
    export namespace Constants {
      /** The IP version(s) to support for this subnet. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
    }
  }

  /**
   * The public gateway to use for internet-bound traffic for this subnet.
   */
  export interface SubnetPublicGatewayPatch {
  }

  /**
   * SubnetReference.
   */
  export interface SubnetReference {
    /** The CRN for this subnet. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this subnet. */
    href: string;
    /** The unique identifier for this subnet. */
    id: string;
    /** The name for this subnet. The name is unique across all subnets in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: SubnetReference.Constants.ResourceType | string;
  }
  export namespace SubnetReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SUBNET = 'subnet',
      }
    }
  }

  /**
   * Identifies a trusted profile by a unique property.
   */
  export interface TrustedProfileIdentity {
  }

  /**
   * TrustedProfileReference.
   */
  export interface TrustedProfileReference {
    /** The CRN for this trusted profile. */
    crn: string;
    /** The unique identifier for this trusted profile. */
    id: string;
    /** The resource type. */
    resource_type: TrustedProfileReference.Constants.ResourceType | string;
  }
  export namespace TrustedProfileReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        TRUSTED_PROFILE = 'trusted_profile',
      }
    }
  }

  /**
   * The VCPU configuration.
   */
  export interface VCPU {
    /** The VCPU architecture.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    architecture: VCPU.Constants.Architecture | string;
    /** The number of VCPUs assigned. */
    count: number;
    /** The VCPU manufacturer.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    manufacturer: VCPU.Constants.Manufacturer | string;
  }
  export namespace VCPU {
    export namespace Constants {
      /** The VCPU architecture. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Architecture {
        AMD64 = 'amd64',
        S390X = 's390x',
      }
      /** The VCPU manufacturer. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Manufacturer {
        AMD = 'amd',
        IBM = 'ibm',
        INTEL = 'intel',
      }
    }
  }

  /**
   * VPC.
   */
  export interface VPC {
    /** Indicates whether this VPC is connected to Classic Infrastructure. If true, this VPC's resources have
     *  private network connectivity to the account's Classic Infrastructure resources. Only one VPC, per region, may be
     *  connected in this way. This value is set at creation and subsequently immutable.
     */
    classic_access: boolean;
    /** The date and time that the VPC was created. */
    created_at: string;
    /** The CRN for this VPC. */
    crn: string;
    /** The CSE ([Cloud Service
     *  Endpoint](https://cloud.ibm.com/docs/account?topic=account-service-endpoints-overview)) source IP addresses for
     *  the VPC. The VPC will have at least one CSE source IP address per zone.
     *
     *  The maximum number of items for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    cse_source_ips?: VPCCSESourceIP[];
    /** The default network ACL to use for subnets created in this VPC. */
    default_network_acl: NetworkACLReference;
    /** The default routing table to use for subnets created in this VPC. */
    default_routing_table: RoutingTableReference;
    /** The default security group for this VPC. Resources created in this VPC that allow
     *  a security group to be optionally specified will use this security group by
     *  default.
     */
    default_security_group: SecurityGroupReference;
    /** The DNS configuration for this VPC. */
    dns: VPCDNS;
    /** The reasons for the current `health_state` (if any). */
    health_reasons: VPCHealthReason[];
    /** The health of this resource:
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle
     *     state. A resource with a lifecycle state of `failed` or `deleting` will have a
     *     health state of `inapplicable`. A `pending` resource may also have this state.
     */
    health_state: VPC.Constants.HealthState | string;
    /** The URL for this VPC. */
    href: string;
    /** The unique identifier for this VPC. */
    id: string;
    /** The name for this VPC. The name is unique across all VPCs in the region. */
    name: string;
    /** The resource group for this VPC. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: VPC.Constants.ResourceType | string;
    /** The status of this VPC.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: VPC.Constants.Status | string;
  }
  export namespace VPC {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The resource type. */
      export enum ResourceType {
        VPC = 'vpc',
      }
      /** The status of this VPC. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        AVAILABLE = 'available',
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
      }
    }
  }

  /**
   * VPCCSESourceIP.
   */
  export interface VPCCSESourceIP {
    /** A cloud service endpoint source IP address for this zone. */
    ip: IP;
    /** The zone this cloud service endpoint source IP resides in. */
    zone: ZoneReference;
  }

  /**
   * VPCCollection.
   */
  export interface VPCCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
    /** A page of VPCs. */
    vpcs: VPC[];
  }

  /**
   * The DNS configuration for this VPC.
   */
  export interface VPCDNS {
    /** Indicates whether this VPC is enabled as a DNS name resolution hub. */
    enable_hub: boolean;
    /** The number of DNS resolution bindings for this VPC. */
    resolution_binding_count: number;
    /** The DNS resolver configuration for the VPC. */
    resolver: VPCDNSResolver;
  }

  /**
   * The DNS configuration for this VPC.
   */
  export interface VPCDNSPatch {
    /** Indicates whether this VPC is enabled as a DNS name resolution hub.
     *
     *  Updating the value to `true` requires `allow_dns_resolution_binding` to be `true` for all endpoint gateways
     *  residing in this VPC.
     *
     *  Changing the value requires `dns.resolution_binding_count` to be zero.
     */
    enable_hub?: boolean;
    resolver?: VPCDNSResolverPatch;
  }

  /**
   * The DNS configuration for this VPC.
   *
   * If unspecified, the system will assign DNS servers capable of resolving hosts and endpoint gateways within this
   * VPC, and hosts on the internet.
   */
  export interface VPCDNSPrototype {
    /** Indicates whether this VPC is enabled as a DNS name resolution hub. */
    enable_hub?: boolean;
    resolver?: VPCDNSResolverPrototype;
  }

  /**
   * VPCDNSResolutionBinding.
   */
  export interface VPCDNSResolutionBinding {
    /** The date and time that the DNS resolution binding was created. */
    created_at: string;
    /** The endpoint gateways that have `allow_dns_resolution_binding` set to `true` and reside in the VPC that has
     *  `dns.enable_hub` set to `false`.
     *
     *  The endpoint gateways may be remote and therefore may not be directly retrievable.
     */
    endpoint_gateways: EndpointGatewayReferenceRemote[];
    /** The reasons for the current `health_state` (if any). */
    health_reasons: VPCDNSResolutionBindingHealthReason[];
    /** The health of this resource:
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle
     *     state. A resource with a lifecycle state of `failed` or `deleting` will have a
     *     health state of `inapplicable`. A `pending` resource may also have this state.
     */
    health_state: VPCDNSResolutionBinding.Constants.HealthState | string;
    /** The URL for this DNS resolution binding. */
    href: string;
    /** The unique identifier for this DNS resolution binding. */
    id: string;
    /** The lifecycle state of the DNS resolution binding. */
    lifecycle_state: VPCDNSResolutionBinding.Constants.LifecycleState | string;
    /** The name for this DNS resolution binding. The name is unique across all DNS resolution bindings for the VPC. */
    name: string;
    /** The resource type. */
    resource_type: VPCDNSResolutionBinding.Constants.ResourceType | string;
    /** The VPC bound to for DNS resolution.
     *
     *  The VPC may be remote and therefore may not be directly retrievable.
     */
    vpc: VPCReferenceRemote;
  }
  export namespace VPCDNSResolutionBinding {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the DNS resolution binding. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        VPC_DNS_RESOLUTION_BINDING = 'vpc_dns_resolution_binding',
      }
    }
  }

  /**
   * VPCDNSResolutionBindingCollection.
   */
  export interface VPCDNSResolutionBindingCollection {
    /** A page of DNS resolution bindings for the VPC. */
    dns_resolution_bindings: VPCDNSResolutionBinding[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * VPCDNSResolutionBindingHealthReason.
   */
  export interface VPCDNSResolutionBindingHealthReason {
    /** A reason code for this health state. */
    code: VPCDNSResolutionBindingHealthReason.Constants.Code | string;
    /** An explanation of the reason for this health state. */
    message: string;
    /** Link to documentation about the reason for this health state. */
    more_info?: string;
  }
  export namespace VPCDNSResolutionBindingHealthReason {
    export namespace Constants {
      /** A reason code for this health state. */
      export enum Code {
        DISCONNECTED_FROM_BOUND_VPC = 'disconnected_from_bound_vpc',
        INTERNAL_ERROR = 'internal_error',
      }
    }
  }

  /**
   * VPCDNSResolver.
   */
  export interface VPCDNSResolver {
    /** The DNS servers for this VPC. The servers are populated:
     *
     *  - by the system when `dns.resolver.type` is `system`
     *  - using the DNS servers in `dns.resolver.vpc` when `dns.resolver.type` is `delegated`
     *  - using `dns.resolver.manual_servers` when the `dns.resolver.type` is `manual`
     *
     *  The maximum number of DNS servers is expected to
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    servers: DNSServer[];
    /** The type of the DNS resolver used for the VPC.
     *
     *  - `delegated`: DNS server addresses are provided by the DNS resolver of the VPC
     *                 specified in `dns.resolver.vpc`.
     *  - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`.
     *  - `system`: DNS server addresses are provided by the system.
     *
     *  The maximum number of DNS servers is expected to
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    type: VPCDNSResolver.Constants.Type | string;
  }
  export namespace VPCDNSResolver {
    export namespace Constants {
      /** The type of the DNS resolver used for the VPC. - `delegated`: DNS server addresses are provided by the DNS resolver of the VPC specified in `dns.resolver.vpc`. - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`. - `system`: DNS server addresses are provided by the system. The maximum number of DNS servers is expected to [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        DELEGATED = 'delegated',
        MANUAL = 'manual',
        SYSTEM = 'system',
      }
    }
  }

  /**
   * VPCDNSResolverPatch.
   */
  export interface VPCDNSResolverPatch {
    /** The DNS servers to use for this VPC, replacing any existing servers. All the DNS servers must either:
     *
     *  - have a unique `zone_affinity`, or
     *  - not have a `zone_affinity`.
     *
     *  If `zone_affinity` is specified, exactly one DNS server must be specified for each zone in the region. The DHCP
     *  [Domain Name Server Option](https://datatracker.ietf.org/doc/html/rfc2132#section-3.8) for a zone will list this
     *  DNS server first, followed by unique DNS servers from other zones if available.
     *
     *  If `zone_affinity` is not specified, the DHCP [Domain Name Server
     *  Option](https://datatracker.ietf.org/doc/html/rfc2132#section-3.8) for each zone will list all the manual DNS
     *  servers in the order specified.
     *
     *  `dns.resolver.manual_servers` must be set if and only if `dns.resolver.type` is `manual`.
     */
    manual_servers?: DNSServerPrototype[];
    /** The type of the DNS resolver to use.
     *
     *  - `delegated`: DNS server addresses will be provided by the resolver for the VPC
     *                 specified in `dns.resolver.vpc`. Requires `dns.enable_hub` to be
     *                 `false`.
     *  - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`.
     *  - `system`: DNS server addresses will be provided by the system and depend on the
     *              configuration.
     *
     *  Updating from `manual` requires `dns.resolver.manual_servers` to be specified as
     *  `null`.
     *
     *  Updating to `manual` requires `dns.resolver.manual_servers` to be specified and not empty.
     *
     *  Updating from `delegated` requires `dns.resolver.vpc` to be specified as `null`.
     */
    type?: VPCDNSResolverPatch.Constants.Type | string;
    /** The VPC to provide DNS server addresses for this VPC.  The specified VPC must be configured
     *  with a [DNS Services](https://cloud.ibm.com/docs/dns-svcs) custom resolver and must be in
     *  one of this VPC's DNS resolution bindings.
     *
     *  Specify `null` to remove an existing VPC.
     *
     *  This property must be set if and only if `dns.resolver.type` is `delegated`.
     */
    vpc?: VPCDNSResolverVPCPatch;
  }
  export namespace VPCDNSResolverPatch {
    export namespace Constants {
      /** The type of the DNS resolver to use. - `delegated`: DNS server addresses will be provided by the resolver for the VPC specified in `dns.resolver.vpc`. Requires `dns.enable_hub` to be `false`. - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`. - `system`: DNS server addresses will be provided by the system and depend on the configuration. Updating from `manual` requires `dns.resolver.manual_servers` to be specified as `null`. Updating to `manual` requires `dns.resolver.manual_servers` to be specified and not empty. Updating from `delegated` requires `dns.resolver.vpc` to be specified as `null`. */
      export enum Type {
        DELEGATED = 'delegated',
        MANUAL = 'manual',
        SYSTEM = 'system',
      }
    }
  }

  /**
   * VPCDNSResolverPrototype.
   */
  export interface VPCDNSResolverPrototype {
    /** The type of the DNS resolver to use.
     *
     *  - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`.
     *  - `system`: DNS server addresses will be provided by the system and depend on the
     *              configuration.
     */
    type?: VPCDNSResolverPrototype.Constants.Type | string;
  }
  export namespace VPCDNSResolverPrototype {
    export namespace Constants {
      /** The type of the DNS resolver to use. - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`. - `system`: DNS server addresses will be provided by the system and depend on the configuration. */
      export enum Type {
        MANUAL = 'manual',
        SYSTEM = 'system',
      }
    }
  }

  /**
   * The VPC to provide DNS server addresses for this VPC.  The specified VPC must be configured with a [DNS
   * Services](https://cloud.ibm.com/docs/dns-svcs) custom resolver and must be in one of this VPC's DNS resolution
   * bindings.
   *
   * Specify `null` to remove an existing VPC.
   *
   * This property must be set if and only if `dns.resolver.type` is `delegated`.
   */
  export interface VPCDNSResolverVPCPatch {
  }

  /**
   * VPCHealthReason.
   */
  export interface VPCHealthReason {
    /** A reason code for this health state. */
    code: VPCHealthReason.Constants.Code | string;
    /** An explanation of the reason for this health state. */
    message: string;
    /** Link to documentation about the reason for this health state. */
    more_info?: string;
  }
  export namespace VPCHealthReason {
    export namespace Constants {
      /** A reason code for this health state. */
      export enum Code {
        DNS_RESOLUTION_BINDING_FAILED = 'dns_resolution_binding_failed',
        INTERNAL_ERROR = 'internal_error',
      }
    }
  }

  /**
   * Identifies a VPC by a unique property.
   */
  export interface VPCIdentity {
  }

  /**
   * VPCReference.
   */
  export interface VPCReference {
    /** The CRN for this VPC. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this VPC. */
    href: string;
    /** The unique identifier for this VPC. */
    id: string;
    /** The name for this VPC. The name is unique across all VPCs in the region. */
    name: string;
    /** The resource type. */
    resource_type: VPCReference.Constants.ResourceType | string;
  }
  export namespace VPCReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPC = 'vpc',
      }
    }
  }

  /**
   * A VPC whose DNS resolver is delegated to provide DNS servers for this VPC.
   *
   * The VPC may be remote and therefore may not be directly retrievable.
   */
  export interface VPCReferenceDNSResolverContext {
    /** The CRN for this VPC. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this VPC. */
    href: string;
    /** The unique identifier for this VPC. */
    id: string;
    /** The name for this VPC. The name is unique across all VPCs in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: VPCRemote;
    /** The resource type. */
    resource_type: VPCReferenceDNSResolverContext.Constants.ResourceType | string;
  }
  export namespace VPCReferenceDNSResolverContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPC = 'vpc',
      }
    }
  }

  /**
   * VPCReferenceRemote.
   */
  export interface VPCReferenceRemote {
    /** The CRN for this VPC. */
    crn: string;
    /** The URL for this VPC. */
    href: string;
    /** The unique identifier for this VPC. */
    id: string;
    /** The name for this VPC. The name is unique across all VPCs in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: VPCRemote;
    /** The resource type. */
    resource_type: VPCReferenceRemote.Constants.ResourceType | string;
  }
  export namespace VPCReferenceRemote {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPC = 'vpc',
      }
    }
  }

  /**
   * If present, this property indicates that the resource associated with this reference is remote and therefore may
   * not be directly retrievable.
   */
  export interface VPCRemote {
    /** If present, this property indicates that the referenced resource is remote to this
     *  account, and identifies the owning account.
     */
    account?: AccountReference;
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /**
   * VPNGateway.
   */
  export interface VPNGateway {
    /** Connections for this VPN gateway. */
    connections: VPNGatewayConnectionReference[];
    /** The date and time that this VPN gateway was created. */
    created_at: string;
    /** The CRN for this VPN gateway. */
    crn: string;
    /** The reasons for the current `health_state` (if any). */
    health_reasons: VPNGatewayHealthReason[];
    /** The health of this resource:
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle
     *     state. A resource with a lifecycle state of `failed` or `deleting` will have a
     *     health state of `inapplicable`. A `pending` resource may also have this state.
     */
    health_state: VPNGateway.Constants.HealthState | string;
    /** The URL for this VPN gateway. */
    href: string;
    /** The unique identifier for this VPN gateway. */
    id: string;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: VPNGatewayLifecycleReason[];
    /** The lifecycle state of the VPN gateway. */
    lifecycle_state: VPNGateway.Constants.LifecycleState | string;
    /** The members for the VPN gateway. */
    members: VPNGatewayMember[];
    /** The name for this VPN gateway. The name is unique across all VPN gateways in the VPC. */
    name: string;
    /** The resource group for this VPN gateway. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: VPNGateway.Constants.ResourceType | string;
    subnet: SubnetReference;
    /** The VPC this VPN gateway resides in. */
    vpc: VPCReference;
  }
  export namespace VPNGateway {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the VPN gateway. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        VPN_GATEWAY = 'vpn_gateway',
      }
    }
  }

  /**
   * VPNGatewayCollection.
   */
  export interface VPNGatewayCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
    /** A page of VPN gateways. */
    vpn_gateways: VPNGateway[];
  }

  /**
   * VPNGatewayConnection.
   */
  export interface VPNGatewayConnection {
    /** If set to false, the VPN gateway connection is shut down. */
    admin_state_up: boolean;
    /** The authentication mode.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    authentication_mode: VPNGatewayConnection.Constants.AuthenticationMode | string;
    /** The date and time that this VPN gateway connection was created. */
    created_at: string;
    /** The Dead Peer Detection settings. */
    dead_peer_detection: VPNGatewayConnectionDPD;
    /** The establish mode of the VPN gateway connection:
     *  - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol
     *     negotiations or rekeying processes.
     *  - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway
     *     connection. Additionally, the peer is responsible for initiating the rekeying process
     *     after the connection is established. If rekeying does not occur, the VPN gateway
     *     connection will be brought down after its lifetime expires.
     */
    establish_mode: VPNGatewayConnection.Constants.EstablishMode | string;
    /** The URL for this VPN gateway connection. */
    href: string;
    /** The unique identifier for this VPN gateway connection. */
    id: string;
    /** The IKE policy. If absent, [auto-negotiation is
     *  used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
     */
    ike_policy?: IKEPolicyReference;
    /** The IPsec policy. If absent, [auto-negotiation is
     *  used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
     */
    ipsec_policy?: IPsecPolicyReference;
    /** The mode of the VPN gateway.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    mode: VPNGatewayConnection.Constants.Mode | string;
    /** The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway. */
    name: string;
    /** The pre-shared key. */
    psk: string;
    /** The resource type. */
    resource_type: VPNGatewayConnection.Constants.ResourceType | string;
    /** The status of a VPN gateway connection. */
    status: VPNGatewayConnection.Constants.Status | string;
    /** The reasons for the current VPN gateway connection status (if any). */
    status_reasons: VPNGatewayConnectionStatusReason[];
  }
  export namespace VPNGatewayConnection {
    export namespace Constants {
      /** The authentication mode. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AuthenticationMode {
        PSK = 'psk',
      }
      /** The establish mode of the VPN gateway connection: - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol negotiations or rekeying processes. - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway connection. Additionally, the peer is responsible for initiating the rekeying process after the connection is established. If rekeying does not occur, the VPN gateway connection will be brought down after its lifetime expires. */
      export enum EstablishMode {
        BIDIRECTIONAL = 'bidirectional',
        PEER_ONLY = 'peer_only',
      }
      /** The mode of the VPN gateway. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Mode {
        POLICY = 'policy',
        ROUTE = 'route',
      }
      /** The resource type. */
      export enum ResourceType {
        VPN_GATEWAY_CONNECTION = 'vpn_gateway_connection',
      }
      /** The status of a VPN gateway connection. */
      export enum Status {
        DOWN = 'down',
        UP = 'up',
      }
    }
  }

  /**
   * VPNGatewayConnectionCIDRs.
   */
  export interface VPNGatewayConnectionCIDRs {
    /** The CIDRs for this resource. */
    cidrs: string[];
  }

  /**
   * VPNGatewayConnectionCollection.
   */
  export interface VPNGatewayConnectionCollection {
    /** A page of connections for the VPN gateway. */
    connections: VPNGatewayConnection[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * The Dead Peer Detection settings.
   */
  export interface VPNGatewayConnectionDPD {
    /** Dead Peer Detection actions. */
    action: VPNGatewayConnectionDPD.Constants.Action | string;
    /** Dead Peer Detection interval in seconds. */
    interval: number;
    /** Dead Peer Detection timeout in seconds. Must be at least the interval. */
    timeout: number;
  }
  export namespace VPNGatewayConnectionDPD {
    export namespace Constants {
      /** Dead Peer Detection actions. */
      export enum Action {
        CLEAR = 'clear',
        HOLD = 'hold',
        NONE = 'none',
        RESTART = 'restart',
      }
    }
  }

  /**
   * The Dead Peer Detection settings.
   */
  export interface VPNGatewayConnectionDPDPatch {
    /** Dead Peer Detection actions. */
    action?: VPNGatewayConnectionDPDPatch.Constants.Action | string;
    /** Dead Peer Detection interval in seconds. */
    interval?: number;
    /** Dead Peer Detection timeout in seconds. Must be at least the interval. */
    timeout?: number;
  }
  export namespace VPNGatewayConnectionDPDPatch {
    export namespace Constants {
      /** Dead Peer Detection actions. */
      export enum Action {
        CLEAR = 'clear',
        HOLD = 'hold',
        NONE = 'none',
        RESTART = 'restart',
      }
    }
  }

  /**
   * The Dead Peer Detection settings.
   */
  export interface VPNGatewayConnectionDPDPrototype {
    /** Dead Peer Detection actions. */
    action?: VPNGatewayConnectionDPDPrototype.Constants.Action | string;
    /** Dead Peer Detection interval in seconds. */
    interval?: number;
    /** Dead Peer Detection timeout in seconds. Must be at least the interval. */
    timeout?: number;
  }
  export namespace VPNGatewayConnectionDPDPrototype {
    export namespace Constants {
      /** Dead Peer Detection actions. */
      export enum Action {
        CLEAR = 'clear',
        HOLD = 'hold',
        NONE = 'none',
        RESTART = 'restart',
      }
    }
  }

  /**
   * VPNGatewayConnectionIKEIdentity.
   */
  export interface VPNGatewayConnectionIKEIdentity {
    /** The IKE identity type.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    type: VPNGatewayConnectionIKEIdentity.Constants.Type | string;
  }
  export namespace VPNGatewayConnectionIKEIdentity {
    export namespace Constants {
      /** The IKE identity type. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        FQDN = 'fqdn',
        HOSTNAME = 'hostname',
        IPV4_ADDRESS = 'ipv4_address',
        KEY_ID = 'key_id',
      }
    }
  }

  /**
   * VPNGatewayConnectionIKEIdentityPrototype.
   */
  export interface VPNGatewayConnectionIKEIdentityPrototype {
    /** The IKE identity type. */
    type: VPNGatewayConnectionIKEIdentityPrototype.Constants.Type | string;
  }
  export namespace VPNGatewayConnectionIKEIdentityPrototype {
    export namespace Constants {
      /** The IKE identity type. */
      export enum Type {
        FQDN = 'fqdn',
        HOSTNAME = 'hostname',
        IPV4_ADDRESS = 'ipv4_address',
        KEY_ID = 'key_id',
      }
    }
  }

  /**
   * The IKE policy to use. Specify `null` to remove any existing policy, [resulting in
   * auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
   */
  export interface VPNGatewayConnectionIKEPolicyPatch {
  }

  /**
   * The IKE policy to use. If unspecified, [auto-negotiation will be
   * used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
   */
  export interface VPNGatewayConnectionIKEPolicyPrototype {
  }

  /**
   * The IPsec policy to use. Specify `null` to remove any existing policy, [resulting in
   * auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
   */
  export interface VPNGatewayConnectionIPsecPolicyPatch {
  }

  /**
   * The IPsec policy to use. If unspecified, [auto-negotiation will be
   * used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
   */
  export interface VPNGatewayConnectionIPsecPolicyPrototype {
  }

  /**
   * VPNGatewayConnectionPeerPatch.
   */
  export interface VPNGatewayConnectionPeerPatch {
  }

  /**
   * VPNGatewayConnectionPolicyModeLocal.
   */
  export interface VPNGatewayConnectionPolicyModeLocal {
    /** The local CIDRs for this VPN gateway connection. */
    cidrs: string[];
    /** The local IKE identities.
     *
     *  A VPN gateway in policy mode consists of two members in active-standby mode. The local IKE identity applies to
     *  the active member.
     */
    ike_identities: VPNGatewayConnectionIKEIdentity[];
  }

  /**
   * VPNGatewayConnectionPolicyModeLocalPrototype.
   */
  export interface VPNGatewayConnectionPolicyModeLocalPrototype {
    /** The local CIDRs for this VPN gateway connection. */
    cidrs: string[];
    /** The local IKE identities to use.
     *
     *  A VPN gateway in policy mode consists of two members in active-standby mode. The specified identity will be
     *  applied to the active member.
     *
     *  If unspecified, then `type` will be `ipv4_address` and `value` will be the public IP address of the VPN gateway.
     */
    ike_identities?: VPNGatewayConnectionIKEIdentityPrototype[];
  }

  /**
   * VPNGatewayConnectionPolicyModePeer.
   */
  export interface VPNGatewayConnectionPolicyModePeer {
    /** The peer CIDRs for this VPN gateway connection. */
    cidrs: string[];
    /** The peer IKE identity. */
    ike_identity: VPNGatewayConnectionIKEIdentity;
    /** Indicates whether `peer.address` or `peer.fqdn` is used. */
    type: VPNGatewayConnectionPolicyModePeer.Constants.Type | string;
  }
  export namespace VPNGatewayConnectionPolicyModePeer {
    export namespace Constants {
      /** Indicates whether `peer.address` or `peer.fqdn` is used. */
      export enum Type {
        ADDRESS = 'address',
        FQDN = 'fqdn',
      }
    }
  }

  /**
   * VPNGatewayConnectionPolicyModePeerPrototype.
   */
  export interface VPNGatewayConnectionPolicyModePeerPrototype {
    /** The peer CIDRs for this VPN gateway connection. */
    cidrs: string[];
    /** The peer IKE identity to use.
     *
     *  If unspecified:
     *  - If `peer.address` is specified, the `type` will be `ipv4_address`, and
     *  the `value` will be `peer.address`.
     *  - If `peer.fqdn` is specified, the `type` will be `fqdn`, and the `value`
     *  will be `peer.fqdn`.
     */
    ike_identity?: VPNGatewayConnectionIKEIdentityPrototype;
  }

  /**
   * VPNGatewayConnectionPrototype.
   */
  export interface VPNGatewayConnectionPrototype {
    /** If set to false, the VPN gateway connection is shut down. */
    admin_state_up?: boolean;
    /** The Dead Peer Detection settings. */
    dead_peer_detection?: VPNGatewayConnectionDPDPrototype;
    /** The establish mode of the VPN gateway connection:
     *  - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol
     *     negotiations or rekeying processes.
     *  - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway
     *     connection. Additionally, the peer is responsible for initiating the rekeying process
     *     after the connection is established. If rekeying does not occur, the VPN gateway
     *     connection will be brought down after its lifetime expires.
     */
    establish_mode?: VPNGatewayConnectionPrototype.Constants.EstablishMode | string;
    /** The IKE policy to use. If unspecified, [auto-negotiation will be
     *  used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
     */
    ike_policy?: VPNGatewayConnectionIKEPolicyPrototype;
    /** The IPsec policy to use. If unspecified, [auto-negotiation will be
     *  used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
     */
    ipsec_policy?: VPNGatewayConnectionIPsecPolicyPrototype;
    /** The name for this VPN gateway connection. The name must not be used by another connection for the VPN
     *  gateway. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The pre-shared key. */
    psk: string;
  }
  export namespace VPNGatewayConnectionPrototype {
    export namespace Constants {
      /** The establish mode of the VPN gateway connection: - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol negotiations or rekeying processes. - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway connection. Additionally, the peer is responsible for initiating the rekeying process after the connection is established. If rekeying does not occur, the VPN gateway connection will be brought down after its lifetime expires. */
      export enum EstablishMode {
        BIDIRECTIONAL = 'bidirectional',
        PEER_ONLY = 'peer_only',
      }
    }
  }

  /**
   * VPNGatewayConnectionReference.
   */
  export interface VPNGatewayConnectionReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this VPN gateway connection. */
    href: string;
    /** The unique identifier for this VPN gateway connection. */
    id: string;
    /** The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway. */
    name: string;
    /** The resource type. */
    resource_type: VPNGatewayConnectionReference.Constants.ResourceType | string;
  }
  export namespace VPNGatewayConnectionReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPN_GATEWAY_CONNECTION = 'vpn_gateway_connection',
      }
    }
  }

  /**
   * VPNGatewayConnectionStaticRouteModeLocal.
   */
  export interface VPNGatewayConnectionStaticRouteModeLocal {
    /** The local IKE identities.
     *
     *  A VPN gateway in static route mode consists of two members in active-active mode. The first identity applies to
     *  the first member, and the second identity applies to the second member.
     */
    ike_identities: VPNGatewayConnectionIKEIdentity[];
  }

  /**
   * VPNGatewayConnectionStaticRouteModeLocalPrototype.
   */
  export interface VPNGatewayConnectionStaticRouteModeLocalPrototype {
    /** The local IKE identities to use.
     *
     *  A VPN gateway in static route mode consists of two members in active-active mode. The first specified identity
     *  will be applied to the first member, and the second specified identity will be applied to the second member.
     *
     *  If unspecified, then `type` will be `ipv4_address` and `value` will be the public IP address of the member's VPN
     *  connection tunnel.
     */
    ike_identities?: VPNGatewayConnectionIKEIdentityPrototype[];
  }

  /**
   * VPNGatewayConnectionStaticRouteModePeer.
   */
  export interface VPNGatewayConnectionStaticRouteModePeer {
    /** The peer IKE identity. */
    ike_identity: VPNGatewayConnectionIKEIdentity;
    /** Indicates whether `peer.address` or `peer.fqdn` is used. */
    type: VPNGatewayConnectionStaticRouteModePeer.Constants.Type | string;
  }
  export namespace VPNGatewayConnectionStaticRouteModePeer {
    export namespace Constants {
      /** Indicates whether `peer.address` or `peer.fqdn` is used. */
      export enum Type {
        ADDRESS = 'address',
        FQDN = 'fqdn',
      }
    }
  }

  /**
   * VPNGatewayConnectionStaticRouteModePeerPrototype.
   */
  export interface VPNGatewayConnectionStaticRouteModePeerPrototype {
    /** The peer IKE identity to use.
     *
     *  If unspecified:
     *  - If `peer.address` is specified, the `type` will be `ipv4_address`, and
     *  the `value` will be `peer.address`.
     *  - If `peer.fqdn` is specified, the `type` will be `fqdn`, and the `value`
     *  will be `peer.fqdn`.
     */
    ike_identity?: VPNGatewayConnectionIKEIdentityPrototype;
  }

  /**
   * VPNGatewayConnectionStaticRouteModeTunnel.
   */
  export interface VPNGatewayConnectionStaticRouteModeTunnel {
    /** The IP address of the VPN gateway member in which the tunnel resides. */
    public_ip: IP;
    /** The status of the VPN Tunnel.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: VPNGatewayConnectionStaticRouteModeTunnel.Constants.Status | string;
    /** The reasons for the current status (if any). */
    status_reasons: VPNGatewayConnectionTunnelStatusReason[];
  }
  export namespace VPNGatewayConnectionStaticRouteModeTunnel {
    export namespace Constants {
      /** The status of the VPN Tunnel. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        DOWN = 'down',
        UP = 'up',
      }
    }
  }

  /**
   * VPNGatewayConnectionStatusReason.
   */
  export interface VPNGatewayConnectionStatusReason {
    /** A snake case string succinctly identifying the status reason.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: VPNGatewayConnectionStatusReason.Constants.Code | string;
    /** An explanation of the reason for this VPN gateway connection's status. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace VPNGatewayConnectionStatusReason {
    export namespace Constants {
      /** A snake case string succinctly identifying the status reason. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        CANNOT_AUTHENTICATE_CONNECTION = 'cannot_authenticate_connection',
        IKE_POLICY_MISMATCH = 'ike_policy_mismatch',
        IKE_V1_ID_LOCAL_REMOTE_CIDR_MISMATCH = 'ike_v1_id_local_remote_cidr_mismatch',
        IKE_V2_LOCAL_REMOTE_CIDR_MISMATCH = 'ike_v2_local_remote_cidr_mismatch',
        INTERNAL_ERROR = 'internal_error',
        IPSEC_POLICY_MISMATCH = 'ipsec_policy_mismatch',
        PEER_NOT_RESPONDING = 'peer_not_responding',
      }
    }
  }

  /**
   * VPNGatewayConnectionTunnelStatusReason.
   */
  export interface VPNGatewayConnectionTunnelStatusReason {
    /** A reason code for this status:
     *  - `cannot_authenticate_connection`: Failed to authenticate a connection because of
     *    mismatched IKE ID and PSK (check IKE ID and PSK in peer VPN configuration)
     *  - `internal_error`: Internal error (contact IBM support)
     *  - `ike_policy_mismatch`: None of the proposed IKE crypto suites was acceptable (check
     *     the IKE policies on both sides of the VPN)
     *  - `ike_v1_id_local_remote_cidr_mismatch`: Invalid IKE ID or mismatched local CIDRs and
     *    remote CIDRs in IKE V1 (check the IKE ID or the local CIDRs and remote CIDRs in IKE
     *    V1 configuration)
     *  - `ike_v2_local_remote_cidr_mismatch`: Mismatched local CIDRs and remote CIDRs in IKE
     *    V2 (check the local CIDRs and remote CIDRs in IKE V2 configuration)
     *  - `ipsec_policy_mismatch`: None of the proposed IPsec crypto suites was acceptable
     *    (check the IPsec policies on both sides of the VPN)
     *  - `peer_not_responding`: No response from peer (check network ACL configuration, peer
     *    availability, and on-premise firewall configuration)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: VPNGatewayConnectionTunnelStatusReason.Constants.Code | string;
    /** An explanation of the reason for this VPN gateway connection tunnel's status. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace VPNGatewayConnectionTunnelStatusReason {
    export namespace Constants {
      /** A reason code for this status: - `cannot_authenticate_connection`: Failed to authenticate a connection because of mismatched IKE ID and PSK (check IKE ID and PSK in peer VPN configuration) - `internal_error`: Internal error (contact IBM support) - `ike_policy_mismatch`: None of the proposed IKE crypto suites was acceptable (check the IKE policies on both sides of the VPN) - `ike_v1_id_local_remote_cidr_mismatch`: Invalid IKE ID or mismatched local CIDRs and remote CIDRs in IKE V1 (check the IKE ID or the local CIDRs and remote CIDRs in IKE V1 configuration) - `ike_v2_local_remote_cidr_mismatch`: Mismatched local CIDRs and remote CIDRs in IKE V2 (check the local CIDRs and remote CIDRs in IKE V2 configuration) - `ipsec_policy_mismatch`: None of the proposed IPsec crypto suites was acceptable (check the IPsec policies on both sides of the VPN) - `peer_not_responding`: No response from peer (check network ACL configuration, peer availability, and on-premise firewall configuration) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        CANNOT_AUTHENTICATE_CONNECTION = 'cannot_authenticate_connection',
        IKE_POLICY_MISMATCH = 'ike_policy_mismatch',
        IKE_V1_ID_LOCAL_REMOTE_CIDR_MISMATCH = 'ike_v1_id_local_remote_cidr_mismatch',
        IKE_V2_LOCAL_REMOTE_CIDR_MISMATCH = 'ike_v2_local_remote_cidr_mismatch',
        INTERNAL_ERROR = 'internal_error',
        IPSEC_POLICY_MISMATCH = 'ipsec_policy_mismatch',
        PEER_NOT_RESPONDING = 'peer_not_responding',
      }
    }
  }

  /**
   * VPNGatewayHealthReason.
   */
  export interface VPNGatewayHealthReason {
    /** A reason code for this health state:
     *  - `cannot_create_vpc_route`: VPN cannot create route (check for conflict)
     *  - `cannot_reserve_ip_address`: IP address exhaustion (release addresses on the VPN's
     *    subnet)
     *  - `internal_error`: Internal error (contact IBM support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: VPNGatewayHealthReason.Constants.Code | string;
    /** An explanation of the reason for this health state. */
    message: string;
    /** Link to documentation about the reason for this health state. */
    more_info?: string;
  }
  export namespace VPNGatewayHealthReason {
    export namespace Constants {
      /** A reason code for this health state: - `cannot_create_vpc_route`: VPN cannot create route (check for conflict) - `cannot_reserve_ip_address`: IP address exhaustion (release addresses on the VPN's subnet) - `internal_error`: Internal error (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        CANNOT_CREATE_VPC_ROUTE = 'cannot_create_vpc_route',
        CANNOT_RESERVE_IP_ADDRESS = 'cannot_reserve_ip_address',
        INTERNAL_ERROR = 'internal_error',
      }
    }
  }

  /**
   * VPNGatewayLifecycleReason.
   */
  export interface VPNGatewayLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: VPNGatewayLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace VPNGatewayLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * VPNGatewayMember.
   */
  export interface VPNGatewayMember {
    /** The reasons for the current `health_state` (if any). */
    health_reasons: VPNGatewayMemberHealthReason[];
    /** The health of this resource:
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle
     *     state. A resource with a lifecycle state of `failed` or `deleting` will have a
     *     health state of `inapplicable`. A `pending` resource may also have this state.
     */
    health_state: VPNGatewayMember.Constants.HealthState | string;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: VPNGatewayMemberLifecycleReason[];
    /** The lifecycle state of the VPN gateway member. */
    lifecycle_state: VPNGatewayMember.Constants.LifecycleState | string;
    /** The reserved IP address assigned to the VPN gateway member.
     *
     *  This property will be present only when the VPN gateway status is `available`.
     */
    private_ip: ReservedIPReference;
    /** The public IP address assigned to the VPN gateway member. */
    public_ip: IP;
    /** The high availability role assigned to the VPN gateway member.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    role: VPNGatewayMember.Constants.Role | string;
  }
  export namespace VPNGatewayMember {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the VPN gateway member. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The high availability role assigned to the VPN gateway member. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Role {
        ACTIVE = 'active',
        STANDBY = 'standby',
      }
    }
  }

  /**
   * VPNGatewayMemberHealthReason.
   */
  export interface VPNGatewayMemberHealthReason {
    /** A reason code for this health state:
     *  - `cannot_reserve_ip_address`: IP address exhaustion (release addresses on the VPN's
     *    subnet)
     *  - `internal_error`: Internal error (contact IBM support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: VPNGatewayMemberHealthReason.Constants.Code | string;
    /** An explanation of the reason for this health state. */
    message: string;
    /** Link to documentation about the reason for this health state. */
    more_info?: string;
  }
  export namespace VPNGatewayMemberHealthReason {
    export namespace Constants {
      /** A reason code for this health state: - `cannot_reserve_ip_address`: IP address exhaustion (release addresses on the VPN's subnet) - `internal_error`: Internal error (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        CANNOT_RESERVE_IP_ADDRESS = 'cannot_reserve_ip_address',
        INTERNAL_ERROR = 'internal_error',
      }
    }
  }

  /**
   * VPNGatewayMemberLifecycleReason.
   */
  export interface VPNGatewayMemberLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: VPNGatewayMemberLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace VPNGatewayMemberLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * VPNGatewayPrototype.
   */
  export interface VPNGatewayPrototype {
    /** The name for this VPN gateway. The name must not be used by another VPN gateway in the VPC. If unspecified,
     *  the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** Identifies a subnet by a unique property. */
    subnet: SubnetIdentity;
  }

  /**
   * VPNServer.
   */
  export interface VPNServer {
    /** The certificate instance for this VPN server. */
    certificate: CertificateInstanceReference;
    /** The methods used to authenticate VPN clients to this VPN server. VPN clients must authenticate against all
     *  specified methods.
     */
    client_authentication: VPNServerAuthentication[];
    /** Indicates whether disconnected VPN clients will be automatically deleted after
     *  `client_auto_delete_timeout` hours have passed. At present, this is always `true`, but may be modifiable in the
     *  future.
     */
    client_auto_delete: boolean;
    /** If `client_auto_delete` is `true`, the hours after which disconnected VPN clients will be automatically
     *  deleted. If the value is `0`, disconnected VPN clients will be deleted immediately. This value may be modifiable
     *  in the future.
     */
    client_auto_delete_timeout: number;
    /** The DNS server addresses that will be provided to VPN clients that are connected to this VPN server. */
    client_dns_server_ips: IP[];
    /** The seconds a VPN client can be idle before this VPN server will disconnect it.  If `0`, the server will not
     *  disconnect idle clients.
     */
    client_idle_timeout: number;
    /** The VPN client IPv4 address pool, expressed in CIDR format. */
    client_ip_pool: string;
    /** The date and time that the VPN server was created. */
    created_at: string;
    /** The CRN for this VPN server. */
    crn: string;
    /** Indicates whether the split tunneling is enabled on this VPN server. */
    enable_split_tunneling: boolean;
    /** The reasons for the current `health_state` (if any). */
    health_reasons: VPNServerHealthReason[];
    /** The health of this resource:
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle
     *     state. A resource with a lifecycle state of `failed` or `deleting` will have a
     *     health state of `inapplicable`. A `pending` resource may also have this state.
     */
    health_state: VPNServer.Constants.HealthState | string;
    /** Fully qualified domain name assigned to this VPN server. */
    hostname: string;
    /** The URL for this VPN server. */
    href: string;
    /** The unique identifier for this VPN server. */
    id: string;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: VPNServerLifecycleReason[];
    /** The lifecycle state of the VPN server. */
    lifecycle_state: VPNServer.Constants.LifecycleState | string;
    /** The name for this VPN server. The name is unique across all VPN servers in the VPC. */
    name: string;
    /** The port number used by this VPN server. */
    port: number;
    /** The reserved IPs bound to this VPN server. */
    private_ips: ReservedIPReference[];
    /** The transport protocol to use for this VPN server.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    protocol: VPNServer.Constants.Protocol | string;
    /** The resource group for this VPN server. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: VPNServer.Constants.ResourceType | string;
    /** The security groups targeting this VPN server. */
    security_groups: SecurityGroupReference[];
    /** The subnets this VPN server is provisioned in. */
    subnets: SubnetReference[];
    /** The VPC this VPN server resides in. */
    vpc: VPCReference;
  }
  export namespace VPNServer {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the VPN server. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The transport protocol to use for this VPN server. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Protocol {
        TCP = 'tcp',
        UDP = 'udp',
      }
      /** The resource type. */
      export enum ResourceType {
        VPN_SERVER = 'vpn_server',
      }
    }
  }

  /**
   * An authentication method for this VPN server.
   */
  export interface VPNServerAuthentication {
    /** The type of authentication.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    method: VPNServerAuthentication.Constants.Method | string;
  }
  export namespace VPNServerAuthentication {
    export namespace Constants {
      /** The type of authentication. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Method {
        CERTIFICATE = 'certificate',
        USERNAME = 'username',
      }
    }
  }

  /**
   * The type of identity provider to be used by VPN client.
   */
  export interface VPNServerAuthenticationByUsernameIdProvider {
  }

  /**
   * An authentication method for this VPN server.
   */
  export interface VPNServerAuthenticationPrototype {
    /** The type of authentication. */
    method: VPNServerAuthenticationPrototype.Constants.Method | string;
  }
  export namespace VPNServerAuthenticationPrototype {
    export namespace Constants {
      /** The type of authentication. */
      export enum Method {
        CERTIFICATE = 'certificate',
        USERNAME = 'username',
      }
    }
  }

  /**
   * VPNServerClient.
   */
  export interface VPNServerClient {
    /** The IP address assigned to this VPN client from `client_ip_pool`. */
    client_ip: IP;
    /** The common name of client certificate that the VPN client provided when connecting to the server.
     *
     *  This property will be present only when the `certificate` client authentication method is enabled on the VPN
     *  server.
     */
    common_name?: string;
    /** The date and time that the VPN client was created. */
    created_at: string;
    /** The date and time that the VPN client was disconnected.
     *
     *  This property will be present only when the client `status` is `disconnected`.
     */
    disconnected_at?: string;
    /** The URL for this VPN client. */
    href: string;
    /** The unique identifier for this VPN client. */
    id: string;
    /** The remote IP address of this VPN client. */
    remote_ip: IP;
    /** The remote port of this VPN client. */
    remote_port: number;
    /** The resource type. */
    resource_type: VPNServerClient.Constants.ResourceType | string;
    /** The status of the VPN client:
     *  - `connected`: the VPN client is `connected` to this VPN server.
     *  - `disconnected`: the VPN client is `disconnected` from this VPN server.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: VPNServerClient.Constants.Status | string;
    /** The username that this VPN client provided when connecting to the VPN server.
     *
     *  This property will be present only when the `username` client authentication method is enabled on the VPN
     *  server.
     */
    username?: string;
  }
  export namespace VPNServerClient {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPN_SERVER_CLIENT = 'vpn_server_client',
      }
      /** The status of the VPN client: - `connected`: the VPN client is `connected` to this VPN server. - `disconnected`: the VPN client is `disconnected` from this VPN server. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        CONNECTED = 'connected',
        DISCONNECTED = 'disconnected',
      }
    }
  }

  /**
   * VPNServerClientCollection.
   */
  export interface VPNServerClientCollection {
    /** A page of clients of the VPN server. */
    clients: VPNServerClient[];
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * VPNServerCollection.
   */
  export interface VPNServerCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
    /** A page of VPN servers. */
    vpn_servers: VPNServer[];
  }

  /**
   * VPNServerHealthReason.
   */
  export interface VPNServerHealthReason {
    /** A reason code for this health state:
     *  - `cannot_access_client_certificate`: VPN server's client certificate is inaccessible
     *    (verify certificate exists and that IAM policies grant `VPN server for VPC` access
     *    to `Secrets Manager`)
     *  - `cannot_access_server_certificate`: VPN server's server certificate is inaccessible
     *    (verify certificate exists and that IAM policies grant `VPN server for VPC` access
     *    to `Secrets Manager`)
     *  - `cannot_create_vpc_route`: VPN cannot create route (check for conflict)
     *  - `cannot_reserve_ip_address`: IP address exhaustion (release addresses on the VPN's
     *    subnet)
     *  - `internal_error`: Internal error (contact IBM support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: VPNServerHealthReason.Constants.Code | string;
    /** An explanation of the reason for this health state. */
    message: string;
    /** Link to documentation about the reason for this health state. */
    more_info?: string;
  }
  export namespace VPNServerHealthReason {
    export namespace Constants {
      /** A reason code for this health state: - `cannot_access_client_certificate`: VPN server's client certificate is inaccessible (verify certificate exists and that IAM policies grant `VPN server for VPC` access to `Secrets Manager`) - `cannot_access_server_certificate`: VPN server's server certificate is inaccessible (verify certificate exists and that IAM policies grant `VPN server for VPC` access to `Secrets Manager`) - `cannot_create_vpc_route`: VPN cannot create route (check for conflict) - `cannot_reserve_ip_address`: IP address exhaustion (release addresses on the VPN's subnet) - `internal_error`: Internal error (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        CANNOT_ACCESS_CLIENT_CERTIFICATE = 'cannot_access_client_certificate',
        CANNOT_ACCESS_SERVER_CERTIFICATE = 'cannot_access_server_certificate',
        CANNOT_CREATE_VPC_ROUTE = 'cannot_create_vpc_route',
        CANNOT_RESERVE_IP_ADDRESS = 'cannot_reserve_ip_address',
        INTERNAL_ERROR = 'internal_error',
      }
    }
  }

  /**
   * VPNServerLifecycleReason.
   */
  export interface VPNServerLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: VPNServerLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace VPNServerLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * VPNServerRoute.
   */
  export interface VPNServerRoute {
    /** The action to perform with a packet matching the VPN route:
     *  - `translate`: translate the source IP address to one of the private IP addresses of
     *    the VPN server, then deliver the packet to target.
     *  - `deliver`: deliver the packet into the VPC.
     *  - `drop`: drop the packet
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    action: VPNServerRoute.Constants.Action | string;
    /** The date and time that the VPN route was created. */
    created_at: string;
    /** The destination for this VPN route in the VPN server. If an incoming packet does not match any destination,
     *  it will be dropped.
     */
    destination: string;
    /** The reasons for the current `health_state` (if any). */
    health_reasons: VPNServerRouteHealthReason[];
    /** The health of this resource:
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle
     *     state. A resource with a lifecycle state of `failed` or `deleting` will have a
     *     health state of `inapplicable`. A `pending` resource may also have this state.
     */
    health_state: VPNServerRoute.Constants.HealthState | string;
    /** The URL for this VPN route. */
    href: string;
    /** The unique identifier for this VPN route. */
    id: string;
    /** The reasons for the current `lifecycle_state` (if any). */
    lifecycle_reasons: VPNServerRouteLifecycleReason[];
    /** The lifecycle state of the VPN route. */
    lifecycle_state: VPNServerRoute.Constants.LifecycleState | string;
    /** The name for this VPN route. The name is unique across all routes for a VPN server. */
    name: string;
    /** The resource type. */
    resource_type: VPNServerRoute.Constants.ResourceType | string;
  }
  export namespace VPNServerRoute {
    export namespace Constants {
      /** The action to perform with a packet matching the VPN route: - `translate`: translate the source IP address to one of the private IP addresses of the VPN server, then deliver the packet to target. - `deliver`: deliver the packet into the VPC. - `drop`: drop the packet The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Action {
        DELIVER = 'deliver',
        DROP = 'drop',
        TRANSLATE = 'translate',
      }
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the VPN route. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        VPN_SERVER_ROUTE = 'vpn_server_route',
      }
    }
  }

  /**
   * VPNServerRouteCollection.
   */
  export interface VPNServerRouteCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of routes for the VPN server. */
    routes: VPNServerRoute[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * VPNServerRouteHealthReason.
   */
  export interface VPNServerRouteHealthReason {
    /** A reason code for this health state:
     *  - `internal_error`: Internal error (contact IBM support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: VPNServerRouteHealthReason.Constants.Code | string;
    /** An explanation of the reason for this health state. */
    message: string;
    /** Link to documentation about the reason for this health state. */
    more_info?: string;
  }
  export namespace VPNServerRouteHealthReason {
    export namespace Constants {
      /** A reason code for this health state: - `internal_error`: Internal error (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
      }
    }
  }

  /**
   * VPNServerRouteLifecycleReason.
   */
  export interface VPNServerRouteLifecycleReason {
    /** A reason code for this lifecycle state:
     *  - `internal_error`: internal error (contact IBM support)
     *  - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
     *    support)
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: VPNServerRouteLifecycleReason.Constants.Code | string;
    /** An explanation of the reason for this lifecycle state. */
    message: string;
    /** Link to documentation about the reason for this lifecycle state. */
    more_info?: string;
  }
  export namespace VPNServerRouteLifecycleReason {
    export namespace Constants {
      /** A reason code for this lifecycle state: - `internal_error`: internal error (contact IBM support) - `resource_suspended_by_provider`: The resource has been suspended (contact IBM support) The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        INTERNAL_ERROR = 'internal_error',
        RESOURCE_SUSPENDED_BY_PROVIDER = 'resource_suspended_by_provider',
      }
    }
  }

  /**
   * VirtualNetworkInterface.
   */
  export interface VirtualNetworkInterface {
    /** Indicates whether source IP spoofing is allowed on this interface. If `false`, source IP spoofing is
     *  prevented on this interface. If `true`, source IP spoofing is allowed on this interface.
     */
    allow_ip_spoofing: boolean;
    /** Indicates whether this virtual network interface will be automatically deleted when `target` is deleted. */
    auto_delete: boolean;
    /** The date and time that the virtual network interface was created. */
    created_at: string;
    /** The CRN for this virtual network interface. */
    crn: string;
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the virtual network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - Can only be attached to a `target` with a `resource_type` of
     *    `bare_metal_server_network_attachment`.
     */
    enable_infrastructure_nat: boolean;
    /** The URL for this virtual network interface. */
    href: string;
    /** The unique identifier for this virtual network interface. */
    id: string;
    /** The reserved IPs bound to this virtual network interface.
     *
     *  May be empty when `lifecycle_state` is `pending`.
     */
    ips: ReservedIPReference[];
    /** The lifecycle state of the virtual network interface. */
    lifecycle_state: VirtualNetworkInterface.Constants.LifecycleState | string;
    /** The MAC address of the virtual network interface. May be absent if `lifecycle_state` is `pending`. */
    mac_address?: string;
    /** The name for this virtual network interface. The name is unique across all virtual network interfaces in the
     *  VPC.
     */
    name: string;
    /** The reserved IP for this virtual network interface. */
    primary_ip: ReservedIPReference;
    /** The protocol state filtering mode used for this virtual network interface. If `auto`, protocol state packet
     *  filtering is enabled or disabled based on the virtual network interface's `target` resource type:
     *
     *  - `bare_metal_server_network_attachment`: disabled
     *  - `instance_network_attachment`: enabled
     *  - `share_mount_target`: enabled
     *
     *  Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops
     *  any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering
     *  mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering)) for more information.
     */
    protocol_state_filtering_mode: VirtualNetworkInterface.Constants.ProtocolStateFilteringMode | string;
    /** The resource group for this virtual network interface. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: VirtualNetworkInterface.Constants.ResourceType | string;
    /** The security groups for this virtual network interface. */
    security_groups: SecurityGroupReference[];
    /** The associated subnet. */
    subnet: SubnetReference;
    /** The target of this virtual network interface.
     *
     *  If absent, this virtual network interface is not attached to a target.
     */
    target?: VirtualNetworkInterfaceTarget;
    /** The VPC this virtual network interface resides in. */
    vpc: VPCReference;
    /** The zone this virtual network interface resides in. */
    zone: ZoneReference;
  }
  export namespace VirtualNetworkInterface {
    export namespace Constants {
      /** The lifecycle state of the virtual network interface. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The protocol state filtering mode used for this virtual network interface. If `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target` resource type: - `bare_metal_server_network_attachment`: disabled - `instance_network_attachment`: enabled - `share_mount_target`: enabled Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering)) for more information. */
      export enum ProtocolStateFilteringMode {
        AUTO = 'auto',
        DISABLED = 'disabled',
        ENABLED = 'enabled',
      }
      /** The resource type. */
      export enum ResourceType {
        VIRTUAL_NETWORK_INTERFACE = 'virtual_network_interface',
      }
    }
  }

  /**
   * VirtualNetworkInterfaceCollection.
   */
  export interface VirtualNetworkInterfaceCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
    /** A page of virtual network interfaces. */
    virtual_network_interfaces: VirtualNetworkInterface[];
  }

  /**
   * VirtualNetworkInterfaceIPPrototype.
   */
  export interface VirtualNetworkInterfaceIPPrototype {
  }

  /**
   * VirtualNetworkInterfacePrimaryIPPrototype.
   */
  export interface VirtualNetworkInterfacePrimaryIPPrototype {
  }

  /**
   * VirtualNetworkInterfaceReferenceAttachmentContext.
   */
  export interface VirtualNetworkInterfaceReferenceAttachmentContext {
    /** The CRN for this virtual network interface. */
    crn: string;
    /** The URL for this virtual network interface. */
    href: string;
    /** The unique identifier for this virtual network interface. */
    id: string;
    /** The name for this virtual network interface. The name is unique across all virtual network interfaces in the
     *  VPC.
     */
    name: string;
    /** The resource type. */
    resource_type: VirtualNetworkInterfaceReferenceAttachmentContext.Constants.ResourceType | string;
  }
  export namespace VirtualNetworkInterfaceReferenceAttachmentContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VIRTUAL_NETWORK_INTERFACE = 'virtual_network_interface',
      }
    }
  }

  /**
   * A virtual network interface target.
   *
   * The resources supported by this property may
   * [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
   */
  export interface VirtualNetworkInterfaceTarget {
  }

  /**
   * Volume.
   */
  export interface Volume {
    /** Indicates whether a running virtual server instance has an attachment to this volume. */
    active: boolean;
    /** The attachment states that support adjustable capacity for this volume. */
    adjustable_capacity_states: Volume.Constants.AdjustableCapacityStates[] | string[];
    /** The attachment states that support adjustable IOPS for this volume. */
    adjustable_iops_states: Volume.Constants.AdjustableIopsStates[] | string[];
    /** The attachment state of the volume
     *  - `unattached`: Not attached to any virtual server instances
     *  - `attached`: Attached to a virtual server instance (even if the instance is stopped)
     *  - `unusable`: Not able to be attached to any virtual server instances.
     */
    attachment_state: Volume.Constants.AttachmentState | string;
    /** The maximum bandwidth (in megabits per second) for the volume.
     *
     *  If the volume profile has a `bandwidth.type` of `dependent`, the [bandwidth is
     *  calculated](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-bandwidth#attached-block-vol-bandwidth) from
     *  the `iops` value.
     *
     *  The minimum and maximum limits for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    bandwidth: number;
    /** Indicates whether this volume is performing an operation that must be serialized. This must be `false` to
     *  perform an operation that is specified to require serialization.
     */
    busy: boolean;
    /** The capacity to use for the volume (in gigabytes).
     *
     *  The minimum and maximum limits for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    capacity: number;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering this volume was created from. If a virtual server instance is provisioned
     *  with a `boot_volume_attachment` specifying this volume, the virtual server instance
     *  will use this volume's catalog offering, including its pricing plan.
     *
     *  If absent, this volume was not created from a catalog offering.
     */
    catalog_offering?: VolumeCatalogOffering;
    /** The date and time that the volume was created. */
    created_at: string;
    /** The CRN for this volume. */
    crn: string;
    /** The type of encryption used on the volume. */
    encryption: Volume.Constants.Encryption | string;
    /** The root key used to wrap the data encryption key for the volume.
     *
     *  This property will be present for volumes with an `encryption` type of
     *  `user_managed`.
     */
    encryption_key?: EncryptionKeyReference;
    /** The reasons for the current `health_state` (if any). */
    health_reasons: VolumeHealthReason[];
    /** The health of this resource:
     *  - `ok`: No abnormal behavior detected
     *  - `degraded`: Experiencing compromised performance, capacity, or connectivity
     *  - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
     *  - `inapplicable`: The health state does not apply because of the current lifecycle
     *     state. A resource with a lifecycle state of `failed` or `deleting` will have a
     *     health state of `inapplicable`. A `pending` resource may also have this state.
     */
    health_state: Volume.Constants.HealthState | string;
    /** The URL for this volume. */
    href: string;
    /** The unique identifier for this volume. */
    id: string;
    /** The maximum I/O operations per second (IOPS) for this volume. */
    iops: number;
    /** The name for this volume. The name is unique across all volumes in the region. */
    name: string;
    /** The operating system associated with this volume. If absent, this volume was not
     *  created from an image, or the image did not include an operating system.
     */
    operating_system?: OperatingSystem;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) for this volume. */
    profile: VolumeProfileReference;
    /** The resource group for this volume. */
    resource_group: ResourceGroupReference;
    /** The resource type. */
    resource_type: Volume.Constants.ResourceType | string;
    /** The image from which this volume was created (this may be
     *  [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
     *  If absent, this volume was not created from an image.
     */
    source_image?: ImageReference;
    /** The snapshot from which this volume was cloned. */
    source_snapshot?: SnapshotReference;
    /** The status of the volume.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: Volume.Constants.Status | string;
    /** The reasons for the current status (if any). */
    status_reasons: VolumeStatusReason[];
    /** The [storage
     *  generation](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles&interface=api#using-api-iops-profiles):
     *  - `1`: The first storage generation
     *  - `2`: The second storage generation
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    storage_generation: number;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume. */
    user_tags: string[];
    /** The volume attachments for this volume. */
    volume_attachments: VolumeAttachmentReferenceVolumeContext[];
    /** The zone this volume resides in. */
    zone: ZoneReference;
  }
  export namespace Volume {
    export namespace Constants {
      /** The attachment states that support adjustable capacity for this volume. */
      export enum AdjustableCapacityStates {
        ATTACHED = 'attached',
        UNATTACHED = 'unattached',
        UNUSABLE = 'unusable',
      }
      /** The attachment states that support adjustable IOPS for this volume. */
      export enum AdjustableIopsStates {
        ATTACHED = 'attached',
        UNATTACHED = 'unattached',
        UNUSABLE = 'unusable',
      }
      /** The attachment state of the volume - `unattached`: Not attached to any virtual server instances - `attached`: Attached to a virtual server instance (even if the instance is stopped) - `unusable`: Not able to be attached to any virtual server instances. */
      export enum AttachmentState {
        ATTACHED = 'attached',
        UNATTACHED = 'unattached',
        UNUSABLE = 'unusable',
      }
      /** The type of encryption used on the volume. */
      export enum Encryption {
        PROVIDER_MANAGED = 'provider_managed',
        USER_MANAGED = 'user_managed',
      }
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The resource type. */
      export enum ResourceType {
        VOLUME = 'volume',
      }
      /** The status of the volume. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        AVAILABLE = 'available',
        FAILED = 'failed',
        PENDING = 'pending',
        PENDING_DELETION = 'pending_deletion',
        UNUSABLE = 'unusable',
        UPDATING = 'updating',
      }
    }
  }

  /**
   * VolumeAttachment.
   */
  export interface VolumeAttachment {
    /** The maximum bandwidth (in megabits per second) for the volume when attached to this instance. This may be
     *  lower than the volume bandwidth depending on the configuration of the instance.
     */
    bandwidth: number;
    /** The date and time that the volume was attached. */
    created_at: string;
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete: boolean;
    /** Information about how the volume is exposed to the instance operating system.
     *
     *  This property may be absent if the volume attachment's `status` is not `attached`.
     */
    device?: VolumeAttachmentDevice;
    /** The URL for this volume attachment. */
    href: string;
    /** The unique identifier for this volume attachment. */
    id: string;
    /** The name for this volume attachment. The name is unique across all volume attachments on the instance. */
    name: string;
    /** The status of this volume attachment.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: VolumeAttachment.Constants.Status | string;
    /** The type of volume attachment.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    type: VolumeAttachment.Constants.Type | string;
    /** The attached volume.
     *
     *  This property will be absent if the volume has not yet been provisioned.
     */
    volume?: VolumeReferenceVolumeAttachmentContext;
  }
  export namespace VolumeAttachment {
    export namespace Constants {
      /** The status of this volume attachment. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        ATTACHED = 'attached',
        ATTACHING = 'attaching',
        DELETING = 'deleting',
        DETACHING = 'detaching',
      }
      /** The type of volume attachment. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        BOOT = 'boot',
        DATA = 'data',
      }
    }
  }

  /**
   * VolumeAttachmentCollection.
   */
  export interface VolumeAttachmentCollection {
    /** The volume attachments for the instance. */
    volume_attachments: VolumeAttachment[];
  }

  /**
   * VolumeAttachmentDevice.
   */
  export interface VolumeAttachmentDevice {
    /** A unique identifier for the device which is exposed to the instance operating system. */
    id: string;
  }

  /**
   * VolumeAttachmentPrototype.
   */
  export interface VolumeAttachmentPrototype {
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The volume to use for this attachment. This can be specified as an existing unattached
     *  volume, or a prototype object for a new volume.
     */
    volume: VolumeAttachmentPrototypeVolume;
  }

  /**
   * VolumeAttachmentPrototypeInstanceByImageContext.
   */
  export interface VolumeAttachmentPrototypeInstanceByImageContext {
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** A prototype object for a new volume. */
    volume: VolumePrototypeInstanceByImageContext;
  }

  /**
   * VolumeAttachmentPrototypeInstanceBySourceSnapshotContext.
   */
  export interface VolumeAttachmentPrototypeInstanceBySourceSnapshotContext {
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** A prototype object for a new volume from a snapshot. */
    volume: VolumePrototypeInstanceBySourceSnapshotContext;
  }

  /**
   * VolumeAttachmentPrototypeInstanceByVolumeContext.
   */
  export interface VolumeAttachmentPrototypeInstanceByVolumeContext {
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete?: boolean;
    /** The name for this volume attachment. The name must not be used by another volume attachment on the instance.
     *  If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** An existing unattached volume. */
    volume: VolumeIdentity;
  }

  /**
   * The volume to use for this attachment. This can be specified as an existing unattached volume, or a prototype
   * object for a new volume.
   */
  export interface VolumeAttachmentPrototypeVolume {
  }

  /**
   * VolumeAttachmentReferenceInstanceContext.
   */
  export interface VolumeAttachmentReferenceInstanceContext {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** Information about how the volume is exposed to the instance operating system.
     *
     *  This property may be absent if the volume attachment's `status` is not `attached`.
     */
    device?: VolumeAttachmentDevice;
    /** The URL for this volume attachment. */
    href: string;
    /** The unique identifier for this volume attachment. */
    id: string;
    /** The name for this volume attachment. The name is unique across all volume attachments on the instance. */
    name: string;
    /** The attached volume.
     *
     *  This property will be absent if the volume has not yet been provisioned.
     */
    volume?: VolumeReferenceVolumeAttachmentContext;
  }

  /**
   * VolumeAttachmentReferenceVolumeContext.
   */
  export interface VolumeAttachmentReferenceVolumeContext {
    /** Indicates whether deleting the instance will also delete the attached volume. */
    delete_volume_on_instance_delete: boolean;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** Information about how the volume is exposed to the instance operating system.
     *
     *  This property may be absent if the volume attachment's `status` is not `attached`.
     */
    device?: VolumeAttachmentDevice;
    /** The URL for this volume attachment. */
    href: string;
    /** The unique identifier for this volume attachment. */
    id: string;
    /** The attached instance. */
    instance: InstanceReference;
    /** The name for this volume attachment. The name is unique across all volume attachments on the instance. */
    name: string;
    /** The type of volume attachment.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    type: VolumeAttachmentReferenceVolumeContext.Constants.Type | string;
  }
  export namespace VolumeAttachmentReferenceVolumeContext {
    export namespace Constants {
      /** The type of volume attachment. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        BOOT = 'boot',
        DATA = 'data',
      }
    }
  }

  /**
   * VolumeCatalogOffering.
   */
  export interface VolumeCatalogOffering {
    /** The billing plan associated with the catalog offering version.
     *
     *  If absent, no billing plan is associated with the catalog offering version
     *  (free).
     */
    plan?: CatalogOfferingVersionPlanReference;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering version this volume was created from.
     */
    version: CatalogOfferingVersionReference;
  }

  /**
   * VolumeCollection.
   */
  export interface VolumeCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** The total number of resources across all pages. */
    total_count: number;
    /** A page of volumes. */
    volumes: Volume[];
  }

  /**
   * VolumeHealthReason.
   */
  export interface VolumeHealthReason {
    /** A reason code for this health state. */
    code: VolumeHealthReason.Constants.Code | string;
    /** An explanation of the reason for this health state. */
    message: string;
    /** Link to documentation about the reason for this health state. */
    more_info?: string;
  }
  export namespace VolumeHealthReason {
    export namespace Constants {
      /** A reason code for this health state. */
      export enum Code {
        INITIALIZING_FROM_SNAPSHOT = 'initializing_from_snapshot',
        THROTTLED_BY_INSUFFICIENT_INSTANCE_BANDWIDTH = 'throttled_by_insufficient_instance_bandwidth',
      }
    }
  }

  /**
   * Identifies a volume by a unique property.
   */
  export interface VolumeIdentity {
  }

  /**
   * VolumeProfile.
   */
  export interface VolumeProfile {
    adjustable_capacity_states: VolumeProfileAdjustableCapacityStates;
    adjustable_iops_states: VolumeProfileAdjustableIOPSStates;
    bandwidth: VolumeProfileBandwidth;
    boot_capacity: VolumeProfileBootCapacity;
    capacity: VolumeProfileCapacity;
    /** The product family this volume profile belongs to.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    family: VolumeProfile.Constants.Family | string;
    /** The URL for this volume profile. */
    href: string;
    iops: VolumeProfileIOPS;
    /** The globally unique name for this volume profile. */
    name: string;
    /** The storage generation value of volumes of this profile. */
    storage_generation: VolumeProfileStorageGenerationFixed;
  }
  export namespace VolumeProfile {
    export namespace Constants {
      /** The product family this volume profile belongs to. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Family {
        CUSTOM = 'custom',
        DEFINED_PERFORMANCE = 'defined_performance',
        TIERED = 'tiered',
      }
    }
  }

  /**
   * VolumeProfileAdjustableCapacityStates.
   */
  export interface VolumeProfileAdjustableCapacityStates {
    /** The type for this profile field. */
    type: VolumeProfileAdjustableCapacityStates.Constants.Type | string;
    /** The attachment states that support adjustable capacity for a volume with this profile. */
    values: VolumeProfileAdjustableCapacityStates.Constants.Values[] | string[];
  }
  export namespace VolumeProfileAdjustableCapacityStates {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The attachment states that support adjustable capacity for a volume with this profile. */
      export enum Values {
        ATTACHED = 'attached',
        UNATTACHED = 'unattached',
        UNUSABLE = 'unusable',
      }
    }
  }

  /**
   * VolumeProfileAdjustableIOPSStates.
   */
  export interface VolumeProfileAdjustableIOPSStates {
    /** The type for this profile field. */
    type: VolumeProfileAdjustableIOPSStates.Constants.Type | string;
    /** The attachment states that support adjustable IOPS for a volume with this profile. */
    values: VolumeProfileAdjustableIOPSStates.Constants.Values[] | string[];
  }
  export namespace VolumeProfileAdjustableIOPSStates {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The attachment states that support adjustable IOPS for a volume with this profile. */
      export enum Values {
        ATTACHED = 'attached',
        UNATTACHED = 'unattached',
        UNUSABLE = 'unusable',
      }
    }
  }

  /**
   * VolumeProfileBandwidth.
   */
  export interface VolumeProfileBandwidth {
  }

  /**
   * VolumeProfileBootCapacity.
   */
  export interface VolumeProfileBootCapacity {
  }

  /**
   * VolumeProfileCapacity.
   */
  export interface VolumeProfileCapacity {
  }

  /**
   * VolumeProfileCollection.
   */
  export interface VolumeProfileCollection {
    /** A link to the first page of resources. */
    first: PageLink;
    /** The maximum number of resources that can be returned by the request. */
    limit: number;
    /** A link to the next page of resources. This property is present for all pages except the last page. */
    next?: PageLink;
    /** A page of volume profiles. */
    profiles: VolumeProfile[];
    /** The total number of resources across all pages. */
    total_count: number;
  }

  /**
   * VolumeProfileIOPS.
   */
  export interface VolumeProfileIOPS {
  }

  /**
   * Identifies a volume profile by a unique property.
   */
  export interface VolumeProfileIdentity {
  }

  /**
   * VolumeProfileReference.
   */
  export interface VolumeProfileReference {
    /** The URL for this volume profile. */
    href: string;
    /** The globally unique name for this volume profile. */
    name: string;
  }

  /**
   * The storage generation value of volumes of this profile.
   */
  export interface VolumeProfileStorageGenerationFixed {
    /** The type for this profile field. */
    type: VolumeProfileStorageGenerationFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace VolumeProfileStorageGenerationFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * VolumePrototype.
   */
  export interface VolumePrototype {
    /** The maximum bandwidth (in megabits per second) for the volume.
     *
     *  If the volume profile has a `bandwidth.type` of `dependent`, this property is system-managed and must not be
     *  specified.
     *
     *  Provided the property is user-managed, if it is unspecified, its value will be set based on the specified
     *  [`iops` and
     *  `capacity`](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles&interface=api).
     */
    bandwidth?: number;
    /** The maximum I/O operations per second (IOPS) to use for this volume.
     *
     *  If the volume profile has a `iops.type` of `dependent`, this property is system-managed and must not be
     *  specified.
     *
     *  Provided the property is user-managed, if it is unspecified, its value will be set based on the specified [
     *  `capacity`](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles&interface=api).
     */
    iops?: number;
    /** The name for this volume. The name must not be used by another volume in the region. If unspecified, the
     *  name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) for this volume. */
    profile: VolumeProfileIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume. */
    user_tags?: string[];
    /** The zone this volume will reside in. */
    zone: ZoneIdentity;
  }

  /**
   * VolumePrototypeInstanceByImageContext.
   */
  export interface VolumePrototypeInstanceByImageContext {
    /** The maximum bandwidth (in megabits per second) for the volume.
     *
     *  If the volume profile has a `bandwidth.type` of `dependent`, this property is system-managed and must not be
     *  specified.
     *
     *  Provided the property is user-managed, if it is unspecified, its value will be set based on the specified
     *  [`iops` and
     *  `capacity`](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles&interface=api).
     */
    bandwidth?: number;
    /** The capacity to use for the volume (in gigabytes). The specified value must be at least the image's
     *  `minimum_provisioned_size`, at most 250 gigabytes, and within the
     *  `boot_capacity` range of the volume's profile.
     *
     *  If unspecified, the capacity will be the image's `minimum_provisioned_size`.
     */
    capacity?: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The maximum I/O operations per second (IOPS) to use for this volume.
     *
     *  If the volume profile has a `iops.type` of `dependent`, this property is system-managed and must not be
     *  specified.
     *
     *  Provided the property is user-managed, if it is unspecified, its value will be set based on the specified [
     *  `capacity`](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles&interface=api).
     */
    iops?: number;
    /** The name for this volume. The name must not be used by another volume in the region. If unspecified, the
     *  name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) for this volume. */
    profile: VolumeProfileIdentity;
    /** The resource group to use for this volume. If unspecified, the instance's resource group will be used. */
    resource_group?: ResourceGroupIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume. */
    user_tags?: string[];
  }

  /**
   * VolumePrototypeInstanceBySourceSnapshotContext.
   */
  export interface VolumePrototypeInstanceBySourceSnapshotContext {
    /** The maximum bandwidth (in megabits per second) for the volume.
     *
     *  If the volume profile has a `bandwidth.type` of `dependent`, this property is system-managed and must not be
     *  specified.
     *
     *  Provided the property is user-managed, if it is unspecified, its value will be set based on the specified
     *  [`iops` and
     *  `capacity`](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles&interface=api).
     */
    bandwidth?: number;
    /** The capacity to use for the volume (in gigabytes). The specified value must be at least the snapshot's
     *  `minimum_capacity`, at most 250 gigabytes, and within the `boot_capacity` range of the volume's profile.
     */
    capacity?: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The maximum I/O operations per second (IOPS) to use for this volume.
     *
     *  If the volume profile has a `iops.type` of `dependent`, this property is system-managed and must not be
     *  specified.
     *
     *  Provided the property is user-managed, if it is unspecified, its value will be set based on the specified [
     *  `capacity`](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles&interface=api).
     */
    iops?: number;
    /** The name for this volume. The name must not be used by another volume in the region. If unspecified, the
     *  name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) for this volume. */
    profile: VolumeProfileIdentity;
    /** The resource group to use for this volume. If unspecified, the instance's resource group will be used. */
    resource_group?: ResourceGroupIdentity;
    /** The snapshot to use as a source for the volume's data.
     *
     *  The specified snapshot may be in a different account, subject to IAM policies.
     *
     *  To create a volume from a `source_snapshot`, the volume profile and the
     *  source snapshot must have the same `storage_generation` value.
     */
    source_snapshot: SnapshotIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume. */
    user_tags?: string[];
  }

  /**
   * VolumeReference.
   */
  export interface VolumeReference {
    /** The CRN for this volume. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this volume. */
    href: string;
    /** The unique identifier for this volume. */
    id: string;
    /** The name for this volume. The name is unique across all volumes in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: VolumeRemote;
    /** The resource type. */
    resource_type: VolumeReference.Constants.ResourceType | string;
  }
  export namespace VolumeReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VOLUME = 'volume',
      }
    }
  }

  /**
   * VolumeReferenceVolumeAttachmentContext.
   */
  export interface VolumeReferenceVolumeAttachmentContext {
    /** The CRN for this volume. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this volume. */
    href: string;
    /** The unique identifier for this volume. */
    id: string;
    /** The name for this volume. The name is unique across all volumes in the region. */
    name: string;
    /** The resource type. */
    resource_type: VolumeReferenceVolumeAttachmentContext.Constants.ResourceType | string;
  }
  export namespace VolumeReferenceVolumeAttachmentContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VOLUME = 'volume',
      }
    }
  }

  /**
   * If present, this property indicates that the resource associated with this reference is remote and therefore may
   * not be directly retrievable.
   */
  export interface VolumeRemote {
    /** If present, this property indicates that the referenced resource is remote to this
     *  region, and identifies the native region.
     */
    region?: RegionReference;
  }

  /**
   * VolumeStatusReason.
   */
  export interface VolumeStatusReason {
    /** A snake case string succinctly identifying the status reason.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    code: VolumeStatusReason.Constants.Code | string;
    /** An explanation of the status reason. */
    message: string;
    /** Link to documentation about this status reason. */
    more_info?: string;
  }
  export namespace VolumeStatusReason {
    export namespace Constants {
      /** A snake case string succinctly identifying the status reason. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Code {
        ENCRYPTION_KEY_DELETED = 'encryption_key_deleted',
      }
    }
  }

  /**
   * Zone.
   */
  export interface Zone {
    /** The physical data center assigned to this logical zone.
     *
     *  If absent, no physical data center has been assigned.
     */
    data_center?: string;
    /** The URL for this zone. */
    href: string;
    /** The globally unique name for this zone. */
    name: string;
    /** The region this zone resides in. */
    region: RegionReference;
    /** The status of the zone.
     *
     *  - `available`: The zone is available to create and manage resources.
     *  - `impaired`: The zone's availability and performance to create and manage resources
     *    may be impaired.
     *  - `unavailable`: The zone is unavailable to create and manage resources.
     *  - `unassigned`: The zone has not been assigned to a physical zone.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    status: Zone.Constants.Status | string;
    /** The [universal name](https://cloud.ibm.com/docs/overview?topic=overview-locations#zone-mapping) for this
     *  zone. Will be absent if this zone has a `status` of `unassigned`.
     */
    universal_name?: string;
  }
  export namespace Zone {
    export namespace Constants {
      /** The status of the zone. - `available`: The zone is available to create and manage resources. - `impaired`: The zone's availability and performance to create and manage resources may be impaired. - `unavailable`: The zone is unavailable to create and manage resources. - `unassigned`: The zone has not been assigned to a physical zone. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        AVAILABLE = 'available',
        IMPAIRED = 'impaired',
        UNASSIGNED = 'unassigned',
        UNAVAILABLE = 'unavailable',
      }
    }
  }

  /**
   * ZoneCollection.
   */
  export interface ZoneCollection {
    /** The zones for the region. */
    zones: Zone[];
  }

  /**
   * Identifies a zone by a unique property.
   */
  export interface ZoneIdentity {
  }

  /**
   * ZoneReference.
   */
  export interface ZoneReference {
    /** The URL for this zone. */
    href: string;
    /** The globally unique name for this zone. */
    name: string;
  }

  /**
   * AccountIdentityById.
   */
  export interface AccountIdentityById extends AccountIdentity {
    /** The unique identifier for this account. */
    id: string;
  }

  /**
   * BackupPolicyJobSourceInstanceReference.
   */
  export interface BackupPolicyJobSourceInstanceReference extends BackupPolicyJobSource {
    /** The CRN for this virtual server instance. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this virtual server instance. */
    href: string;
    /** The unique identifier for this virtual server instance. */
    id: string;
    /** The name for this virtual server instance. The name is unique across all virtual server instances in the
     *  region.
     */
    name: string;
  }

  /**
   * BackupPolicyJobSourceShareReference.
   */
  export interface BackupPolicyJobSourceShareReference extends BackupPolicyJobSource {
    /** The CRN for this file share. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this file share. */
    href: string;
    /** The unique identifier for this file share. */
    id: string;
    /** The name for this share. The name is unique across all shares in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: ShareRemote;
    /** The resource type. */
    resource_type: BackupPolicyJobSourceShareReference.Constants.ResourceType | string;
  }
  export namespace BackupPolicyJobSourceShareReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SHARE = 'share',
      }
    }
  }

  /**
   * BackupPolicyJobSourceVolumeReference.
   */
  export interface BackupPolicyJobSourceVolumeReference extends BackupPolicyJobSource {
    /** The CRN for this volume. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this volume. */
    href: string;
    /** The unique identifier for this volume. */
    id: string;
    /** The name for this volume. The name is unique across all volumes in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: VolumeRemote;
    /** The resource type. */
    resource_type: BackupPolicyJobSourceVolumeReference.Constants.ResourceType | string;
  }
  export namespace BackupPolicyJobSourceVolumeReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VOLUME = 'volume',
      }
    }
  }

  /**
   * BackupPolicyMatchResourceTypeInstance.
   */
  export interface BackupPolicyMatchResourceTypeInstance extends BackupPolicy {
    /** The included content for backups created using this policy:
     *  - `boot_volume`: Include the instance's boot volume.
     *  - `data_volumes`: Include the instance's data volumes.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    included_content: BackupPolicyMatchResourceTypeInstance.Constants.IncludedContent[] | string[];
    /** The resource type this backup policy applies to. Resources that have both a matching type and a matching
     *  user tag will be subject to the backup policy.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    match_resource_type: BackupPolicyMatchResourceTypeInstance.Constants.MatchResourceType | string;
  }
  export namespace BackupPolicyMatchResourceTypeInstance {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the backup policy. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        BACKUP_POLICY = 'backup_policy',
      }
      /** The included content for backups created using this policy: - `boot_volume`: Include the instance's boot volume. - `data_volumes`: Include the instance's data volumes. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum IncludedContent {
        BOOT_VOLUME = 'boot_volume',
        DATA_VOLUMES = 'data_volumes',
      }
      /** The resource type this backup policy applies to. Resources that have both a matching type and a matching user tag will be subject to the backup policy. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum MatchResourceType {
        INSTANCE = 'instance',
      }
    }
  }

  /**
   * BackupPolicyMatchResourceTypeShare.
   */
  export interface BackupPolicyMatchResourceTypeShare extends BackupPolicy {
    /** The resource type this backup policy applies to. Resources that have both a matching type and a matching
     *  user tag will be subject to the backup policy.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    match_resource_type: BackupPolicyMatchResourceTypeShare.Constants.MatchResourceType | string;
  }
  export namespace BackupPolicyMatchResourceTypeShare {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the backup policy. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        BACKUP_POLICY = 'backup_policy',
      }
      /** The resource type this backup policy applies to. Resources that have both a matching type and a matching user tag will be subject to the backup policy. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum MatchResourceType {
        SHARE = 'share',
      }
    }
  }

  /**
   * BackupPolicyMatchResourceTypeVolume.
   */
  export interface BackupPolicyMatchResourceTypeVolume extends BackupPolicy {
    /** The resource type this backup policy applies to. Resources that have both a matching type and a matching
     *  user tag will be subject to the backup policy.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    match_resource_type: BackupPolicyMatchResourceTypeVolume.Constants.MatchResourceType | string;
  }
  export namespace BackupPolicyMatchResourceTypeVolume {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the backup policy. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        BACKUP_POLICY = 'backup_policy',
      }
      /** The resource type this backup policy applies to. Resources that have both a matching type and a matching user tag will be subject to the backup policy. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum MatchResourceType {
        VOLUME = 'volume',
      }
    }
  }

  /**
   * BackupPolicyPrototypeBackupPolicyMatchResourceTypeInstancePrototype.
   */
  export interface BackupPolicyPrototypeBackupPolicyMatchResourceTypeInstancePrototype extends BackupPolicyPrototype {
    /** The included content for backups created using this policy:
     *  - `boot_volume`: Include the instance's boot volume.
     *  - `data_volumes`: Include the instance's data volumes.
     */
    included_content?: BackupPolicyPrototypeBackupPolicyMatchResourceTypeInstancePrototype.Constants.IncludedContent[] | string[];
    /** The resource type this backup policy will apply to. Resources that have both a matching type and a matching
     *  user tag will be subject to the backup policy.
     */
    match_resource_type: BackupPolicyPrototypeBackupPolicyMatchResourceTypeInstancePrototype.Constants.MatchResourceType | string;
  }
  export namespace BackupPolicyPrototypeBackupPolicyMatchResourceTypeInstancePrototype {
    export namespace Constants {
      /** The included content for backups created using this policy: - `boot_volume`: Include the instance's boot volume. - `data_volumes`: Include the instance's data volumes. */
      export enum IncludedContent {
        BOOT_VOLUME = 'boot_volume',
        DATA_VOLUMES = 'data_volumes',
      }
      /** The resource type this backup policy will apply to. Resources that have both a matching type and a matching user tag will be subject to the backup policy. */
      export enum MatchResourceType {
        INSTANCE = 'instance',
      }
    }
  }

  /**
   * BackupPolicyPrototypeBackupPolicyMatchResourceTypeSharePrototype.
   */
  export interface BackupPolicyPrototypeBackupPolicyMatchResourceTypeSharePrototype extends BackupPolicyPrototype {
    /** The resource type this backup policy will apply to. Resources that have both a matching type and a matching
     *  user tag will be subject to the backup policy.
     */
    match_resource_type: BackupPolicyPrototypeBackupPolicyMatchResourceTypeSharePrototype.Constants.MatchResourceType | string;
  }
  export namespace BackupPolicyPrototypeBackupPolicyMatchResourceTypeSharePrototype {
    export namespace Constants {
      /** The resource type this backup policy will apply to. Resources that have both a matching type and a matching user tag will be subject to the backup policy. */
      export enum MatchResourceType {
        SHARE = 'share',
      }
    }
  }

  /**
   * BackupPolicyPrototypeBackupPolicyMatchResourceTypeVolumePrototype.
   */
  export interface BackupPolicyPrototypeBackupPolicyMatchResourceTypeVolumePrototype extends BackupPolicyPrototype {
    /** The resource type this backup policy will apply to. Resources that have both a matching type and a matching
     *  user tag will be subject to the backup policy.
     */
    match_resource_type: BackupPolicyPrototypeBackupPolicyMatchResourceTypeVolumePrototype.Constants.MatchResourceType | string;
  }
  export namespace BackupPolicyPrototypeBackupPolicyMatchResourceTypeVolumePrototype {
    export namespace Constants {
      /** The resource type this backup policy will apply to. Resources that have both a matching type and a matching user tag will be subject to the backup policy. */
      export enum MatchResourceType {
        VOLUME = 'volume',
      }
    }
  }

  /**
   * Identifies an enterprise by a unique property.
   */
  export interface BackupPolicyScopePrototypeEnterpriseIdentity extends BackupPolicyScopePrototype {
  }

  /**
   * BackupPolicyScopeAccountReference.
   */
  export interface BackupPolicyScopeAccountReference extends BackupPolicyScope {
    /** The unique identifier for this account. */
    id: string;
    /** The resource type. */
    resource_type: BackupPolicyScopeAccountReference.Constants.ResourceType | string;
  }
  export namespace BackupPolicyScopeAccountReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        ACCOUNT = 'account',
      }
    }
  }

  /**
   * BackupPolicyScopeEnterpriseReference.
   */
  export interface BackupPolicyScopeEnterpriseReference extends BackupPolicyScope {
    /** The CRN for this enterprise. */
    crn: string;
    /** The unique identifier for this enterprise. */
    id: string;
    /** The resource type. */
    resource_type: BackupPolicyScopeEnterpriseReference.Constants.ResourceType | string;
  }
  export namespace BackupPolicyScopeEnterpriseReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        ENTERPRISE = 'enterprise',
      }
    }
  }

  /**
   * BackupPolicyTargetSnapshotShareSnapshotReference.
   */
  export interface BackupPolicyTargetSnapshotShareSnapshotReference extends BackupPolicyTargetSnapshot {
    /** The CRN for this share snapshot. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this share snapshot. */
    href: string;
    /** The unique identifier for this share snapshot. */
    id: string;
    /** The name for this share snapshot. The name is unique across all snapshots for the file share. */
    name: string;
    /** The resource type. */
    resource_type: BackupPolicyTargetSnapshotShareSnapshotReference.Constants.ResourceType | string;
  }
  export namespace BackupPolicyTargetSnapshotShareSnapshotReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SHARE_SNAPSHOT = 'share_snapshot',
      }
    }
  }

  /**
   * BackupPolicyTargetSnapshotSnapshotReference.
   */
  export interface BackupPolicyTargetSnapshotSnapshotReference extends BackupPolicyTargetSnapshot {
    /** The CRN of this snapshot. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this snapshot. */
    href: string;
    /** The unique identifier for this snapshot. */
    id: string;
    /** The name for this snapshot. The name is unique across all snapshots in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: SnapshotRemote;
    /** The resource type. */
    resource_type: BackupPolicyTargetSnapshotSnapshotReference.Constants.ResourceType | string;
  }
  export namespace BackupPolicyTargetSnapshotSnapshotReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SNAPSHOT = 'snapshot',
      }
    }
  }

  /**
   * BareMetalServerBootTargetBareMetalServerDiskReference.
   */
  export interface BareMetalServerBootTargetBareMetalServerDiskReference extends BareMetalServerBootTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this bare metal server disk. */
    href: string;
    /** The unique identifier for this bare metal server disk. */
    id: string;
    /** The name for this bare metal server disk. The name is unique across all disks on the bare metal server. */
    name: string;
    /** The resource type. */
    resource_type: BareMetalServerBootTargetBareMetalServerDiskReference.Constants.ResourceType | string;
  }
  export namespace BareMetalServerBootTargetBareMetalServerDiskReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        BARE_METAL_SERVER_DISK = 'bare_metal_server_disk',
      }
    }
  }

  /**
   * BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount.
   */
  export interface BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount extends BareMetalServerInitializationUserAccount {
    /** The password at initialization, encrypted using `encryption_key`, and returned base64-encoded. */
    encrypted_password: string;
    /** The public SSH key used to encrypt the password. */
    encryption_key: KeyReference;
    /** The resource type. */
    resource_type: BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount.Constants.ResourceType | string;
    /** The username for the account created at initialization. */
    username: string;
  }
  export namespace BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        HOST_USER_ACCOUNT = 'host_user_account',
      }
    }
  }

  /**
   * BareMetalServerNetworkAttachmentByPCI.
   */
  export interface BareMetalServerNetworkAttachmentByPCI extends BareMetalServerNetworkAttachment {
    /** The VLAN IDs allowed for `vlan` attachments using this PCI attachment. */
    allowed_vlans: number[];
    /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI attachment
     *    - Cannot directly use an IEEE 802.1Q tag.
     */
    interface_type: BareMetalServerNetworkAttachmentByPCI.Constants.InterfaceType | string;
  }
  export namespace BareMetalServerNetworkAttachmentByPCI {
    export namespace Constants {
      /** The lifecycle state of the bare metal server network attachment. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        BARE_METAL_SERVER_NETWORK_ATTACHMENT = 'bare_metal_server_network_attachment',
      }
      /** The bare metal server network attachment type. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        PRIMARY = 'primary',
        SECONDARY = 'secondary',
      }
      /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal server is stopped - Has an `allowed_vlans` property which controls the VLANs that will be permitted to use the PCI attachment - Cannot directly use an IEEE 802.1Q tag. */
      export enum InterfaceType {
        PCI = 'pci',
      }
    }
  }

  /**
   * BareMetalServerNetworkAttachmentByVLAN.
   */
  export interface BareMetalServerNetworkAttachmentByVLAN extends BareMetalServerNetworkAttachment {
    /** Indicates if the data path for the network attachment can float to another bare metal server. Can only be
     *  `true` for network attachments with an `interface_type` of `vlan`.
     *
     *  If `true`, and the network detects traffic for this data path on another bare metal server in the resource
     *  group, the network attachment will be automatically deleted from this bare metal server and a new network
     *  attachment with the same `id`, `name` and `vlan` will be created on the other bare metal server.  The virtual
     *  network interface for this network attachment will be automatically be attached to the new network attachment.
     *
     *  For the data path to float, the other bare metal server must be in the same
     *  `resource_group`, and must have a network attachment with `interface_type` of `pci` with `allowed_vlans`
     *  including this network attachment's `vlan`.
     */
    allow_to_float: boolean;
    /** - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array
     *     of `allowed_vlans`.
     *    - Must use an IEEE 802.1Q tag.
     */
    interface_type: BareMetalServerNetworkAttachmentByVLAN.Constants.InterfaceType | string;
    /** The IEEE 802.1Q VLAN ID that must be used for all traffic on this attachment. */
    vlan: number;
  }
  export namespace BareMetalServerNetworkAttachmentByVLAN {
    export namespace Constants {
      /** The lifecycle state of the bare metal server network attachment. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        BARE_METAL_SERVER_NETWORK_ATTACHMENT = 'bare_metal_server_network_attachment',
      }
      /** The bare metal server network attachment type. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        PRIMARY = 'primary',
        SECONDARY = 'secondary',
      }
      /** - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array of `allowed_vlans`. - Must use an IEEE 802.1Q tag. */
      export enum InterfaceType {
        VLAN = 'vlan',
      }
    }
  }

  /**
   * Identifies a virtual network interface by a unique property.
   */
  export interface BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentity extends BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterface {
  }

  /**
   * The virtual network interface for this target.
   */
  export interface BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfacePrototypeBareMetalServerNetworkAttachmentContext extends BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterface {
    /** Indicates whether source IP spoofing is allowed on this interface. If `false`, source IP spoofing is
     *  prevented on this interface. If `true`, source IP spoofing is allowed on this interface.
     */
    allow_ip_spoofing?: boolean;
    /** Indicates whether this virtual network interface will be automatically deleted when `target` is deleted. */
    auto_delete?: boolean;
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the virtual network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - Can only be attached to a `target` with a `resource_type` of
     *    `bare_metal_server_network_attachment`.
     */
    enable_infrastructure_nat?: boolean;
    /** Additional IP addresses to bind to the virtual network interface. Each item may be either a reserved IP
     *  identity, or a reserved IP prototype object which will be used to create a new reserved IP. All IP addresses
     *  must be in the primary IP's subnet.
     *
     *  If reserved IP identities are provided, the specified reserved IPs must be unbound.
     *
     *  If reserved IP prototype objects with addresses are provided, the addresses must be available on the virtual
     *  network interface's subnet. For any prototype objects that do not specify an address, an available address on
     *  the subnet will be automatically selected and reserved.
     */
    ips?: VirtualNetworkInterfaceIPPrototype[];
    /** The name for this virtual network interface. The name must not be used by another virtual network interface
     *  in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words. Names beginning with
     *  `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
    /** The primary IP address to bind to the virtual network interface. May be either a
     *  reserved IP identity, or a reserved IP prototype object which will be used to create a
     *  new reserved IP.
     *
     *  If a reserved IP identity is provided, the specified reserved IP must be unbound.
     *
     *  If a reserved IP prototype object with an address is provided, the address must be
     *  available on the virtual network interface's subnet. If no address is specified,
     *  an available address on the subnet will be automatically selected and reserved.
     */
    primary_ip?: VirtualNetworkInterfacePrimaryIPPrototype;
    /** The protocol state filtering mode to use for this virtual network interface. If
     *  `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target`
     *  resource type:
     *
     *  - `bare_metal_server_network_attachment`: disabled
     *  - `instance_network_attachment`: enabled
     *  - `share_mount_target`: enabled
     *
     *  Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops
     *  any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering
     *  mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information.
     */
    protocol_state_filtering_mode?: BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfacePrototypeBareMetalServerNetworkAttachmentContext.Constants.ProtocolStateFilteringMode | string;
    /** The resource group to use for this virtual network interface. If unspecified, the
     *  bare metal server's resource group will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The security groups to use for this virtual network interface. If unspecified, the default security group of
     *  the VPC for the subnet is used.
     */
    security_groups?: SecurityGroupIdentity[];
    /** The associated subnet. Required if `primary_ip` does not specify a reserved IP identity. */
    subnet?: SubnetIdentity;
  }
  export namespace BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfacePrototypeBareMetalServerNetworkAttachmentContext {
    export namespace Constants {
      /** The protocol state filtering mode to use for this virtual network interface. If `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target` resource type: - `bare_metal_server_network_attachment`: disabled - `instance_network_attachment`: enabled - `share_mount_target`: enabled Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information. */
      export enum ProtocolStateFilteringMode {
        AUTO = 'auto',
        DISABLED = 'disabled',
        ENABLED = 'enabled',
      }
    }
  }

  /**
   * BareMetalServerNetworkAttachmentPrototypeBareMetalServerNetworkAttachmentByPCIPrototype.
   */
  export interface BareMetalServerNetworkAttachmentPrototypeBareMetalServerNetworkAttachmentByPCIPrototype extends BareMetalServerNetworkAttachmentPrototype {
    /** The VLAN IDs to allow for `vlan` attachments using this PCI attachment. */
    allowed_vlans?: number[];
    /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI attachment
     *    - Cannot directly use an IEEE 802.1Q tag.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type: BareMetalServerNetworkAttachmentPrototypeBareMetalServerNetworkAttachmentByPCIPrototype.Constants.InterfaceType | string;
  }
  export namespace BareMetalServerNetworkAttachmentPrototypeBareMetalServerNetworkAttachmentByPCIPrototype {
    export namespace Constants {
      /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal server is stopped - Has an `allowed_vlans` property which controls the VLANs that will be permitted to use the PCI attachment - Cannot directly use an IEEE 802.1Q tag. - Not supported on bare metal servers with a `cpu.architecture` of `s390x`. */
      export enum InterfaceType {
        PCI = 'pci',
      }
    }
  }

  /**
   * BareMetalServerNetworkAttachmentPrototypeBareMetalServerNetworkAttachmentByVLANPrototype.
   */
  export interface BareMetalServerNetworkAttachmentPrototypeBareMetalServerNetworkAttachmentByVLANPrototype extends BareMetalServerNetworkAttachmentPrototype {
    /** Indicates if the data path for the network attachment can float to another bare metal server. Can only be
     *  `true` for network attachments with an `interface_type` of `vlan`.
     *
     *  If `true`, and the network detects traffic for this data path on another bare metal server in the resource
     *  group, the network attachment will be automatically deleted from this bare metal server and a new network
     *  attachment with the same `id`, `name` and `vlan` will be created on the other bare metal server.  The virtual
     *  network interface for this network attachment will be automatically be attached to the new network attachment.
     *
     *  For the data path to float, the other bare metal server must be in the same
     *  `resource_group`, and must have a network attachment with `interface_type` of `pci` with `allowed_vlans`
     *  including this network attachment's `vlan`.
     */
    allow_to_float?: boolean;
    /** - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array
     *     of `allowed_vlans`.
     *    - Must use an IEEE 802.1Q tag.
     */
    interface_type: BareMetalServerNetworkAttachmentPrototypeBareMetalServerNetworkAttachmentByVLANPrototype.Constants.InterfaceType | string;
    /** The IEEE 802.1Q VLAN ID that must be used for all traffic on this attachment. */
    vlan: number;
  }
  export namespace BareMetalServerNetworkAttachmentPrototypeBareMetalServerNetworkAttachmentByVLANPrototype {
    export namespace Constants {
      /** - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array of `allowed_vlans`. - Must use an IEEE 802.1Q tag. */
      export enum InterfaceType {
        VLAN = 'vlan',
      }
    }
  }

  /**
   * BareMetalServerNetworkInterfaceByHiperSocket.
   */
  export interface BareMetalServerNetworkInterfaceByHiperSocket extends BareMetalServerNetworkInterface {
    /** - `hipersocket`: a virtual network device that provides high-speed TCP/IP connectivity
     *    within a `s390x` based system.
     */
    interface_type: BareMetalServerNetworkInterfaceByHiperSocket.Constants.InterfaceType | string;
  }
  export namespace BareMetalServerNetworkInterfaceByHiperSocket {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
      /** The status of the bare metal server network interface. If this bare metal server has network attachments, this network interface is a read-only representation of its corresponding network attachment and its attached virtual network interface, and the status is [computed from them](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients). */
      export enum Status {
        AVAILABLE = 'available',
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
      }
      /** The bare metal server network interface type. If this bare metal server has network attachments, this network interface is a [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding network attachment and its attached virtual network interface, and the type is that of its corresponding network attachment. */
      export enum Type {
        PRIMARY = 'primary',
        SECONDARY = 'secondary',
      }
      /** - `hipersocket`: a virtual network device that provides high-speed TCP/IP connectivity within a `s390x` based system. */
      export enum InterfaceType {
        HIPERSOCKET = 'hipersocket',
      }
    }
  }

  /**
   * BareMetalServerNetworkInterfaceByPCI.
   */
  export interface BareMetalServerNetworkInterfaceByPCI extends BareMetalServerNetworkInterface {
    /** The VLAN IDs allowed for `vlan` interfaces using this PCI interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the VLAN IDs match the
     *  `allow_vlans` of the corresponding network attachment.
     */
    allowed_vlans: number[];
    /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI interface
     *    - Cannot directly use an IEEE 802.1Q tag.
     */
    interface_type: BareMetalServerNetworkInterfaceByPCI.Constants.InterfaceType | string;
  }
  export namespace BareMetalServerNetworkInterfaceByPCI {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
      /** The status of the bare metal server network interface. If this bare metal server has network attachments, this network interface is a read-only representation of its corresponding network attachment and its attached virtual network interface, and the status is [computed from them](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients). */
      export enum Status {
        AVAILABLE = 'available',
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
      }
      /** The bare metal server network interface type. If this bare metal server has network attachments, this network interface is a [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding network attachment and its attached virtual network interface, and the type is that of its corresponding network attachment. */
      export enum Type {
        PRIMARY = 'primary',
        SECONDARY = 'secondary',
      }
      /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal server is stopped - Has an `allowed_vlans` property which controls the VLANs that will be permitted to use the PCI interface - Cannot directly use an IEEE 802.1Q tag. */
      export enum InterfaceType {
        PCI = 'pci',
      }
    }
  }

  /**
   * BareMetalServerNetworkInterfaceByVLAN.
   */
  export interface BareMetalServerNetworkInterfaceByVLAN extends BareMetalServerNetworkInterface {
    /** Indicates if the data path for the network interface can float to another bare metal server. Can only be
     *  `true` for network interfaces with an `interface_type` of `vlan`.
     *
     *  If `true`, and the network detects traffic for this data path on another bare metal server in the resource
     *  group, the network interface will be automatically deleted from this bare metal server and a new network
     *  interface with the same `id`, `name` and `vlan` will be created on the other bare metal server.
     *
     *  For the data path to float, the other bare metal server must be in the same
     *  `resource_group`, and must have a network interface with `interface_type` of `pci` with `allowed_vlans`
     *  including this network interface's `vlan`.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the value of this property
     *  matches that of the `allow_to_float` property of the corresponding network attachment.
     */
    allow_interface_to_float: boolean;
    /** - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array
     *     of `allowed_vlans`.
     *    - Must use an IEEE 802.1Q tag.
     *    - Has its own security groups and does not inherit those of the PCI device through
     *      which traffic flows.
     */
    interface_type: BareMetalServerNetworkInterfaceByVLAN.Constants.InterfaceType | string;
    /** The VLAN ID used in the IEEE 802.1Q tag present in all traffic on this interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the VLAN ID matches the `vlan`
     *  of the corresponding network attachment.
     */
    vlan: number;
  }
  export namespace BareMetalServerNetworkInterfaceByVLAN {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
      /** The status of the bare metal server network interface. If this bare metal server has network attachments, this network interface is a read-only representation of its corresponding network attachment and its attached virtual network interface, and the status is [computed from them](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients). */
      export enum Status {
        AVAILABLE = 'available',
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
      }
      /** The bare metal server network interface type. If this bare metal server has network attachments, this network interface is a [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its corresponding network attachment and its attached virtual network interface, and the type is that of its corresponding network attachment. */
      export enum Type {
        PRIMARY = 'primary',
        SECONDARY = 'secondary',
      }
      /** - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array of `allowed_vlans`. - Must use an IEEE 802.1Q tag. - Has its own security groups and does not inherit those of the PCI device through which traffic flows. */
      export enum InterfaceType {
        VLAN = 'vlan',
      }
    }
  }

  /**
   * BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype.
   */
  export interface BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype extends BareMetalServerNetworkInterfacePrototype {
    /** - `hipersocket`: a virtual network device that provides high-speed TCP/IP connectivity
     *    within a `s390x` based system.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `amd64`.
     */
    interface_type: BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype.Constants.InterfaceType | string;
  }
  export namespace BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype {
    export namespace Constants {
      /** - `hipersocket`: a virtual network device that provides high-speed TCP/IP connectivity within a `s390x` based system. - Not supported on bare metal servers with a `cpu.architecture` of `amd64`. */
      export enum InterfaceType {
        HIPERSOCKET = 'hipersocket',
      }
    }
  }

  /**
   * BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPCIPrototype.
   */
  export interface BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPCIPrototype extends BareMetalServerNetworkInterfacePrototype {
    /** The VLAN IDs to allow for `vlan` interfaces using this PCI interface. */
    allowed_vlans?: number[];
    /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI interface
     *    - Cannot directly use an IEEE 802.1Q tag.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type: BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPCIPrototype.Constants.InterfaceType | string;
  }
  export namespace BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPCIPrototype {
    export namespace Constants {
      /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal server is stopped - Has an `allowed_vlans` property which controls the VLANs that will be permitted to use the PCI interface - Cannot directly use an IEEE 802.1Q tag. - Not supported on bare metal servers with a `cpu.architecture` of `s390x`. */
      export enum InterfaceType {
        PCI = 'pci',
      }
    }
  }

  /**
   * BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVLANPrototype.
   */
  export interface BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVLANPrototype extends BareMetalServerNetworkInterfacePrototype {
    /** Indicates if the data path for the network interface can float to another bare metal server. Can only be
     *  `true` for network interfaces with an `interface_type` of `vlan`.
     *
     *  If `true`, and the network detects traffic for this data path on another bare metal server in the resource
     *  group, the network interface will be automatically deleted from this bare metal server and a new network
     *  interface with the same `id`, `name` and `vlan` will be created on the other bare metal server.
     *
     *  For the data path to float, the other bare metal server must be in the same
     *  `resource_group`, and must have a network interface with `interface_type` of `pci` with `allowed_vlans`
     *  including this network interface's `vlan`.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the value of this property
     *  matches that of the `allow_to_float` property of the corresponding network attachment.
     */
    allow_interface_to_float?: boolean;
    /** - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array
     *     of `allowed_vlans`.
     *    - Must use an IEEE 802.1Q tag.
     *    - Has its own security groups and does not inherit those of the PCI device through
     *      which traffic flows.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type: BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVLANPrototype.Constants.InterfaceType | string;
    /** The VLAN ID used in the IEEE 802.1Q tag present in all traffic on this interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the VLAN ID matches the `vlan`
     *  of the corresponding network attachment.
     */
    vlan: number;
  }
  export namespace BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVLANPrototype {
    export namespace Constants {
      /** - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array of `allowed_vlans`. - Must use an IEEE 802.1Q tag. - Has its own security groups and does not inherit those of the PCI device through which traffic flows. - Not supported on bare metal servers with a `cpu.architecture` of `s390x`. */
      export enum InterfaceType {
        VLAN = 'vlan',
      }
    }
  }

  /**
   * BareMetalServerPrimaryNetworkAttachmentPrototypeBareMetalServerPrimaryNetworkAttachmentByPCIPrototype.
   */
  export interface BareMetalServerPrimaryNetworkAttachmentPrototypeBareMetalServerPrimaryNetworkAttachmentByPCIPrototype extends BareMetalServerPrimaryNetworkAttachmentPrototype {
    /** The VLAN IDs to allow for `vlan` attachments using this PCI attachment. */
    allowed_vlans?: number[];
    /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal
     *    server is stopped
     *    - Has an `allowed_vlans` property which controls the VLANs that will be permitted
     *      to use the PCI attachment
     *    - Cannot directly use an IEEE 802.1Q tag.
     *    - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
     */
    interface_type?: BareMetalServerPrimaryNetworkAttachmentPrototypeBareMetalServerPrimaryNetworkAttachmentByPCIPrototype.Constants.InterfaceType | string;
  }
  export namespace BareMetalServerPrimaryNetworkAttachmentPrototypeBareMetalServerPrimaryNetworkAttachmentByPCIPrototype {
    export namespace Constants {
      /** - `pci`: a physical PCI device which can only be created or deleted when the bare metal server is stopped - Has an `allowed_vlans` property which controls the VLANs that will be permitted to use the PCI attachment - Cannot directly use an IEEE 802.1Q tag. - Not supported on bare metal servers with a `cpu.architecture` of `s390x`. */
      export enum InterfaceType {
        PCI = 'pci',
      }
    }
  }

  /**
   * The total bandwidth shared across the bare metal server network attachments or bare metal server network interfaces
   * of a bare metal server with this profile depends on its configuration.
   */
  export interface BareMetalServerProfileBandwidthDependent extends BareMetalServerProfileBandwidth {
    /** The type for this profile field. */
    type: BareMetalServerProfileBandwidthDependent.Constants.Type | string;
  }
  export namespace BareMetalServerProfileBandwidthDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted total bandwidth values (in megabits per second) shared across the bare metal server network
   * attachments or bare metal server network interfaces of a bare metal server with this profile.
   */
  export interface BareMetalServerProfileBandwidthEnum extends BareMetalServerProfileBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileBandwidthEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace BareMetalServerProfileBandwidthEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The total bandwidth (in megabits per second) shared across the bare metal server network attachments or bare metal
   * server network interfaces of a bare metal server with this profile.
   */
  export interface BareMetalServerProfileBandwidthFixed extends BareMetalServerProfileBandwidth {
    /** The type for this profile field. */
    type: BareMetalServerProfileBandwidthFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace BareMetalServerProfileBandwidthFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted total bandwidth range (in megabits per second) shared across the network attachments or network
   * interfaces of a bare metal server with this profile.
   */
  export interface BareMetalServerProfileBandwidthRange extends BareMetalServerProfileBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileBandwidthRange.Constants.Type | string;
  }
  export namespace BareMetalServerProfileBandwidthRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The CPU core count for a bare metal server with this profile depends on its configuration.
   */
  export interface BareMetalServerProfileCPUCoreCountDependent extends BareMetalServerProfileCPUCoreCount {
    /** The type for this profile field. */
    type: BareMetalServerProfileCPUCoreCountDependent.Constants.Type | string;
  }
  export namespace BareMetalServerProfileCPUCoreCountDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted values for CPU cores for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileCPUCoreCountEnum extends BareMetalServerProfileCPUCoreCount {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileCPUCoreCountEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace BareMetalServerProfileCPUCoreCountEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The CPU core count for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileCPUCoreCountFixed extends BareMetalServerProfileCPUCoreCount {
    /** The type for this profile field. */
    type: BareMetalServerProfileCPUCoreCountFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace BareMetalServerProfileCPUCoreCountFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted range for the number of CPU cores for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileCPUCoreCountRange extends BareMetalServerProfileCPUCoreCount {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileCPUCoreCountRange.Constants.Type | string;
  }
  export namespace BareMetalServerProfileCPUCoreCountRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The CPU socket count for a bare metal server with this profile depends on its configuration.
   */
  export interface BareMetalServerProfileCPUSocketCountDependent extends BareMetalServerProfileCPUSocketCount {
    /** The type for this profile field. */
    type: BareMetalServerProfileCPUSocketCountDependent.Constants.Type | string;
  }
  export namespace BareMetalServerProfileCPUSocketCountDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted values for CPU sockets for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileCPUSocketCountEnum extends BareMetalServerProfileCPUSocketCount {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileCPUSocketCountEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace BareMetalServerProfileCPUSocketCountEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The number of CPU sockets for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileCPUSocketCountFixed extends BareMetalServerProfileCPUSocketCount {
    /** The type for this profile field. */
    type: BareMetalServerProfileCPUSocketCountFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace BareMetalServerProfileCPUSocketCountFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted range for the number of CPU sockets for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileCPUSocketCountRange extends BareMetalServerProfileCPUSocketCount {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileCPUSocketCountRange.Constants.Type | string;
  }
  export namespace BareMetalServerProfileCPUSocketCountRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The number of disks of this configuration for a bare metal server with this profile depends on its bare metal
   * server configuration.
   */
  export interface BareMetalServerProfileDiskQuantityDependent extends BareMetalServerProfileDiskQuantity {
    /** The type for this profile field. */
    type: BareMetalServerProfileDiskQuantityDependent.Constants.Type | string;
  }
  export namespace BareMetalServerProfileDiskQuantityDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted the number of disks of this configuration for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileDiskQuantityEnum extends BareMetalServerProfileDiskQuantity {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileDiskQuantityEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace BareMetalServerProfileDiskQuantityEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The number of disks of this configuration for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileDiskQuantityFixed extends BareMetalServerProfileDiskQuantity {
    /** The type for this profile field. */
    type: BareMetalServerProfileDiskQuantityFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace BareMetalServerProfileDiskQuantityFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted range for the number of disks of this configuration for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileDiskQuantityRange extends BareMetalServerProfileDiskQuantity {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileDiskQuantityRange.Constants.Type | string;
  }
  export namespace BareMetalServerProfileDiskQuantityRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The disk size in GB (gigabytes) of this configuration for a bare metal server with this profile depends on its bare
   * metal server configuration.
   */
  export interface BareMetalServerProfileDiskSizeDependent extends BareMetalServerProfileDiskSize {
    /** The type for this profile field. */
    type: BareMetalServerProfileDiskSizeDependent.Constants.Type | string;
  }
  export namespace BareMetalServerProfileDiskSizeDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted disk size in GB (gigabytes) of this configuration for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileDiskSizeEnum extends BareMetalServerProfileDiskSize {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileDiskSizeEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace BareMetalServerProfileDiskSizeEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The size of the disk in GB (gigabytes).
   */
  export interface BareMetalServerProfileDiskSizeFixed extends BareMetalServerProfileDiskSize {
    /** The type for this profile field. */
    type: BareMetalServerProfileDiskSizeFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace BareMetalServerProfileDiskSizeFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted range for the disk size of this configuration in GB (gigabytes) for a bare metal server with this
   * profile.
   */
  export interface BareMetalServerProfileDiskSizeRange extends BareMetalServerProfileDiskSize {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileDiskSizeRange.Constants.Type | string;
  }
  export namespace BareMetalServerProfileDiskSizeRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * BareMetalServerProfileIdentityByHref.
   */
  export interface BareMetalServerProfileIdentityByHref extends BareMetalServerProfileIdentity {
    /** The URL for this bare metal server profile. */
    href: string;
  }

  /**
   * BareMetalServerProfileIdentityByName.
   */
  export interface BareMetalServerProfileIdentityByName extends BareMetalServerProfileIdentity {
    /** The name for this bare metal server profile. */
    name: string;
  }

  /**
   * The memory value for a bare metal server with this profile depends on its configuration.
   */
  export interface BareMetalServerProfileMemoryDependent extends BareMetalServerProfileMemory {
    /** The type for this profile field. */
    type: BareMetalServerProfileMemoryDependent.Constants.Type | string;
  }
  export namespace BareMetalServerProfileMemoryDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted memory values (in gibibytes) for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileMemoryEnum extends BareMetalServerProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileMemoryEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace BareMetalServerProfileMemoryEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The memory (in gibibytes) for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileMemoryFixed extends BareMetalServerProfileMemory {
    /** The type for this profile field. */
    type: BareMetalServerProfileMemoryFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace BareMetalServerProfileMemoryFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted memory range (in gibibytes) for a bare metal server with this profile.
   */
  export interface BareMetalServerProfileMemoryRange extends BareMetalServerProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileMemoryRange.Constants.Type | string;
  }
  export namespace BareMetalServerProfileMemoryRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The number of network attachments supported on a bare metal server with this profile is dependent on its
   * configuration.
   */
  export interface BareMetalServerProfileNetworkAttachmentCountDependent extends BareMetalServerProfileNetworkAttachmentCount {
    /** The type for this profile field. */
    type: BareMetalServerProfileNetworkAttachmentCountDependent.Constants.Type | string;
  }
  export namespace BareMetalServerProfileNetworkAttachmentCountDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The number of network attachments supported on a bare metal server with this profile.
   */
  export interface BareMetalServerProfileNetworkAttachmentCountRange extends BareMetalServerProfileNetworkAttachmentCount {
    /** The maximum value for this profile field. */
    max?: number;
    /** The minimum value for this profile field. */
    min?: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileNetworkAttachmentCountRange.Constants.Type | string;
  }
  export namespace BareMetalServerProfileNetworkAttachmentCountRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The number of bare metal server network interfaces supported on a bare metal server with this profile is dependent
   * on its configuration.
   */
  export interface BareMetalServerProfileNetworkInterfaceCountDependent extends BareMetalServerProfileNetworkInterfaceCount {
    /** The type for this profile field. */
    type: BareMetalServerProfileNetworkInterfaceCountDependent.Constants.Type | string;
  }
  export namespace BareMetalServerProfileNetworkInterfaceCountDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The number of bare metal server network interfaces supported on a bare metal server with this profile.
   */
  export interface BareMetalServerProfileNetworkInterfaceCountRange extends BareMetalServerProfileNetworkInterfaceCount {
    /** The maximum value for this profile field. */
    max?: number;
    /** The minimum value for this profile field. */
    min?: number;
    /** The type for this profile field. */
    type: BareMetalServerProfileNetworkInterfaceCountRange.Constants.Type | string;
  }
  export namespace BareMetalServerProfileNetworkInterfaceCountRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * BareMetalServerPrototypeBareMetalServerByNetworkAttachment.
   */
  export interface BareMetalServerPrototypeBareMetalServerByNetworkAttachment extends BareMetalServerPrototype {
    /** The additional network attachments to create for the bare metal server. */
    network_attachments?: BareMetalServerNetworkAttachmentPrototype[];
    /** The primary network attachment to create for the bare metal server. */
    primary_network_attachment: BareMetalServerPrimaryNetworkAttachmentPrototype;
  }

  /**
   * BareMetalServerPrototypeBareMetalServerByNetworkInterface.
   */
  export interface BareMetalServerPrototypeBareMetalServerByNetworkInterface extends BareMetalServerPrototype {
    /** The additional bare metal server network interfaces to create. */
    network_interfaces?: BareMetalServerNetworkInterfacePrototype[];
    /** The primary bare metal server network interface to create. */
    primary_network_interface: BareMetalServerPrimaryNetworkInterfacePrototype;
  }

  /**
   * CatalogOfferingIdentityCatalogOfferingByCRN.
   */
  export interface CatalogOfferingIdentityCatalogOfferingByCRN extends CatalogOfferingIdentity {
    /** The CRN for this [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering. */
    crn: string;
  }

  /**
   * CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN.
   */
  export interface CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN extends CatalogOfferingVersionIdentity {
    /** The CRN for this version of a
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering.
     */
    crn: string;
  }

  /**
   * CatalogOfferingVersionPlanIdentityCatalogOfferingVersionPlanByCRN.
   */
  export interface CatalogOfferingVersionPlanIdentityCatalogOfferingVersionPlanByCRN extends CatalogOfferingVersionPlanIdentity {
    /** The CRN for this
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering version's billing plan.
     */
    crn: string;
  }

  /**
   * CertificateInstanceIdentityByCRN.
   */
  export interface CertificateInstanceIdentityByCRN extends CertificateInstanceIdentity {
    /** The CRN for this certificate instance. */
    crn: string;
  }

  /**
   * CloudObjectStorageBucketIdentityByCRN.
   */
  export interface CloudObjectStorageBucketIdentityByCRN extends CloudObjectStorageBucketIdentity {
    /** The CRN of this Cloud Object Storage bucket. */
    crn: string;
  }

  /**
   * CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName.
   */
  export interface CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName extends CloudObjectStorageBucketIdentity {
    /** The globally unique name of this Cloud Object Storage bucket. */
    name: string;
  }

  /**
   * Identifies a cluster network subnet reserved IP by a unique property. Required if `subnet` is not specified. The
   * cluster network subnet reserved IP must be currently unbound.
   */
  export interface ClusterNetworkInterfacePrimaryIPPrototypeClusterNetworkSubnetReservedIPIdentityClusterNetworkInterfacePrimaryIPContext extends ClusterNetworkInterfacePrimaryIPPrototype {
  }

  /**
   * The prototype for a new cluster network subnet reserved IP. Requires `subnet` to be specified.
   */
  export interface ClusterNetworkInterfacePrimaryIPPrototypeClusterNetworkSubnetReservedIPPrototypeClusterNetworkInterfacePrimaryIPContext extends ClusterNetworkInterfacePrimaryIPPrototype {
    /** The IP address to reserve, which must not already be reserved on the subnet.
     *
     *  If unspecified, an available address on the subnet will automatically be selected.
     */
    address?: string;
    /** Indicates whether this cluster network subnet reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the cluster network subnet reserved IP is unbound.
     */
    auto_delete?: boolean;
    /** The name for this cluster network subnet reserved IP. The name must not be used by another reserved IP in
     *  the cluster network subnet. Names starting with `ibm-` are reserved for provider-owned resources, and are not
     *  allowed. If unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /**
   * ClusterNetworkInterfaceTargetInstanceClusterNetworkAttachmentReferenceClusterNetworkInterfaceContext.
   */
  export interface ClusterNetworkInterfaceTargetInstanceClusterNetworkAttachmentReferenceClusterNetworkInterfaceContext extends ClusterNetworkInterfaceTarget {
    /** The URL for this instance cluster network attachment. */
    href: string;
    /** The unique identifier for this instance cluster network attachment. */
    id: string;
    /** The name for this instance cluster network attachment. The name is unique across all network attachments for
     *  the instance.
     */
    name: string;
    /** The resource type. */
    resource_type: ClusterNetworkInterfaceTargetInstanceClusterNetworkAttachmentReferenceClusterNetworkInterfaceContext.Constants.ResourceType | string;
  }
  export namespace ClusterNetworkInterfaceTargetInstanceClusterNetworkAttachmentReferenceClusterNetworkInterfaceContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_CLUSTER_NETWORK_ATTACHMENT = 'instance_cluster_network_attachment',
      }
    }
  }

  /**
   * ClusterNetworkProfileIdentityByHref.
   */
  export interface ClusterNetworkProfileIdentityByHref extends ClusterNetworkProfileIdentity {
    /** The URL for this cluster network profile. */
    href: string;
  }

  /**
   * ClusterNetworkProfileIdentityByName.
   */
  export interface ClusterNetworkProfileIdentityByName extends ClusterNetworkProfileIdentity {
    /** The globally unique name for this cluster network profile. */
    name: string;
  }

  /**
   * ClusterNetworkSubnetIdentityByHref.
   */
  export interface ClusterNetworkSubnetIdentityByHref extends ClusterNetworkSubnetIdentity {
    /** The URL for this cluster network subnet. */
    href: string;
  }

  /**
   * ClusterNetworkSubnetIdentityById.
   */
  export interface ClusterNetworkSubnetIdentityById extends ClusterNetworkSubnetIdentity {
    /** The unique identifier for this cluster network subnet. */
    id: string;
  }

  /**
   * ClusterNetworkSubnetPrototypeClusterNetworkSubnetByIPv4CIDRBlockPrototype.
   */
  export interface ClusterNetworkSubnetPrototypeClusterNetworkSubnetByIPv4CIDRBlockPrototype extends ClusterNetworkSubnetPrototype {
    /** The IPv4 range of the cluster network subnet, expressed in CIDR format. The prefix length of the cluster
     *  network subnet's CIDR must be between `/8` (16,777,216 addresses) and `/29`
     *  (8 addresses). The IPv4 range of the cluster network subnet's CIDR must be within the cluster network's
     *  `subnet_prefixes`.
     *
     *  The range must not overlap with any of the following reserved address ranges:
     *
     *    - `127.0.0.0/8` (IPv4 loopback addresses)
     *    - `169.254.0.0/16` (IPv4 link-local addresses)
     *    - `224.0.0.0/4` (IPv4 multicast addresses).
     */
    ipv4_cidr_block: string;
  }
  export namespace ClusterNetworkSubnetPrototypeClusterNetworkSubnetByIPv4CIDRBlockPrototype {
    export namespace Constants {
      /** The IP version(s) to support for this cluster network subnet. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
    }
  }

  /**
   * ClusterNetworkSubnetPrototypeClusterNetworkSubnetByTotalCountPrototype.
   */
  export interface ClusterNetworkSubnetPrototypeClusterNetworkSubnetByTotalCountPrototype extends ClusterNetworkSubnetPrototype {
    /** The total number of IPv4 addresses required. Must be a power of 2.
     *
     *  A CIDR will be allocated from a subnet prefix in the cluster network that has an
     *  `allocation_policy` of `auto`. There must be a subnet prefix that has a free CIDR range with at least this
     *  number of addresses.
     */
    total_ipv4_address_count: number;
  }
  export namespace ClusterNetworkSubnetPrototypeClusterNetworkSubnetByTotalCountPrototype {
    export namespace Constants {
      /** The IP version(s) to support for this cluster network subnet. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
    }
  }

  /**
   * ClusterNetworkSubnetReservedIPTargetClusterNetworkInterfaceReferenceClusterNetworkSubnetReservedIPTargetContext.
   */
  export interface ClusterNetworkSubnetReservedIPTargetClusterNetworkInterfaceReferenceClusterNetworkSubnetReservedIPTargetContext extends ClusterNetworkSubnetReservedIPTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this cluster network interface. */
    href: string;
    /** The unique identifier for this cluster network interface. */
    id: string;
    /** The name for this cluster network interface. The name is unique across all interfaces in the cluster
     *  network.
     */
    name: string;
    /** The resource type. */
    resource_type: ClusterNetworkSubnetReservedIPTargetClusterNetworkInterfaceReferenceClusterNetworkSubnetReservedIPTargetContext.Constants.ResourceType | string;
  }
  export namespace ClusterNetworkSubnetReservedIPTargetClusterNetworkInterfaceReferenceClusterNetworkSubnetReservedIPTargetContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        CLUSTER_NETWORK_INTERFACE = 'cluster_network_interface',
      }
    }
  }

  /**
   * DNSInstanceIdentityByCRN.
   */
  export interface DNSInstanceIdentityByCRN extends DNSInstanceIdentity {
    /** The CRN for this DNS instance. */
    crn: string;
  }

  /**
   * DNSZoneIdentityById.
   */
  export interface DNSZoneIdentityById extends DNSZoneIdentity {
    id: string;
  }

  /**
   * DedicatedHostGroupIdentityByCRN.
   */
  export interface DedicatedHostGroupIdentityByCRN extends DedicatedHostGroupIdentity {
    /** The CRN for this dedicated host group. */
    crn: string;
  }

  /**
   * DedicatedHostGroupIdentityByHref.
   */
  export interface DedicatedHostGroupIdentityByHref extends DedicatedHostGroupIdentity {
    /** The URL for this dedicated host group. */
    href: string;
  }

  /**
   * DedicatedHostGroupIdentityById.
   */
  export interface DedicatedHostGroupIdentityById extends DedicatedHostGroupIdentity {
    /** The unique identifier for this dedicated host group. */
    id: string;
  }

  /**
   * DedicatedHostProfileIdentityByHref.
   */
  export interface DedicatedHostProfileIdentityByHref extends DedicatedHostProfileIdentity {
    /** The URL for this dedicated host profile. */
    href: string;
  }

  /**
   * DedicatedHostProfileIdentityByName.
   */
  export interface DedicatedHostProfileIdentityByName extends DedicatedHostProfileIdentity {
    /** The globally unique name for this dedicated host profile. */
    name: string;
  }

  /**
   * The memory value for a dedicated host with this profile depends on its configuration.
   */
  export interface DedicatedHostProfileMemoryDependent extends DedicatedHostProfileMemory {
    /** The type for this profile field. */
    type: DedicatedHostProfileMemoryDependent.Constants.Type | string;
  }
  export namespace DedicatedHostProfileMemoryDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted memory values (in gibibytes) for a dedicated host with this profile.
   */
  export interface DedicatedHostProfileMemoryEnum extends DedicatedHostProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: DedicatedHostProfileMemoryEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace DedicatedHostProfileMemoryEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The memory (in gibibytes) for a dedicated host with this profile.
   */
  export interface DedicatedHostProfileMemoryFixed extends DedicatedHostProfileMemory {
    /** The type for this profile field. */
    type: DedicatedHostProfileMemoryFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace DedicatedHostProfileMemoryFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted memory range (in gibibytes) for a dedicated host with this profile.
   */
  export interface DedicatedHostProfileMemoryRange extends DedicatedHostProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: DedicatedHostProfileMemoryRange.Constants.Type | string;
  }
  export namespace DedicatedHostProfileMemoryRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The CPU socket count for a dedicated host with this profile depends on its configuration.
   */
  export interface DedicatedHostProfileSocketDependent extends DedicatedHostProfileSocket {
    /** The type for this profile field. */
    type: DedicatedHostProfileSocketDependent.Constants.Type | string;
  }
  export namespace DedicatedHostProfileSocketDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted values for CPU socket count for a dedicated host with this profile.
   */
  export interface DedicatedHostProfileSocketEnum extends DedicatedHostProfileSocket {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: DedicatedHostProfileSocketEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace DedicatedHostProfileSocketEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The CPU socket count for a dedicated host with this profile.
   */
  export interface DedicatedHostProfileSocketFixed extends DedicatedHostProfileSocket {
    /** The type for this profile field. */
    type: DedicatedHostProfileSocketFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace DedicatedHostProfileSocketFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted range for CPU socket count for a dedicated host with this profile.
   */
  export interface DedicatedHostProfileSocketRange extends DedicatedHostProfileSocket {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: DedicatedHostProfileSocketRange.Constants.Type | string;
  }
  export namespace DedicatedHostProfileSocketRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The VCPU count for a dedicated host with this profile depends on its configuration.
   */
  export interface DedicatedHostProfileVCPUDependent extends DedicatedHostProfileVCPU {
    /** The type for this profile field. */
    type: DedicatedHostProfileVCPUDependent.Constants.Type | string;
  }
  export namespace DedicatedHostProfileVCPUDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted values for VCPU count for a dedicated host with this profile.
   */
  export interface DedicatedHostProfileVCPUEnum extends DedicatedHostProfileVCPU {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: DedicatedHostProfileVCPUEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace DedicatedHostProfileVCPUEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The VCPU count for a dedicated host with this profile.
   */
  export interface DedicatedHostProfileVCPUFixed extends DedicatedHostProfileVCPU {
    /** The type for this profile field. */
    type: DedicatedHostProfileVCPUFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace DedicatedHostProfileVCPUFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted range for VCPU count for a dedicated host with this profile.
   */
  export interface DedicatedHostProfileVCPURange extends DedicatedHostProfileVCPU {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: DedicatedHostProfileVCPURange.Constants.Type | string;
  }
  export namespace DedicatedHostProfileVCPURange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * DedicatedHostPrototypeDedicatedHostByGroup.
   */
  export interface DedicatedHostPrototypeDedicatedHostByGroup extends DedicatedHostPrototype {
    /** The dedicated host group for this dedicated host. */
    group: DedicatedHostGroupIdentity;
  }

  /**
   * DedicatedHostPrototypeDedicatedHostByZone.
   */
  export interface DedicatedHostPrototypeDedicatedHostByZone extends DedicatedHostPrototype {
    group?: DedicatedHostGroupPrototypeDedicatedHostByZoneContext;
    /** The zone this dedicated host will reside in. */
    zone: ZoneIdentity;
  }

  /**
   * EncryptionKeyIdentityByCRN.
   */
  export interface EncryptionKeyIdentityByCRN extends EncryptionKeyIdentity {
    /** The CRN of the [Key Protect Root
     *  Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
     *  Services Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
     */
    crn: string;
  }

  /**
   * Identifies a reserved IP by a unique property.
   */
  export interface EndpointGatewayReservedIPReservedIPIdentity extends EndpointGatewayReservedIP {
  }

  /**
   * EndpointGatewayReservedIPReservedIPPrototypeTargetContext.
   */
  export interface EndpointGatewayReservedIPReservedIPPrototypeTargetContext extends EndpointGatewayReservedIP {
    /** The IP address to reserve, which must not already be reserved on the subnet.
     *
     *  If unspecified, an available address on the subnet will automatically be selected.
     */
    address?: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound.
     */
    auto_delete?: boolean;
    /** The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The subnet in which to create this reserved IP. */
    subnet: SubnetIdentity;
  }

  /**
   * EndpointGatewayTargetPrototypeEndpointGatewayTargetResourceTypePrivatePathServiceGatewayPrototype.
   */
  export interface EndpointGatewayTargetPrototypeEndpointGatewayTargetResourceTypePrivatePathServiceGatewayPrototype extends EndpointGatewayTargetPrototype {
    /** The CRN for this private path service gateway. */
    crn: string;
    /** The target resource type for this endpoint gateway. */
    resource_type: EndpointGatewayTargetPrototypeEndpointGatewayTargetResourceTypePrivatePathServiceGatewayPrototype.Constants.ResourceType | string;
  }
  export namespace EndpointGatewayTargetPrototypeEndpointGatewayTargetResourceTypePrivatePathServiceGatewayPrototype {
    export namespace Constants {
      /** The target resource type for this endpoint gateway. */
      export enum ResourceType {
        PRIVATE_PATH_SERVICE_GATEWAY = 'private_path_service_gateway',
      }
    }
  }

  /**
   * EndpointGatewayTargetPrototypeEndpointGatewayTargetResourceTypeProviderCloudServicePrototype.
   */
  export interface EndpointGatewayTargetPrototypeEndpointGatewayTargetResourceTypeProviderCloudServicePrototype extends EndpointGatewayTargetPrototype {
    /** The CRN for this provider cloud service, or the CRN for the user's instance of a provider cloud service. */
    crn: string;
    /** The target resource type for this endpoint gateway. */
    resource_type: EndpointGatewayTargetPrototypeEndpointGatewayTargetResourceTypeProviderCloudServicePrototype.Constants.ResourceType | string;
  }
  export namespace EndpointGatewayTargetPrototypeEndpointGatewayTargetResourceTypeProviderCloudServicePrototype {
    export namespace Constants {
      /** The target resource type for this endpoint gateway. */
      export enum ResourceType {
        PROVIDER_CLOUD_SERVICE = 'provider_cloud_service',
      }
    }
  }

  /**
   * The name of this provider infrastructure service.
   */
  export interface EndpointGatewayTargetPrototypeEndpointGatewayTargetResourceTypeProviderInfrastructureServicePrototype extends EndpointGatewayTargetPrototype {
    /** The name of a provider infrastructure service. Must be:
     *  - `ibm-ntp-server`: An NTP (Network Time Protocol) server provided by IBM.
     */
    name: string;
    /** The target resource type for this endpoint gateway. */
    resource_type: EndpointGatewayTargetPrototypeEndpointGatewayTargetResourceTypeProviderInfrastructureServicePrototype.Constants.ResourceType | string;
  }
  export namespace EndpointGatewayTargetPrototypeEndpointGatewayTargetResourceTypeProviderInfrastructureServicePrototype {
    export namespace Constants {
      /** The target resource type for this endpoint gateway. */
      export enum ResourceType {
        PROVIDER_INFRASTRUCTURE_SERVICE = 'provider_infrastructure_service',
      }
    }
  }

  /**
   * EndpointGatewayTargetPrivatePathServiceGatewayReference.
   */
  export interface EndpointGatewayTargetPrivatePathServiceGatewayReference extends EndpointGatewayTarget {
    /** The CRN for this private path service gateway. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this private path service gateway. */
    href: string;
    /** The unique identifier for this private path service gateway. */
    id: string;
    /** The name for this private path service gateway. The name is unique across all private path service gateways
     *  in the VPC.
     */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: PrivatePathServiceGatewayRemote;
    /** The resource type. */
    resource_type: EndpointGatewayTargetPrivatePathServiceGatewayReference.Constants.ResourceType | string;
  }
  export namespace EndpointGatewayTargetPrivatePathServiceGatewayReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        PRIVATE_PATH_SERVICE_GATEWAY = 'private_path_service_gateway',
      }
    }
  }

  /**
   * EndpointGatewayTargetProviderCloudServiceReference.
   */
  export interface EndpointGatewayTargetProviderCloudServiceReference extends EndpointGatewayTarget {
    /** The CRN for this provider cloud service, or the CRN for the user's instance of a provider cloud service. */
    crn: string;
    /** The type of target. */
    resource_type: EndpointGatewayTargetProviderCloudServiceReference.Constants.ResourceType | string;
  }
  export namespace EndpointGatewayTargetProviderCloudServiceReference {
    export namespace Constants {
      /** The type of target. */
      export enum ResourceType {
        PROVIDER_CLOUD_SERVICE = 'provider_cloud_service',
      }
    }
  }

  /**
   * The name of this provider infrastructure service.
   */
  export interface EndpointGatewayTargetProviderInfrastructureServiceReference extends EndpointGatewayTarget {
    /** The name of a provider infrastructure service. Must be:
     *  - `ibm-ntp-server`: An NTP (Network Time Protocol) server provided by IBM.
     */
    name: string;
    /** The type of target. */
    resource_type: EndpointGatewayTargetProviderInfrastructureServiceReference.Constants.ResourceType | string;
  }
  export namespace EndpointGatewayTargetProviderInfrastructureServiceReference {
    export namespace Constants {
      /** The type of target. */
      export enum ResourceType {
        PROVIDER_INFRASTRUCTURE_SERVICE = 'provider_infrastructure_service',
      }
    }
  }

  /**
   * FloatingIPPrototypeFloatingIPByTarget.
   */
  export interface FloatingIPPrototypeFloatingIPByTarget extends FloatingIPPrototype {
    /** The target resource to bind this floating IP to.
     *
     *  The target resource must not already have a floating IP bound to it if the target
     *  resource is:
     *
     *  - an instance network interface
     *  - a bare metal server network interface with `enable_infrastructure_nat` set to `true`
     *  - a virtual network interface with `enable_infrastructure_nat` set to `true`.
     */
    target: FloatingIPTargetPrototype;
  }

  /**
   * FloatingIPPrototypeFloatingIPByZone.
   */
  export interface FloatingIPPrototypeFloatingIPByZone extends FloatingIPPrototype {
    /** The zone this floating IP will reside in. */
    zone: ZoneIdentity;
  }

  /**
   * Identifies a bare metal server network interface by a unique property.
   */
  export interface FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity extends FloatingIPTargetPatch {
  }

  /**
   * Identifies an instance network interface by a unique property.
   */
  export interface FloatingIPTargetPatchNetworkInterfaceIdentity extends FloatingIPTargetPatch {
  }

  /**
   * Identifies a virtual network interface by a unique property.
   */
  export interface FloatingIPTargetPatchVirtualNetworkInterfaceIdentity extends FloatingIPTargetPatch {
  }

  /**
   * Identifies a bare metal server network interface by a unique property.
   */
  export interface FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity extends FloatingIPTargetPrototype {
  }

  /**
   * Identifies an instance network interface by a unique property.
   */
  export interface FloatingIPTargetPrototypeNetworkInterfaceIdentity extends FloatingIPTargetPrototype {
  }

  /**
   * Identifies a virtual network interface by a unique property.
   */
  export interface FloatingIPTargetPrototypeVirtualNetworkInterfaceIdentity extends FloatingIPTargetPrototype {
  }

  /**
   * FloatingIPTargetBareMetalServerNetworkInterfaceReference.
   */
  export interface FloatingIPTargetBareMetalServerNetworkInterfaceReference extends FloatingIPTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
    /** The unique identifier for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
    /** The name for this bare metal server network interface. */
    name: string;
    /** The primary IP address of this bare metal server network interface. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: FloatingIPTargetBareMetalServerNetworkInterfaceReference.Constants.ResourceType | string;
  }
  export namespace FloatingIPTargetBareMetalServerNetworkInterfaceReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
    }
  }

  /**
   * FloatingIPTargetNetworkInterfaceReference.
   */
  export interface FloatingIPTargetNetworkInterfaceReference extends FloatingIPTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
    /** The unique identifier for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
    /** The name for this instance network interface. */
    name: string;
    /** The primary IP address of this instance network interface. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: FloatingIPTargetNetworkInterfaceReference.Constants.ResourceType | string;
  }
  export namespace FloatingIPTargetNetworkInterfaceReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
    }
  }

  /**
   * FloatingIPTargetPublicGatewayReference.
   */
  export interface FloatingIPTargetPublicGatewayReference extends FloatingIPTarget {
    /** The CRN for this public gateway. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this public gateway. */
    href: string;
    /** The unique identifier for this public gateway. */
    id: string;
    /** The name for this public gateway. The name is unique across all public gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: FloatingIPTargetPublicGatewayReference.Constants.ResourceType | string;
  }
  export namespace FloatingIPTargetPublicGatewayReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        PUBLIC_GATEWAY = 'public_gateway',
      }
    }
  }

  /**
   * FloatingIPTargetVirtualNetworkInterfaceReference.
   */
  export interface FloatingIPTargetVirtualNetworkInterfaceReference extends FloatingIPTarget {
    /** The CRN for this virtual network interface. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this virtual network interface. */
    href: string;
    /** The unique identifier for this virtual network interface. */
    id: string;
    /** The name for this virtual network interface. The name is unique across all virtual network interfaces in the
     *  VPC.
     */
    name: string;
    /** The primary IP for this virtual network interface. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: FloatingIPTargetVirtualNetworkInterfaceReference.Constants.ResourceType | string;
    /** The associated subnet. */
    subnet: SubnetReference;
  }
  export namespace FloatingIPTargetVirtualNetworkInterfaceReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VIRTUAL_NETWORK_INTERFACE = 'virtual_network_interface',
      }
    }
  }

  /**
   * Identifies a virtual server instance by a unique property.
   */
  export interface FlowLogCollectorTargetPrototypeInstanceIdentity extends FlowLogCollectorTargetPrototype {
  }

  /**
   * Identifies an instance network attachment by a unique property.
   */
  export interface FlowLogCollectorTargetPrototypeInstanceNetworkAttachmentIdentity extends FlowLogCollectorTargetPrototype {
  }

  /**
   * Identifies an instance network interface by a unique property.
   */
  export interface FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity extends FlowLogCollectorTargetPrototype {
  }

  /**
   * Identifies a subnet by a unique property.
   */
  export interface FlowLogCollectorTargetPrototypeSubnetIdentity extends FlowLogCollectorTargetPrototype {
  }

  /**
   * Identifies a VPC by a unique property.
   */
  export interface FlowLogCollectorTargetPrototypeVPCIdentity extends FlowLogCollectorTargetPrototype {
  }

  /**
   * Identifies a virtual network interface by a unique property.
   */
  export interface FlowLogCollectorTargetPrototypeVirtualNetworkInterfaceIdentity extends FlowLogCollectorTargetPrototype {
  }

  /**
   * FlowLogCollectorTargetInstanceNetworkAttachmentReference.
   */
  export interface FlowLogCollectorTargetInstanceNetworkAttachmentReference extends FlowLogCollectorTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance network attachment. */
    href: string;
    /** The unique identifier for this instance network attachment. */
    id: string;
    /** The name for this instance network attachment. The name is unique across all network attachments for the
     *  instance.
     */
    name: string;
    /** The primary IP address of the virtual network interface for the instance network attachment. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: FlowLogCollectorTargetInstanceNetworkAttachmentReference.Constants.ResourceType | string;
    /** The subnet of the virtual network interface for the instance network attachment. */
    subnet: SubnetReference;
    /** The virtual network interface for this instance network attachment. */
    virtual_network_interface: VirtualNetworkInterfaceReferenceAttachmentContext;
  }
  export namespace FlowLogCollectorTargetInstanceNetworkAttachmentReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_NETWORK_ATTACHMENT = 'instance_network_attachment',
      }
    }
  }

  /**
   * FlowLogCollectorTargetInstanceReference.
   */
  export interface FlowLogCollectorTargetInstanceReference extends FlowLogCollectorTarget {
    /** The CRN for this virtual server instance. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this virtual server instance. */
    href: string;
    /** The unique identifier for this virtual server instance. */
    id: string;
    /** The name for this virtual server instance. The name is unique across all virtual server instances in the
     *  region.
     */
    name: string;
  }

  /**
   * FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext.
   */
  export interface FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext extends FlowLogCollectorTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
    /** The unique identifier for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
    /** The name for this instance network interface. */
    name: string;
    /** The resource type. */
    resource_type: FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext.Constants.ResourceType | string;
  }
  export namespace FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
    }
  }

  /**
   * FlowLogCollectorTargetSubnetReference.
   */
  export interface FlowLogCollectorTargetSubnetReference extends FlowLogCollectorTarget {
    /** The CRN for this subnet. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this subnet. */
    href: string;
    /** The unique identifier for this subnet. */
    id: string;
    /** The name for this subnet. The name is unique across all subnets in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: FlowLogCollectorTargetSubnetReference.Constants.ResourceType | string;
  }
  export namespace FlowLogCollectorTargetSubnetReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SUBNET = 'subnet',
      }
    }
  }

  /**
   * FlowLogCollectorTargetVPCReference.
   */
  export interface FlowLogCollectorTargetVPCReference extends FlowLogCollectorTarget {
    /** The CRN for this VPC. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this VPC. */
    href: string;
    /** The unique identifier for this VPC. */
    id: string;
    /** The name for this VPC. The name is unique across all VPCs in the region. */
    name: string;
    /** The resource type. */
    resource_type: FlowLogCollectorTargetVPCReference.Constants.ResourceType | string;
  }
  export namespace FlowLogCollectorTargetVPCReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPC = 'vpc',
      }
    }
  }

  /**
   * FlowLogCollectorTargetVirtualNetworkInterfaceReferenceAttachmentContext.
   */
  export interface FlowLogCollectorTargetVirtualNetworkInterfaceReferenceAttachmentContext extends FlowLogCollectorTarget {
    /** The CRN for this virtual network interface. */
    crn: string;
    /** The URL for this virtual network interface. */
    href: string;
    /** The unique identifier for this virtual network interface. */
    id: string;
    /** The name for this virtual network interface. The name is unique across all virtual network interfaces in the
     *  VPC.
     */
    name: string;
    /** The resource type. */
    resource_type: FlowLogCollectorTargetVirtualNetworkInterfaceReferenceAttachmentContext.Constants.ResourceType | string;
  }
  export namespace FlowLogCollectorTargetVirtualNetworkInterfaceReferenceAttachmentContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VIRTUAL_NETWORK_INTERFACE = 'virtual_network_interface',
      }
    }
  }

  /**
   * ImageIdentityByCRN.
   */
  export interface ImageIdentityByCRN extends ImageIdentity {
    /** The CRN for this image. */
    crn: string;
  }

  /**
   * ImageIdentityByHref.
   */
  export interface ImageIdentityByHref extends ImageIdentity {
    /** The URL for this image. */
    href: string;
  }

  /**
   * ImageIdentityById.
   */
  export interface ImageIdentityById extends ImageIdentity {
    /** The unique identifier for this image. */
    id: string;
  }

  /**
   * ImagePrototypeImageByFile.
   */
  export interface ImagePrototypeImageByFile extends ImagePrototype {
    /** A base64-encoded, encrypted representation of the key that was used to encrypt the data for this image.
     *
     *  That representation is created by wrapping the key's value with the `encryption_key` root key (which must also
     *  be specified), using either [Key Protect](https://cloud.ibm.com/docs/key-protect?topic=key-protect-wrap-keys) or
     *  the
     *  [Hyper Protect Crypto Services](https://cloud.ibm.com/docs/services/hs-crypto?topic=hs-crypto-wrap-keys).
     *
     *  If unspecified, the imported image is treated as unencrypted.
     */
    encrypted_data_key?: string;
    /** The root key that was used to wrap the data key (which is ultimately represented as
     *  `encrypted_data_key`). Additionally, the root key will be used to encrypt volumes
     *  created from this image (unless an alternate `encryption_key` is specified at volume
     *  creation).
     *
     *  If unspecified, the imported image is treated as unencrypted.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The file from which to create the image. */
    file: ImageFilePrototype;
    /** The [supported operating
     *  system](https://cloud.ibm.com/apidocs/vpc#list-operating-systems) included in this
     *  image.
     */
    operating_system: OperatingSystemIdentity;
  }

  /**
   * ImagePrototypeImageBySourceVolume.
   */
  export interface ImagePrototypeImageBySourceVolume extends ImagePrototype {
    /** The root key used to wrap the system-generated data encryption key for the image.
     *
     *  If unspecified, the root key from `source_volume` will be used.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The volume from which to create the image. The specified volume must:
     *  - Have an `operating_system`, which will be used to populate this image's
     *    operating system information.
     *  - Not be `active` or `busy`.
     *
     *  During image creation, the specified volume may briefly become `busy`.
     */
    source_volume: VolumeIdentity;
  }

  /**
   * InstanceCatalogOfferingPrototypeCatalogOfferingByOffering.
   */
  export interface InstanceCatalogOfferingPrototypeCatalogOfferingByOffering extends InstanceCatalogOfferingPrototype {
    /** Identifies a [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering by a unique property.
     */
    offering: CatalogOfferingIdentity;
  }

  /**
   * InstanceCatalogOfferingPrototypeCatalogOfferingByVersion.
   */
  export interface InstanceCatalogOfferingPrototypeCatalogOfferingByVersion extends InstanceCatalogOfferingPrototype {
    /** Identifies a version of a
     *  [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering by a
     *  unique property.
     */
    version: CatalogOfferingVersionIdentity;
  }

  /**
   * InstanceClusterNetworkAttachmentBeforePrototypeInstanceClusterNetworkAttachmentIdentityByHref.
   */
  export interface InstanceClusterNetworkAttachmentBeforePrototypeInstanceClusterNetworkAttachmentIdentityByHref extends InstanceClusterNetworkAttachmentBeforePrototype {
    /** The URL for this instance cluster network attachment. */
    href: string;
  }

  /**
   * InstanceClusterNetworkAttachmentBeforePrototypeInstanceClusterNetworkAttachmentIdentityById.
   */
  export interface InstanceClusterNetworkAttachmentBeforePrototypeInstanceClusterNetworkAttachmentIdentityById extends InstanceClusterNetworkAttachmentBeforePrototype {
    /** The unique identifier for this instance cluster network attachment. */
    id: string;
  }

  /**
   * Identifies a cluster network interface by a unique property.
   */
  export interface InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterfaceClusterNetworkInterfaceIdentity extends InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterface {
  }

  /**
   * The cluster network interface for this target.
   */
  export interface InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterfaceInstanceClusterNetworkInterfacePrototypeInstanceClusterNetworkAttachment extends InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterface {
    /** Indicates whether this cluster network interface will be automatically deleted when `target` is deleted. */
    auto_delete?: boolean;
    /** The name for this cluster network interface. The name must not be used by another interface in the cluster
     *  network. Names beginning with `ibm-` are reserved for provider-owned resources, and are not allowed. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The primary IP address to bind to the cluster network interface. May be either
     *  a cluster network subnet reserved IP identity, or a cluster network subnet reserved IP
     *  prototype object which will be used to create a new cluster network subnet reserved IP.
     *
     *  If a cluster network subnet reserved IP identity is provided, the specified cluster
     *  network subnet reserved IP must be unbound.
     *
     *  If a cluster network subnet reserved IP prototype object with an address is provided,
     *  the address must be available on the cluster network interface's cluster network
     *  subnet. If no address is specified, an available address on the cluster network subnet
     *  will be automatically selected and reserved.
     */
    primary_ip?: ClusterNetworkInterfacePrimaryIPPrototype;
    /** The associated cluster network subnet. Required if `primary_ip` does not specify a
     *  cluster network subnet reserved IP identity.
     */
    subnet?: ClusterNetworkSubnetIdentity;
  }

  /**
   * InstanceGroupManagerActionPrototypeScheduledActionPrototype.
   */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototype extends InstanceGroupManagerActionPrototype {
  }

  /**
   * InstanceGroupManagerActionScheduledAction.
   */
  export interface InstanceGroupManagerActionScheduledAction extends InstanceGroupManagerAction {
    /** The type of action for the instance group. */
    action_type: InstanceGroupManagerActionScheduledAction.Constants.ActionType | string;
    /** The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within
     *  a 5 min period.
     */
    cron_spec?: string;
    /** The date and time the scheduled action was last applied. If absent, the action has never been applied. */
    last_applied_at?: string;
    /** The date and time the scheduled action will next run. If absent, the system is currently calculating the
     *  next run time.
     */
    next_run_at?: string;
  }
  export namespace InstanceGroupManagerActionScheduledAction {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_GROUP_MANAGER_ACTION = 'instance_group_manager_action',
      }
      /** The status of the instance group action - `active`: Action is ready to be run - `completed`: Action was completed successfully - `failed`: Action could not be completed successfully - `incompatible`: Action parameters are not compatible with the group or manager - `omitted`: Action was not applied because this action's manager was disabled The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        ACTIVE = 'active',
        COMPLETED = 'completed',
        FAILED = 'failed',
        INCOMPATIBLE = 'incompatible',
        OMITTED = 'omitted',
      }
      /** The type of action for the instance group. */
      export enum ActionType {
        SCHEDULED = 'scheduled',
      }
    }
  }

  /**
   * InstanceGroupManagerAutoScale.
   */
  export interface InstanceGroupManagerAutoScale extends InstanceGroupManager {
    /** The time window in seconds to aggregate metrics prior to evaluation. */
    aggregation_window: number;
    /** The duration of time in seconds to pause further scale actions after scaling has taken place. */
    cooldown: number;
    /** The type of instance group manager. */
    manager_type: InstanceGroupManagerAutoScale.Constants.ManagerType | string;
    /** The maximum number of members in a managed instance group. */
    max_membership_count: number;
    /** The minimum number of members in a managed instance group. */
    min_membership_count: number;
    /** The policies of the instance group manager. */
    policies: InstanceGroupManagerPolicyReference[];
  }
  export namespace InstanceGroupManagerAutoScale {
    export namespace Constants {
      /** The type of instance group manager. */
      export enum ManagerType {
        AUTOSCALE = 'autoscale',
      }
    }
  }

  /**
   * InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype.
   */
  export interface InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype extends InstanceGroupManagerPolicyPrototype {
    /** The type of metric to be evaluated. */
    metric_type: InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype.Constants.MetricType | string;
    /** The metric value to be evaluated. */
    metric_value: number;
    /** The type of policy for the instance group. */
    policy_type: InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype.Constants.PolicyType | string;
  }
  export namespace InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype {
    export namespace Constants {
      /** The type of metric to be evaluated. */
      export enum MetricType {
        CPU = 'cpu',
        MEMORY = 'memory',
        NETWORK_IN = 'network_in',
        NETWORK_OUT = 'network_out',
      }
      /** The type of policy for the instance group. */
      export enum PolicyType {
        TARGET = 'target',
      }
    }
  }

  /**
   * InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy.
   */
  export interface InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy extends InstanceGroupManagerPolicy {
    /** The type of metric to be evaluated
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    metric_type: InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy.Constants.MetricType | string;
    /** The metric value to be evaluated. */
    metric_value: number;
    /** The type of policy for the instance group
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    policy_type: InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy.Constants.PolicyType | string;
  }
  export namespace InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy {
    export namespace Constants {
      /** The type of metric to be evaluated The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum MetricType {
        CPU = 'cpu',
        MEMORY = 'memory',
        NETWORK_IN = 'network_in',
        NETWORK_OUT = 'network_out',
      }
      /** The type of policy for the instance group The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum PolicyType {
        TARGET = 'target',
      }
    }
  }

  /**
   * InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype.
   */
  export interface InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype extends InstanceGroupManagerPrototype {
    /** The time window in seconds to aggregate metrics prior to evaluation. */
    aggregation_window?: number;
    /** The duration of time in seconds to pause further scale actions after scaling has taken place. */
    cooldown?: number;
    /** The type of instance group manager. */
    manager_type: InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype.Constants.ManagerType | string;
    /** The maximum number of members in a managed instance group. */
    max_membership_count: number;
    /** The minimum number of members in a managed instance group. */
    min_membership_count?: number;
  }
  export namespace InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype {
    export namespace Constants {
      /** The type of instance group manager. */
      export enum ManagerType {
        AUTOSCALE = 'autoscale',
      }
    }
  }

  /**
   * InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype.
   */
  export interface InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype extends InstanceGroupManagerPrototype {
    /** The type of instance group manager. */
    manager_type: InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype.Constants.ManagerType | string;
  }
  export namespace InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype {
    export namespace Constants {
      /** The type of instance group manager. */
      export enum ManagerType {
        SCHEDULED = 'scheduled',
      }
    }
  }

  /**
   * InstanceGroupManagerScheduled.
   */
  export interface InstanceGroupManagerScheduled extends InstanceGroupManager {
    /** The actions of the instance group manager. */
    actions: InstanceGroupManagerActionReference[];
    /** The type of instance group manager. */
    manager_type: InstanceGroupManagerScheduled.Constants.ManagerType | string;
  }
  export namespace InstanceGroupManagerScheduled {
    export namespace Constants {
      /** The type of instance group manager. */
      export enum ManagerType {
        SCHEDULED = 'scheduled',
      }
    }
  }

  /**
   * InstanceGroupManagerScheduledActionManagerAutoScale.
   */
  export interface InstanceGroupManagerScheduledActionManagerAutoScale extends InstanceGroupManagerScheduledActionManager {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance group manager. */
    href: string;
    /** The unique identifier for this instance group manager. */
    id: string;
    /** The name for this instance group manager. The name is unique across all managers for the instance group. */
    name: string;
    /** The desired maximum number of instance group members at the scheduled time. */
    max_membership_count?: number;
    /** The desired minimum number of instance group members at the scheduled time. */
    min_membership_count?: number;
  }

  /**
   * The auto scale manager to update, and one or more properties to be updated. Either `id` or `href` must be
   * specified, in addition to at least one of `min_membership_count` and
   * `max_membership_count`.
   */
  export interface InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype extends InstanceGroupManagerScheduledActionManagerPrototype {
    /** The desired maximum number of instance group members at the scheduled time. */
    max_membership_count?: number;
    /** The desired minimum number of instance group members at the scheduled time. */
    min_membership_count?: number;
  }

  /**
   * Identifies a virtual network interface by a unique property.
   */
  export interface InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentity extends InstanceNetworkAttachmentPrototypeVirtualNetworkInterface {
  }

  /**
   * The virtual network interface for this target.
   */
  export interface InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfacePrototypeInstanceNetworkAttachmentContext extends InstanceNetworkAttachmentPrototypeVirtualNetworkInterface {
    /** Indicates whether source IP spoofing is allowed on this interface. If `false`, source IP spoofing is
     *  prevented on this interface. If `true`, source IP spoofing is allowed on this interface.
     */
    allow_ip_spoofing?: boolean;
    /** Indicates whether this virtual network interface will be automatically deleted when `target` is deleted. */
    auto_delete?: boolean;
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the virtual network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - Can only be attached to a `target` with a `resource_type` of
     *    `bare_metal_server_network_attachment`.
     */
    enable_infrastructure_nat?: boolean;
    /** Additional IP addresses to bind to the virtual network interface. Each item may be either a reserved IP
     *  identity, or a reserved IP prototype object which will be used to create a new reserved IP. All IP addresses
     *  must be in the primary IP's subnet.
     *
     *  If reserved IP identities are provided, the specified reserved IPs must be unbound.
     *
     *  If reserved IP prototype objects with addresses are provided, the addresses must be available on the virtual
     *  network interface's subnet. For any prototype objects that do not specify an address, an available address on
     *  the subnet will be automatically selected and reserved.
     */
    ips?: VirtualNetworkInterfaceIPPrototype[];
    /** The name for this virtual network interface. The name must not be used by another virtual network interface
     *  in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words. Names beginning with
     *  `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
    /** The primary IP address to bind to the virtual network interface. May be either a
     *  reserved IP identity, or a reserved IP prototype object which will be used to create a
     *  new reserved IP.
     *
     *  If a reserved IP identity is provided, the specified reserved IP must be unbound.
     *
     *  If a reserved IP prototype object with an address is provided, the address must be
     *  available on the virtual network interface's subnet. If no address is specified,
     *  an available address on the subnet will be automatically selected and reserved.
     */
    primary_ip?: VirtualNetworkInterfacePrimaryIPPrototype;
    /** The protocol state filtering mode to use for this virtual network interface. If
     *  `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target`
     *  resource type:
     *
     *  - `bare_metal_server_network_attachment`: disabled
     *  - `instance_network_attachment`: enabled
     *  - `share_mount_target`: enabled
     *
     *  Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops
     *  any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering
     *  mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information.
     */
    protocol_state_filtering_mode?: InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfacePrototypeInstanceNetworkAttachmentContext.Constants.ProtocolStateFilteringMode | string;
    /** The resource group to use for this virtual network interface. If unspecified, the
     *  virtual server instance's resource group will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The security groups to use for this virtual network interface. If unspecified, the default security group of
     *  the VPC for the subnet is used.
     */
    security_groups?: SecurityGroupIdentity[];
    /** The associated subnet. Required if `primary_ip` does not specify a reserved IP identity. */
    subnet?: SubnetIdentity;
  }
  export namespace InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfacePrototypeInstanceNetworkAttachmentContext {
    export namespace Constants {
      /** The protocol state filtering mode to use for this virtual network interface. If `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target` resource type: - `bare_metal_server_network_attachment`: disabled - `instance_network_attachment`: enabled - `share_mount_target`: enabled Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information. */
      export enum ProtocolStateFilteringMode {
        AUTO = 'auto',
        DISABLED = 'disabled',
        ENABLED = 'enabled',
      }
    }
  }

  /**
   * InstancePatchProfileInstanceProfileIdentityByHref.
   */
  export interface InstancePatchProfileInstanceProfileIdentityByHref extends InstancePatchProfile {
    /** The URL for this virtual server instance profile. */
    href: string;
  }

  /**
   * InstancePatchProfileInstanceProfileIdentityByName.
   */
  export interface InstancePatchProfileInstanceProfileIdentityByName extends InstancePatchProfile {
    /** The globally unique name for this virtual server instance profile. */
    name: string;
  }

  /**
   * Identifies a dedicated host group by a unique property.
   */
  export interface InstancePlacementTargetPatchDedicatedHostGroupIdentity extends InstancePlacementTargetPatch {
  }

  /**
   * Identifies a dedicated host by a unique property.
   */
  export interface InstancePlacementTargetPatchDedicatedHostIdentity extends InstancePlacementTargetPatch {
  }

  /**
   * Identifies a dedicated host group by a unique property.
   */
  export interface InstancePlacementTargetPrototypeDedicatedHostGroupIdentity extends InstancePlacementTargetPrototype {
  }

  /**
   * Identifies a dedicated host by a unique property.
   */
  export interface InstancePlacementTargetPrototypeDedicatedHostIdentity extends InstancePlacementTargetPrototype {
  }

  /**
   * Identifies a placement group by a unique property.
   */
  export interface InstancePlacementTargetPrototypePlacementGroupIdentity extends InstancePlacementTargetPrototype {
  }

  /**
   * InstancePlacementTargetDedicatedHostGroupReference.
   */
  export interface InstancePlacementTargetDedicatedHostGroupReference extends InstancePlacementTarget {
    /** The CRN for this dedicated host group. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this dedicated host group. */
    href: string;
    /** The unique identifier for this dedicated host group. */
    id: string;
    /** The name for this dedicated host group. The name is unique across all dedicated host groups in the region. */
    name: string;
    /** The resource type. */
    resource_type: InstancePlacementTargetDedicatedHostGroupReference.Constants.ResourceType | string;
  }
  export namespace InstancePlacementTargetDedicatedHostGroupReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        DEDICATED_HOST_GROUP = 'dedicated_host_group',
      }
    }
  }

  /**
   * InstancePlacementTargetDedicatedHostReference.
   */
  export interface InstancePlacementTargetDedicatedHostReference extends InstancePlacementTarget {
    /** The CRN for this dedicated host. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this dedicated host. */
    href: string;
    /** The unique identifier for this dedicated host. */
    id: string;
    /** The name for this dedicated host. The name is unique across all dedicated hosts in the region. */
    name: string;
    /** The resource type. */
    resource_type: InstancePlacementTargetDedicatedHostReference.Constants.ResourceType | string;
  }
  export namespace InstancePlacementTargetDedicatedHostReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        DEDICATED_HOST = 'dedicated_host',
      }
    }
  }

  /**
   * InstancePlacementTargetPlacementGroupReference.
   */
  export interface InstancePlacementTargetPlacementGroupReference extends InstancePlacementTarget {
    /** The CRN for this placement group. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this placement group. */
    href: string;
    /** The unique identifier for this placement group. */
    id: string;
    /** The name for this placement group. The name is unique across all placement groups in the region. */
    name: string;
    /** The resource type. */
    resource_type: InstancePlacementTargetPlacementGroupReference.Constants.ResourceType | string;
  }
  export namespace InstancePlacementTargetPlacementGroupReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        PLACEMENT_GROUP = 'placement_group',
      }
    }
  }

  /**
   * The total bandwidth shared across the network attachments or network interfaces and storage volumes of an instance
   * with this profile depends on its configuration.
   */
  export interface InstanceProfileBandwidthDependent extends InstanceProfileBandwidth {
    /** The type for this profile field. */
    type: InstanceProfileBandwidthDependent.Constants.Type | string;
  }
  export namespace InstanceProfileBandwidthDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted total bandwidth values (in megabits per second) shared across the network attachments or network
   * interfaces and storage volumes of an instance with this profile.
   */
  export interface InstanceProfileBandwidthEnum extends InstanceProfileBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: InstanceProfileBandwidthEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace InstanceProfileBandwidthEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The total bandwidth (in megabits per second) shared across the network attachments or network interfaces and
   * storage volumes of an instance with this profile.
   */
  export interface InstanceProfileBandwidthFixed extends InstanceProfileBandwidth {
    /** The type for this profile field. */
    type: InstanceProfileBandwidthFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace InstanceProfileBandwidthFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted total bandwidth range (in megabits per second) shared across the network attachments or network
   * interfaces and storage volumes of an instance with this profile.
   */
  export interface InstanceProfileBandwidthRange extends InstanceProfileBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: InstanceProfileBandwidthRange.Constants.Type | string;
  }
  export namespace InstanceProfileBandwidthRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The number of cluster network attachments supported on an instance with this profile is dependent on its
   * configuration.
   */
  export interface InstanceProfileClusterNetworkAttachmentCountDependent extends InstanceProfileClusterNetworkAttachmentCount {
    /** The type for this profile field. */
    type: InstanceProfileClusterNetworkAttachmentCountDependent.Constants.Type | string;
  }
  export namespace InstanceProfileClusterNetworkAttachmentCountDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted values for cluster network attachment count for an instance with this profile.
   */
  export interface InstanceProfileClusterNetworkAttachmentCountEnum extends InstanceProfileClusterNetworkAttachmentCount {
    default?: number;
    /** The type for this profile field. */
    type: InstanceProfileClusterNetworkAttachmentCountEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace InstanceProfileClusterNetworkAttachmentCountEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The number of network attachments supported on an instance with this profile.
   */
  export interface InstanceProfileClusterNetworkAttachmentCountRange extends InstanceProfileClusterNetworkAttachmentCount {
    /** The maximum value for this profile field. */
    max?: number;
    /** The minimum value for this profile field. */
    min?: number;
    step?: number;
    /** The type for this profile field. */
    type: InstanceProfileClusterNetworkAttachmentCountRange.Constants.Type | string;
  }
  export namespace InstanceProfileClusterNetworkAttachmentCountRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The number of disks of this configuration for an instance with this profile depends on its instance configuration.
   */
  export interface InstanceProfileDiskQuantityDependent extends InstanceProfileDiskQuantity {
    /** The type for this profile field. */
    type: InstanceProfileDiskQuantityDependent.Constants.Type | string;
  }
  export namespace InstanceProfileDiskQuantityDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted the number of disks of this configuration for an instance with this profile.
   */
  export interface InstanceProfileDiskQuantityEnum extends InstanceProfileDiskQuantity {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: InstanceProfileDiskQuantityEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace InstanceProfileDiskQuantityEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The number of disks of this configuration for an instance with this profile.
   */
  export interface InstanceProfileDiskQuantityFixed extends InstanceProfileDiskQuantity {
    /** The type for this profile field. */
    type: InstanceProfileDiskQuantityFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace InstanceProfileDiskQuantityFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted range for the number of disks of this configuration for an instance with this profile.
   */
  export interface InstanceProfileDiskQuantityRange extends InstanceProfileDiskQuantity {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: InstanceProfileDiskQuantityRange.Constants.Type | string;
  }
  export namespace InstanceProfileDiskQuantityRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The disk size in GB (gigabytes) of this configuration for an instance with this profile depends on its instance
   * configuration.
   */
  export interface InstanceProfileDiskSizeDependent extends InstanceProfileDiskSize {
    /** The type for this profile field. */
    type: InstanceProfileDiskSizeDependent.Constants.Type | string;
  }
  export namespace InstanceProfileDiskSizeDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted disk size in GB (gigabytes) of this configuration for an instance with this profile.
   */
  export interface InstanceProfileDiskSizeEnum extends InstanceProfileDiskSize {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: InstanceProfileDiskSizeEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace InstanceProfileDiskSizeEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The size of the disk in GB (gigabytes).
   */
  export interface InstanceProfileDiskSizeFixed extends InstanceProfileDiskSize {
    /** The type for this profile field. */
    type: InstanceProfileDiskSizeFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace InstanceProfileDiskSizeFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted range for the disk size of this configuration in GB (gigabytes) for an instance with this profile.
   */
  export interface InstanceProfileDiskSizeRange extends InstanceProfileDiskSize {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: InstanceProfileDiskSizeRange.Constants.Type | string;
  }
  export namespace InstanceProfileDiskSizeRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The GPU count for an instance with this profile depends on its configuration.
   */
  export interface InstanceProfileGPUDependent extends InstanceProfileGPU {
    /** The type for this profile field. */
    type: InstanceProfileGPUDependent.Constants.Type | string;
  }
  export namespace InstanceProfileGPUDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted GPU count values for an instance with this profile.
   */
  export interface InstanceProfileGPUEnum extends InstanceProfileGPU {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: InstanceProfileGPUEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace InstanceProfileGPUEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The GPU count for an instance with this profile.
   */
  export interface InstanceProfileGPUFixed extends InstanceProfileGPU {
    /** The type for this profile field. */
    type: InstanceProfileGPUFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace InstanceProfileGPUFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The overall GPU memory value for an instance with this profile depends on its configuration.
   */
  export interface InstanceProfileGPUMemoryDependent extends InstanceProfileGPUMemory {
    /** The type for this profile field. */
    type: InstanceProfileGPUMemoryDependent.Constants.Type | string;
  }
  export namespace InstanceProfileGPUMemoryDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted overall GPU memory values in GiB (gibibytes) for an instance with this profile.
   */
  export interface InstanceProfileGPUMemoryEnum extends InstanceProfileGPUMemory {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: InstanceProfileGPUMemoryEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace InstanceProfileGPUMemoryEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The overall GPU memory in GiB (gibibytes) for an instance with this profile.
   */
  export interface InstanceProfileGPUMemoryFixed extends InstanceProfileGPUMemory {
    /** The type for this profile field. */
    type: InstanceProfileGPUMemoryFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace InstanceProfileGPUMemoryFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted overall GPU memory range in GiB (gibibytes) for an instance with this profile.
   */
  export interface InstanceProfileGPUMemoryRange extends InstanceProfileGPUMemory {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: InstanceProfileGPUMemoryRange.Constants.Type | string;
  }
  export namespace InstanceProfileGPUMemoryRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The permitted GPU count range for an instance with this profile.
   */
  export interface InstanceProfileGPURange extends InstanceProfileGPU {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: InstanceProfileGPURange.Constants.Type | string;
  }
  export namespace InstanceProfileGPURange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * InstanceProfileIdentityByHref.
   */
  export interface InstanceProfileIdentityByHref extends InstanceProfileIdentity {
    /** The URL for this virtual server instance profile. */
    href: string;
  }

  /**
   * InstanceProfileIdentityByName.
   */
  export interface InstanceProfileIdentityByName extends InstanceProfileIdentity {
    /** The globally unique name for this virtual server instance profile. */
    name: string;
  }

  /**
   * The memory value for an instance with this profile depends on its configuration.
   */
  export interface InstanceProfileMemoryDependent extends InstanceProfileMemory {
    /** The type for this profile field. */
    type: InstanceProfileMemoryDependent.Constants.Type | string;
  }
  export namespace InstanceProfileMemoryDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted memory values (in gibibytes) for an instance with this profile.
   */
  export interface InstanceProfileMemoryEnum extends InstanceProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: InstanceProfileMemoryEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace InstanceProfileMemoryEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The memory (in gibibytes) for an instance with this profile.
   */
  export interface InstanceProfileMemoryFixed extends InstanceProfileMemory {
    /** The type for this profile field. */
    type: InstanceProfileMemoryFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace InstanceProfileMemoryFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted memory range (in gibibytes) for an instance with this profile.
   */
  export interface InstanceProfileMemoryRange extends InstanceProfileMemory {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: InstanceProfileMemoryRange.Constants.Type | string;
  }
  export namespace InstanceProfileMemoryRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The total number of NUMA nodes for an instance with this profile depends on its configuration and the capacity
   * constraints within the zone.
   */
  export interface InstanceProfileNUMACountDependent extends InstanceProfileNUMACount {
    /** The type for this profile field. */
    type: InstanceProfileNUMACountDependent.Constants.Type | string;
  }
  export namespace InstanceProfileNUMACountDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The total number of NUMA nodes for an instance with this profile.
   */
  export interface InstanceProfileNUMACountFixed extends InstanceProfileNUMACount {
    /** The type for this profile field. */
    type: InstanceProfileNUMACountFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace InstanceProfileNUMACountFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The number of network attachments supported on an instance with this profile is dependent on its configuration.
   */
  export interface InstanceProfileNetworkAttachmentCountDependent extends InstanceProfileNetworkAttachmentCount {
    /** The type for this profile field. */
    type: InstanceProfileNetworkAttachmentCountDependent.Constants.Type | string;
  }
  export namespace InstanceProfileNetworkAttachmentCountDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The number of network attachments supported on an instance with this profile.
   */
  export interface InstanceProfileNetworkAttachmentCountRange extends InstanceProfileNetworkAttachmentCount {
    /** The maximum value for this profile field. */
    max?: number;
    /** The minimum value for this profile field. */
    min?: number;
    /** The type for this profile field. */
    type: InstanceProfileNetworkAttachmentCountRange.Constants.Type | string;
  }
  export namespace InstanceProfileNetworkAttachmentCountRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The number of network interfaces supported on an instance with this profile is dependent on its configuration.
   */
  export interface InstanceProfileNetworkInterfaceCountDependent extends InstanceProfileNetworkInterfaceCount {
    /** The type for this profile field. */
    type: InstanceProfileNetworkInterfaceCountDependent.Constants.Type | string;
  }
  export namespace InstanceProfileNetworkInterfaceCountDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The number of network interfaces supported on an instance with this profile.
   */
  export interface InstanceProfileNetworkInterfaceCountRange extends InstanceProfileNetworkInterfaceCount {
    /** The maximum value for this profile field. */
    max?: number;
    /** The minimum value for this profile field. */
    min?: number;
    /** The type for this profile field. */
    type: InstanceProfileNetworkInterfaceCountRange.Constants.Type | string;
  }
  export namespace InstanceProfileNetworkInterfaceCountRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The port speed of each network interface of an instance with this profile depends on its configuration.
   */
  export interface InstanceProfilePortSpeedDependent extends InstanceProfilePortSpeed {
    /** The type for this profile field. */
    type: InstanceProfilePortSpeedDependent.Constants.Type | string;
  }
  export namespace InstanceProfilePortSpeedDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The maximum speed (in megabits per second) of each network interface of an instance with this profile.
   */
  export interface InstanceProfilePortSpeedFixed extends InstanceProfilePortSpeed {
    /** The type for this profile field. */
    type: InstanceProfilePortSpeedFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace InstanceProfilePortSpeedFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The VCPU count for an instance with this profile depends on its configuration.
   */
  export interface InstanceProfileVCPUDependent extends InstanceProfileVCPU {
    /** The type for this profile field. */
    type: InstanceProfileVCPUDependent.Constants.Type | string;
  }
  export namespace InstanceProfileVCPUDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted values for VCPU count for an instance with this profile.
   */
  export interface InstanceProfileVCPUEnum extends InstanceProfileVCPU {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: InstanceProfileVCPUEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace InstanceProfileVCPUEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The VCPU count for an instance with this profile.
   */
  export interface InstanceProfileVCPUFixed extends InstanceProfileVCPU {
    /** The type for this profile field. */
    type: InstanceProfileVCPUFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace InstanceProfileVCPUFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted range for VCPU count for an instance with this profile.
   */
  export interface InstanceProfileVCPURange extends InstanceProfileVCPU {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: InstanceProfileVCPURange.Constants.Type | string;
  }
  export namespace InstanceProfileVCPURange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The storage bandwidth shared across the storage volumes of an instance with this profile depends on its
   * configuration.
   */
  export interface InstanceProfileVolumeBandwidthDependent extends InstanceProfileVolumeBandwidth {
    /** The type for this profile field. */
    type: InstanceProfileVolumeBandwidthDependent.Constants.Type | string;
  }
  export namespace InstanceProfileVolumeBandwidthDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted storage bandwidth values (in megabits per second) shared across the storage volumes of an instance
   * with this profile.
   */
  export interface InstanceProfileVolumeBandwidthEnum extends InstanceProfileVolumeBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: InstanceProfileVolumeBandwidthEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace InstanceProfileVolumeBandwidthEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The storage bandwidth (in megabits per second) shared across the storage volumes of an instance with this profile.
   */
  export interface InstanceProfileVolumeBandwidthFixed extends InstanceProfileVolumeBandwidth {
    /** The type for this profile field. */
    type: InstanceProfileVolumeBandwidthFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace InstanceProfileVolumeBandwidthFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted storage bandwidth range (in megabits per second) shared across the storage volumes of an instance
   * with this profile.
   */
  export interface InstanceProfileVolumeBandwidthRange extends InstanceProfileVolumeBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: InstanceProfileVolumeBandwidthRange.Constants.Type | string;
  }
  export namespace InstanceProfileVolumeBandwidthRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * Create an instance by using a catalog offering.
   */
  export interface InstancePrototypeInstanceByCatalogOffering extends InstancePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering
     *  or offering version to use when provisioning this virtual server instance.
     *
     *  If an offering is specified, the latest version of that offering will be used.
     *
     *  The specified offering or offering version may be in a different account, subject
     *  to IAM policies.
     */
    catalog_offering: InstanceCatalogOfferingPrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }
  export namespace InstancePrototypeInstanceByCatalogOffering {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * Create an instance by using an image.
   *
   * The image's `user_data_format` must be `cloud_init`.
   */
  export interface InstancePrototypeInstanceByImage extends InstancePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The image to use when provisioning the virtual server instance. */
    image: ImageIdentity;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }
  export namespace InstancePrototypeInstanceByImage {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * Create an instance by using a snapshot.
   */
  export interface InstancePrototypeInstanceBySourceSnapshot extends InstancePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment: VolumeAttachmentPrototypeInstanceBySourceSnapshotContext;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }
  export namespace InstancePrototypeInstanceBySourceSnapshot {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * Create an instance by using an instance template.
   *
   * The `primary_network_attachment` and `network_attachments` properties may only be specified if
   * `primary_network_attachment` is specified in the source template.
   *
   * The `primary_network_interface` and `network_interfaces` properties may only be specified if
   * `primary_network_interface` is specified in the source template.
   */
  export interface InstancePrototypeInstanceBySourceTemplate extends InstancePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering version to use when provisioning this virtual server instance.
     *  If an offering is specified, the latest version of that offering will be used.
     *
     *  The specified offering or offering version may be in a different account, subject to
     *  IAM policies.
     *
     *  If specified, `image` must not be specified, and `source_template` must not have
     *  `image` specified.
     */
    catalog_offering?: InstanceCatalogOfferingPrototype;
    /** The image to use when provisioning the virtual server instance. */
    image?: ImageIdentity;
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment?: InstanceNetworkAttachmentPrototype;
    /** The primary instance network interface to create. */
    primary_network_interface?: NetworkInterfacePrototype;
    /** The template to create this virtual server instance from. */
    source_template: InstanceTemplateIdentity;
    /** The zone this virtual server instance will reside in. */
    zone?: ZoneIdentity;
  }
  export namespace InstancePrototypeInstanceBySourceTemplate {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * Create an instance by using a boot volume.
   */
  export interface InstancePrototypeInstanceByVolume extends InstancePrototype {
    /** The boot volume attachment for the virtual server instance. */
    boot_volume_attachment: VolumeAttachmentPrototypeInstanceByVolumeContext;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }
  export namespace InstancePrototypeInstanceByVolume {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplateIdentityByCRN.
   */
  export interface InstanceTemplateIdentityByCRN extends InstanceTemplateIdentity {
    /** The CRN for this instance template. */
    crn: string;
  }

  /**
   * InstanceTemplateIdentityByHref.
   */
  export interface InstanceTemplateIdentityByHref extends InstanceTemplateIdentity {
    /** The URL for this instance template. */
    href: string;
  }

  /**
   * InstanceTemplateIdentityById.
   */
  export interface InstanceTemplateIdentityById extends InstanceTemplateIdentity {
    /** The unique identifier for this instance template. */
    id: string;
  }

  /**
   * Create an instance template that creates instances by using a catalog offering.
   */
  export interface InstanceTemplatePrototypeInstanceTemplateByCatalogOffering extends InstanceTemplatePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering
     *  or offering version to use when provisioning this virtual server instance.
     *
     *  If an offering is specified, the latest version of that offering will be used.
     *
     *  The specified offering or offering version may be in a different account, subject
     *  to IAM policies.
     */
    catalog_offering: InstanceCatalogOfferingPrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }
  export namespace InstanceTemplatePrototypeInstanceTemplateByCatalogOffering {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * Create an instance template that creates instances by using an image.
   *
   * The image's `user_data_format` must be `cloud_init`.
   */
  export interface InstanceTemplatePrototypeInstanceTemplateByImage extends InstanceTemplatePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The image to use when provisioning the virtual server instance. */
    image: ImageIdentity;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }
  export namespace InstanceTemplatePrototypeInstanceTemplateByImage {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * Create an instance template that creates instances by using a snapshot.
   */
  export interface InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot extends InstanceTemplatePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment: VolumeAttachmentPrototypeInstanceBySourceSnapshotContext;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }
  export namespace InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * Create an instance template from an existing source instance template.
   *
   * The `primary_network_attachment` and `network_attachments` properties may only be specified if
   * `primary_network_attachment` is specified in the source template.
   *
   * The `primary_network_interface` and `network_interfaces` properties may only be specified if
   * `primary_network_interface` is specified in the source template.
   */
  export interface InstanceTemplatePrototypeInstanceTemplateBySourceTemplate extends InstanceTemplatePrototype {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
     *  offering version to use when provisioning this virtual server instance.
     *  If an offering is specified, the latest version of that offering will be used.
     *
     *  The specified offering or offering version may be in a different account, subject to
     *  IAM policies.
     *
     *  If specified, `image` must not be specified, and `source_template` must not have
     *  `image` specified.
     */
    catalog_offering?: InstanceCatalogOfferingPrototype;
    /** The image to use when provisioning the virtual server instance. */
    image?: ImageIdentity;
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment?: InstanceNetworkAttachmentPrototype;
    /** The primary instance network interface to create. */
    primary_network_interface?: NetworkInterfacePrototype;
    /** The template to create this virtual server instance from. */
    source_template: InstanceTemplateIdentity;
    /** The zone this virtual server instance will reside in. */
    zone?: ZoneIdentity;
  }
  export namespace InstanceTemplatePrototypeInstanceTemplateBySourceTemplate {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * Create an instance by using a catalog offering.
   */
  export interface InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext extends InstanceTemplate {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering
     *  or offering version to use when provisioning this virtual server instance.
     *
     *  If an offering is specified, the latest version of that offering will be used.
     *
     *  The specified offering or offering version may be in a different account, subject
     *  to IAM policies.
     */
    catalog_offering: InstanceCatalogOfferingPrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }
  export namespace InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * Create an instance by using an image.
   */
  export interface InstanceTemplateInstanceByImageInstanceTemplateContext extends InstanceTemplate {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment?: VolumeAttachmentPrototypeInstanceByImageContext;
    /** The image to use when provisioning the virtual server instance. */
    image: ImageIdentity;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }
  export namespace InstanceTemplateInstanceByImageInstanceTemplateContext {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * Create an instance by using a snapshot.
   */
  export interface InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext extends InstanceTemplate {
    /** The boot volume attachment to create for the virtual server instance. */
    boot_volume_attachment: VolumeAttachmentPrototypeInstanceBySourceSnapshotContext;
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment?: InstanceNetworkAttachmentPrototype;
    /** The zone this virtual server instance will reside in. */
    zone: ZoneIdentity;
  }
  export namespace InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * KeyIdentityByCRN.
   */
  export interface KeyIdentityByCRN extends KeyIdentity {
    /** The CRN for this key. */
    crn: string;
  }

  /**
   * KeyIdentityByFingerprint.
   */
  export interface KeyIdentityByFingerprint extends KeyIdentity {
    /** The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm
     *  (always `SHA256`).
     */
    fingerprint: string;
  }

  /**
   * KeyIdentityByHref.
   */
  export interface KeyIdentityByHref extends KeyIdentity {
    /** The URL for this key. */
    href: string;
  }

  /**
   * KeyIdentityById.
   */
  export interface KeyIdentityById extends KeyIdentity {
    /** The unique identifier for this key. */
    id: string;
  }

  /**
   * LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName.
   */
  export interface LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName extends LegacyCloudObjectStorageBucketIdentity {
    /** The globally unique name of this Cloud Object Storage bucket. */
    name: string;
  }

  /**
   * LoadBalancerIdentityByCRN.
   */
  export interface LoadBalancerIdentityByCRN extends LoadBalancerIdentity {
    /** The CRN for this load balancer. */
    crn: string;
  }

  /**
   * LoadBalancerIdentityByHref.
   */
  export interface LoadBalancerIdentityByHref extends LoadBalancerIdentity {
    /** The URL for this load balancer. */
    href: string;
  }

  /**
   * LoadBalancerIdentityById.
   */
  export interface LoadBalancerIdentityById extends LoadBalancerIdentity {
    /** The unique identifier for this load balancer. */
    id: string;
  }

  /**
   * LoadBalancerListenerDefaultPoolPatchLoadBalancerPoolIdentityByHref.
   */
  export interface LoadBalancerListenerDefaultPoolPatchLoadBalancerPoolIdentityByHref extends LoadBalancerListenerDefaultPoolPatch {
    /** The URL for this load balancer pool. */
    href: string;
  }

  /**
   * LoadBalancerListenerDefaultPoolPatchLoadBalancerPoolIdentityById.
   */
  export interface LoadBalancerListenerDefaultPoolPatchLoadBalancerPoolIdentityById extends LoadBalancerListenerDefaultPoolPatch {
    /** The unique identifier for this load balancer pool. */
    id: string;
  }

  /**
   * LoadBalancerListenerIdentityByHref.
   */
  export interface LoadBalancerListenerIdentityByHref extends LoadBalancerListenerIdentity {
    /** The URL for this load balancer listener. */
    href: string;
  }

  /**
   * LoadBalancerListenerIdentityById.
   */
  export interface LoadBalancerListenerIdentityById extends LoadBalancerListenerIdentity {
    /** The unique identifier for this load balancer listener. */
    id: string;
  }

  /**
   * Identifies a load balancer listener by a unique property.
   */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerIdentity extends LoadBalancerListenerPolicyTargetPatch {
  }

  /**
   * LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyHTTPSRedirectPatch.
   */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyHTTPSRedirectPatch extends LoadBalancerListenerPolicyTargetPatch {
    /** The HTTP status code for this redirect. */
    http_status_code?: number;
    /** The target listener.
     *
     *  The target listener must be in this load balancer, and must not be the same as the
     *  listener in the URL.
     */
    listener?: LoadBalancerListenerIdentity;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch.
   */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch extends LoadBalancerListenerPolicyTargetPatch {
    /** The HTTP status code for this redirect. */
    http_status_code?: number;
    /** The redirect target URL. The URL supports [RFC 6570 level 1
     *  expressions](https://datatracker.ietf.org/doc/html/rfc6570#section-1.2) for the following variables which expand
     *  to values from the originally requested URL (or the indicated defaults if the request did not include them):
     *
     *  - `protocol`
     *  - `host`
     *  - `port`  (default: `80` for HTTP requests, `443` for HTTPS requests)
     *  - `path`  (default: '/')
     *  - `query` (default: '')
     *
     *  The protocol, host, and port segments of the URL, must only contain at most one instance of the `protocol`,
     *  `host`, and `port` variables, respectively. The path and query segments of the URL may contain any combination
     *  of variables. If the substitution of `path` results in consecutive leading slashes, the leading slash from the
     *  substitution will be removed. Additional examples:
     *  - `https://{host}:8080/{port}/{host}/{path}`
     *  - `https://www.example.com`
     *  - `{protocol}://test.{host}:80/{path}`.
     */
    url?: string;
  }

  /**
   * Identifies a load balancer pool by a unique property.
   */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity extends LoadBalancerListenerPolicyTargetPatch {
  }

  /**
   * Identifies a load balancer listener by a unique property.
   */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerIdentity extends LoadBalancerListenerPolicyTargetPrototype {
  }

  /**
   * LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyHTTPSRedirectPrototype.
   */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyHTTPSRedirectPrototype extends LoadBalancerListenerPolicyTargetPrototype {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    /** The target listener.
     *
     *  The target listener must be in this load balancer, and must not be the same as the
     *  listener in the URL.
     */
    listener: LoadBalancerListenerIdentity;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype.
   */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype extends LoadBalancerListenerPolicyTargetPrototype {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    /** The redirect target URL. The URL supports [RFC 6570 level 1
     *  expressions](https://datatracker.ietf.org/doc/html/rfc6570#section-1.2) for the following variables which expand
     *  to values from the originally requested URL (or the indicated defaults if the request did not include them):
     *
     *  - `protocol`
     *  - `host`
     *  - `port`  (default: `80` for HTTP requests, `443` for HTTPS requests)
     *  - `path`  (default: '/')
     *  - `query` (default: '')
     *
     *  The protocol, host, and port segments of the URL, must only contain at most one instance of the `protocol`,
     *  `host`, and `port` variables, respectively. The path and query segments of the URL may contain any combination
     *  of variables. If the substitution of `path` results in consecutive leading slashes, the leading slash from the
     *  substitution will be removed. Additional examples:
     *  - `https://{host}:8080/{port}/{host}/{path}`
     *  - `https://www.example.com`
     *  - `{protocol}://test.{host}:80/{path}`.
     */
    url: string;
  }

  /**
   * Identifies a load balancer pool by a unique property.
   */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity extends LoadBalancerListenerPolicyTargetPrototype {
  }

  /**
   * LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyHTTPSRedirect.
   */
  export interface LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyHTTPSRedirect extends LoadBalancerListenerPolicyTarget {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    listener: LoadBalancerListenerReference;
    /** The redirect relative target URI. */
    uri?: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL.
   */
  export interface LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL extends LoadBalancerListenerPolicyTarget {
    /** The HTTP status code for this redirect. */
    http_status_code: number;
    /** The redirect target URL. The URL supports [RFC 6570 level 1
     *  expressions](https://datatracker.ietf.org/doc/html/rfc6570#section-1.2) for the following variables which expand
     *  to values from the originally requested URL (or the indicated defaults if the request did not include them):
     *
     *  - `protocol`
     *  - `host`
     *  - `port`  (default: `80` for HTTP requests, `443` for HTTPS requests)
     *  - `path`  (default: '/')
     *  - `query` (default: '')
     *
     *  The protocol, host, and port segments of the URL, must only contain at most one instance of the `protocol`,
     *  `host`, and `port` variables, respectively. The path and query segments of the URL may contain any combination
     *  of variables. If the substitution of `path` results in consecutive leading slashes, the leading slash from the
     *  substitution will be removed. Additional examples:
     *  - `https://{host}:8080/{port}/{host}/{path}`
     *  - `https://www.example.com`
     *  - `{protocol}://test.{host}:80/{path}`.
     */
    url: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetLoadBalancerListenerReference.
   */
  export interface LoadBalancerListenerPolicyTargetLoadBalancerListenerReference extends LoadBalancerListenerPolicyTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this load balancer listener. */
    href: string;
    /** The unique identifier for this load balancer listener. */
    id: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetLoadBalancerPoolReference.
   */
  export interface LoadBalancerListenerPolicyTargetLoadBalancerPoolReference extends LoadBalancerListenerPolicyTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this load balancer pool. */
    href: string;
    /** The unique identifier for this load balancer pool. */
    id: string;
    /** The name for this load balancer pool. The name is unique across all pools for the load balancer. */
    name: string;
  }

  /**
   * LoadBalancerPoolFailsafePolicyTargetPatchLoadBalancerPoolIdentityByHref.
   */
  export interface LoadBalancerPoolFailsafePolicyTargetPatchLoadBalancerPoolIdentityByHref extends LoadBalancerPoolFailsafePolicyTargetPatch {
    /** The URL for this load balancer pool. */
    href: string;
  }

  /**
   * LoadBalancerPoolFailsafePolicyTargetPatchLoadBalancerPoolIdentityById.
   */
  export interface LoadBalancerPoolFailsafePolicyTargetPatchLoadBalancerPoolIdentityById extends LoadBalancerPoolFailsafePolicyTargetPatch {
    /** The unique identifier for this load balancer pool. */
    id: string;
  }

  /**
   * LoadBalancerPoolHealthMonitorPrototypeLoadBalancerPoolHealthMonitorTypeHTTPHTTPSPrototype.
   */
  export interface LoadBalancerPoolHealthMonitorPrototypeLoadBalancerPoolHealthMonitorTypeHTTPHTTPSPrototype extends LoadBalancerPoolHealthMonitorPrototype {
    /** The protocol type to use for health checks. */
    type: LoadBalancerPoolHealthMonitorPrototypeLoadBalancerPoolHealthMonitorTypeHTTPHTTPSPrototype.Constants.Type | string;
    /** The health check URL path to use.
     *
     *  Must be in the format of an [origin-form request target](https://tools.ietf.org/html/rfc7230#section-5.3.1).
     */
    url_path?: string;
  }
  export namespace LoadBalancerPoolHealthMonitorPrototypeLoadBalancerPoolHealthMonitorTypeHTTPHTTPSPrototype {
    export namespace Constants {
      /** The protocol type to use for health checks. */
      export enum Type {
        HTTP = 'http',
        HTTPS = 'https',
      }
    }
  }

  /**
   * LoadBalancerPoolHealthMonitorPrototypeLoadBalancerPoolHealthMonitorTypeTCPPrototype.
   */
  export interface LoadBalancerPoolHealthMonitorPrototypeLoadBalancerPoolHealthMonitorTypeTCPPrototype extends LoadBalancerPoolHealthMonitorPrototype {
    /** The protocol type to use for health checks. */
    type: LoadBalancerPoolHealthMonitorPrototypeLoadBalancerPoolHealthMonitorTypeTCPPrototype.Constants.Type | string;
  }
  export namespace LoadBalancerPoolHealthMonitorPrototypeLoadBalancerPoolHealthMonitorTypeTCPPrototype {
    export namespace Constants {
      /** The protocol type to use for health checks. */
      export enum Type {
        TCP = 'tcp',
      }
    }
  }

  /**
   * LoadBalancerPoolHealthMonitorTypeHTTPHTTPS.
   */
  export interface LoadBalancerPoolHealthMonitorTypeHTTPHTTPS extends LoadBalancerPoolHealthMonitor {
    /** The protocol type used for health checks. */
    type: LoadBalancerPoolHealthMonitorTypeHTTPHTTPS.Constants.Type | string;
    /** The health check URL path, in the format of an [origin-form request
     *  target](https://tools.ietf.org/html/rfc7230#section-5.3.1).
     */
    url_path: string;
  }
  export namespace LoadBalancerPoolHealthMonitorTypeHTTPHTTPS {
    export namespace Constants {
      /** The protocol type used for health checks. */
      export enum Type {
        HTTP = 'http',
        HTTPS = 'https',
      }
    }
  }

  /**
   * LoadBalancerPoolHealthMonitorTypeTCP.
   */
  export interface LoadBalancerPoolHealthMonitorTypeTCP extends LoadBalancerPoolHealthMonitor {
    /** The protocol type used for health checks. */
    type: LoadBalancerPoolHealthMonitorTypeTCP.Constants.Type | string;
  }
  export namespace LoadBalancerPoolHealthMonitorTypeTCP {
    export namespace Constants {
      /** The protocol type used for health checks. */
      export enum Type {
        TCP = 'tcp',
      }
    }
  }

  /**
   * LoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref.
   */
  export interface LoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref extends LoadBalancerPoolIdentity {
    /** The URL for this load balancer pool. */
    href: string;
  }

  /**
   * LoadBalancerPoolIdentityLoadBalancerPoolIdentityById.
   */
  export interface LoadBalancerPoolIdentityLoadBalancerPoolIdentityById extends LoadBalancerPoolIdentity {
    /** The unique identifier for this load balancer pool. */
    id: string;
  }

  /**
   * LoadBalancerPoolMemberTargetPrototypeIP.
   */
  export interface LoadBalancerPoolMemberTargetPrototypeIP extends LoadBalancerPoolMemberTargetPrototype {
    /** The IP address.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * Identifies a virtual server instance by a unique property.
   */
  export interface LoadBalancerPoolMemberTargetPrototypeInstanceIdentity extends LoadBalancerPoolMemberTargetPrototype {
  }

  /**
   * Identifies a load balancer by a unique property.
   */
  export interface LoadBalancerPoolMemberTargetPrototypeLoadBalancerIdentity extends LoadBalancerPoolMemberTargetPrototype {
  }

  /**
   * LoadBalancerPoolMemberTargetIP.
   */
  export interface LoadBalancerPoolMemberTargetIP extends LoadBalancerPoolMemberTarget {
    /** The IP address.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * LoadBalancerPoolMemberTargetInstanceReference.
   */
  export interface LoadBalancerPoolMemberTargetInstanceReference extends LoadBalancerPoolMemberTarget {
    /** The CRN for this virtual server instance. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this virtual server instance. */
    href: string;
    /** The unique identifier for this virtual server instance. */
    id: string;
    /** The name for this virtual server instance. The name is unique across all virtual server instances in the
     *  region.
     */
    name: string;
  }

  /**
   * LoadBalancerPoolMemberTargetLoadBalancerReference.
   */
  export interface LoadBalancerPoolMemberTargetLoadBalancerReference extends LoadBalancerPoolMemberTarget {
    /** The CRN for this load balancer. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this load balancer. */
    href: string;
    /** The unique identifier for this load balancer. */
    id: string;
    /** The name for this load balancer. The name is unique across all load balancers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: LoadBalancerPoolMemberTargetLoadBalancerReference.Constants.ResourceType | string;
  }
  export namespace LoadBalancerPoolMemberTargetLoadBalancerReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        LOAD_BALANCER = 'load_balancer',
      }
    }
  }

  /**
   * The availability mode for a load balancer with this profile depends on its configuration.
   */
  export interface LoadBalancerProfileAvailabilityDependent extends LoadBalancerProfileAvailability {
    /** The type for this profile field. */
    type: LoadBalancerProfileAvailabilityDependent.Constants.Type | string;
  }
  export namespace LoadBalancerProfileAvailabilityDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The availability mode for a load balancer with this profile.
   */
  export interface LoadBalancerProfileAvailabilityFixed extends LoadBalancerProfileAvailability {
    /** The type for this profile field. */
    type: LoadBalancerProfileAvailabilityFixed.Constants.Type | string;
    /** The availability of this load balancer:
     *  - `subnet`: remains available if at least one zone that the load balancer's subnets reside
     *    in is available
     *  - `region`: remains available if at least one zone in the region is available.
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    value: LoadBalancerProfileAvailabilityFixed.Constants.Value | string;
  }
  export namespace LoadBalancerProfileAvailabilityFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
      /** The availability of this load balancer: - `subnet`: remains available if at least one zone that the load balancer's subnets reside in is available - `region`: remains available if at least one zone in the region is available. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Value {
        REGION = 'region',
        SUBNET = 'subnet',
      }
    }
  }

  /**
   * The failsafe policy action configuration for a load balancer with this profile depends on its configuration.
   */
  export interface LoadBalancerProfileFailsafePolicyActionsDependent extends LoadBalancerProfileFailsafePolicyActions {
    /** The type for this profile field. */
    type: LoadBalancerProfileFailsafePolicyActionsDependent.Constants.Type | string;
  }
  export namespace LoadBalancerProfileFailsafePolicyActionsDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The failsafe policy action configuration for a load balancer with this profile.
   */
  export interface LoadBalancerProfileFailsafePolicyActionsEnum extends LoadBalancerProfileFailsafePolicyActions {
    /** The default failsafe policy action for this profile. */
    default: LoadBalancerProfileFailsafePolicyActionsEnum.Constants.Default | string;
    /** The type for this profile field. */
    type: LoadBalancerProfileFailsafePolicyActionsEnum.Constants.Type | string;
    /** The supported failsafe policy actions. */
    values: LoadBalancerProfileFailsafePolicyActionsEnum.Constants.Values[] | string[];
  }
  export namespace LoadBalancerProfileFailsafePolicyActionsEnum {
    export namespace Constants {
      /** The default failsafe policy action for this profile. */
      export enum Default {
        BYPASS = 'bypass',
        DROP = 'drop',
        FAIL = 'fail',
        FORWARD = 'forward',
      }
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
      /** The supported failsafe policy actions. */
      export enum Values {
        BYPASS = 'bypass',
        DROP = 'drop',
        FAIL = 'fail',
        FORWARD = 'forward',
      }
    }
  }

  /**
   * LoadBalancerProfileIdentityByHref.
   */
  export interface LoadBalancerProfileIdentityByHref extends LoadBalancerProfileIdentity {
    /** The URL for this load balancer profile. */
    href: string;
  }

  /**
   * LoadBalancerProfileIdentityByName.
   */
  export interface LoadBalancerProfileIdentityByName extends LoadBalancerProfileIdentity {
    /** The globally unique name for this load balancer profile. */
    name: string;
  }

  /**
   * The instance groups support for a load balancer with this profile depends on its configuration.
   */
  export interface LoadBalancerProfileInstanceGroupsSupportedDependent extends LoadBalancerProfileInstanceGroupsSupported {
    /** The type for this profile field. */
    type: LoadBalancerProfileInstanceGroupsSupportedDependent.Constants.Type | string;
  }
  export namespace LoadBalancerProfileInstanceGroupsSupportedDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The instance groups support for a load balancer with this profile.
   */
  export interface LoadBalancerProfileInstanceGroupsSupportedFixed extends LoadBalancerProfileInstanceGroupsSupported {
    /** The type for this profile field. */
    type: LoadBalancerProfileInstanceGroupsSupportedFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: boolean;
  }
  export namespace LoadBalancerProfileInstanceGroupsSupportedFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The [route mode](https://cloud.ibm.com/docs/vpc?topic=vpc-nlb-vnf&interface=ui) support for a load balancer with
   * this profile depends on its configuration.
   */
  export interface LoadBalancerProfileRouteModeSupportedDependent extends LoadBalancerProfileRouteModeSupported {
    /** The type for this profile field. */
    type: LoadBalancerProfileRouteModeSupportedDependent.Constants.Type | string;
  }
  export namespace LoadBalancerProfileRouteModeSupportedDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The [route mode](https://cloud.ibm.com/docs/vpc?topic=vpc-nlb-vnf&interface=ui) support for a load balancer with
   * this profile.
   */
  export interface LoadBalancerProfileRouteModeSupportedFixed extends LoadBalancerProfileRouteModeSupported {
    /** The type for this profile field. */
    type: LoadBalancerProfileRouteModeSupportedFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: boolean;
  }
  export namespace LoadBalancerProfileRouteModeSupportedFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The security group support for a load balancer with this profile depends on its configuration.
   */
  export interface LoadBalancerProfileSecurityGroupsSupportedDependent extends LoadBalancerProfileSecurityGroupsSupported {
    /** The type for this profile field. */
    type: LoadBalancerProfileSecurityGroupsSupportedDependent.Constants.Type | string;
  }
  export namespace LoadBalancerProfileSecurityGroupsSupportedDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The security group support for a load balancer with this profile.
   */
  export interface LoadBalancerProfileSecurityGroupsSupportedFixed extends LoadBalancerProfileSecurityGroupsSupported {
    /** The type for this profile field. */
    type: LoadBalancerProfileSecurityGroupsSupportedFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: boolean;
  }
  export namespace LoadBalancerProfileSecurityGroupsSupportedFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The source IP session persistence support for a load balancer with this profile depends on its configuration.
   */
  export interface LoadBalancerProfileSourceIPSessionPersistenceSupportedDependent extends LoadBalancerProfileSourceIPSessionPersistenceSupported {
    /** The type for this profile field. */
    type: LoadBalancerProfileSourceIPSessionPersistenceSupportedDependent.Constants.Type | string;
  }
  export namespace LoadBalancerProfileSourceIPSessionPersistenceSupportedDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The source IP session persistence support for a load balancer with this profile.
   */
  export interface LoadBalancerProfileSourceIPSessionPersistenceSupportedFixed extends LoadBalancerProfileSourceIPSessionPersistenceSupported {
    /** The type for this profile field. */
    type: LoadBalancerProfileSourceIPSessionPersistenceSupportedFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: boolean;
  }
  export namespace LoadBalancerProfileSourceIPSessionPersistenceSupportedFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The UDP support for a load balancer with this profile depends on its configuration.
   */
  export interface LoadBalancerProfileUDPSupportedDependent extends LoadBalancerProfileUDPSupported {
    /** The type for this profile field. */
    type: LoadBalancerProfileUDPSupportedDependent.Constants.Type | string;
  }
  export namespace LoadBalancerProfileUDPSupportedDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The UDP support for a load balancer with this profile.
   */
  export interface LoadBalancerProfileUDPSupportedFixed extends LoadBalancerProfileUDPSupported {
    /** The type for this profile field. */
    type: LoadBalancerProfileUDPSupportedFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: boolean;
  }
  export namespace LoadBalancerProfileUDPSupportedFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * NetworkACLIdentityByCRN.
   */
  export interface NetworkACLIdentityByCRN extends NetworkACLIdentity {
    /** The CRN for this network ACL. */
    crn: string;
  }

  /**
   * NetworkACLIdentityByHref.
   */
  export interface NetworkACLIdentityByHref extends NetworkACLIdentity {
    /** The URL for this network ACL. */
    href: string;
  }

  /**
   * NetworkACLIdentityById.
   */
  export interface NetworkACLIdentityById extends NetworkACLIdentity {
    /** The unique identifier for this network ACL. */
    id: string;
  }

  /**
   * NetworkACLPrototypeNetworkACLByRules.
   */
  export interface NetworkACLPrototypeNetworkACLByRules extends NetworkACLPrototype {
    /** The prototype objects for rules to create along with this network ACL. If unspecified, no rules will be
     *  created, resulting in no traffic being allowed.
     */
    rules?: NetworkACLRulePrototypeNetworkACLContext[];
  }

  /**
   * NetworkACLPrototypeNetworkACLBySourceNetworkACL.
   */
  export interface NetworkACLPrototypeNetworkACLBySourceNetworkACL extends NetworkACLPrototype {
    /** The network ACL to copy rules from. */
    source_network_acl: NetworkACLIdentity;
  }

  /**
   * NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref.
   */
  export interface NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref extends NetworkACLRuleBeforePatch {
    /** The URL for this network ACL rule. */
    href: string;
  }

  /**
   * NetworkACLRuleBeforePatchNetworkACLRuleIdentityById.
   */
  export interface NetworkACLRuleBeforePatchNetworkACLRuleIdentityById extends NetworkACLRuleBeforePatch {
    /** The unique identifier for this network ACL rule. */
    id: string;
  }

  /**
   * NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref.
   */
  export interface NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref extends NetworkACLRuleBeforePrototype {
    /** The URL for this network ACL rule. */
    href: string;
  }

  /**
   * NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityById.
   */
  export interface NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityById extends NetworkACLRuleBeforePrototype {
    /** The unique identifier for this network ACL rule. */
    id: string;
  }

  /**
   * A rule for ICMP, TCP and UDP traffic.
   */
  export interface NetworkACLRuleItemNetworkACLRuleProtocolAll extends NetworkACLRuleItem {
    /** The name of the network protocol. */
    protocol: NetworkACLRuleItemNetworkACLRuleProtocolAll.Constants.Protocol | string;
  }
  export namespace NetworkACLRuleItemNetworkACLRuleProtocolAll {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ALL = 'all',
      }
    }
  }

  /**
   * A rule for ICMP traffic.
   */
  export interface NetworkACLRuleItemNetworkACLRuleProtocolICMP extends NetworkACLRuleItem {
    /** The ICMP traffic code to match.
     *
     *  If absent, all codes are matched.
     */
    code?: number;
    /** The name of the network protocol. */
    protocol: NetworkACLRuleItemNetworkACLRuleProtocolICMP.Constants.Protocol | string;
    /** The ICMP traffic type to match.
     *
     *  If absent, all types are matched.
     */
    type?: number;
  }
  export namespace NetworkACLRuleItemNetworkACLRuleProtocolICMP {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ICMP = 'icmp',
      }
    }
  }

  /**
   * NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP.
   */
  export interface NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP extends NetworkACLRuleItem {
    /** The inclusive upper bound of the TCP or UDP destination port range. */
    destination_port_max: number;
    /** The inclusive lower bound of the TCP or UDP destination port range. */
    destination_port_min: number;
    /** The name of the network protocol. */
    protocol: NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP.Constants.Protocol | string;
    /** The inclusive upper bound of the TCP or UDP source port range. */
    source_port_max: number;
    /** The inclusive lower bound of the TCP or UDP source port range. */
    source_port_min: number;
  }
  export namespace NetworkACLRuleItemNetworkACLRuleProtocolTCPUDP {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * A rule for ICMP, TCP and UDP traffic.
   */
  export interface NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype extends NetworkACLRulePrototypeNetworkACLContext {
    /** The name of the network protocol. */
    protocol: NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype.Constants.Protocol | string;
  }
  export namespace NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ALL = 'all',
      }
    }
  }

  /**
   * A rule for ICMP traffic.
   */
  export interface NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPPrototype extends NetworkACLRulePrototypeNetworkACLContext {
    /** The ICMP traffic code to match.
     *
     *  If specified, `type` must also be specified.  If unspecified, all codes are matched.
     */
    code?: number;
    /** The name of the network protocol. */
    protocol: NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPPrototype.Constants.Protocol | string;
    /** The ICMP traffic type to match.
     *
     *  If unspecified, all types are matched.
     */
    type?: number;
  }
  export namespace NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolICMPPrototype {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ICMP = 'icmp',
      }
    }
  }

  /**
   * A rule for TCP or UDP traffic.
   */
  export interface NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPPrototype extends NetworkACLRulePrototypeNetworkACLContext {
    /** The inclusive upper bound of the TCP or UDP destination port range.
     *
     *  If specified, `destination_port_min` must also be specified, and must not be larger. If unspecified,
     *  `destination_port_min` must also be unspecified, allowing traffic for all destination ports.
     */
    destination_port_max?: number;
    /** The inclusive lower bound of the TCP or UDP destination port range.
     *
     *  If specified, `destination_port_max` must also be specified, and must not be smaller. If unspecified,
     *  `destination_port_max` must also be unspecified, allowing traffic for all destination ports.
     */
    destination_port_min?: number;
    /** The name of the network protocol. */
    protocol: NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPPrototype.Constants.Protocol | string;
    /** The inclusive upper bound of the TCP or UDP source port range.
     *
     *  If specified, `source_port_min` must also be specified, and must not be larger. If unspecified,
     *  `source_port_min` must also be unspecified, allowing traffic for all source ports.
     */
    source_port_max?: number;
    /** The inclusive lower bound of the TCP or UDP source port range.
     *
     *  If specified, `source_port_max` must also be specified, and must not be smaller. If unspecified,
     *  `source_port_max` must also be unspecified, allowing traffic for all source ports.
     */
    source_port_min?: number;
  }
  export namespace NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTCPUDPPrototype {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * A rule for ICMP, TCP and UDP traffic.
   */
  export interface NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype extends NetworkACLRulePrototype {
    /** The name of the network protocol. */
    protocol: NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype.Constants.Protocol | string;
  }
  export namespace NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ALL = 'all',
      }
    }
  }

  /**
   * A rule for ICMP traffic.
   */
  export interface NetworkACLRulePrototypeNetworkACLRuleProtocolICMPPrototype extends NetworkACLRulePrototype {
    /** The ICMP traffic code to match.
     *
     *  If specified, `type` must also be specified.  If unspecified, all codes are matched.
     */
    code?: number;
    /** The name of the network protocol. */
    protocol: NetworkACLRulePrototypeNetworkACLRuleProtocolICMPPrototype.Constants.Protocol | string;
    /** The ICMP traffic type to match.
     *
     *  If unspecified, all types are matched.
     */
    type?: number;
  }
  export namespace NetworkACLRulePrototypeNetworkACLRuleProtocolICMPPrototype {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ICMP = 'icmp',
      }
    }
  }

  /**
   * A rule for TCP or UDP traffic.
   */
  export interface NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPPrototype extends NetworkACLRulePrototype {
    /** The inclusive upper bound of the TCP or UDP destination port range.
     *
     *  If specified, `destination_port_min` must also be specified, and must not be larger. If unspecified,
     *  `destination_port_min` must also be unspecified, allowing traffic for all destination ports.
     */
    destination_port_max?: number;
    /** The inclusive lower bound of the TCP or UDP destination port range.
     *
     *  If specified, `destination_port_max` must also be specified, and must not be smaller. If unspecified,
     *  `destination_port_max` must also be unspecified, allowing traffic for all destination ports.
     */
    destination_port_min?: number;
    /** The name of the network protocol. */
    protocol: NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPPrototype.Constants.Protocol | string;
    /** The inclusive upper bound of the TCP or UDP source port range.
     *
     *  If specified, `source_port_min` must also be specified, and must not be larger. If unspecified,
     *  `source_port_min` must also be unspecified, allowing traffic for all source ports.
     */
    source_port_max?: number;
    /** The inclusive lower bound of the TCP or UDP source port range.
     *
     *  If specified, `source_port_max` must also be specified, and must not be smaller. If unspecified,
     *  `source_port_max` must also be unspecified, allowing traffic for all source ports.
     */
    source_port_min?: number;
  }
  export namespace NetworkACLRulePrototypeNetworkACLRuleProtocolTCPUDPPrototype {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * A rule for ICMP, TCP and UDP traffic.
   */
  export interface NetworkACLRuleNetworkACLRuleProtocolAll extends NetworkACLRule {
    /** The name of the network protocol. */
    protocol: NetworkACLRuleNetworkACLRuleProtocolAll.Constants.Protocol | string;
  }
  export namespace NetworkACLRuleNetworkACLRuleProtocolAll {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ALL = 'all',
      }
    }
  }

  /**
   * A rule for ICMP traffic.
   */
  export interface NetworkACLRuleNetworkACLRuleProtocolICMP extends NetworkACLRule {
    /** The ICMP traffic code to match.
     *
     *  If absent, all codes are matched.
     */
    code?: number;
    /** The name of the network protocol. */
    protocol: NetworkACLRuleNetworkACLRuleProtocolICMP.Constants.Protocol | string;
    /** The ICMP traffic type to match.
     *
     *  If absent, all types are matched.
     */
    type?: number;
  }
  export namespace NetworkACLRuleNetworkACLRuleProtocolICMP {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ICMP = 'icmp',
      }
    }
  }

  /**
   * NetworkACLRuleNetworkACLRuleProtocolTCPUDP.
   */
  export interface NetworkACLRuleNetworkACLRuleProtocolTCPUDP extends NetworkACLRule {
    /** The inclusive upper bound of the TCP or UDP destination port range. */
    destination_port_max: number;
    /** The inclusive lower bound of the TCP or UDP destination port range. */
    destination_port_min: number;
    /** The name of the network protocol. */
    protocol: NetworkACLRuleNetworkACLRuleProtocolTCPUDP.Constants.Protocol | string;
    /** The inclusive upper bound of the TCP or UDP source port range. */
    source_port_max: number;
    /** The inclusive lower bound of the TCP or UDP source port range. */
    source_port_min: number;
  }
  export namespace NetworkACLRuleNetworkACLRuleProtocolTCPUDP {
    export namespace Constants {
      /** The action to perform for a packet matching the rule. */
      export enum Action {
        ALLOW = 'allow',
        DENY = 'deny',
      }
      /** The direction of traffic to match. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version for this rule. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * Identifies a reserved IP by a unique property.
   */
  export interface NetworkInterfaceIPPrototypeReservedIPIdentity extends NetworkInterfaceIPPrototype {
  }

  /**
   * NetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext.
   */
  export interface NetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext extends NetworkInterfaceIPPrototype {
    /** The IP address to reserve, which must not already be reserved on the subnet.
     *
     *  If unspecified, an available address on the subnet will automatically be selected.
     */
    address?: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound.
     */
    auto_delete?: boolean;
    /** The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /**
   * OperatingSystemIdentityByHref.
   */
  export interface OperatingSystemIdentityByHref extends OperatingSystemIdentity {
    /** The URL for this operating system. */
    href: string;
  }

  /**
   * OperatingSystemIdentityByName.
   */
  export interface OperatingSystemIdentityByName extends OperatingSystemIdentity {
    /** The globally unique name for this operating system. */
    name: string;
  }

  /**
   * Identifies a floating IP by a unique property.
   */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPIdentity extends PublicGatewayFloatingIPPrototype {
  }

  /**
   * PublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext.
   */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext extends PublicGatewayFloatingIPPrototype {
    /** The name for this floating IP. The name must not be used by another floating IP in the region. If
     *  unspecified, the name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
  }

  /**
   * PublicGatewayIdentityPublicGatewayIdentityByCRN.
   */
  export interface PublicGatewayIdentityPublicGatewayIdentityByCRN extends PublicGatewayIdentity {
    /** The CRN for this public gateway. */
    crn: string;
  }

  /**
   * PublicGatewayIdentityPublicGatewayIdentityByHref.
   */
  export interface PublicGatewayIdentityPublicGatewayIdentityByHref extends PublicGatewayIdentity {
    /** The URL for this public gateway. */
    href: string;
  }

  /**
   * PublicGatewayIdentityPublicGatewayIdentityById.
   */
  export interface PublicGatewayIdentityPublicGatewayIdentityById extends PublicGatewayIdentity {
    /** The unique identifier for this public gateway. */
    id: string;
  }

  /**
   * RegionIdentityByHref.
   */
  export interface RegionIdentityByHref extends RegionIdentity {
    /** The URL for this region. */
    href: string;
  }

  /**
   * RegionIdentityByName.
   */
  export interface RegionIdentityByName extends RegionIdentity {
    /** The globally unique name for this region. */
    name: string;
  }

  /**
   * ReservationIdentityByCRN.
   */
  export interface ReservationIdentityByCRN extends ReservationIdentity {
    /** The CRN for this reservation. */
    crn: string;
  }

  /**
   * ReservationIdentityByHref.
   */
  export interface ReservationIdentityByHref extends ReservationIdentity {
    /** The URL for this reservation. */
    href: string;
  }

  /**
   * ReservationIdentityById.
   */
  export interface ReservationIdentityById extends ReservationIdentity {
    /** The unique identifier for this reservation. */
    id: string;
  }

  /**
   * ReservationProfileBareMetalServerProfileReference.
   */
  export interface ReservationProfileBareMetalServerProfileReference extends ReservationProfile {
    /** The URL for this bare metal server profile. */
    href: string;
    /** The name for this bare metal server profile. */
    name: string;
    /** The resource type. */
    resource_type: ReservationProfileBareMetalServerProfileReference.Constants.ResourceType | string;
  }
  export namespace ReservationProfileBareMetalServerProfileReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        BARE_METAL_SERVER_PROFILE = 'bare_metal_server_profile',
      }
    }
  }

  /**
   * ReservationProfileInstanceProfileReference.
   */
  export interface ReservationProfileInstanceProfileReference extends ReservationProfile {
    /** The URL for this virtual server instance profile. */
    href: string;
    /** The globally unique name for this virtual server instance profile. */
    name: string;
    /** The resource type. */
    resource_type: ReservationProfileInstanceProfileReference.Constants.ResourceType | string;
  }
  export namespace ReservationProfileInstanceProfileReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_PROFILE = 'instance_profile',
      }
    }
  }

  /**
   * ReservedIPTargetPrototypeEndpointGatewayIdentity.
   */
  export interface ReservedIPTargetPrototypeEndpointGatewayIdentity extends ReservedIPTargetPrototype {
  }

  /**
   * Identifies a virtual network interface by a unique property.
   */
  export interface ReservedIPTargetPrototypeVirtualNetworkInterfaceIdentity extends ReservedIPTargetPrototype {
  }

  /**
   * ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext.
   */
  export interface ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext extends ReservedIPTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
    /** The unique identifier for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
    /** The name for this bare metal server network interface. */
    name: string;
    /** The resource type. */
    resource_type: ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext.Constants.ResourceType | string;
  }
  export namespace ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
    }
  }

  /**
   * ReservedIPTargetEndpointGatewayReference.
   */
  export interface ReservedIPTargetEndpointGatewayReference extends ReservedIPTarget {
    /** The CRN for this endpoint gateway. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this endpoint gateway. */
    href: string;
    /** The unique identifier for this endpoint gateway. */
    id: string;
    /** The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: ReservedIPTargetEndpointGatewayReference.Constants.ResourceType | string;
  }
  export namespace ReservedIPTargetEndpointGatewayReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        ENDPOINT_GATEWAY = 'endpoint_gateway',
      }
    }
  }

  /**
   * Identifying information for a resource that is not native to the VPC API.
   */
  export interface ReservedIPTargetGenericResourceReference extends ReservedIPTarget {
    /** The CRN for the resource. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The resource type. */
    resource_type: ReservedIPTargetGenericResourceReference.Constants.ResourceType | string;
  }
  export namespace ReservedIPTargetGenericResourceReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        CLOUD_RESOURCE = 'cloud_resource',
      }
    }
  }

  /**
   * ReservedIPTargetLoadBalancerReference.
   */
  export interface ReservedIPTargetLoadBalancerReference extends ReservedIPTarget {
    /** The CRN for this load balancer. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this load balancer. */
    href: string;
    /** The unique identifier for this load balancer. */
    id: string;
    /** The name for this load balancer. The name is unique across all load balancers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: ReservedIPTargetLoadBalancerReference.Constants.ResourceType | string;
  }
  export namespace ReservedIPTargetLoadBalancerReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        LOAD_BALANCER = 'load_balancer',
      }
    }
  }

  /**
   * ReservedIPTargetNetworkInterfaceReferenceTargetContext.
   */
  export interface ReservedIPTargetNetworkInterfaceReferenceTargetContext extends ReservedIPTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
    /** The unique identifier for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
    /** The name for this instance network interface. */
    name: string;
    /** The resource type. */
    resource_type: ReservedIPTargetNetworkInterfaceReferenceTargetContext.Constants.ResourceType | string;
  }
  export namespace ReservedIPTargetNetworkInterfaceReferenceTargetContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
    }
  }

  /**
   * ReservedIPTargetVPNGatewayReference.
   */
  export interface ReservedIPTargetVPNGatewayReference extends ReservedIPTarget {
    /** The CRN for this VPN gateway. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this VPN gateway. */
    href: string;
    /** The unique identifier for this VPN gateway. */
    id: string;
    /** The name for this VPN gateway. The name is unique across all VPN gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: ReservedIPTargetVPNGatewayReference.Constants.ResourceType | string;
  }
  export namespace ReservedIPTargetVPNGatewayReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPN_GATEWAY = 'vpn_gateway',
      }
    }
  }

  /**
   * ReservedIPTargetVPNServerReference.
   */
  export interface ReservedIPTargetVPNServerReference extends ReservedIPTarget {
    /** The CRN for this VPN server. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this VPN server. */
    href: string;
    /** The unique identifier for this VPN server. */
    id: string;
    /** The name for this VPN server. The name is unique across all VPN servers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: ReservedIPTargetVPNServerReference.Constants.ResourceType | string;
  }
  export namespace ReservedIPTargetVPNServerReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPN_SERVER = 'vpn_server',
      }
    }
  }

  /**
   * ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext.
   */
  export interface ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext extends ReservedIPTarget {
    /** The CRN for this virtual network interface. */
    crn: string;
    /** The URL for this virtual network interface. */
    href: string;
    /** The unique identifier for this virtual network interface. */
    id: string;
    /** The name for this virtual network interface. The name is unique across all virtual network interfaces in the
     *  VPC.
     */
    name: string;
    /** The resource type. */
    resource_type: ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext.Constants.ResourceType | string;
  }
  export namespace ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VIRTUAL_NETWORK_INTERFACE = 'virtual_network_interface',
      }
    }
  }

  /**
   * ResourceGroupIdentityById.
   */
  export interface ResourceGroupIdentityById extends ResourceGroupIdentity {
    /** The unique identifier for this resource group. */
    id: string;
  }

  /**
   * RouteCreatorVPNGatewayReference.
   */
  export interface RouteCreatorVPNGatewayReference extends RouteCreator {
    /** The CRN for this VPN gateway. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this VPN gateway. */
    href: string;
    /** The unique identifier for this VPN gateway. */
    id: string;
    /** The name for this VPN gateway. The name is unique across all VPN gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: RouteCreatorVPNGatewayReference.Constants.ResourceType | string;
  }
  export namespace RouteCreatorVPNGatewayReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPN_GATEWAY = 'vpn_gateway',
      }
    }
  }

  /**
   * RouteCreatorVPNServerReference.
   */
  export interface RouteCreatorVPNServerReference extends RouteCreator {
    /** The CRN for this VPN server. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this VPN server. */
    href: string;
    /** The unique identifier for this VPN server. */
    id: string;
    /** The name for this VPN server. The name is unique across all VPN servers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: RouteCreatorVPNServerReference.Constants.ResourceType | string;
  }
  export namespace RouteCreatorVPNServerReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPN_SERVER = 'vpn_server',
      }
    }
  }

  /**
   * RouteNextHopIP.
   */
  export interface RouteNextHopIP extends RouteNextHop {
    /** The IP address.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * RouteNextHopPatchRouteNextHopIP.
   */
  export interface RouteNextHopPatchRouteNextHopIP extends RouteNextHopPatch {
  }

  /**
   * Identifies a VPN gateway connection by a unique property.
   */
  export interface RouteNextHopPatchVPNGatewayConnectionIdentity extends RouteNextHopPatch {
  }

  /**
   * RouteNextHopPrototypeRouteNextHopIP.
   */
  export interface RouteNextHopPrototypeRouteNextHopIP extends RouteNextHopPrototype {
  }

  /**
   * Identifies a VPN gateway connection by a unique property.
   */
  export interface RouteNextHopPrototypeVPNGatewayConnectionIdentity extends RouteNextHopPrototype {
  }

  /**
   * RouteNextHopVPNGatewayConnectionReference.
   */
  export interface RouteNextHopVPNGatewayConnectionReference extends RouteNextHop {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this VPN gateway connection. */
    href: string;
    /** The unique identifier for this VPN gateway connection. */
    id: string;
    /** The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway. */
    name: string;
    /** The resource type. */
    resource_type: RouteNextHopVPNGatewayConnectionReference.Constants.ResourceType | string;
  }
  export namespace RouteNextHopVPNGatewayConnectionReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPN_GATEWAY_CONNECTION = 'vpn_gateway_connection',
      }
    }
  }

  /**
   * RoutingTableIdentityByCRN.
   */
  export interface RoutingTableIdentityByCRN extends RoutingTableIdentity {
    /** The CRN for this VPC routing table. */
    crn: string;
  }

  /**
   * RoutingTableIdentityByHref.
   */
  export interface RoutingTableIdentityByHref extends RoutingTableIdentity {
    /** The URL for this routing table. */
    href: string;
  }

  /**
   * RoutingTableIdentityById.
   */
  export interface RoutingTableIdentityById extends RoutingTableIdentity {
    /** The unique identifier for this routing table. */
    id: string;
  }

  /**
   * SecurityGroupIdentityByCRN.
   */
  export interface SecurityGroupIdentityByCRN extends SecurityGroupIdentity {
    /** The CRN for this security group. */
    crn: string;
  }

  /**
   * SecurityGroupIdentityByHref.
   */
  export interface SecurityGroupIdentityByHref extends SecurityGroupIdentity {
    /** The URL for this security group. */
    href: string;
  }

  /**
   * SecurityGroupIdentityById.
   */
  export interface SecurityGroupIdentityById extends SecurityGroupIdentity {
    /** The unique identifier for this security group. */
    id: string;
  }

  /**
   * SecurityGroupRuleLocalPatchCIDR.
   */
  export interface SecurityGroupRuleLocalPatchCIDR extends SecurityGroupRuleLocalPatch {
    /** The CIDR block.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 address
     *  blocks in the future.
     */
    cidr_block: string;
  }

  /**
   * SecurityGroupRuleLocalPatchIP.
   */
  export interface SecurityGroupRuleLocalPatchIP extends SecurityGroupRuleLocalPatch {
    /** The IP address.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * SecurityGroupRuleLocalPrototypeCIDR.
   */
  export interface SecurityGroupRuleLocalPrototypeCIDR extends SecurityGroupRuleLocalPrototype {
    /** The CIDR block.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 address
     *  blocks in the future.
     */
    cidr_block: string;
  }

  /**
   * SecurityGroupRuleLocalPrototypeIP.
   */
  export interface SecurityGroupRuleLocalPrototypeIP extends SecurityGroupRuleLocalPrototype {
    /** The IP address.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * SecurityGroupRuleLocalCIDR.
   */
  export interface SecurityGroupRuleLocalCIDR extends SecurityGroupRuleLocal {
    /** The CIDR block.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 address
     *  blocks in the future.
     */
    cidr_block: string;
  }

  /**
   * SecurityGroupRuleLocalIP.
   */
  export interface SecurityGroupRuleLocalIP extends SecurityGroupRuleLocal {
    /** The IP address.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * A rule allowing ICMP, TCP and UDP traffic.
   */
  export interface SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll extends SecurityGroupRulePrototype {
    /** The name of the network protocol. */
    protocol: SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll.Constants.Protocol | string;
  }
  export namespace SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll {
    export namespace Constants {
      /** The direction of traffic to allow. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version to allow. The format of `local.address`, `remote.address`, `local.cidr_block` or `remote.cidr_block` must match this property, if they are used. If `remote` references a security group, then this rule only applies to IP addresses in that group matching this IP version. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ALL = 'all',
      }
    }
  }

  /**
   * A rule specifying the ICMP traffic to allow.
   */
  export interface SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP extends SecurityGroupRulePrototype {
    /** The ICMP traffic code to allow.
     *
     *  If specified, `type` must also be specified.  If unspecified, all codes are allowed.
     */
    code?: number;
    /** The name of the network protocol. */
    protocol: SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP.Constants.Protocol | string;
    /** The ICMP traffic type to allow.
     *
     *  If unspecified, all types are allowed.
     */
    type?: number;
  }
  export namespace SecurityGroupRulePrototypeSecurityGroupRuleProtocolICMP {
    export namespace Constants {
      /** The direction of traffic to allow. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version to allow. The format of `local.address`, `remote.address`, `local.cidr_block` or `remote.cidr_block` must match this property, if they are used. If `remote` references a security group, then this rule only applies to IP addresses in that group matching this IP version. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ICMP = 'icmp',
      }
    }
  }

  /**
   * A rule specifying the TCP or UDP traffic to allow.
   */
  export interface SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP extends SecurityGroupRulePrototype {
    /** The inclusive upper bound of the TCP or UDP destination port range.
     *
     *  If specified, `port_min` must also be specified, and must not be larger. If unspecified,
     *  `port_min` must also be unspecified, allowing traffic on all destination ports.
     */
    port_max?: number;
    /** The inclusive lower bound of the TCP or UDP destination port range.
     *
     *  If specified, `port_max` must also be specified, and must not be smaller. If unspecified, `port_max` must also
     *  be unspecified, allowing traffic on all destination ports.
     */
    port_min?: number;
    /** The name of the network protocol. */
    protocol: SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP.Constants.Protocol | string;
  }
  export namespace SecurityGroupRulePrototypeSecurityGroupRuleProtocolTCPUDP {
    export namespace Constants {
      /** The direction of traffic to allow. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version to allow. The format of `local.address`, `remote.address`, `local.cidr_block` or `remote.cidr_block` must match this property, if they are used. If `remote` references a security group, then this rule only applies to IP addresses in that group matching this IP version. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * SecurityGroupRuleRemotePatchCIDR.
   */
  export interface SecurityGroupRuleRemotePatchCIDR extends SecurityGroupRuleRemotePatch {
    /** The CIDR block.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 address
     *  blocks in the future.
     */
    cidr_block: string;
  }

  /**
   * SecurityGroupRuleRemotePatchIP.
   */
  export interface SecurityGroupRuleRemotePatchIP extends SecurityGroupRuleRemotePatch {
    /** The IP address.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * Identifies a security group by a unique property.
   */
  export interface SecurityGroupRuleRemotePatchSecurityGroupIdentity extends SecurityGroupRuleRemotePatch {
  }

  /**
   * SecurityGroupRuleRemotePrototypeCIDR.
   */
  export interface SecurityGroupRuleRemotePrototypeCIDR extends SecurityGroupRuleRemotePrototype {
    /** The CIDR block.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 address
     *  blocks in the future.
     */
    cidr_block: string;
  }

  /**
   * SecurityGroupRuleRemotePrototypeIP.
   */
  export interface SecurityGroupRuleRemotePrototypeIP extends SecurityGroupRuleRemotePrototype {
    /** The IP address.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * Identifies a security group by a unique property.
   */
  export interface SecurityGroupRuleRemotePrototypeSecurityGroupIdentity extends SecurityGroupRuleRemotePrototype {
  }

  /**
   * SecurityGroupRuleRemoteCIDR.
   */
  export interface SecurityGroupRuleRemoteCIDR extends SecurityGroupRuleRemote {
    /** The CIDR block.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 address
     *  blocks in the future.
     */
    cidr_block: string;
  }

  /**
   * SecurityGroupRuleRemoteIP.
   */
  export interface SecurityGroupRuleRemoteIP extends SecurityGroupRuleRemote {
    /** The IP address.
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * SecurityGroupRuleRemoteSecurityGroupReference.
   */
  export interface SecurityGroupRuleRemoteSecurityGroupReference extends SecurityGroupRuleRemote {
    /** The CRN for this security group. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this security group. */
    href: string;
    /** The unique identifier for this security group. */
    id: string;
    /** The name for this security group. The name is unique across all security groups for the VPC. */
    name: string;
  }

  /**
   * A rule allowing ICMP, TCP and UDP traffic.
   */
  export interface SecurityGroupRuleSecurityGroupRuleProtocolAll extends SecurityGroupRule {
    /** The name of the network protocol. */
    protocol: SecurityGroupRuleSecurityGroupRuleProtocolAll.Constants.Protocol | string;
  }
  export namespace SecurityGroupRuleSecurityGroupRuleProtocolAll {
    export namespace Constants {
      /** The direction of traffic to allow. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version to allow. The format of `local.address`, `remote.address`, `local.cidr_block` or `remote.cidr_block` must match this property, if they are used. If `remote` references a security group, then this rule only applies to IP addresses in that group matching this IP version. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ALL = 'all',
      }
    }
  }

  /**
   * A rule specifying the ICMP traffic to allow.
   */
  export interface SecurityGroupRuleSecurityGroupRuleProtocolICMP extends SecurityGroupRule {
    /** The ICMP traffic code to allow. If absent, all codes are allowed. */
    code?: number;
    /** The name of the network protocol. */
    protocol: SecurityGroupRuleSecurityGroupRuleProtocolICMP.Constants.Protocol | string;
    /** The ICMP traffic type to allow. If absent, all types are allowed. */
    type?: number;
  }
  export namespace SecurityGroupRuleSecurityGroupRuleProtocolICMP {
    export namespace Constants {
      /** The direction of traffic to allow. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version to allow. The format of `local.address`, `remote.address`, `local.cidr_block` or `remote.cidr_block` must match this property, if they are used. If `remote` references a security group, then this rule only applies to IP addresses in that group matching this IP version. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        ICMP = 'icmp',
      }
    }
  }

  /**
   * A rule specifying the TCP or UDP traffic to allow.
   *
   * Either both `port_min` and `port_max` will be present, or neither. When neither is present, all destination ports
   * are allowed for the protocol. When both have the same value, that single destination port is allowed.
   */
  export interface SecurityGroupRuleSecurityGroupRuleProtocolTCPUDP extends SecurityGroupRule {
    /** The inclusive upper bound of the TCP or UDP destination port range. */
    port_max?: number;
    /** The inclusive lower bound of the TCP or UDP destination port range. */
    port_min?: number;
    /** The name of the network protocol. */
    protocol: SecurityGroupRuleSecurityGroupRuleProtocolTCPUDP.Constants.Protocol | string;
  }
  export namespace SecurityGroupRuleSecurityGroupRuleProtocolTCPUDP {
    export namespace Constants {
      /** The direction of traffic to allow. */
      export enum Direction {
        INBOUND = 'inbound',
        OUTBOUND = 'outbound',
      }
      /** The IP version to allow. The format of `local.address`, `remote.address`, `local.cidr_block` or `remote.cidr_block` must match this property, if they are used. If `remote` references a security group, then this rule only applies to IP addresses in that group matching this IP version. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
      /** The name of the network protocol. */
      export enum Protocol {
        TCP = 'tcp',
        UDP = 'udp',
      }
    }
  }

  /**
   * SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext.
   */
  export interface SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext extends SecurityGroupTargetReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
    /** The unique identifier for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
    /** The name for this bare metal server network interface. */
    name: string;
    /** The resource type. */
    resource_type: SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext.Constants.ResourceType | string;
  }
  export namespace SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
    }
  }

  /**
   * SecurityGroupTargetReferenceEndpointGatewayReference.
   */
  export interface SecurityGroupTargetReferenceEndpointGatewayReference extends SecurityGroupTargetReference {
    /** The CRN for this endpoint gateway. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this endpoint gateway. */
    href: string;
    /** The unique identifier for this endpoint gateway. */
    id: string;
    /** The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: SecurityGroupTargetReferenceEndpointGatewayReference.Constants.ResourceType | string;
  }
  export namespace SecurityGroupTargetReferenceEndpointGatewayReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        ENDPOINT_GATEWAY = 'endpoint_gateway',
      }
    }
  }

  /**
   * SecurityGroupTargetReferenceLoadBalancerReference.
   */
  export interface SecurityGroupTargetReferenceLoadBalancerReference extends SecurityGroupTargetReference {
    /** The CRN for this load balancer. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this load balancer. */
    href: string;
    /** The unique identifier for this load balancer. */
    id: string;
    /** The name for this load balancer. The name is unique across all load balancers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: SecurityGroupTargetReferenceLoadBalancerReference.Constants.ResourceType | string;
  }
  export namespace SecurityGroupTargetReferenceLoadBalancerReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        LOAD_BALANCER = 'load_balancer',
      }
    }
  }

  /**
   * SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext.
   */
  export interface SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext extends SecurityGroupTargetReference {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
    /** The unique identifier for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
    /** The name for this instance network interface. */
    name: string;
    /** The resource type. */
    resource_type: SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext.Constants.ResourceType | string;
  }
  export namespace SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        NETWORK_INTERFACE = 'network_interface',
      }
    }
  }

  /**
   * SecurityGroupTargetReferenceVPNServerReference.
   */
  export interface SecurityGroupTargetReferenceVPNServerReference extends SecurityGroupTargetReference {
    /** The CRN for this VPN server. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this VPN server. */
    href: string;
    /** The unique identifier for this VPN server. */
    id: string;
    /** The name for this VPN server. The name is unique across all VPN servers in the VPC. */
    name: string;
    /** The resource type. */
    resource_type: SecurityGroupTargetReferenceVPNServerReference.Constants.ResourceType | string;
  }
  export namespace SecurityGroupTargetReferenceVPNServerReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VPN_SERVER = 'vpn_server',
      }
    }
  }

  /**
   * SecurityGroupTargetReferenceVirtualNetworkInterfaceReference.
   */
  export interface SecurityGroupTargetReferenceVirtualNetworkInterfaceReference extends SecurityGroupTargetReference {
    /** The CRN for this virtual network interface. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this virtual network interface. */
    href: string;
    /** The unique identifier for this virtual network interface. */
    id: string;
    /** The name for this virtual network interface. The name is unique across all virtual network interfaces in the
     *  VPC.
     */
    name: string;
    /** The primary IP for this virtual network interface. */
    primary_ip: ReservedIPReference;
    /** The resource type. */
    resource_type: SecurityGroupTargetReferenceVirtualNetworkInterfaceReference.Constants.ResourceType | string;
    /** The associated subnet. */
    subnet: SubnetReference;
  }
  export namespace SecurityGroupTargetReferenceVirtualNetworkInterfaceReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        VIRTUAL_NETWORK_INTERFACE = 'virtual_network_interface',
      }
    }
  }

  /**
   * ShareAccessorBindingAccessorShareReference.
   */
  export interface ShareAccessorBindingAccessorShareReference extends ShareAccessorBindingAccessor {
    /** The CRN for this file share. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this file share. */
    href: string;
    /** The unique identifier for this file share. */
    id: string;
    /** The name for this share. The name is unique across all shares in the region. */
    name: string;
    /** If present, this property indicates that the resource associated with this reference
     *  is remote and therefore may not be directly retrievable.
     */
    remote?: ShareRemote;
    /** The resource type. */
    resource_type: ShareAccessorBindingAccessorShareReference.Constants.ResourceType | string;
  }
  export namespace ShareAccessorBindingAccessorShareReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SHARE = 'share',
      }
    }
  }

  /**
   * ShareAccessorBindingAccessorWatsonxMachineLearningReference.
   */
  export interface ShareAccessorBindingAccessorWatsonxMachineLearningReference extends ShareAccessorBindingAccessor {
    /** The CRN for the watsonx machine learning resource. */
    crn: string;
    /** The resource type. */
    resource_type: ShareAccessorBindingAccessorWatsonxMachineLearningReference.Constants.ResourceType | string;
  }
  export namespace ShareAccessorBindingAccessorWatsonxMachineLearningReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        WATSONX_MACHINE_LEARNING = 'watsonx_machine_learning',
      }
    }
  }

  /**
   * ShareIdentityByCRN.
   */
  export interface ShareIdentityByCRN extends ShareIdentity {
    /** The CRN for this file share. */
    crn: string;
  }

  /**
   * ShareIdentityByHref.
   */
  export interface ShareIdentityByHref extends ShareIdentity {
    /** The URL for this file share. */
    href: string;
  }

  /**
   * ShareIdentityById.
   */
  export interface ShareIdentityById extends ShareIdentity {
    /** The unique identifier for this file share. */
    id: string;
  }

  /**
   * The virtual network interface for this share mount target. The virtual network interface must:
   *
   * - have `allow_ip_spoofing` set to `false`
   * - have `enable_infrastructure_nat` set to `true`
   * - have `protocol_state_filtering_mode` set to `auto` or `enabled`
   * - not be in the same VPC as an existing mount target for this share
   * - not have `ips` other than the `primary_ip` address
   *
   * If an existing virtual network interface is specified, it must not have a floating IP bound to it, and it must not
   * be the target of a flow log collector.
   *
   * Required if the share's `access_control_mode` is `security_group`.
   */
  export interface ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup extends ShareMountTargetPrototype {
    virtual_network_interface: ShareMountTargetVirtualNetworkInterfacePrototype;
  }
  export namespace ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup {
    export namespace Constants {
      /** The transit encryption mode to use for this share mount target: - `none`: Not encrypted in transit. - `user_managed`: Encrypted in transit using an instance identity certificate.  The `access_control_mode` for the share must be `security_group`. The specified value must be listed in the share's `allowed_transit_encryption_modes`. */
      export enum TransitEncryption {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
    }
  }

  /**
   * The VPC in which clients can mount the file share using this mount target.  The VPC must not be used by another
   * mount target for this share.
   *
   * Required if the share's `access_control_mode` is `vpc`.
   */
  export interface ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC extends ShareMountTargetPrototype {
    /** Identifies a VPC by a unique property. */
    vpc: VPCIdentity;
  }
  export namespace ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC {
    export namespace Constants {
      /** The transit encryption mode to use for this share mount target: - `none`: Not encrypted in transit. - `user_managed`: Encrypted in transit using an instance identity certificate.  The `access_control_mode` for the share must be `security_group`. The specified value must be listed in the share's `allowed_transit_encryption_modes`. */
      export enum TransitEncryption {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
    }
  }

  /**
   * Identifies a virtual network interface by a unique property.
   */
  export interface ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfaceIdentity extends ShareMountTargetVirtualNetworkInterfacePrototype {
  }

  /**
   * The virtual network interface for this target.
   */
  export interface ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext extends ShareMountTargetVirtualNetworkInterfacePrototype {
    /** Indicates whether source IP spoofing is allowed on this interface. If `false`, source IP spoofing is
     *  prevented on this interface. If `true`, source IP spoofing is allowed on this interface.
     */
    allow_ip_spoofing?: boolean;
    /** Indicates whether this virtual network interface will be automatically deleted when `target` is deleted. */
    auto_delete?: boolean;
    /** If `true`:
     *  - The VPC infrastructure performs any needed NAT operations.
     *  - `floating_ips` must not have more than one floating IP.
     *
     *  If `false`:
     *  - Packets are passed unchanged to/from the virtual network interface,
     *    allowing the workload to perform any needed NAT operations.
     *  - `allow_ip_spoofing` must be `false`.
     *  - Can only be attached to a `target` with a `resource_type` of
     *    `bare_metal_server_network_attachment`.
     */
    enable_infrastructure_nat?: boolean;
    /** Additional IP addresses to bind to the virtual network interface. Each item may be either a reserved IP
     *  identity, or a reserved IP prototype object which will be used to create a new reserved IP. All IP addresses
     *  must be in the primary IP's subnet.
     *
     *  If reserved IP identities are provided, the specified reserved IPs must be unbound.
     *
     *  If reserved IP prototype objects with addresses are provided, the addresses must be available on the virtual
     *  network interface's subnet. For any prototype objects that do not specify an address, an available address on
     *  the subnet will be automatically selected and reserved.
     */
    ips?: VirtualNetworkInterfaceIPPrototype[];
    /** The name for this virtual network interface. The name must not be used by another virtual network interface
     *  in the VPC. If unspecified, the name will be a hyphenated list of randomly-selected words. Names beginning with
     *  `ibm-` are reserved for provider-owned resources, and are not allowed.
     */
    name?: string;
    /** The primary IP address to bind to the virtual network interface. May be either a
     *  reserved IP identity, or a reserved IP prototype object which will be used to create a
     *  new reserved IP.
     *
     *  If a reserved IP identity is provided, the specified reserved IP must be unbound.
     *
     *  If a reserved IP prototype object with an address is provided, the address must be
     *  available on the virtual network interface's subnet. If no address is specified,
     *  an available address on the subnet will be automatically selected and reserved.
     */
    primary_ip?: VirtualNetworkInterfacePrimaryIPPrototype;
    /** The protocol state filtering mode to use for this virtual network interface. If
     *  `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target`
     *  resource type:
     *
     *  - `bare_metal_server_network_attachment`: disabled
     *  - `instance_network_attachment`: enabled
     *  - `share_mount_target`: enabled
     *
     *  Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops
     *  any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering
     *  mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information.
     */
    protocol_state_filtering_mode?: ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext.Constants.ProtocolStateFilteringMode | string;
    /** The resource group to use for this virtual network interface. If unspecified, the
     *  share's resource group will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The security groups to use for this virtual network interface. If unspecified, the default security group of
     *  the VPC for the subnet is used.
     */
    security_groups?: SecurityGroupIdentity[];
    /** The associated subnet. Required if `primary_ip` does not specify a reserved IP identity. */
    subnet?: SubnetIdentity;
  }
  export namespace ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext {
    export namespace Constants {
      /** The protocol state filtering mode to use for this virtual network interface. If `auto`, protocol state packet filtering is enabled or disabled based on the virtual network interface's `target` resource type: - `bare_metal_server_network_attachment`: disabled - `instance_network_attachment`: enabled - `share_mount_target`: enabled Protocol state filtering monitors each network connection flowing over this virtual network interface, and drops any packets that are invalid based on the current connection state and protocol. See [Protocol state filtering mode](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#protocol-state-filtering) for more information. */
      export enum ProtocolStateFilteringMode {
        AUTO = 'auto',
        ENABLED = 'enabled',
      }
    }
  }

  /**
   * The permitted total capacity (in gigabytes) of a share with this profile depends on its configuration.
   */
  export interface ShareProfileCapacityDependentRange extends ShareProfileCapacity {
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: ShareProfileCapacityDependentRange.Constants.Type | string;
  }
  export namespace ShareProfileCapacityDependentRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT_RANGE = 'dependent_range',
      }
    }
  }

  /**
   * The permitted total capacities (in gigabytes) of a share with this profile.
   */
  export interface ShareProfileCapacityEnum extends ShareProfileCapacity {
    /** The type for this profile field. */
    type: ShareProfileCapacityEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace ShareProfileCapacityEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The permitted total capacity (in gigabytes) of a share with this profile is fixed.
   */
  export interface ShareProfileCapacityFixed extends ShareProfileCapacity {
    /** The type for this profile field. */
    type: ShareProfileCapacityFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace ShareProfileCapacityFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted total capacity range (in gigabytes) of a share with this profile.
   */
  export interface ShareProfileCapacityRange extends ShareProfileCapacity {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: ShareProfileCapacityRange.Constants.Type | string;
  }
  export namespace ShareProfileCapacityRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The permitted IOPS for a share with this profile depends on its configuration.
   */
  export interface ShareProfileIOPSDependent extends ShareProfileIOPS {
    /** The type for this profile field. */
    type: ShareProfileIOPSDependent.Constants.Type | string;
  }
  export namespace ShareProfileIOPSDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The permitted IOPS range of a share with this profile depends on its configuration.
   */
  export interface ShareProfileIOPSDependentRange extends ShareProfileIOPS {
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: ShareProfileIOPSDependentRange.Constants.Type | string;
  }
  export namespace ShareProfileIOPSDependentRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT_RANGE = 'dependent_range',
      }
    }
  }

  /**
   * The permitted IOPS values of a share with this profile.
   */
  export interface ShareProfileIOPSEnum extends ShareProfileIOPS {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: ShareProfileIOPSEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace ShareProfileIOPSEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The permitted IOPS of a share with this profile is fixed.
   */
  export interface ShareProfileIOPSFixed extends ShareProfileIOPS {
    /** The type for this profile field. */
    type: ShareProfileIOPSFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace ShareProfileIOPSFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted IOPS range of a share with this profile.
   */
  export interface ShareProfileIOPSRange extends ShareProfileIOPS {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: ShareProfileIOPSRange.Constants.Type | string;
  }
  export namespace ShareProfileIOPSRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * ShareProfileIdentityByHref.
   */
  export interface ShareProfileIdentityByHref extends ShareProfileIdentity {
    /** The URL for this share profile. */
    href: string;
  }

  /**
   * ShareProfileIdentityByName.
   */
  export interface ShareProfileIdentityByName extends ShareProfileIdentity {
    /** The globally unique name for this share profile. */
    name: string;
  }

  /**
   * Create an accessor file share for an existing file share. The values for
   * `access_control_mode`, `encryption_key`, `initial_owner`, `iops`, `profile`, `size`, and
   * `zone` will be inherited from `origin_share`.
   */
  export interface SharePrototypeShareByOriginShare extends SharePrototype {
    /** The origin share for the accessor share. The origin share must have an
     *  `access_control_mode` of `security_group`, and must not have an
     *  `accessor_binding_role` of `accessor`.
     *
     *  The specified share may be in a different account, subject to IAM policies.
     */
    origin_share: ShareIdentity;
  }
  export namespace SharePrototypeShareByOriginShare {
    export namespace Constants {
      /** The transit encryption modes to allow for this share. If unspecified: - If share mount targets are specified, and those share mount targets all specify a `transit_encryption` of `user_managed`, then only `user_managed` will be allowed. - Otherwise, all `transit_encryption` modes will be allowed. */
      export enum AllowedTransitEncryptionModes {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
    }
  }

  /**
   * Create a file share by size.
   */
  export interface SharePrototypeShareBySize extends SharePrototype {
    /** The access control mode for the share:
     *
     *  - `security_group`: The security groups on the virtual network interface for a
     *    mount target control access to the mount target. Mount targets for this share
     *    require a virtual network interface.
     *  - `vpc`: All clients in the VPC for a mount target have access to the mount target.
     *    Mount targets for this share require a VPC.
     */
    access_control_mode?: SharePrototypeShareBySize.Constants.AccessControlMode | string;
    /** The root key to use to wrap the data encryption key for the share.
     *
     *  If unspecified, the `encryption` type for the share will be `provider_managed`.
     *
     *  The specified key may be in a different account, subject to IAM policies.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The owner assigned to the file share at creation. Subsequent changes to the owner
     *  must be performed by a client that has mounted the file share.
     */
    initial_owner?: ShareInitialOwner;
    /** The maximum input/output operations per second (IOPS) for the file share.
     *
     *  If the share profile has an `iops.type` of `dependent` or `fixed`, this property is system-managed and must not
     *  be specified. Otherwise, the specified value must be within the `iops` range of the share profile as supported
     *  by the share's specified size.
     */
    iops?: number;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) to use
     *  for this file share. The profile must support the share's specified IOPS and size.
     */
    profile: ShareProfileIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The size of the file share (in gigabytes), excluding share snapshots.
     *
     *  The specified value must be within the permitted `capacity` range of the share's profile and supported by the
     *  share's specified IOPS.
     *
     *  The maximum size for a share may increase in the future.
     */
    size: number;
    /** The zone this file share will reside in. For a replica share in the same region as
     *  the source share, this must be a different zone from the source share.
     */
    zone: ZoneIdentity;
  }
  export namespace SharePrototypeShareBySize {
    export namespace Constants {
      /** The transit encryption modes to allow for this share. If unspecified: - If share mount targets are specified, and those share mount targets all specify a `transit_encryption` of `user_managed`, then only `user_managed` will be allowed. - Otherwise, all `transit_encryption` modes will be allowed. */
      export enum AllowedTransitEncryptionModes {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
      /** The access control mode for the share: - `security_group`: The security groups on the virtual network interface for a mount target control access to the mount target. Mount targets for this share require a virtual network interface. - `vpc`: All clients in the VPC for a mount target have access to the mount target. Mount targets for this share require a VPC. */
      export enum AccessControlMode {
        SECURITY_GROUP = 'security_group',
        VPC = 'vpc',
      }
    }
  }

  /**
   * Create a replica file share for an existing file share. The values for
   * `access_control_mode`, `encryption_key`, `initial_owner`, and `size` will be inherited from `source_share`.
   */
  export interface SharePrototypeShareBySourceShare extends SharePrototype {
    /** The root key to use to wrap the data encryption key for the share.
     *
     *  This property must be specified if the `source_share` is in a different region and has
     *  an `encryption` type of `user_managed`, and must not be specified otherwise (its value
     *  will be inherited from `source_share`).
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The maximum input/output operations per second (IOPS) for the file share.
     *
     *  If the share profile has an `iops.type` of `dependent` or `fixed`, this property is system-managed and must not
     *  be specified. Otherwise, the specified value must be within the `iops` range of the share profile as supported
     *  by the share's specified size.
     */
    iops?: number;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) to use
     *  for this file share. The profile must support the share's specified IOPS and size.
     */
    profile: ShareProfileIdentity;
    /** The cron specification for the file share replication schedule.
     *
     *  Replication of a share can be scheduled to occur at most once every 15 minutes.
     *
     *  The scheduling frequency for this property may
     *  [increase](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    replication_cron_spec: string;
    /** The resource group to use. If unspecified, the resource group from the source share will be used. */
    resource_group?: ResourceGroupIdentity;
    /** The source file share for this replica file share. The specified file share must not
     *  already have a replica, and must not be a replica. If source file share is specified
     *  by CRN, it may be in an [associated partner
     *  region](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-replication).
     */
    source_share: ShareIdentity;
    /** The zone this file share will reside in. For a replica share in the same region as
     *  the source share, this must be a different zone from the source share.
     */
    zone: ZoneIdentity;
  }
  export namespace SharePrototypeShareBySourceShare {
    export namespace Constants {
      /** The transit encryption modes to allow for this share. If unspecified: - If share mount targets are specified, and those share mount targets all specify a `transit_encryption` of `user_managed`, then only `user_managed` will be allowed. - Otherwise, all `transit_encryption` modes will be allowed. */
      export enum AllowedTransitEncryptionModes {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
    }
  }

  /**
   * Create a file share from a source snapshot. The initial value for `access_control_mode`, and the zone the file
   * share resides in will be inherited from `source_snapshot`.
   */
  export interface SharePrototypeShareBySourceSnapshot extends SharePrototype {
    /** The root key to use to wrap the data encryption key for the share.
     *
     *  The specified key may be in a different account, subject to IAM policies.
     *
     *  If unspecified, the source snapshot's `encryption_key` will be used.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The owner assigned to the file share at creation. Subsequent changes to the owner
     *  must be performed by a client that has mounted the file share.
     */
    initial_owner?: ShareInitialOwner;
    /** The maximum input/output operations per second (IOPS) for the file share.
     *
     *  If the share profile has an `iops.type` of `dependent` or `fixed`, this property is system-managed and must not
     *  be specified. Otherwise, the specified value must be within the `iops` range of the share profile as supported
     *  by the share's specified size.
     */
    iops?: number;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) to use
     *  for this file share. The profile must support the share's specified IOPS and size.
     */
    profile: ShareProfileIdentity;
    /** The resource group to use. If unspecified, the account's [default resource
     *  group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
     */
    resource_group?: ResourceGroupIdentity;
    /** The size to use for the file share (in gigabytes). The specified value must be at least the snapshot's
     *  `minimum_size`, and must be within the `size` range of the share's profile.
     *
     *  If unspecified, the source snapshot's `minimum_size` will be used.
     */
    size?: number;
    /** The source snapshot for this file share.
     *
     *  This file share will reside in the same zone as the specified source snapshot.
     *  The snapshot must have the `lifecycle_state` as `stable` and `status` as `available`
     *  to be able to restore a share for it.
     */
    source_snapshot: ShareSourceSnapshotPrototype;
  }
  export namespace SharePrototypeShareBySourceSnapshot {
    export namespace Constants {
      /** The transit encryption modes to allow for this share. If unspecified: - If share mount targets are specified, and those share mount targets all specify a `transit_encryption` of `user_managed`, then only `user_managed` will be allowed. - Otherwise, all `transit_encryption` modes will be allowed. */
      export enum AllowedTransitEncryptionModes {
        NONE = 'none',
        USER_MANAGED = 'user_managed',
      }
    }
  }

  /**
   * Identifies a share snapshot by a unique property.
   */
  export interface ShareSourceSnapshotPrototypeShareSnapshotIdentity extends ShareSourceSnapshotPrototype {
  }

  /**
   * ShareSourceSnapshotShareSnapshotReference.
   */
  export interface ShareSourceSnapshotShareSnapshotReference extends ShareSourceSnapshot {
    /** The CRN for this share snapshot. */
    crn: string;
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this share snapshot. */
    href: string;
    /** The unique identifier for this share snapshot. */
    id: string;
    /** The name for this share snapshot. The name is unique across all snapshots for the file share. */
    name: string;
    /** The resource type. */
    resource_type: ShareSourceSnapshotShareSnapshotReference.Constants.ResourceType | string;
  }
  export namespace ShareSourceSnapshotShareSnapshotReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SHARE_SNAPSHOT = 'share_snapshot',
      }
    }
  }

  /**
   * SnapshotConsistencyGroupPrototypeSnapshotConsistencyGroupBySnapshots.
   */
  export interface SnapshotConsistencyGroupPrototypeSnapshotConsistencyGroupBySnapshots extends SnapshotConsistencyGroupPrototype {
    /** The data-consistent member snapshots to create.  All snapshots must specify a
     *  `source_volume` attached to the same virtual server instance.
     */
    snapshots: SnapshotPrototypeSnapshotConsistencyGroupContext[];
  }

  /**
   * SnapshotIdentityByCRN.
   */
  export interface SnapshotIdentityByCRN extends SnapshotIdentity {
    /** The CRN of this snapshot. */
    crn: string;
  }

  /**
   * SnapshotIdentityByHref.
   */
  export interface SnapshotIdentityByHref extends SnapshotIdentity {
    /** The URL for this snapshot. */
    href: string;
  }

  /**
   * SnapshotIdentityById.
   */
  export interface SnapshotIdentityById extends SnapshotIdentity {
    /** The unique identifier for this snapshot. */
    id: string;
  }

  /**
   * SnapshotPrototypeSnapshotBySourceSnapshot.
   */
  export interface SnapshotPrototypeSnapshotBySourceSnapshot extends SnapshotPrototype {
    /** The root key to use to wrap the data encryption key for this snapshot.
     *
     *  A key must be specified if and only if the source snapshot has an `encryption` type of
     *  `user_managed`. To maximize snapshot availability and sharing of snapshot data, specify
     *  a key in the same region as the new snapshot, and use the same encryption key for all
     *  snapshots using the same source volume.
     *
     *  The specified key may be in a different account, subject to IAM policies.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The source snapshot (in another region) to create this snapshot from.
     *  The specified snapshot must not already be the source of another snapshot in this
     *  region.
     */
    source_snapshot: SnapshotIdentityByCRN;
  }

  /**
   * SnapshotPrototypeSnapshotBySourceVolume.
   */
  export interface SnapshotPrototypeSnapshotBySourceVolume extends SnapshotPrototype {
    /** The volume to create this snapshot from. */
    source_volume: VolumeIdentity;
  }

  /**
   * SubnetIdentityByCRN.
   */
  export interface SubnetIdentityByCRN extends SubnetIdentity {
    /** The CRN for this subnet. */
    crn: string;
  }

  /**
   * SubnetIdentityByHref.
   */
  export interface SubnetIdentityByHref extends SubnetIdentity {
    /** The URL for this subnet. */
    href: string;
  }

  /**
   * SubnetIdentityById.
   */
  export interface SubnetIdentityById extends SubnetIdentity {
    /** The unique identifier for this subnet. */
    id: string;
  }

  /**
   * SubnetPrototypeSubnetByCIDR.
   */
  export interface SubnetPrototypeSubnetByCIDR extends SubnetPrototype {
    /** The IPv4 range of the subnet, expressed in CIDR format. The prefix length of the subnet's CIDR must be
     *  between `/9` (8,388,608 addresses) and `/29` (8 addresses). The IPv4 range of the subnet's CIDR must fall within
     *  an existing address prefix in the VPC and must not overlap with any existing subnet. The subnet will be created
     *  in the zone of the address prefix that contains the IPv4 CIDR. If zone is specified, it must match the zone of
     *  the address prefix that contains the subnet's IPv4 CIDR.
     */
    ipv4_cidr_block: string;
    /** The zone this subnet will reside in. */
    zone?: ZoneIdentity;
  }
  export namespace SubnetPrototypeSubnetByCIDR {
    export namespace Constants {
      /** The IP version(s) to support for this subnet. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
    }
  }

  /**
   * SubnetPrototypeSubnetByTotalCount.
   */
  export interface SubnetPrototypeSubnetByTotalCount extends SubnetPrototype {
    /** The total number of IPv4 addresses required. Must be a power of 2. The VPC must have a default address
     *  prefix in the specified zone, and that prefix must have a free CIDR range with at least this number of
     *  addresses.
     */
    total_ipv4_address_count: number;
    /** The zone this subnet will reside in. */
    zone: ZoneIdentity;
  }
  export namespace SubnetPrototypeSubnetByTotalCount {
    export namespace Constants {
      /** The IP version(s) to support for this subnet. */
      export enum IpVersion {
        IPV4 = 'ipv4',
      }
    }
  }

  /**
   * SubnetPublicGatewayPatchPublicGatewayIdentityByCRN.
   */
  export interface SubnetPublicGatewayPatchPublicGatewayIdentityByCRN extends SubnetPublicGatewayPatch {
    /** The CRN for this public gateway. */
    crn: string;
  }

  /**
   * SubnetPublicGatewayPatchPublicGatewayIdentityByHref.
   */
  export interface SubnetPublicGatewayPatchPublicGatewayIdentityByHref extends SubnetPublicGatewayPatch {
    /** The URL for this public gateway. */
    href: string;
  }

  /**
   * SubnetPublicGatewayPatchPublicGatewayIdentityById.
   */
  export interface SubnetPublicGatewayPatchPublicGatewayIdentityById extends SubnetPublicGatewayPatch {
    /** The unique identifier for this public gateway. */
    id: string;
  }

  /**
   * TrustedProfileIdentityByCRN.
   */
  export interface TrustedProfileIdentityByCRN extends TrustedProfileIdentity {
    /** The CRN for this trusted profile. */
    crn: string;
  }

  /**
   * TrustedProfileIdentityById.
   */
  export interface TrustedProfileIdentityById extends TrustedProfileIdentity {
    /** The unique identifier for this trusted profile. */
    id: string;
  }

  /**
   * Manually specify the DNS server addresses for this VPC.
   */
  export interface VPCDNSResolverPrototypeVPCDNSResolverTypeManualPrototype extends VPCDNSResolverPrototype {
    /** The DNS servers to use for this VPC. All the DNS servers must either:
     *
     *  - have a unique `zone_affinity`, or
     *  - not have a `zone_affinity`.
     *
     *  If `zone_affinity` is specified, exactly one DNS server must be specified for each zone in the region. The DHCP
     *  [Domain Name Server Option](https://datatracker.ietf.org/doc/html/rfc2132#section-3.8) for a zone will list this
     *  DNS server first, followed by unique DNS servers from other zones if available.
     *
     *  If `zone_affinity` is not specified, the DHCP [Domain Name Server
     *  Option](https://datatracker.ietf.org/doc/html/rfc2132#section-3.8) for each zone will list all the manual DNS
     *  servers in the order specified.
     */
    manual_servers: DNSServerPrototype[];
    /** The type of the DNS resolver to use. */
    type: VPCDNSResolverPrototypeVPCDNSResolverTypeManualPrototype.Constants.Type | string;
  }
  export namespace VPCDNSResolverPrototypeVPCDNSResolverTypeManualPrototype {
    export namespace Constants {
      /** The type of the DNS resolver to use. */
      export enum Type {
        MANUAL = 'manual',
      }
    }
  }

  /**
   * The system will provide DNS server addresses for this VPC. The system-provided DNS server addresses depend on
   * whether any endpoint gateways reside in the VPC, and whether a
   * [DNS Services](https://cloud.ibm.com/docs/dns-svcs) instance is configured for the VPC.
   */
  export interface VPCDNSResolverPrototypeVPCDNSResolverTypeSystemPrototype extends VPCDNSResolverPrototype {
    /** The type of the DNS resolver to use. */
    type?: VPCDNSResolverPrototypeVPCDNSResolverTypeSystemPrototype.Constants.Type | string;
  }
  export namespace VPCDNSResolverPrototypeVPCDNSResolverTypeSystemPrototype {
    export namespace Constants {
      /** The type of the DNS resolver to use. */
      export enum Type {
        SYSTEM = 'system',
      }
    }
  }

  /**
   * The DNS server addresses are delegated to the DNS resolver of another VPC.
   */
  export interface VPCDNSResolverTypeDelegated extends VPCDNSResolver {
    /** The type of the DNS resolver used for the VPC. */
    type: VPCDNSResolverTypeDelegated.Constants.Type | string;
    /** The VPC whose DNS resolver provides the DNS server addresses for this VPC.
     *
     *  The VPC may be remote and therefore may not be directly retrievable.
     */
    vpc: VPCReferenceDNSResolverContext;
  }
  export namespace VPCDNSResolverTypeDelegated {
    export namespace Constants {
      /** The type of the DNS resolver used for the VPC. */
      export enum Type {
        DELEGATED = 'delegated',
      }
    }
  }

  /**
   * The DNS server addresses are manually specified.
   */
  export interface VPCDNSResolverTypeManual extends VPCDNSResolver {
    /** The manually specified DNS servers for this VPC.
     *
     *  If the DNS servers have `zone_affinity`, the DHCP [Domain Name Server
     *  Option](https://datatracker.ietf.org/doc/html/rfc2132#section-3.8) for a zone will list the DNS server with the
     *  affinity for that zone first, followed by the unique DNS servers from other zones.
     *
     *  If the DNS servers do not have `zone_affinity`, the DHCP [Domain Name Server
     *  Option](https://datatracker.ietf.org/doc/html/rfc2132#section-3.8) for each zone will list all the manual DNS
     *  servers in the order specified.
     *
     *  The maximum number of manual DNS servers is expected to
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    manual_servers: DNSServer[];
    /** The type of the DNS resolver used for the VPC. */
    type: VPCDNSResolverTypeManual.Constants.Type | string;
  }
  export namespace VPCDNSResolverTypeManual {
    export namespace Constants {
      /** The type of the DNS resolver used for the VPC. */
      export enum Type {
        MANUAL = 'manual',
      }
    }
  }

  /**
   * The DNS server addresses are provided by the system and depend on the configuration.
   */
  export interface VPCDNSResolverTypeSystem extends VPCDNSResolver {
    /** The configuration of the system DNS resolver for this VPC.
     *
     *  - `custom_resolver`: A custom DNS resolver is configured for this VPC.
     *
     *  - `private_resolver`: A private DNS resolver is configured for this VPC. Applies when
     *    the VPC has either or both of the following:
     *
     *      - at least one endpoint gateway residing in it
     *      - a [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it
     *
     *  - `default`: The provider default DNS resolvers are configured for this VPC.
     *
     *    This system DNS resolver configuration is used when the VPC has:
     *
     *    - no custom DNS resolver configured for it, and
     *    - no endpoint gateways residing in it, and
     *    - no [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it.
     */
    configuration: VPCDNSResolverTypeSystem.Constants.Configuration | string;
    /** The type of the DNS resolver used for the VPC. */
    type: VPCDNSResolverTypeSystem.Constants.Type | string;
  }
  export namespace VPCDNSResolverTypeSystem {
    export namespace Constants {
      /** The configuration of the system DNS resolver for this VPC. - `custom_resolver`: A custom DNS resolver is configured for this VPC. - `private_resolver`: A private DNS resolver is configured for this VPC. Applies when the VPC has either or both of the following: - at least one endpoint gateway residing in it - a [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it - `default`: The provider default DNS resolvers are configured for this VPC. This system DNS resolver configuration is used when the VPC has: - no custom DNS resolver configured for it, and - no endpoint gateways residing in it, and - no [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it. */
      export enum Configuration {
        CUSTOM_RESOLVER = 'custom_resolver',
        DEFAULT = 'default',
        PRIVATE_RESOLVER = 'private_resolver',
      }
      /** The type of the DNS resolver used for the VPC. */
      export enum Type {
        SYSTEM = 'system',
      }
    }
  }

  /**
   * VPCDNSResolverVPCPatchVPCIdentityByCRN.
   */
  export interface VPCDNSResolverVPCPatchVPCIdentityByCRN extends VPCDNSResolverVPCPatch {
    /** The CRN for this VPC. */
    crn: string;
  }

  /**
   * VPCDNSResolverVPCPatchVPCIdentityByHref.
   */
  export interface VPCDNSResolverVPCPatchVPCIdentityByHref extends VPCDNSResolverVPCPatch {
    /** The URL for this VPC. */
    href: string;
  }

  /**
   * VPCDNSResolverVPCPatchVPCIdentityById.
   */
  export interface VPCDNSResolverVPCPatchVPCIdentityById extends VPCDNSResolverVPCPatch {
    /** The unique identifier for this VPC. */
    id: string;
  }

  /**
   * VPCIdentityByCRN.
   */
  export interface VPCIdentityByCRN extends VPCIdentity {
    /** The CRN for this VPC. */
    crn: string;
  }

  /**
   * VPCIdentityByHref.
   */
  export interface VPCIdentityByHref extends VPCIdentity {
    /** The URL for this VPC. */
    href: string;
  }

  /**
   * VPCIdentityById.
   */
  export interface VPCIdentityById extends VPCIdentity {
    /** The unique identifier for this VPC. */
    id: string;
  }

  /**
   * VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityFQDN.
   */
  export interface VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityFQDN extends VPNGatewayConnectionIKEIdentityPrototype {
    /** The IKE identity FQDN value. */
    value: string;
  }
  export namespace VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityFQDN {
    export namespace Constants {
      /** The IKE identity type. */
      export enum Type {
        FQDN = 'fqdn',
        HOSTNAME = 'hostname',
        IPV4_ADDRESS = 'ipv4_address',
        KEY_ID = 'key_id',
      }
    }
  }

  /**
   * VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityHostname.
   */
  export interface VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityHostname extends VPNGatewayConnectionIKEIdentityPrototype {
    /** The IKE identity hostname value. */
    value: string;
  }
  export namespace VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityHostname {
    export namespace Constants {
      /** The IKE identity type. */
      export enum Type {
        FQDN = 'fqdn',
        HOSTNAME = 'hostname',
        IPV4_ADDRESS = 'ipv4_address',
        KEY_ID = 'key_id',
      }
    }
  }

  /**
   * VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityIPv4.
   */
  export interface VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityIPv4 extends VPNGatewayConnectionIKEIdentityPrototype {
    /** The IKE identity IPv4 address value. */
    value: string;
  }
  export namespace VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityIPv4 {
    export namespace Constants {
      /** The IKE identity type. */
      export enum Type {
        FQDN = 'fqdn',
        HOSTNAME = 'hostname',
        IPV4_ADDRESS = 'ipv4_address',
        KEY_ID = 'key_id',
      }
    }
  }

  /**
   * VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityKeyID.
   */
  export interface VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityKeyID extends VPNGatewayConnectionIKEIdentityPrototype {
    /** The base64-encoded IKE identity key ID value. */
    value: string;
  }
  export namespace VPNGatewayConnectionIKEIdentityPrototypeVPNGatewayConnectionIKEIdentityKeyID {
    export namespace Constants {
      /** The IKE identity type. */
      export enum Type {
        FQDN = 'fqdn',
        HOSTNAME = 'hostname',
        IPV4_ADDRESS = 'ipv4_address',
        KEY_ID = 'key_id',
      }
    }
  }

  /**
   * VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityFQDN.
   */
  export interface VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityFQDN extends VPNGatewayConnectionIKEIdentity {
    /** The IKE identity FQDN value. */
    value: string;
  }
  export namespace VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityFQDN {
    export namespace Constants {
      /** The IKE identity type. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        FQDN = 'fqdn',
        HOSTNAME = 'hostname',
        IPV4_ADDRESS = 'ipv4_address',
        KEY_ID = 'key_id',
      }
    }
  }

  /**
   * VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityHostname.
   */
  export interface VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityHostname extends VPNGatewayConnectionIKEIdentity {
    /** The IKE identity hostname value. */
    value: string;
  }
  export namespace VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityHostname {
    export namespace Constants {
      /** The IKE identity type. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        FQDN = 'fqdn',
        HOSTNAME = 'hostname',
        IPV4_ADDRESS = 'ipv4_address',
        KEY_ID = 'key_id',
      }
    }
  }

  /**
   * VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityIPv4.
   */
  export interface VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityIPv4 extends VPNGatewayConnectionIKEIdentity {
    /** The IKE identity IPv4 address value. */
    value: string;
  }
  export namespace VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityIPv4 {
    export namespace Constants {
      /** The IKE identity type. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        FQDN = 'fqdn',
        HOSTNAME = 'hostname',
        IPV4_ADDRESS = 'ipv4_address',
        KEY_ID = 'key_id',
      }
    }
  }

  /**
   * VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityKeyID.
   */
  export interface VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityKeyID extends VPNGatewayConnectionIKEIdentity {
    /** The base64-encoded IKE identity key ID value. */
    value: string;
  }
  export namespace VPNGatewayConnectionIKEIdentityVPNGatewayConnectionIKEIdentityKeyID {
    export namespace Constants {
      /** The IKE identity type. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Type {
        FQDN = 'fqdn',
        HOSTNAME = 'hostname',
        IPV4_ADDRESS = 'ipv4_address',
        KEY_ID = 'key_id',
      }
    }
  }

  /**
   * VPNGatewayConnectionIKEPolicyPatchIKEPolicyIdentityByHref.
   */
  export interface VPNGatewayConnectionIKEPolicyPatchIKEPolicyIdentityByHref extends VPNGatewayConnectionIKEPolicyPatch {
    /** The URL for this IKE policy. */
    href: string;
  }

  /**
   * VPNGatewayConnectionIKEPolicyPatchIKEPolicyIdentityById.
   */
  export interface VPNGatewayConnectionIKEPolicyPatchIKEPolicyIdentityById extends VPNGatewayConnectionIKEPolicyPatch {
    /** The unique identifier for this IKE policy. */
    id: string;
  }

  /**
   * VPNGatewayConnectionIKEPolicyPrototypeIKEPolicyIdentityByHref.
   */
  export interface VPNGatewayConnectionIKEPolicyPrototypeIKEPolicyIdentityByHref extends VPNGatewayConnectionIKEPolicyPrototype {
    /** The URL for this IKE policy. */
    href: string;
  }

  /**
   * VPNGatewayConnectionIKEPolicyPrototypeIKEPolicyIdentityById.
   */
  export interface VPNGatewayConnectionIKEPolicyPrototypeIKEPolicyIdentityById extends VPNGatewayConnectionIKEPolicyPrototype {
    /** The unique identifier for this IKE policy. */
    id: string;
  }

  /**
   * VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref.
   */
  export interface VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref extends VPNGatewayConnectionIPsecPolicyPatch {
    /** The URL for this IPsec policy. */
    href: string;
  }

  /**
   * VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityById.
   */
  export interface VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityById extends VPNGatewayConnectionIPsecPolicyPatch {
    /** The unique identifier for this IPsec policy. */
    id: string;
  }

  /**
   * VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref.
   */
  export interface VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref extends VPNGatewayConnectionIPsecPolicyPrototype {
    /** The URL for this IPsec policy. */
    href: string;
  }

  /**
   * VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityById.
   */
  export interface VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityById extends VPNGatewayConnectionIPsecPolicyPrototype {
    /** The unique identifier for this IPsec policy. */
    id: string;
  }

  /**
   * The peer VPN gateway for this connection. If `peer.type` is `ipv4_address`, only `peer.address` may be specified.
   * If `peer.type` is fqdn, only `peer.fqdn` may be specified.
   */
  export interface VPNGatewayConnectionPeerPatchVPNGatewayConnectionPolicyModePeerPatch extends VPNGatewayConnectionPeerPatch {
  }

  /**
   * The peer VPN gateway for this connection. If `peer.type` is `ipv4_address`, only `peer.address` may be specified.
   * If `peer.type` is fqdn, only `peer.fqdn` may be specified.
   */
  export interface VPNGatewayConnectionPeerPatchVPNGatewayConnectionStaticRouteModePeerPatch extends VPNGatewayConnectionPeerPatch {
  }

  /**
   * VPNGatewayConnectionPolicyMode.
   */
  export interface VPNGatewayConnectionPolicyMode extends VPNGatewayConnection {
    local: VPNGatewayConnectionPolicyModeLocal;
    peer: VPNGatewayConnectionPolicyModePeer;
  }
  export namespace VPNGatewayConnectionPolicyMode {
    export namespace Constants {
      /** The authentication mode. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AuthenticationMode {
        PSK = 'psk',
      }
      /** The establish mode of the VPN gateway connection: - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol negotiations or rekeying processes. - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway connection. Additionally, the peer is responsible for initiating the rekeying process after the connection is established. If rekeying does not occur, the VPN gateway connection will be brought down after its lifetime expires. */
      export enum EstablishMode {
        BIDIRECTIONAL = 'bidirectional',
        PEER_ONLY = 'peer_only',
      }
      /** The mode of the VPN gateway. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Mode {
        POLICY = 'policy',
        ROUTE = 'route',
      }
      /** The resource type. */
      export enum ResourceType {
        VPN_GATEWAY_CONNECTION = 'vpn_gateway_connection',
      }
      /** The status of a VPN gateway connection. */
      export enum Status {
        DOWN = 'down',
        UP = 'up',
      }
    }
  }

  /**
   * VPNGatewayConnectionPolicyModePeerPrototypeVPNGatewayConnectionPeerByAddress.
   */
  export interface VPNGatewayConnectionPolicyModePeerPrototypeVPNGatewayConnectionPeerByAddress extends VPNGatewayConnectionPolicyModePeerPrototype {
    /** The IP address of the peer VPN gateway for this connection. */
    address: string;
  }

  /**
   * VPNGatewayConnectionPolicyModePeerPrototypeVPNGatewayConnectionPeerByFQDN.
   */
  export interface VPNGatewayConnectionPolicyModePeerPrototypeVPNGatewayConnectionPeerByFQDN extends VPNGatewayConnectionPolicyModePeerPrototype {
    /** The FQDN of the peer VPN gateway for this connection. */
    fqdn: string;
  }

  /**
   * VPNGatewayConnectionPolicyModePeerVPNGatewayConnectionPeerByAddress.
   */
  export interface VPNGatewayConnectionPolicyModePeerVPNGatewayConnectionPeerByAddress extends VPNGatewayConnectionPolicyModePeer {
    /** The IP address of the peer VPN gateway for this connection. */
    address: string;
  }
  export namespace VPNGatewayConnectionPolicyModePeerVPNGatewayConnectionPeerByAddress {
    export namespace Constants {
      /** Indicates whether `peer.address` or `peer.fqdn` is used. */
      export enum Type {
        ADDRESS = 'address',
        FQDN = 'fqdn',
      }
    }
  }

  /**
   * VPNGatewayConnectionPolicyModePeerVPNGatewayConnectionPeerByFQDN.
   */
  export interface VPNGatewayConnectionPolicyModePeerVPNGatewayConnectionPeerByFQDN extends VPNGatewayConnectionPolicyModePeer {
    /** The FQDN of the peer VPN gateway for this connection. */
    fqdn: string;
  }
  export namespace VPNGatewayConnectionPolicyModePeerVPNGatewayConnectionPeerByFQDN {
    export namespace Constants {
      /** Indicates whether `peer.address` or `peer.fqdn` is used. */
      export enum Type {
        ADDRESS = 'address',
        FQDN = 'fqdn',
      }
    }
  }

  /**
   * VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype.
   */
  export interface VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype extends VPNGatewayConnectionPrototype {
    local: VPNGatewayConnectionPolicyModeLocalPrototype;
    peer: VPNGatewayConnectionPolicyModePeerPrototype;
  }
  export namespace VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype {
    export namespace Constants {
      /** The establish mode of the VPN gateway connection: - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol negotiations or rekeying processes. - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway connection. Additionally, the peer is responsible for initiating the rekeying process after the connection is established. If rekeying does not occur, the VPN gateway connection will be brought down after its lifetime expires. */
      export enum EstablishMode {
        BIDIRECTIONAL = 'bidirectional',
        PEER_ONLY = 'peer_only',
      }
    }
  }

  /**
   * VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype.
   */
  export interface VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype extends VPNGatewayConnectionPrototype {
    /** Indicates whether the traffic is distributed between the `up` tunnels of the VPN gateway connection when the
     *  VPC route's next hop is a VPN connection. If `false`, the traffic is only routed through the `up` tunnel with
     *  the lower `public_ip` address. Before enabling it on VPN connections to on-prem private networks, review
     *  [distributing traffic
     *  restrictions](https://cloud.ibm.com/docs/vpc?topic=vpc-vpn-limitations#distributing-traffic-restrictions).
     */
    distribute_traffic?: boolean;
    local?: VPNGatewayConnectionStaticRouteModeLocalPrototype;
    peer: VPNGatewayConnectionStaticRouteModePeerPrototype;
    /** Routing protocols are disabled for this VPN gateway connection. */
    routing_protocol?: VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype.Constants.RoutingProtocol | string;
  }
  export namespace VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype {
    export namespace Constants {
      /** The establish mode of the VPN gateway connection: - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol negotiations or rekeying processes. - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway connection. Additionally, the peer is responsible for initiating the rekeying process after the connection is established. If rekeying does not occur, the VPN gateway connection will be brought down after its lifetime expires. */
      export enum EstablishMode {
        BIDIRECTIONAL = 'bidirectional',
        PEER_ONLY = 'peer_only',
      }
      /** Routing protocols are disabled for this VPN gateway connection. */
      export enum RoutingProtocol {
        NONE = 'none',
      }
    }
  }

  /**
   * VPNGatewayConnectionRouteMode.
   */
  export interface VPNGatewayConnectionRouteMode extends VPNGatewayConnection {
  }
  export namespace VPNGatewayConnectionRouteMode {
    export namespace Constants {
      /** The authentication mode. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AuthenticationMode {
        PSK = 'psk',
      }
      /** The establish mode of the VPN gateway connection: - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol negotiations or rekeying processes. - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway connection. Additionally, the peer is responsible for initiating the rekeying process after the connection is established. If rekeying does not occur, the VPN gateway connection will be brought down after its lifetime expires. */
      export enum EstablishMode {
        BIDIRECTIONAL = 'bidirectional',
        PEER_ONLY = 'peer_only',
      }
      /** The mode of the VPN gateway. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Mode {
        POLICY = 'policy',
        ROUTE = 'route',
      }
      /** The resource type. */
      export enum ResourceType {
        VPN_GATEWAY_CONNECTION = 'vpn_gateway_connection',
      }
      /** The status of a VPN gateway connection. */
      export enum Status {
        DOWN = 'down',
        UP = 'up',
      }
    }
  }

  /**
   * VPNGatewayConnectionStaticRouteModePeerPrototypeVPNGatewayConnectionPeerByAddress.
   */
  export interface VPNGatewayConnectionStaticRouteModePeerPrototypeVPNGatewayConnectionPeerByAddress extends VPNGatewayConnectionStaticRouteModePeerPrototype {
    /** The IP address of the peer VPN gateway for this connection. */
    address: string;
  }

  /**
   * VPNGatewayConnectionStaticRouteModePeerPrototypeVPNGatewayConnectionPeerByFQDN.
   */
  export interface VPNGatewayConnectionStaticRouteModePeerPrototypeVPNGatewayConnectionPeerByFQDN extends VPNGatewayConnectionStaticRouteModePeerPrototype {
    /** The FQDN of the peer VPN gateway for this connection. */
    fqdn: string;
  }

  /**
   * VPNGatewayConnectionStaticRouteModePeerVPNGatewayConnectionPeerByAddress.
   */
  export interface VPNGatewayConnectionStaticRouteModePeerVPNGatewayConnectionPeerByAddress extends VPNGatewayConnectionStaticRouteModePeer {
    /** The IP address of the peer VPN gateway for this connection. */
    address: string;
  }
  export namespace VPNGatewayConnectionStaticRouteModePeerVPNGatewayConnectionPeerByAddress {
    export namespace Constants {
      /** Indicates whether `peer.address` or `peer.fqdn` is used. */
      export enum Type {
        ADDRESS = 'address',
        FQDN = 'fqdn',
      }
    }
  }

  /**
   * VPNGatewayConnectionStaticRouteModePeerVPNGatewayConnectionPeerByFQDN.
   */
  export interface VPNGatewayConnectionStaticRouteModePeerVPNGatewayConnectionPeerByFQDN extends VPNGatewayConnectionStaticRouteModePeer {
    /** The FQDN of the peer VPN gateway for this connection. */
    fqdn: string;
  }
  export namespace VPNGatewayConnectionStaticRouteModePeerVPNGatewayConnectionPeerByFQDN {
    export namespace Constants {
      /** Indicates whether `peer.address` or `peer.fqdn` is used. */
      export enum Type {
        ADDRESS = 'address',
        FQDN = 'fqdn',
      }
    }
  }

  /**
   * VPNGatewayPolicyMode.
   */
  export interface VPNGatewayPolicyMode extends VPNGateway {
    /** Policy mode VPN gateway. */
    mode: VPNGatewayPolicyMode.Constants.Mode | string;
  }
  export namespace VPNGatewayPolicyMode {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the VPN gateway. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        VPN_GATEWAY = 'vpn_gateway',
      }
      /** Policy mode VPN gateway. */
      export enum Mode {
        POLICY = 'policy',
      }
    }
  }

  /**
   * VPNGatewayPrototypeVPNGatewayPolicyModePrototype.
   */
  export interface VPNGatewayPrototypeVPNGatewayPolicyModePrototype extends VPNGatewayPrototype {
    /** Policy mode VPN gateway. */
    mode?: VPNGatewayPrototypeVPNGatewayPolicyModePrototype.Constants.Mode | string;
  }
  export namespace VPNGatewayPrototypeVPNGatewayPolicyModePrototype {
    export namespace Constants {
      /** Policy mode VPN gateway. */
      export enum Mode {
        POLICY = 'policy',
      }
    }
  }

  /**
   * VPNGatewayPrototypeVPNGatewayRouteModePrototype.
   */
  export interface VPNGatewayPrototypeVPNGatewayRouteModePrototype extends VPNGatewayPrototype {
    /** Route mode VPN gateway. */
    mode?: VPNGatewayPrototypeVPNGatewayRouteModePrototype.Constants.Mode | string;
  }
  export namespace VPNGatewayPrototypeVPNGatewayRouteModePrototype {
    export namespace Constants {
      /** Route mode VPN gateway. */
      export enum Mode {
        ROUTE = 'route',
      }
    }
  }

  /**
   * VPNGatewayRouteMode.
   */
  export interface VPNGatewayRouteMode extends VPNGateway {
    /** Route mode VPN gateway. */
    mode: VPNGatewayRouteMode.Constants.Mode | string;
  }
  export namespace VPNGatewayRouteMode {
    export namespace Constants {
      /** The health of this resource: - `ok`: No abnormal behavior detected - `degraded`: Experiencing compromised performance, capacity, or connectivity - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this state. */
      export enum HealthState {
        DEGRADED = 'degraded',
        FAULTED = 'faulted',
        INAPPLICABLE = 'inapplicable',
        OK = 'ok',
      }
      /** The lifecycle state of the VPN gateway. */
      export enum LifecycleState {
        DELETING = 'deleting',
        FAILED = 'failed',
        PENDING = 'pending',
        STABLE = 'stable',
        SUSPENDED = 'suspended',
        UPDATING = 'updating',
        WAITING = 'waiting',
      }
      /** The resource type. */
      export enum ResourceType {
        VPN_GATEWAY = 'vpn_gateway',
      }
      /** Route mode VPN gateway. */
      export enum Mode {
        ROUTE = 'route',
      }
    }
  }

  /**
   * VPNServerAuthenticationByCertificate.
   */
  export interface VPNServerAuthenticationByCertificate extends VPNServerAuthentication {
    /** The certificate instance used for the VPN client certificate authority (CA). */
    client_ca: CertificateInstanceReference;
    /** The certificate revocation list contents, encoded in PEM format. */
    crl?: string;
  }
  export namespace VPNServerAuthenticationByCertificate {
    export namespace Constants {
      /** The type of authentication. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Method {
        CERTIFICATE = 'certificate',
        USERNAME = 'username',
      }
    }
  }

  /**
   * VPNServerAuthenticationByUsername.
   */
  export interface VPNServerAuthenticationByUsername extends VPNServerAuthentication {
    /** The type of identity provider to be used by VPN client. */
    identity_provider: VPNServerAuthenticationByUsernameIdProvider;
  }
  export namespace VPNServerAuthenticationByUsername {
    export namespace Constants {
      /** The type of authentication. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Method {
        CERTIFICATE = 'certificate',
        USERNAME = 'username',
      }
    }
  }

  /**
   * VPNServerAuthenticationByUsernameIdProviderByIAM.
   */
  export interface VPNServerAuthenticationByUsernameIdProviderByIAM extends VPNServerAuthenticationByUsernameIdProvider {
    /** The type of identity provider to be used by the VPN client:
     *  - `iam`: IBM identity and access management
     *
     *  The enumerated values for this property may
     *  [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future.
     */
    provider_type: VPNServerAuthenticationByUsernameIdProviderByIAM.Constants.ProviderType | string;
  }
  export namespace VPNServerAuthenticationByUsernameIdProviderByIAM {
    export namespace Constants {
      /** The type of identity provider to be used by the VPN client: - `iam`: IBM identity and access management The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum ProviderType {
        IAM = 'iam',
      }
    }
  }

  /**
   * VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype.
   */
  export interface VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype extends VPNServerAuthenticationPrototype {
    /** The certificate instance to use for the VPN client certificate authority (CA). */
    client_ca: CertificateInstanceIdentity;
    /** The certificate revocation list contents, encoded in PEM format. */
    crl?: string;
  }
  export namespace VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype {
    export namespace Constants {
      /** The type of authentication. */
      export enum Method {
        CERTIFICATE = 'certificate',
        USERNAME = 'username',
      }
    }
  }

  /**
   * VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype.
   */
  export interface VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype extends VPNServerAuthenticationPrototype {
    /** The type of identity provider to be used by VPN client. */
    identity_provider: VPNServerAuthenticationByUsernameIdProvider;
  }
  export namespace VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype {
    export namespace Constants {
      /** The type of authentication. */
      export enum Method {
        CERTIFICATE = 'certificate',
        USERNAME = 'username',
      }
    }
  }

  /**
   * Identifies a reserved IP by a unique property. The reserved IP must be currently unbound and in the primary IP's
   * subnet.
   */
  export interface VirtualNetworkInterfaceIPPrototypeReservedIPIdentityVirtualNetworkInterfaceIPsContext extends VirtualNetworkInterfaceIPPrototype {
  }

  /**
   * The prototype for a new reserved IP. Must be in the primary IP's subnet.
   */
  export interface VirtualNetworkInterfaceIPPrototypeReservedIPPrototypeVirtualNetworkInterfaceIPsContext extends VirtualNetworkInterfaceIPPrototype {
    /** The IP address to reserve, which must not already be reserved on the subnet.
     *
     *  If unspecified, an available address on the subnet will automatically be selected.
     */
    address?: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound.
     */
    auto_delete?: boolean;
    /** The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /**
   * Identifies a reserved IP by a unique property. Required if `subnet` is not specified. The reserved IP must be
   * currently unbound.
   */
  export interface VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext extends VirtualNetworkInterfacePrimaryIPPrototype {
  }

  /**
   * The prototype for a new reserved IP. Requires `subnet` to be specified.
   */
  export interface VirtualNetworkInterfacePrimaryIPPrototypeReservedIPPrototypeVirtualNetworkInterfacePrimaryIPContext extends VirtualNetworkInterfacePrimaryIPPrototype {
    /** The IP address to reserve, which must not already be reserved on the subnet.
     *
     *  If unspecified, an available address on the subnet will automatically be selected.
     */
    address?: string;
    /** Indicates whether this reserved IP member will be automatically deleted when either
     *  `target` is deleted, or the reserved IP is unbound.
     */
    auto_delete?: boolean;
    /** The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names
     *  starting with `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name
     *  will be a hyphenated list of randomly-selected words.
     */
    name?: string;
  }

  /**
   * VirtualNetworkInterfaceTargetBareMetalServerNetworkAttachmentReferenceVirtualNetworkInterfaceContext.
   */
  export interface VirtualNetworkInterfaceTargetBareMetalServerNetworkAttachmentReferenceVirtualNetworkInterfaceContext extends VirtualNetworkInterfaceTarget {
    /** The URL for this bare metal server network attachment. */
    href: string;
    /** The unique identifier for this bare metal server network attachment. */
    id: string;
    /** The name for this bare metal server network attachment. The name is unique across all network attachments
     *  for the bare metal server.
     */
    name: string;
    /** The resource type. */
    resource_type: VirtualNetworkInterfaceTargetBareMetalServerNetworkAttachmentReferenceVirtualNetworkInterfaceContext.Constants.ResourceType | string;
  }
  export namespace VirtualNetworkInterfaceTargetBareMetalServerNetworkAttachmentReferenceVirtualNetworkInterfaceContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        BARE_METAL_SERVER_NETWORK_ATTACHMENT = 'bare_metal_server_network_attachment',
      }
    }
  }

  /**
   * VirtualNetworkInterfaceTargetInstanceNetworkAttachmentReferenceVirtualNetworkInterfaceContext.
   */
  export interface VirtualNetworkInterfaceTargetInstanceNetworkAttachmentReferenceVirtualNetworkInterfaceContext extends VirtualNetworkInterfaceTarget {
    /** The URL for this instance network attachment. */
    href: string;
    /** The unique identifier for this instance network attachment. */
    id: string;
    /** The name for this instance network attachment. The name is unique across all network attachments for the
     *  instance.
     */
    name: string;
    /** The resource type. */
    resource_type: VirtualNetworkInterfaceTargetInstanceNetworkAttachmentReferenceVirtualNetworkInterfaceContext.Constants.ResourceType | string;
  }
  export namespace VirtualNetworkInterfaceTargetInstanceNetworkAttachmentReferenceVirtualNetworkInterfaceContext {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_NETWORK_ATTACHMENT = 'instance_network_attachment',
      }
    }
  }

  /**
   * VirtualNetworkInterfaceTargetShareMountTargetReference.
   */
  export interface VirtualNetworkInterfaceTargetShareMountTargetReference extends VirtualNetworkInterfaceTarget {
    /** If present, this property indicates the referenced resource has been deleted, and provides
     *  some supplementary information.
     */
    deleted?: Deleted;
    /** The URL for this share mount target. */
    href: string;
    /** The unique identifier for this share mount target. */
    id: string;
    /** The name for this share mount target. The name is unique across all mount targets for the file share. */
    name: string;
    /** The resource type. */
    resource_type: VirtualNetworkInterfaceTargetShareMountTargetReference.Constants.ResourceType | string;
  }
  export namespace VirtualNetworkInterfaceTargetShareMountTargetReference {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        SHARE_MOUNT_TARGET = 'share_mount_target',
      }
    }
  }

  /**
   * Identifies a volume by a unique property.
   */
  export interface VolumeAttachmentPrototypeVolumeVolumeIdentity extends VolumeAttachmentPrototypeVolume {
  }

  /**
   * VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext.
   */
  export interface VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext extends VolumeAttachmentPrototypeVolume {
    /** The maximum bandwidth (in megabits per second) for the volume.
     *
     *  If the volume profile has a `bandwidth.type` of `dependent`, this property is system-managed and must not be
     *  specified.
     *
     *  Provided the property is user-managed, if it is unspecified, its value will be set based on the specified
     *  [`iops` and
     *  `capacity`](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles&interface=api).
     */
    bandwidth?: number;
    /** The maximum I/O operations per second (IOPS) to use for this volume.
     *
     *  If the volume profile has a `iops.type` of `dependent`, this property is system-managed and must not be
     *  specified.
     *
     *  Provided the property is user-managed, if it is unspecified, its value will be set based on the specified [
     *  `capacity`](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles&interface=api).
     */
    iops?: number;
    /** The name for this volume. The name must not be used by another volume in the region. If unspecified, the
     *  name will be a hyphenated list of randomly-selected words.
     */
    name?: string;
    /** The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) for this volume. */
    profile: VolumeProfileIdentity;
    /** The resource group to use for this volume. If unspecified, the instance's resource group will be used. */
    resource_group?: ResourceGroupIdentity;
    /** The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume. */
    user_tags?: string[];
  }

  /**
   * VolumeIdentityByCRN.
   */
  export interface VolumeIdentityByCRN extends VolumeIdentity {
    /** The CRN for this volume. */
    crn: string;
  }

  /**
   * VolumeIdentityByHref.
   */
  export interface VolumeIdentityByHref extends VolumeIdentity {
    /** The URL for this volume. */
    href: string;
  }

  /**
   * VolumeIdentityById.
   */
  export interface VolumeIdentityById extends VolumeIdentity {
    /** The unique identifier for this volume. */
    id: string;
  }

  /**
   * The maximum bandwidth (in Mbps) of a volume with this profile depends on its configuration.
   */
  export interface VolumeProfileBandwidthDependent extends VolumeProfileBandwidth {
    /** The type for this profile field. */
    type: VolumeProfileBandwidthDependent.Constants.Type | string;
  }
  export namespace VolumeProfileBandwidthDependent {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT = 'dependent',
      }
    }
  }

  /**
   * The maximum bandwidth (in Mbps) of a volume with this profile varies depending on its configuration.
   */
  export interface VolumeProfileBandwidthDependentRange extends VolumeProfileBandwidth {
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: VolumeProfileBandwidthDependentRange.Constants.Type | string;
  }
  export namespace VolumeProfileBandwidthDependentRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT_RANGE = 'dependent_range',
      }
    }
  }

  /**
   * The available maximum bandwidth values (in Mbps) of a volume with this profile.
   */
  export interface VolumeProfileBandwidthEnum extends VolumeProfileBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: VolumeProfileBandwidthEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace VolumeProfileBandwidthEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The maximum bandwidth (in Mbps) of a volume with this profile is fixed.
   */
  export interface VolumeProfileBandwidthFixed extends VolumeProfileBandwidth {
    /** The type for this profile field. */
    type: VolumeProfileBandwidthFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace VolumeProfileBandwidthFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The maximum bandwidth range (in Mbps) of a volume with this profile.
   */
  export interface VolumeProfileBandwidthRange extends VolumeProfileBandwidth {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: VolumeProfileBandwidthRange.Constants.Type | string;
  }
  export namespace VolumeProfileBandwidthRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The permitted total capacity (in gigabytes) of a boot volume with this profile depends on its configuration.
   */
  export interface VolumeProfileBootCapacityDependentRange extends VolumeProfileBootCapacity {
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: VolumeProfileBootCapacityDependentRange.Constants.Type | string;
  }
  export namespace VolumeProfileBootCapacityDependentRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT_RANGE = 'dependent_range',
      }
    }
  }

  /**
   * The permitted total capacities (in gigabytes) of a boot volume with this profile.
   */
  export interface VolumeProfileBootCapacityEnum extends VolumeProfileBootCapacity {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: VolumeProfileBootCapacityEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace VolumeProfileBootCapacityEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The permitted total capacity (in gigabytes) of a boot volume with this profile is fixed.
   */
  export interface VolumeProfileBootCapacityFixed extends VolumeProfileBootCapacity {
    /** The type for this profile field. */
    type: VolumeProfileBootCapacityFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace VolumeProfileBootCapacityFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted total capacity range (in gigabytes) of a boot volume with this profile.
   */
  export interface VolumeProfileBootCapacityRange extends VolumeProfileBootCapacity {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: VolumeProfileBootCapacityRange.Constants.Type | string;
  }
  export namespace VolumeProfileBootCapacityRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The permitted total capacity (in gigabytes) of a data volume with this profile depends on its configuration.
   */
  export interface VolumeProfileCapacityDependentRange extends VolumeProfileCapacity {
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: VolumeProfileCapacityDependentRange.Constants.Type | string;
  }
  export namespace VolumeProfileCapacityDependentRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT_RANGE = 'dependent_range',
      }
    }
  }

  /**
   * The permitted total capacities (in gigabytes) of a data volume with this profile.
   */
  export interface VolumeProfileCapacityEnum extends VolumeProfileCapacity {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: VolumeProfileCapacityEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace VolumeProfileCapacityEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The permitted total capacity (in gigabytes) of a data volume with this profile is fixed.
   */
  export interface VolumeProfileCapacityFixed extends VolumeProfileCapacity {
    /** The type for this profile field. */
    type: VolumeProfileCapacityFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace VolumeProfileCapacityFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted total capacity range (in gigabytes) of a data volume with this profile.
   */
  export interface VolumeProfileCapacityRange extends VolumeProfileCapacity {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: VolumeProfileCapacityRange.Constants.Type | string;
  }
  export namespace VolumeProfileCapacityRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * The permitted IOPS range of a volume with this profile depends on its configuration.
   */
  export interface VolumeProfileIOPSDependentRange extends VolumeProfileIOPS {
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: VolumeProfileIOPSDependentRange.Constants.Type | string;
  }
  export namespace VolumeProfileIOPSDependentRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        DEPENDENT_RANGE = 'dependent_range',
      }
    }
  }

  /**
   * The permitted IOPS values of a volume with this profile.
   */
  export interface VolumeProfileIOPSEnum extends VolumeProfileIOPS {
    /** The default value for this profile field. */
    default: number;
    /** The type for this profile field. */
    type: VolumeProfileIOPSEnum.Constants.Type | string;
    /** The permitted values for this profile field. */
    values: number[];
  }
  export namespace VolumeProfileIOPSEnum {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        ENUM = 'enum',
      }
    }
  }

  /**
   * The permitted IOPS of a volume with this profile is fixed.
   */
  export interface VolumeProfileIOPSFixed extends VolumeProfileIOPS {
    /** The type for this profile field. */
    type: VolumeProfileIOPSFixed.Constants.Type | string;
    /** The value for this profile field. */
    value: number;
  }
  export namespace VolumeProfileIOPSFixed {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        FIXED = 'fixed',
      }
    }
  }

  /**
   * The permitted IOPS range of a volume with this profile.
   */
  export interface VolumeProfileIOPSRange extends VolumeProfileIOPS {
    /** The default value for this profile field. */
    default: number;
    /** The maximum value for this profile field. */
    max: number;
    /** The minimum value for this profile field. */
    min: number;
    /** The increment step value for this profile field. */
    step: number;
    /** The type for this profile field. */
    type: VolumeProfileIOPSRange.Constants.Type | string;
  }
  export namespace VolumeProfileIOPSRange {
    export namespace Constants {
      /** The type for this profile field. */
      export enum Type {
        RANGE = 'range',
      }
    }
  }

  /**
   * VolumeProfileIdentityByHref.
   */
  export interface VolumeProfileIdentityByHref extends VolumeProfileIdentity {
    /** The URL for this volume profile. */
    href: string;
  }

  /**
   * VolumeProfileIdentityByName.
   */
  export interface VolumeProfileIdentityByName extends VolumeProfileIdentity {
    /** The globally unique name for this volume profile. */
    name: string;
  }

  /**
   * VolumePrototypeVolumeByCapacity.
   */
  export interface VolumePrototypeVolumeByCapacity extends VolumePrototype {
    /** The capacity to use for the volume (in gigabytes). The specified value must be within the `capacity` range
     *  of the volume's profile.
     */
    capacity: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
  }

  /**
   * VolumePrototypeVolumeBySourceSnapshot.
   */
  export interface VolumePrototypeVolumeBySourceSnapshot extends VolumePrototype {
    /** The capacity to use for the volume (in gigabytes). The specified value must be at least the snapshot's
     *  `minimum_capacity`, and must be within the `capacity` range of the volume's profile.
     *
     *  If unspecified, the capacity will be the source snapshot's `minimum_capacity`.
     */
    capacity?: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The snapshot to use as a source for the volume's data.
     *
     *  The specified snapshot may be in a different account, subject to IAM policies.
     *
     *  To create a volume from a `source_snapshot`, the volume profile and the
     *  source snapshot must have the same `storage_generation` value.
     */
    source_snapshot: SnapshotIdentity;
  }

  /**
   * ZoneIdentityByHref.
   */
  export interface ZoneIdentityByHref extends ZoneIdentity {
    /** The URL for this zone. */
    href: string;
  }

  /**
   * ZoneIdentityByName.
   */
  export interface ZoneIdentityByName extends ZoneIdentity {
    /** The globally unique name for this zone. */
    name: string;
  }

  /**
   * BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN.
   */
  export interface BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN extends BackupPolicyScopePrototypeEnterpriseIdentity {
    /** The CRN for this enterprise. */
    crn: string;
  }

  /**
   * BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN.
   */
  export interface BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN extends BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentity {
    /** The CRN for this virtual network interface. */
    crn: string;
  }

  /**
   * BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref.
   */
  export interface BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref extends BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentity {
    /** The URL for this virtual network interface. */
    href: string;
  }

  /**
   * BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById.
   */
  export interface BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById extends BareMetalServerNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentity {
    /** The unique identifier for this virtual network interface. */
    id: string;
  }

  /**
   * ClusterNetworkInterfacePrimaryIPPrototypeClusterNetworkSubnetReservedIPIdentityClusterNetworkInterfacePrimaryIPContextByHref.
   */
  export interface ClusterNetworkInterfacePrimaryIPPrototypeClusterNetworkSubnetReservedIPIdentityClusterNetworkInterfacePrimaryIPContextByHref extends ClusterNetworkInterfacePrimaryIPPrototypeClusterNetworkSubnetReservedIPIdentityClusterNetworkInterfacePrimaryIPContext {
    /** The URL for this cluster network subnet reserved IP. */
    href: string;
  }

  /**
   * ClusterNetworkInterfacePrimaryIPPrototypeClusterNetworkSubnetReservedIPIdentityClusterNetworkInterfacePrimaryIPContextById.
   */
  export interface ClusterNetworkInterfacePrimaryIPPrototypeClusterNetworkSubnetReservedIPIdentityClusterNetworkInterfacePrimaryIPContextById extends ClusterNetworkInterfacePrimaryIPPrototypeClusterNetworkSubnetReservedIPIdentityClusterNetworkInterfacePrimaryIPContext {
    /** The unique identifier for this cluster network subnet reserved IP. */
    id: string;
  }

  /**
   * EndpointGatewayReservedIPReservedIPIdentityByHref.
   */
  export interface EndpointGatewayReservedIPReservedIPIdentityByHref extends EndpointGatewayReservedIPReservedIPIdentity {
    /** The URL for this reserved IP. */
    href: string;
  }

  /**
   * EndpointGatewayReservedIPReservedIPIdentityById.
   */
  export interface EndpointGatewayReservedIPReservedIPIdentityById extends EndpointGatewayReservedIPReservedIPIdentity {
    /** The unique identifier for this reserved IP. */
    id: string;
  }

  /**
   * FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref.
   */
  export interface FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref extends FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity {
    /** The URL for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
  }

  /**
   * FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityById.
   */
  export interface FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityById extends FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity {
    /** The unique identifier for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
  }

  /**
   * FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref.
   */
  export interface FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref extends FloatingIPTargetPatchNetworkInterfaceIdentity {
    /** The URL for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
  }

  /**
   * FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityById.
   */
  export interface FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityById extends FloatingIPTargetPatchNetworkInterfaceIdentity {
    /** The unique identifier for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
  }

  /**
   * FloatingIPTargetPatchVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN.
   */
  export interface FloatingIPTargetPatchVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN extends FloatingIPTargetPatchVirtualNetworkInterfaceIdentity {
    /** The CRN for this virtual network interface. */
    crn: string;
  }

  /**
   * FloatingIPTargetPatchVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref.
   */
  export interface FloatingIPTargetPatchVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref extends FloatingIPTargetPatchVirtualNetworkInterfaceIdentity {
    /** The URL for this virtual network interface. */
    href: string;
  }

  /**
   * FloatingIPTargetPatchVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById.
   */
  export interface FloatingIPTargetPatchVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById extends FloatingIPTargetPatchVirtualNetworkInterfaceIdentity {
    /** The unique identifier for this virtual network interface. */
    id: string;
  }

  /**
   * FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref.
   */
  export interface FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref extends FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity {
    /** The URL for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
  }

  /**
   * FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityById.
   */
  export interface FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityById extends FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity {
    /** The unique identifier for this bare metal server network interface.
     *
     *  If this bare metal server has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
  }

  /**
   * FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref.
   */
  export interface FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref extends FloatingIPTargetPrototypeNetworkInterfaceIdentity {
    /** The URL for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
  }

  /**
   * FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityById.
   */
  export interface FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityById extends FloatingIPTargetPrototypeNetworkInterfaceIdentity {
    /** The unique identifier for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
  }

  /**
   * FloatingIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN.
   */
  export interface FloatingIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN extends FloatingIPTargetPrototypeVirtualNetworkInterfaceIdentity {
    /** The CRN for this virtual network interface. */
    crn: string;
  }

  /**
   * FloatingIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref.
   */
  export interface FloatingIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref extends FloatingIPTargetPrototypeVirtualNetworkInterfaceIdentity {
    /** The URL for this virtual network interface. */
    href: string;
  }

  /**
   * FloatingIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById.
   */
  export interface FloatingIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById extends FloatingIPTargetPrototypeVirtualNetworkInterfaceIdentity {
    /** The unique identifier for this virtual network interface. */
    id: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN.
   */
  export interface FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN extends FlowLogCollectorTargetPrototypeInstanceIdentity {
    /** The CRN for this virtual server instance. */
    crn: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref.
   */
  export interface FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref extends FlowLogCollectorTargetPrototypeInstanceIdentity {
    /** The URL for this virtual server instance. */
    href: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityById.
   */
  export interface FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityById extends FlowLogCollectorTargetPrototypeInstanceIdentity {
    /** The unique identifier for this virtual server instance. */
    id: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeInstanceNetworkAttachmentIdentityInstanceNetworkAttachmentIdentityByHref.
   */
  export interface FlowLogCollectorTargetPrototypeInstanceNetworkAttachmentIdentityInstanceNetworkAttachmentIdentityByHref extends FlowLogCollectorTargetPrototypeInstanceNetworkAttachmentIdentity {
    /** The URL for this instance network attachment. */
    href: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeInstanceNetworkAttachmentIdentityInstanceNetworkAttachmentIdentityById.
   */
  export interface FlowLogCollectorTargetPrototypeInstanceNetworkAttachmentIdentityInstanceNetworkAttachmentIdentityById extends FlowLogCollectorTargetPrototypeInstanceNetworkAttachmentIdentity {
    /** The unique identifier for this instance network attachment. */
    id: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref.
   */
  export interface FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref extends FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity {
    /** The URL for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment.
     */
    href: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityById.
   */
  export interface FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityById extends FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity {
    /** The unique identifier for this instance network interface.
     *
     *  If this instance has network attachments, this network interface is a
     *  [read-only representation](https://cloud.ibm.com/docs/vpc?topic=vpc-vni-about#vni-old-api-clients) of its
     *  corresponding network attachment and its attached virtual network interface, and the identifier is that of the
     *  corresponding network attachment.
     */
    id: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN.
   */
  export interface FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN extends FlowLogCollectorTargetPrototypeSubnetIdentity {
    /** The CRN for this subnet. */
    crn: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref.
   */
  export interface FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref extends FlowLogCollectorTargetPrototypeSubnetIdentity {
    /** The URL for this subnet. */
    href: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityById.
   */
  export interface FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityById extends FlowLogCollectorTargetPrototypeSubnetIdentity {
    /** The unique identifier for this subnet. */
    id: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN.
   */
  export interface FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN extends FlowLogCollectorTargetPrototypeVPCIdentity {
    /** The CRN for this VPC. */
    crn: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref.
   */
  export interface FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref extends FlowLogCollectorTargetPrototypeVPCIdentity {
    /** The URL for this VPC. */
    href: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityById.
   */
  export interface FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityById extends FlowLogCollectorTargetPrototypeVPCIdentity {
    /** The unique identifier for this VPC. */
    id: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN.
   */
  export interface FlowLogCollectorTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN extends FlowLogCollectorTargetPrototypeVirtualNetworkInterfaceIdentity {
    /** The CRN for this virtual network interface. */
    crn: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref.
   */
  export interface FlowLogCollectorTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref extends FlowLogCollectorTargetPrototypeVirtualNetworkInterfaceIdentity {
    /** The URL for this virtual network interface. */
    href: string;
  }

  /**
   * FlowLogCollectorTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById.
   */
  export interface FlowLogCollectorTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById extends FlowLogCollectorTargetPrototypeVirtualNetworkInterfaceIdentity {
    /** The unique identifier for this virtual network interface. */
    id: string;
  }

  /**
   * InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterfaceClusterNetworkInterfaceIdentityClusterNetworkInterfaceIdentityByHref.
   */
  export interface InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterfaceClusterNetworkInterfaceIdentityClusterNetworkInterfaceIdentityByHref extends InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterfaceClusterNetworkInterfaceIdentity {
    /** The URL for this cluster network interface. */
    href: string;
  }

  /**
   * InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterfaceClusterNetworkInterfaceIdentityClusterNetworkInterfaceIdentityById.
   */
  export interface InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterfaceClusterNetworkInterfaceIdentityClusterNetworkInterfaceIdentityById extends InstanceClusterNetworkAttachmentPrototypeClusterNetworkInterfaceClusterNetworkInterfaceIdentity {
    /** The unique identifier for this cluster network interface. */
    id: string;
  }

  /**
   * InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec.
   */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec extends InstanceGroupManagerActionPrototypeScheduledActionPrototype {
    /** The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within
     *  a 5 min period.
     */
    cron_spec?: string;
  }

  /**
   * InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt.
   */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt extends InstanceGroupManagerActionPrototypeScheduledActionPrototype {
    /** The date and time the scheduled action will run. */
    run_at?: string;
  }

  /**
   * InstanceGroupManagerActionScheduledActionGroupTarget.
   */
  export interface InstanceGroupManagerActionScheduledActionGroupTarget extends InstanceGroupManagerActionScheduledAction {
    group: InstanceGroupManagerScheduledActionGroup;
  }
  export namespace InstanceGroupManagerActionScheduledActionGroupTarget {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_GROUP_MANAGER_ACTION = 'instance_group_manager_action',
      }
      /** The status of the instance group action - `active`: Action is ready to be run - `completed`: Action was completed successfully - `failed`: Action could not be completed successfully - `incompatible`: Action parameters are not compatible with the group or manager - `omitted`: Action was not applied because this action's manager was disabled The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        ACTIVE = 'active',
        COMPLETED = 'completed',
        FAILED = 'failed',
        INCOMPATIBLE = 'incompatible',
        OMITTED = 'omitted',
      }
      /** The type of action for the instance group. */
      export enum ActionType {
        SCHEDULED = 'scheduled',
      }
    }
  }

  /**
   * InstanceGroupManagerActionScheduledActionManagerTarget.
   */
  export interface InstanceGroupManagerActionScheduledActionManagerTarget extends InstanceGroupManagerActionScheduledAction {
    manager: InstanceGroupManagerScheduledActionManager;
  }
  export namespace InstanceGroupManagerActionScheduledActionManagerTarget {
    export namespace Constants {
      /** The resource type. */
      export enum ResourceType {
        INSTANCE_GROUP_MANAGER_ACTION = 'instance_group_manager_action',
      }
      /** The status of the instance group action - `active`: Action is ready to be run - `completed`: Action was completed successfully - `failed`: Action could not be completed successfully - `incompatible`: Action parameters are not compatible with the group or manager - `omitted`: Action was not applied because this action's manager was disabled The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Status {
        ACTIVE = 'active',
        COMPLETED = 'completed',
        FAILED = 'failed',
        INCOMPATIBLE = 'incompatible',
        OMITTED = 'omitted',
      }
      /** The type of action for the instance group. */
      export enum ActionType {
        SCHEDULED = 'scheduled',
      }
    }
  }

  /**
   * InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref.
   */
  export interface InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref extends InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype {
    /** The URL for this instance group manager. */
    href: string;
  }

  /**
   * InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeById.
   */
  export interface InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeById extends InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype {
    /** The unique identifier for this instance group manager. */
    id: string;
  }

  /**
   * InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN.
   */
  export interface InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN extends InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentity {
    /** The CRN for this virtual network interface. */
    crn: string;
  }

  /**
   * InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref.
   */
  export interface InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref extends InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentity {
    /** The URL for this virtual network interface. */
    href: string;
  }

  /**
   * InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById.
   */
  export interface InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById extends InstanceNetworkAttachmentPrototypeVirtualNetworkInterfaceVirtualNetworkInterfaceIdentity {
    /** The unique identifier for this virtual network interface. */
    id: string;
  }

  /**
   * InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN.
   */
  export interface InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN extends InstancePlacementTargetPatchDedicatedHostGroupIdentity {
    /** The CRN for this dedicated host group. */
    crn: string;
  }

  /**
   * InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref.
   */
  export interface InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref extends InstancePlacementTargetPatchDedicatedHostGroupIdentity {
    /** The URL for this dedicated host group. */
    href: string;
  }

  /**
   * InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityById.
   */
  export interface InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityById extends InstancePlacementTargetPatchDedicatedHostGroupIdentity {
    /** The unique identifier for this dedicated host group. */
    id: string;
  }

  /**
   * InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN.
   */
  export interface InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN extends InstancePlacementTargetPatchDedicatedHostIdentity {
    /** The CRN for this dedicated host. */
    crn: string;
  }

  /**
   * InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref.
   */
  export interface InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref extends InstancePlacementTargetPatchDedicatedHostIdentity {
    /** The URL for this dedicated host. */
    href: string;
  }

  /**
   * InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityById.
   */
  export interface InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityById extends InstancePlacementTargetPatchDedicatedHostIdentity {
    /** The unique identifier for this dedicated host. */
    id: string;
  }

  /**
   * InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN.
   */
  export interface InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN extends InstancePlacementTargetPrototypeDedicatedHostGroupIdentity {
    /** The CRN for this dedicated host group. */
    crn: string;
  }

  /**
   * InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref.
   */
  export interface InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref extends InstancePlacementTargetPrototypeDedicatedHostGroupIdentity {
    /** The URL for this dedicated host group. */
    href: string;
  }

  /**
   * InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityById.
   */
  export interface InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityById extends InstancePlacementTargetPrototypeDedicatedHostGroupIdentity {
    /** The unique identifier for this dedicated host group. */
    id: string;
  }

  /**
   * InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN.
   */
  export interface InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN extends InstancePlacementTargetPrototypeDedicatedHostIdentity {
    /** The CRN for this dedicated host. */
    crn: string;
  }

  /**
   * InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref.
   */
  export interface InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref extends InstancePlacementTargetPrototypeDedicatedHostIdentity {
    /** The URL for this dedicated host. */
    href: string;
  }

  /**
   * InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityById.
   */
  export interface InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityById extends InstancePlacementTargetPrototypeDedicatedHostIdentity {
    /** The unique identifier for this dedicated host. */
    id: string;
  }

  /**
   * InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN.
   */
  export interface InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN extends InstancePlacementTargetPrototypePlacementGroupIdentity {
    /** The CRN for this placement group. */
    crn: string;
  }

  /**
   * InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref.
   */
  export interface InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref extends InstancePlacementTargetPrototypePlacementGroupIdentity {
    /** The URL for this placement group. */
    href: string;
  }

  /**
   * InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityById.
   */
  export interface InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityById extends InstancePlacementTargetPrototypePlacementGroupIdentity {
    /** The unique identifier for this placement group. */
    id: string;
  }

  /**
   * InstancePrototypeInstanceByCatalogOfferingInstanceByCatalogOfferingInstanceByNetworkAttachment.
   */
  export interface InstancePrototypeInstanceByCatalogOfferingInstanceByCatalogOfferingInstanceByNetworkAttachment extends InstancePrototypeInstanceByCatalogOffering {
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment: InstanceNetworkAttachmentPrototype;
  }
  export namespace InstancePrototypeInstanceByCatalogOfferingInstanceByCatalogOfferingInstanceByNetworkAttachment {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstancePrototypeInstanceByCatalogOfferingInstanceByCatalogOfferingInstanceByNetworkInterface.
   */
  export interface InstancePrototypeInstanceByCatalogOfferingInstanceByCatalogOfferingInstanceByNetworkInterface extends InstancePrototypeInstanceByCatalogOffering {
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
  }
  export namespace InstancePrototypeInstanceByCatalogOfferingInstanceByCatalogOfferingInstanceByNetworkInterface {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstancePrototypeInstanceByImageInstanceByImageInstanceByNetworkAttachment.
   */
  export interface InstancePrototypeInstanceByImageInstanceByImageInstanceByNetworkAttachment extends InstancePrototypeInstanceByImage {
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment: InstanceNetworkAttachmentPrototype;
  }
  export namespace InstancePrototypeInstanceByImageInstanceByImageInstanceByNetworkAttachment {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstancePrototypeInstanceByImageInstanceByImageInstanceByNetworkInterface.
   */
  export interface InstancePrototypeInstanceByImageInstanceByImageInstanceByNetworkInterface extends InstancePrototypeInstanceByImage {
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
  }
  export namespace InstancePrototypeInstanceByImageInstanceByImageInstanceByNetworkInterface {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstancePrototypeInstanceBySourceSnapshotInstanceBySourceSnapshotInstanceByNetworkAttachment.
   */
  export interface InstancePrototypeInstanceBySourceSnapshotInstanceBySourceSnapshotInstanceByNetworkAttachment extends InstancePrototypeInstanceBySourceSnapshot {
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment: InstanceNetworkAttachmentPrototype;
  }
  export namespace InstancePrototypeInstanceBySourceSnapshotInstanceBySourceSnapshotInstanceByNetworkAttachment {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstancePrototypeInstanceBySourceSnapshotInstanceBySourceSnapshotInstanceByNetworkInterface.
   */
  export interface InstancePrototypeInstanceBySourceSnapshotInstanceBySourceSnapshotInstanceByNetworkInterface extends InstancePrototypeInstanceBySourceSnapshot {
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
  }
  export namespace InstancePrototypeInstanceBySourceSnapshotInstanceBySourceSnapshotInstanceByNetworkInterface {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstancePrototypeInstanceByVolumeInstanceByVolumeInstanceByNetworkAttachment.
   */
  export interface InstancePrototypeInstanceByVolumeInstanceByVolumeInstanceByNetworkAttachment extends InstancePrototypeInstanceByVolume {
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment: InstanceNetworkAttachmentPrototype;
  }
  export namespace InstancePrototypeInstanceByVolumeInstanceByVolumeInstanceByNetworkAttachment {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstancePrototypeInstanceByVolumeInstanceByVolumeInstanceByNetworkInterface.
   */
  export interface InstancePrototypeInstanceByVolumeInstanceByVolumeInstanceByNetworkInterface extends InstancePrototypeInstanceByVolume {
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
  }
  export namespace InstancePrototypeInstanceByVolumeInstanceByVolumeInstanceByNetworkInterface {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplatePrototypeInstanceTemplateByCatalogOfferingInstanceTemplateByCatalogOfferingInstanceByNetworkAttachment.
   */
  export interface InstanceTemplatePrototypeInstanceTemplateByCatalogOfferingInstanceTemplateByCatalogOfferingInstanceByNetworkAttachment extends InstanceTemplatePrototypeInstanceTemplateByCatalogOffering {
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment: InstanceNetworkAttachmentPrototype;
  }
  export namespace InstanceTemplatePrototypeInstanceTemplateByCatalogOfferingInstanceTemplateByCatalogOfferingInstanceByNetworkAttachment {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplatePrototypeInstanceTemplateByCatalogOfferingInstanceTemplateByCatalogOfferingInstanceByNetworkInterface.
   */
  export interface InstanceTemplatePrototypeInstanceTemplateByCatalogOfferingInstanceTemplateByCatalogOfferingInstanceByNetworkInterface extends InstanceTemplatePrototypeInstanceTemplateByCatalogOffering {
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
  }
  export namespace InstanceTemplatePrototypeInstanceTemplateByCatalogOfferingInstanceTemplateByCatalogOfferingInstanceByNetworkInterface {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplatePrototypeInstanceTemplateByImageInstanceTemplateByImageInstanceByNetworkAttachment.
   */
  export interface InstanceTemplatePrototypeInstanceTemplateByImageInstanceTemplateByImageInstanceByNetworkAttachment extends InstanceTemplatePrototypeInstanceTemplateByImage {
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment: InstanceNetworkAttachmentPrototype;
  }
  export namespace InstanceTemplatePrototypeInstanceTemplateByImageInstanceTemplateByImageInstanceByNetworkAttachment {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplatePrototypeInstanceTemplateByImageInstanceTemplateByImageInstanceByNetworkInterface.
   */
  export interface InstanceTemplatePrototypeInstanceTemplateByImageInstanceTemplateByImageInstanceByNetworkInterface extends InstanceTemplatePrototypeInstanceTemplateByImage {
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
  }
  export namespace InstanceTemplatePrototypeInstanceTemplateByImageInstanceTemplateByImageInstanceByNetworkInterface {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplatePrototypeInstanceTemplateBySourceSnapshotInstanceTemplateBySourceSnapshotInstanceByNetworkAttachment.
   */
  export interface InstanceTemplatePrototypeInstanceTemplateBySourceSnapshotInstanceTemplateBySourceSnapshotInstanceByNetworkAttachment extends InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot {
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment: InstanceNetworkAttachmentPrototype;
  }
  export namespace InstanceTemplatePrototypeInstanceTemplateBySourceSnapshotInstanceTemplateBySourceSnapshotInstanceByNetworkAttachment {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplatePrototypeInstanceTemplateBySourceSnapshotInstanceTemplateBySourceSnapshotInstanceByNetworkInterface.
   */
  export interface InstanceTemplatePrototypeInstanceTemplateBySourceSnapshotInstanceTemplateBySourceSnapshotInstanceByNetworkInterface extends InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot {
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
  }
  export namespace InstanceTemplatePrototypeInstanceTemplateBySourceSnapshotInstanceTemplateBySourceSnapshotInstanceByNetworkInterface {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContextInstanceByCatalogOfferingInstanceTemplateContextInstanceByNetworkAttachment.
   */
  export interface InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContextInstanceByCatalogOfferingInstanceTemplateContextInstanceByNetworkAttachment extends InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext {
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment: InstanceNetworkAttachmentPrototype;
  }
  export namespace InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContextInstanceByCatalogOfferingInstanceTemplateContextInstanceByNetworkAttachment {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContextInstanceByCatalogOfferingInstanceTemplateContextInstanceByNetworkInterface.
   */
  export interface InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContextInstanceByCatalogOfferingInstanceTemplateContextInstanceByNetworkInterface extends InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext {
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
  }
  export namespace InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContextInstanceByCatalogOfferingInstanceTemplateContextInstanceByNetworkInterface {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplateInstanceByImageInstanceTemplateContextInstanceByImageInstanceTemplateContextInstanceByNetworkAttachment.
   */
  export interface InstanceTemplateInstanceByImageInstanceTemplateContextInstanceByImageInstanceTemplateContextInstanceByNetworkAttachment extends InstanceTemplateInstanceByImageInstanceTemplateContext {
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment: InstanceNetworkAttachmentPrototype;
  }
  export namespace InstanceTemplateInstanceByImageInstanceTemplateContextInstanceByImageInstanceTemplateContextInstanceByNetworkAttachment {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplateInstanceByImageInstanceTemplateContextInstanceByImageInstanceTemplateContextInstanceByNetworkInterface.
   */
  export interface InstanceTemplateInstanceByImageInstanceTemplateContextInstanceByImageInstanceTemplateContextInstanceByNetworkInterface extends InstanceTemplateInstanceByImageInstanceTemplateContext {
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
  }
  export namespace InstanceTemplateInstanceByImageInstanceTemplateContextInstanceByImageInstanceTemplateContextInstanceByNetworkInterface {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContextInstanceBySourceSnapshotInstanceTemplateContextInstanceByNetworkAttachment.
   */
  export interface InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContextInstanceBySourceSnapshotInstanceTemplateContextInstanceByNetworkAttachment extends InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext {
    /** The additional network attachments to create for the virtual server instance. */
    network_attachments?: InstanceNetworkAttachmentPrototype[];
    /** The primary network attachment to create for the virtual server instance. */
    primary_network_attachment: InstanceNetworkAttachmentPrototype;
  }
  export namespace InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContextInstanceBySourceSnapshotInstanceTemplateContextInstanceByNetworkAttachment {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContextInstanceBySourceSnapshotInstanceTemplateContextInstanceByNetworkInterface.
   */
  export interface InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContextInstanceBySourceSnapshotInstanceTemplateContextInstanceByNetworkInterface extends InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext {
    /** The additional instance network interfaces to create. */
    network_interfaces?: NetworkInterfacePrototype[];
    /** The primary instance network interface to create. */
    primary_network_interface: NetworkInterfacePrototype;
  }
  export namespace InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContextInstanceBySourceSnapshotInstanceTemplateContextInstanceByNetworkInterface {
    export namespace Constants {
      /** The confidential compute mode to use for this virtual server instance. If unspecified, the default confidential compute mode from the profile will be used. */
      export enum ConfidentialComputeMode {
        DISABLED = 'disabled',
        SGX = 'sgx',
        TDX = 'tdx',
      }
    }
  }

  /**
   * LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerIdentityLoadBalancerListenerIdentityByHref.
   */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerIdentityLoadBalancerListenerIdentityByHref extends LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerIdentity {
    /** The URL for this load balancer listener. */
    href: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerIdentityLoadBalancerListenerIdentityById.
   */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerIdentityLoadBalancerListenerIdentityById extends LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerIdentity {
    /** The unique identifier for this load balancer listener. */
    id: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref.
   */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref extends LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity {
    /** The URL for this load balancer pool. */
    href: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityLoadBalancerPoolIdentityById.
   */
  export interface LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityLoadBalancerPoolIdentityById extends LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity {
    /** The unique identifier for this load balancer pool. */
    id: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerIdentityLoadBalancerListenerIdentityByHref.
   */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerIdentityLoadBalancerListenerIdentityByHref extends LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerIdentity {
    /** The URL for this load balancer listener. */
    href: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerIdentityLoadBalancerListenerIdentityById.
   */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerIdentityLoadBalancerListenerIdentityById extends LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerIdentity {
    /** The unique identifier for this load balancer listener. */
    id: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref.
   */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref extends LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity {
    /** The URL for this load balancer pool. */
    href: string;
  }

  /**
   * LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityLoadBalancerPoolIdentityById.
   */
  export interface LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityLoadBalancerPoolIdentityById extends LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity {
    /** The unique identifier for this load balancer pool. */
    id: string;
  }

  /**
   * LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN.
   */
  export interface LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN extends LoadBalancerPoolMemberTargetPrototypeInstanceIdentity {
    /** The CRN for this virtual server instance. */
    crn: string;
  }

  /**
   * LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref.
   */
  export interface LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref extends LoadBalancerPoolMemberTargetPrototypeInstanceIdentity {
    /** The URL for this virtual server instance. */
    href: string;
  }

  /**
   * LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityById.
   */
  export interface LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityById extends LoadBalancerPoolMemberTargetPrototypeInstanceIdentity {
    /** The unique identifier for this virtual server instance. */
    id: string;
  }

  /**
   * LoadBalancerPoolMemberTargetPrototypeLoadBalancerIdentityLoadBalancerIdentityByCRN.
   */
  export interface LoadBalancerPoolMemberTargetPrototypeLoadBalancerIdentityLoadBalancerIdentityByCRN extends LoadBalancerPoolMemberTargetPrototypeLoadBalancerIdentity {
    /** The CRN for this load balancer. */
    crn: string;
  }

  /**
   * LoadBalancerPoolMemberTargetPrototypeLoadBalancerIdentityLoadBalancerIdentityByHref.
   */
  export interface LoadBalancerPoolMemberTargetPrototypeLoadBalancerIdentityLoadBalancerIdentityByHref extends LoadBalancerPoolMemberTargetPrototypeLoadBalancerIdentity {
    /** The URL for this load balancer. */
    href: string;
  }

  /**
   * LoadBalancerPoolMemberTargetPrototypeLoadBalancerIdentityLoadBalancerIdentityById.
   */
  export interface LoadBalancerPoolMemberTargetPrototypeLoadBalancerIdentityLoadBalancerIdentityById extends LoadBalancerPoolMemberTargetPrototypeLoadBalancerIdentity {
    /** The unique identifier for this load balancer. */
    id: string;
  }

  /**
   * NetworkInterfaceIPPrototypeReservedIPIdentityByHref.
   */
  export interface NetworkInterfaceIPPrototypeReservedIPIdentityByHref extends NetworkInterfaceIPPrototypeReservedIPIdentity {
    /** The URL for this reserved IP. */
    href: string;
  }

  /**
   * NetworkInterfaceIPPrototypeReservedIPIdentityById.
   */
  export interface NetworkInterfaceIPPrototypeReservedIPIdentityById extends NetworkInterfaceIPPrototypeReservedIPIdentity {
    /** The unique identifier for this reserved IP. */
    id: string;
  }

  /**
   * PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress.
   */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress extends PublicGatewayFloatingIPPrototypeFloatingIPIdentity {
    /** The globally unique IP address. */
    address: string;
  }

  /**
   * PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN.
   */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN extends PublicGatewayFloatingIPPrototypeFloatingIPIdentity {
    /** The CRN for this floating IP. */
    crn: string;
  }

  /**
   * PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref.
   */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref extends PublicGatewayFloatingIPPrototypeFloatingIPIdentity {
    /** The URL for this floating IP. */
    href: string;
  }

  /**
   * PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityById.
   */
  export interface PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityById extends PublicGatewayFloatingIPPrototypeFloatingIPIdentity {
    /** The unique identifier for this floating IP. */
    id: string;
  }

  /**
   * ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN.
   */
  export interface ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN extends ReservedIPTargetPrototypeEndpointGatewayIdentity {
    /** The CRN for this endpoint gateway. */
    crn: string;
  }

  /**
   * ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref.
   */
  export interface ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref extends ReservedIPTargetPrototypeEndpointGatewayIdentity {
    /** The URL for this endpoint gateway. */
    href: string;
  }

  /**
   * ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityById.
   */
  export interface ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityById extends ReservedIPTargetPrototypeEndpointGatewayIdentity {
    /** The unique identifier for this endpoint gateway. */
    id: string;
  }

  /**
   * ReservedIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN.
   */
  export interface ReservedIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN extends ReservedIPTargetPrototypeVirtualNetworkInterfaceIdentity {
    /** The CRN for this virtual network interface. */
    crn: string;
  }

  /**
   * ReservedIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref.
   */
  export interface ReservedIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref extends ReservedIPTargetPrototypeVirtualNetworkInterfaceIdentity {
    /** The URL for this virtual network interface. */
    href: string;
  }

  /**
   * ReservedIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById.
   */
  export interface ReservedIPTargetPrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById extends ReservedIPTargetPrototypeVirtualNetworkInterfaceIdentity {
    /** The unique identifier for this virtual network interface. */
    id: string;
  }

  /**
   * RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP.
   */
  export interface RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP extends RouteNextHopPatchRouteNextHopIP {
    /** The sentinel IP address (`0.0.0.0`).
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP.
   */
  export interface RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP extends RouteNextHopPatchRouteNextHopIP {
    /** A unicast IP address, which must not be any of the following values:
     *
     *  - `0.0.0.0` (the sentinel IP address)
     *  - `224.0.0.0` to `239.255.255.255` (multicast IP addresses)
     *  - `255.255.255.255` (the broadcast IP address)
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref.
   */
  export interface RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref extends RouteNextHopPatchVPNGatewayConnectionIdentity {
    /** The URL for this VPN gateway connection. */
    href: string;
  }

  /**
   * RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityById.
   */
  export interface RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityById extends RouteNextHopPatchVPNGatewayConnectionIdentity {
    /** The unique identifier for this VPN gateway connection. */
    id: string;
  }

  /**
   * RouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP.
   */
  export interface RouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP extends RouteNextHopPrototypeRouteNextHopIP {
    /** The sentinel IP address (`0.0.0.0`).
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * RouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP.
   */
  export interface RouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP extends RouteNextHopPrototypeRouteNextHopIP {
    /** A unicast IP address, which must not be any of the following values:
     *
     *  - `0.0.0.0` (the sentinel IP address)
     *  - `224.0.0.0` to `239.255.255.255` (multicast IP addresses)
     *  - `255.255.255.255` (the broadcast IP address)
     *
     *  This property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) to support IPv6 addresses
     *  in the future.
     */
    address: string;
  }

  /**
   * RouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref.
   */
  export interface RouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref extends RouteNextHopPrototypeVPNGatewayConnectionIdentity {
    /** The URL for this VPN gateway connection. */
    href: string;
  }

  /**
   * RouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityById.
   */
  export interface RouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityById extends RouteNextHopPrototypeVPNGatewayConnectionIdentity {
    /** The unique identifier for this VPN gateway connection. */
    id: string;
  }

  /**
   * SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN.
   */
  export interface SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN extends SecurityGroupRuleRemotePatchSecurityGroupIdentity {
    /** The CRN for this security group. */
    crn: string;
  }

  /**
   * SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref.
   */
  export interface SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref extends SecurityGroupRuleRemotePatchSecurityGroupIdentity {
    /** The URL for this security group. */
    href: string;
  }

  /**
   * SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityById.
   */
  export interface SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityById extends SecurityGroupRuleRemotePatchSecurityGroupIdentity {
    /** The unique identifier for this security group. */
    id: string;
  }

  /**
   * SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN.
   */
  export interface SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN extends SecurityGroupRuleRemotePrototypeSecurityGroupIdentity {
    /** The CRN for this security group. */
    crn: string;
  }

  /**
   * SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref.
   */
  export interface SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref extends SecurityGroupRuleRemotePrototypeSecurityGroupIdentity {
    /** The URL for this security group. */
    href: string;
  }

  /**
   * SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityById.
   */
  export interface SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityById extends SecurityGroupRuleRemotePrototypeSecurityGroupIdentity {
    /** The unique identifier for this security group. */
    id: string;
  }

  /**
   * ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN.
   */
  export interface ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByCRN extends ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfaceIdentity {
    /** The CRN for this virtual network interface. */
    crn: string;
  }

  /**
   * ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref.
   */
  export interface ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityByHref extends ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfaceIdentity {
    /** The URL for this virtual network interface. */
    href: string;
  }

  /**
   * ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById.
   */
  export interface ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfaceIdentityVirtualNetworkInterfaceIdentityById extends ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfaceIdentity {
    /** The unique identifier for this virtual network interface. */
    id: string;
  }

  /**
   * ShareSourceSnapshotPrototypeShareSnapshotIdentityShareSnapshotIdentityByCRN.
   */
  export interface ShareSourceSnapshotPrototypeShareSnapshotIdentityShareSnapshotIdentityByCRN extends ShareSourceSnapshotPrototypeShareSnapshotIdentity {
    /** The CRN for this share snapshot. */
    crn: string;
  }

  /**
   * ShareSourceSnapshotPrototypeShareSnapshotIdentityShareSnapshotIdentityByHref.
   */
  export interface ShareSourceSnapshotPrototypeShareSnapshotIdentityShareSnapshotIdentityByHref extends ShareSourceSnapshotPrototypeShareSnapshotIdentity {
    /** The URL for this share snapshot. */
    href: string;
  }

  /**
   * ShareSourceSnapshotPrototypeShareSnapshotIdentityShareSnapshotIdentityById.
   */
  export interface ShareSourceSnapshotPrototypeShareSnapshotIdentityShareSnapshotIdentityById extends ShareSourceSnapshotPrototypeShareSnapshotIdentity {
    /** The unique identifier for this share snapshot. */
    id: string;
  }

  /**
   * VPNGatewayConnectionPeerPatchVPNGatewayConnectionPolicyModePeerPatchVPNGatewayConnectionPolicyModePeerPatchVPNGatewayConnectionPeerAddressPatch.
   */
  export interface VPNGatewayConnectionPeerPatchVPNGatewayConnectionPolicyModePeerPatchVPNGatewayConnectionPolicyModePeerPatchVPNGatewayConnectionPeerAddressPatch extends VPNGatewayConnectionPeerPatchVPNGatewayConnectionPolicyModePeerPatch {
    /** The IP address of the peer VPN gateway for this connection. */
    address?: string;
  }

  /**
   * VPNGatewayConnectionPeerPatchVPNGatewayConnectionPolicyModePeerPatchVPNGatewayConnectionPolicyModePeerPatchVPNGatewayConnectionPeerFQDNPatch.
   */
  export interface VPNGatewayConnectionPeerPatchVPNGatewayConnectionPolicyModePeerPatchVPNGatewayConnectionPolicyModePeerPatchVPNGatewayConnectionPeerFQDNPatch extends VPNGatewayConnectionPeerPatchVPNGatewayConnectionPolicyModePeerPatch {
    /** The FQDN of the peer VPN gateway for this connection. */
    fqdn?: string;
  }

  /**
   * VPNGatewayConnectionPeerPatchVPNGatewayConnectionStaticRouteModePeerPatchVPNGatewayConnectionStaticRouteModePeerPatchVPNGatewayConnectionPeerAddressPatch.
   */
  export interface VPNGatewayConnectionPeerPatchVPNGatewayConnectionStaticRouteModePeerPatchVPNGatewayConnectionStaticRouteModePeerPatchVPNGatewayConnectionPeerAddressPatch extends VPNGatewayConnectionPeerPatchVPNGatewayConnectionStaticRouteModePeerPatch {
    /** The IP address of the peer VPN gateway for this connection. */
    address?: string;
  }

  /**
   * VPNGatewayConnectionPeerPatchVPNGatewayConnectionStaticRouteModePeerPatchVPNGatewayConnectionStaticRouteModePeerPatchVPNGatewayConnectionPeerFQDNPatch.
   */
  export interface VPNGatewayConnectionPeerPatchVPNGatewayConnectionStaticRouteModePeerPatchVPNGatewayConnectionStaticRouteModePeerPatchVPNGatewayConnectionPeerFQDNPatch extends VPNGatewayConnectionPeerPatchVPNGatewayConnectionStaticRouteModePeerPatch {
    /** The FQDN of the peer VPN gateway for this connection. */
    fqdn?: string;
  }

  /**
   * VPNGatewayConnectionRouteModeVPNGatewayConnectionStaticRouteMode.
   */
  export interface VPNGatewayConnectionRouteModeVPNGatewayConnectionStaticRouteMode extends VPNGatewayConnectionRouteMode {
    /** Indicates whether the traffic is distributed between the `up` tunnels of the VPN gateway connection when the
     *  VPC route's next hop is a VPN connection. If `false`, the traffic is only routed through the `up` tunnel with
     *  the lower `public_ip` address.
     */
    distribute_traffic: boolean;
    local: VPNGatewayConnectionStaticRouteModeLocal;
    peer: VPNGatewayConnectionStaticRouteModePeer;
    /** Routing protocols are disabled for this VPN gateway connection. */
    routing_protocol: VPNGatewayConnectionRouteModeVPNGatewayConnectionStaticRouteMode.Constants.RoutingProtocol | string;
    /** The VPN tunnel configuration for this VPN gateway connection (in static route mode). */
    tunnels: VPNGatewayConnectionStaticRouteModeTunnel[];
  }
  export namespace VPNGatewayConnectionRouteModeVPNGatewayConnectionStaticRouteMode {
    export namespace Constants {
      /** The authentication mode. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum AuthenticationMode {
        PSK = 'psk',
      }
      /** The establish mode of the VPN gateway connection: - `bidirectional`: Either side of the VPN gateway can initiate IKE protocol negotiations or rekeying processes. - `peer_only`: Only the peer can initiate IKE protocol negotiations for this VPN gateway connection. Additionally, the peer is responsible for initiating the rekeying process after the connection is established. If rekeying does not occur, the VPN gateway connection will be brought down after its lifetime expires. */
      export enum EstablishMode {
        BIDIRECTIONAL = 'bidirectional',
        PEER_ONLY = 'peer_only',
      }
      /** The mode of the VPN gateway. The enumerated values for this property may [expand](https://cloud.ibm.com/apidocs/vpc#property-value-expansion) in the future. */
      export enum Mode {
        POLICY = 'policy',
        ROUTE = 'route',
      }
      /** The resource type. */
      export enum ResourceType {
        VPN_GATEWAY_CONNECTION = 'vpn_gateway_connection',
      }
      /** The status of a VPN gateway connection. */
      export enum Status {
        DOWN = 'down',
        UP = 'up',
      }
      /** Routing protocols are disabled for this VPN gateway connection. */
      export enum RoutingProtocol {
        NONE = 'none',
      }
    }
  }

  /**
   * VirtualNetworkInterfaceIPPrototypeReservedIPIdentityVirtualNetworkInterfaceIPsContextByHref.
   */
  export interface VirtualNetworkInterfaceIPPrototypeReservedIPIdentityVirtualNetworkInterfaceIPsContextByHref extends VirtualNetworkInterfaceIPPrototypeReservedIPIdentityVirtualNetworkInterfaceIPsContext {
    /** The URL for this reserved IP. */
    href: string;
  }

  /**
   * VirtualNetworkInterfaceIPPrototypeReservedIPIdentityVirtualNetworkInterfaceIPsContextById.
   */
  export interface VirtualNetworkInterfaceIPPrototypeReservedIPIdentityVirtualNetworkInterfaceIPsContextById extends VirtualNetworkInterfaceIPPrototypeReservedIPIdentityVirtualNetworkInterfaceIPsContext {
    /** The unique identifier for this reserved IP. */
    id: string;
  }

  /**
   * VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref.
   */
  export interface VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref extends VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext {
    /** The URL for this reserved IP. */
    href: string;
  }

  /**
   * VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextById.
   */
  export interface VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextById extends VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext {
    /** The unique identifier for this reserved IP. */
    id: string;
  }

  /**
   * VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN.
   */
  export interface VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN extends VolumeAttachmentPrototypeVolumeVolumeIdentity {
    /** The CRN for this volume. */
    crn: string;
  }

  /**
   * VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref.
   */
  export interface VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref extends VolumeAttachmentPrototypeVolumeVolumeIdentity {
    /** The URL for this volume. */
    href: string;
  }

  /**
   * VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityById.
   */
  export interface VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityById extends VolumeAttachmentPrototypeVolumeVolumeIdentity {
    /** The unique identifier for this volume. */
    id: string;
  }

  /**
   * VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity.
   */
  export interface VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity extends VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext {
    /** The capacity to use for the volume (in gigabytes). The specified value must be within the `capacity` range
     *  of the volume's profile.
     */
    capacity: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
  }

  /**
   * VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot.
   */
  export interface VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot extends VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext {
    /** The capacity to use for the volume (in gigabytes). The specified value must be at least the snapshot's
     *  `minimum_capacity`, and must be within the `capacity` range of the volume's profile.
     *
     *  If unspecified, the capacity will be the source snapshot's `minimum_capacity`.
     */
    capacity?: number;
    /** The root key to use to wrap the data encryption key for the volume.
     *
     *  If unspecified, the `encryption` type for the volume will be `provider_managed`.
     */
    encryption_key?: EncryptionKeyIdentity;
    /** The snapshot to use as a source for the volume's data.
     *
     *  The specified snapshot may be in a different account, subject to IAM policies.
     *
     *  To create a volume from a `source_snapshot`, the volume profile and the
     *  source snapshot must have the same `storage_generation` value.
     */
    source_snapshot: SnapshotIdentity;
  }

  /**
   * InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup.
   */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup extends InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec {
    group: InstanceGroupManagerScheduledActionGroupPrototype;
  }

  /**
   * InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager.
   */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager extends InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec {
    manager: InstanceGroupManagerScheduledActionManagerPrototype;
  }

  /**
   * InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup.
   */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup extends InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt {
    group: InstanceGroupManagerScheduledActionGroupPrototype;
  }

  /**
   * InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager.
   */
  export interface InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager extends InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt {
    manager: InstanceGroupManagerScheduledActionManagerPrototype;
  }

  /*************************
   * pager classes
   ************************/

  /**
   * VpcsPager can be used to simplify the use of listVpcs().
   */
  export class VpcsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpcsParams;

    /**
     * Construct a VpcsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpcs()
     * @param {Object} [params] - The parameters to be passed to listVpcs()
     * @constructor
     * @returns {VpcsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListVpcsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpcs().
     * @returns {Promise<VpcV1.VPC[]>}
     */
    public async getNext(): Promise<VpcV1.VPC[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpcs(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.vpcs;
    }

    /**
     * Returns all results by invoking listVpcs() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPC[]>}
     */
    public async getAll(): Promise<VpcV1.VPC[]> {
      const results: VPC[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpcAddressPrefixesPager can be used to simplify the use of listVpcAddressPrefixes().
   */
  export class VpcAddressPrefixesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpcAddressPrefixesParams;

    /**
     * Construct a VpcAddressPrefixesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpcAddressPrefixes()
     * @param {Object} params - The parameters to be passed to listVpcAddressPrefixes()
     * @constructor
     * @returns {VpcAddressPrefixesPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListVpcAddressPrefixesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpcAddressPrefixes().
     * @returns {Promise<VpcV1.AddressPrefix[]>}
     */
    public async getNext(): Promise<VpcV1.AddressPrefix[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpcAddressPrefixes(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.address_prefixes;
    }

    /**
     * Returns all results by invoking listVpcAddressPrefixes() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.AddressPrefix[]>}
     */
    public async getAll(): Promise<VpcV1.AddressPrefix[]> {
      const results: AddressPrefix[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpcDnsResolutionBindingsPager can be used to simplify the use of listVpcDnsResolutionBindings().
   */
  export class VpcDnsResolutionBindingsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpcDnsResolutionBindingsParams;

    /**
     * Construct a VpcDnsResolutionBindingsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpcDnsResolutionBindings()
     * @param {Object} params - The parameters to be passed to listVpcDnsResolutionBindings()
     * @constructor
     * @returns {VpcDnsResolutionBindingsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListVpcDnsResolutionBindingsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpcDnsResolutionBindings().
     * @returns {Promise<VpcV1.VPCDNSResolutionBinding[]>}
     */
    public async getNext(): Promise<VpcV1.VPCDNSResolutionBinding[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpcDnsResolutionBindings(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.dns_resolution_bindings;
    }

    /**
     * Returns all results by invoking listVpcDnsResolutionBindings() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPCDNSResolutionBinding[]>}
     */
    public async getAll(): Promise<VpcV1.VPCDNSResolutionBinding[]> {
      const results: VPCDNSResolutionBinding[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpcRoutesPager can be used to simplify the use of listVpcRoutes().
   */
  export class VpcRoutesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpcRoutesParams;

    /**
     * Construct a VpcRoutesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpcRoutes()
     * @param {Object} params - The parameters to be passed to listVpcRoutes()
     * @constructor
     * @returns {VpcRoutesPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListVpcRoutesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpcRoutes().
     * @returns {Promise<VpcV1.Route[]>}
     */
    public async getNext(): Promise<VpcV1.Route[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpcRoutes(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.routes;
    }

    /**
     * Returns all results by invoking listVpcRoutes() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Route[]>}
     */
    public async getAll(): Promise<VpcV1.Route[]> {
      const results: Route[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpcRoutingTablesPager can be used to simplify the use of listVpcRoutingTables().
   */
  export class VpcRoutingTablesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpcRoutingTablesParams;

    /**
     * Construct a VpcRoutingTablesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpcRoutingTables()
     * @param {Object} params - The parameters to be passed to listVpcRoutingTables()
     * @constructor
     * @returns {VpcRoutingTablesPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListVpcRoutingTablesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpcRoutingTables().
     * @returns {Promise<VpcV1.RoutingTable[]>}
     */
    public async getNext(): Promise<VpcV1.RoutingTable[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpcRoutingTables(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.routing_tables;
    }

    /**
     * Returns all results by invoking listVpcRoutingTables() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.RoutingTable[]>}
     */
    public async getAll(): Promise<VpcV1.RoutingTable[]> {
      const results: RoutingTable[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpcRoutingTableRoutesPager can be used to simplify the use of listVpcRoutingTableRoutes().
   */
  export class VpcRoutingTableRoutesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpcRoutingTableRoutesParams;

    /**
     * Construct a VpcRoutingTableRoutesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpcRoutingTableRoutes()
     * @param {Object} params - The parameters to be passed to listVpcRoutingTableRoutes()
     * @constructor
     * @returns {VpcRoutingTableRoutesPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListVpcRoutingTableRoutesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpcRoutingTableRoutes().
     * @returns {Promise<VpcV1.Route[]>}
     */
    public async getNext(): Promise<VpcV1.Route[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpcRoutingTableRoutes(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.routes;
    }

    /**
     * Returns all results by invoking listVpcRoutingTableRoutes() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Route[]>}
     */
    public async getAll(): Promise<VpcV1.Route[]> {
      const results: Route[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SubnetsPager can be used to simplify the use of listSubnets().
   */
  export class SubnetsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSubnetsParams;

    /**
     * Construct a SubnetsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listSubnets()
     * @param {Object} [params] - The parameters to be passed to listSubnets()
     * @constructor
     * @returns {SubnetsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListSubnetsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSubnets().
     * @returns {Promise<VpcV1.Subnet[]>}
     */
    public async getNext(): Promise<VpcV1.Subnet[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listSubnets(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.subnets;
    }

    /**
     * Returns all results by invoking listSubnets() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Subnet[]>}
     */
    public async getAll(): Promise<VpcV1.Subnet[]> {
      const results: Subnet[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SubnetReservedIpsPager can be used to simplify the use of listSubnetReservedIps().
   */
  export class SubnetReservedIpsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSubnetReservedIpsParams;

    /**
     * Construct a SubnetReservedIpsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listSubnetReservedIps()
     * @param {Object} params - The parameters to be passed to listSubnetReservedIps()
     * @constructor
     * @returns {SubnetReservedIpsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListSubnetReservedIpsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSubnetReservedIps().
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getNext(): Promise<VpcV1.ReservedIP[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listSubnetReservedIps(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.reserved_ips;
    }

    /**
     * Returns all results by invoking listSubnetReservedIps() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getAll(): Promise<VpcV1.ReservedIP[]> {
      const results: ReservedIP[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ImagesPager can be used to simplify the use of listImages().
   */
  export class ImagesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListImagesParams;

    /**
     * Construct a ImagesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listImages()
     * @param {Object} [params] - The parameters to be passed to listImages()
     * @constructor
     * @returns {ImagesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListImagesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listImages().
     * @returns {Promise<VpcV1.Image[]>}
     */
    public async getNext(): Promise<VpcV1.Image[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listImages(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.images;
    }

    /**
     * Returns all results by invoking listImages() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Image[]>}
     */
    public async getAll(): Promise<VpcV1.Image[]> {
      const results: Image[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * OperatingSystemsPager can be used to simplify the use of listOperatingSystems().
   */
  export class OperatingSystemsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListOperatingSystemsParams;

    /**
     * Construct a OperatingSystemsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listOperatingSystems()
     * @param {Object} [params] - The parameters to be passed to listOperatingSystems()
     * @constructor
     * @returns {OperatingSystemsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListOperatingSystemsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listOperatingSystems().
     * @returns {Promise<VpcV1.OperatingSystem[]>}
     */
    public async getNext(): Promise<VpcV1.OperatingSystem[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listOperatingSystems(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.operating_systems;
    }

    /**
     * Returns all results by invoking listOperatingSystems() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.OperatingSystem[]>}
     */
    public async getAll(): Promise<VpcV1.OperatingSystem[]> {
      const results: OperatingSystem[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * KeysPager can be used to simplify the use of listKeys().
   */
  export class KeysPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListKeysParams;

    /**
     * Construct a KeysPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listKeys()
     * @param {Object} [params] - The parameters to be passed to listKeys()
     * @constructor
     * @returns {KeysPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListKeysParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listKeys().
     * @returns {Promise<VpcV1.Key[]>}
     */
    public async getNext(): Promise<VpcV1.Key[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listKeys(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.keys;
    }

    /**
     * Returns all results by invoking listKeys() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Key[]>}
     */
    public async getAll(): Promise<VpcV1.Key[]> {
      const results: Key[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstancesPager can be used to simplify the use of listInstances().
   */
  export class InstancesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstancesParams;

    /**
     * Construct a InstancesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstances()
     * @param {Object} [params] - The parameters to be passed to listInstances()
     * @constructor
     * @returns {InstancesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListInstancesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstances().
     * @returns {Promise<VpcV1.Instance[]>}
     */
    public async getNext(): Promise<VpcV1.Instance[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstances(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.instances;
    }

    /**
     * Returns all results by invoking listInstances() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Instance[]>}
     */
    public async getAll(): Promise<VpcV1.Instance[]> {
      const results: Instance[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceClusterNetworkAttachmentsPager can be used to simplify the use of listInstanceClusterNetworkAttachments().
   */
  export class InstanceClusterNetworkAttachmentsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceClusterNetworkAttachmentsParams;

    /**
     * Construct a InstanceClusterNetworkAttachmentsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceClusterNetworkAttachments()
     * @param {Object} params - The parameters to be passed to listInstanceClusterNetworkAttachments()
     * @constructor
     * @returns {InstanceClusterNetworkAttachmentsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListInstanceClusterNetworkAttachmentsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceClusterNetworkAttachments().
     * @returns {Promise<VpcV1.InstanceClusterNetworkAttachment[]>}
     */
    public async getNext(): Promise<VpcV1.InstanceClusterNetworkAttachment[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceClusterNetworkAttachments(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.cluster_network_attachments;
    }

    /**
     * Returns all results by invoking listInstanceClusterNetworkAttachments() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.InstanceClusterNetworkAttachment[]>}
     */
    public async getAll(): Promise<VpcV1.InstanceClusterNetworkAttachment[]> {
      const results: InstanceClusterNetworkAttachment[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceNetworkInterfaceIpsPager can be used to simplify the use of listInstanceNetworkInterfaceIps().
   */
  export class InstanceNetworkInterfaceIpsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceNetworkInterfaceIpsParams;

    /**
     * Construct a InstanceNetworkInterfaceIpsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceNetworkInterfaceIps()
     * @param {Object} params - The parameters to be passed to listInstanceNetworkInterfaceIps()
     * @constructor
     * @returns {InstanceNetworkInterfaceIpsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListInstanceNetworkInterfaceIpsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceNetworkInterfaceIps().
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getNext(): Promise<VpcV1.ReservedIP[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceNetworkInterfaceIps(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.ips;
    }

    /**
     * Returns all results by invoking listInstanceNetworkInterfaceIps() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getAll(): Promise<VpcV1.ReservedIP[]> {
      const results: ReservedIP[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceGroupsPager can be used to simplify the use of listInstanceGroups().
   */
  export class InstanceGroupsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceGroupsParams;

    /**
     * Construct a InstanceGroupsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceGroups()
     * @param {Object} [params] - The parameters to be passed to listInstanceGroups()
     * @constructor
     * @returns {InstanceGroupsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListInstanceGroupsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceGroups().
     * @returns {Promise<VpcV1.InstanceGroup[]>}
     */
    public async getNext(): Promise<VpcV1.InstanceGroup[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceGroups(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.instance_groups;
    }

    /**
     * Returns all results by invoking listInstanceGroups() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.InstanceGroup[]>}
     */
    public async getAll(): Promise<VpcV1.InstanceGroup[]> {
      const results: InstanceGroup[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceGroupManagersPager can be used to simplify the use of listInstanceGroupManagers().
   */
  export class InstanceGroupManagersPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceGroupManagersParams;

    /**
     * Construct a InstanceGroupManagersPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceGroupManagers()
     * @param {Object} params - The parameters to be passed to listInstanceGroupManagers()
     * @constructor
     * @returns {InstanceGroupManagersPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListInstanceGroupManagersParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceGroupManagers().
     * @returns {Promise<VpcV1.InstanceGroupManager[]>}
     */
    public async getNext(): Promise<VpcV1.InstanceGroupManager[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceGroupManagers(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.managers;
    }

    /**
     * Returns all results by invoking listInstanceGroupManagers() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.InstanceGroupManager[]>}
     */
    public async getAll(): Promise<VpcV1.InstanceGroupManager[]> {
      const results: InstanceGroupManager[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceGroupManagerActionsPager can be used to simplify the use of listInstanceGroupManagerActions().
   */
  export class InstanceGroupManagerActionsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceGroupManagerActionsParams;

    /**
     * Construct a InstanceGroupManagerActionsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceGroupManagerActions()
     * @param {Object} params - The parameters to be passed to listInstanceGroupManagerActions()
     * @constructor
     * @returns {InstanceGroupManagerActionsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListInstanceGroupManagerActionsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceGroupManagerActions().
     * @returns {Promise<VpcV1.InstanceGroupManagerAction[]>}
     */
    public async getNext(): Promise<VpcV1.InstanceGroupManagerAction[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceGroupManagerActions(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.actions;
    }

    /**
     * Returns all results by invoking listInstanceGroupManagerActions() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.InstanceGroupManagerAction[]>}
     */
    public async getAll(): Promise<VpcV1.InstanceGroupManagerAction[]> {
      const results: InstanceGroupManagerAction[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceGroupManagerPoliciesPager can be used to simplify the use of listInstanceGroupManagerPolicies().
   */
  export class InstanceGroupManagerPoliciesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceGroupManagerPoliciesParams;

    /**
     * Construct a InstanceGroupManagerPoliciesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceGroupManagerPolicies()
     * @param {Object} params - The parameters to be passed to listInstanceGroupManagerPolicies()
     * @constructor
     * @returns {InstanceGroupManagerPoliciesPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListInstanceGroupManagerPoliciesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceGroupManagerPolicies().
     * @returns {Promise<VpcV1.InstanceGroupManagerPolicy[]>}
     */
    public async getNext(): Promise<VpcV1.InstanceGroupManagerPolicy[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceGroupManagerPolicies(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.policies;
    }

    /**
     * Returns all results by invoking listInstanceGroupManagerPolicies() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.InstanceGroupManagerPolicy[]>}
     */
    public async getAll(): Promise<VpcV1.InstanceGroupManagerPolicy[]> {
      const results: InstanceGroupManagerPolicy[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * InstanceGroupMembershipsPager can be used to simplify the use of listInstanceGroupMemberships().
   */
  export class InstanceGroupMembershipsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListInstanceGroupMembershipsParams;

    /**
     * Construct a InstanceGroupMembershipsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listInstanceGroupMemberships()
     * @param {Object} params - The parameters to be passed to listInstanceGroupMemberships()
     * @constructor
     * @returns {InstanceGroupMembershipsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListInstanceGroupMembershipsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listInstanceGroupMemberships().
     * @returns {Promise<VpcV1.InstanceGroupMembership[]>}
     */
    public async getNext(): Promise<VpcV1.InstanceGroupMembership[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listInstanceGroupMemberships(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.memberships;
    }

    /**
     * Returns all results by invoking listInstanceGroupMemberships() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.InstanceGroupMembership[]>}
     */
    public async getAll(): Promise<VpcV1.InstanceGroupMembership[]> {
      const results: InstanceGroupMembership[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ReservationsPager can be used to simplify the use of listReservations().
   */
  export class ReservationsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListReservationsParams;

    /**
     * Construct a ReservationsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listReservations()
     * @param {Object} [params] - The parameters to be passed to listReservations()
     * @constructor
     * @returns {ReservationsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListReservationsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listReservations().
     * @returns {Promise<VpcV1.Reservation[]>}
     */
    public async getNext(): Promise<VpcV1.Reservation[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listReservations(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.reservations;
    }

    /**
     * Returns all results by invoking listReservations() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Reservation[]>}
     */
    public async getAll(): Promise<VpcV1.Reservation[]> {
      const results: Reservation[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * DedicatedHostGroupsPager can be used to simplify the use of listDedicatedHostGroups().
   */
  export class DedicatedHostGroupsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListDedicatedHostGroupsParams;

    /**
     * Construct a DedicatedHostGroupsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listDedicatedHostGroups()
     * @param {Object} [params] - The parameters to be passed to listDedicatedHostGroups()
     * @constructor
     * @returns {DedicatedHostGroupsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListDedicatedHostGroupsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listDedicatedHostGroups().
     * @returns {Promise<VpcV1.DedicatedHostGroup[]>}
     */
    public async getNext(): Promise<VpcV1.DedicatedHostGroup[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listDedicatedHostGroups(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.groups;
    }

    /**
     * Returns all results by invoking listDedicatedHostGroups() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.DedicatedHostGroup[]>}
     */
    public async getAll(): Promise<VpcV1.DedicatedHostGroup[]> {
      const results: DedicatedHostGroup[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * DedicatedHostProfilesPager can be used to simplify the use of listDedicatedHostProfiles().
   */
  export class DedicatedHostProfilesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListDedicatedHostProfilesParams;

    /**
     * Construct a DedicatedHostProfilesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listDedicatedHostProfiles()
     * @param {Object} [params] - The parameters to be passed to listDedicatedHostProfiles()
     * @constructor
     * @returns {DedicatedHostProfilesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListDedicatedHostProfilesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listDedicatedHostProfiles().
     * @returns {Promise<VpcV1.DedicatedHostProfile[]>}
     */
    public async getNext(): Promise<VpcV1.DedicatedHostProfile[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listDedicatedHostProfiles(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.profiles;
    }

    /**
     * Returns all results by invoking listDedicatedHostProfiles() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.DedicatedHostProfile[]>}
     */
    public async getAll(): Promise<VpcV1.DedicatedHostProfile[]> {
      const results: DedicatedHostProfile[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * DedicatedHostsPager can be used to simplify the use of listDedicatedHosts().
   */
  export class DedicatedHostsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListDedicatedHostsParams;

    /**
     * Construct a DedicatedHostsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listDedicatedHosts()
     * @param {Object} [params] - The parameters to be passed to listDedicatedHosts()
     * @constructor
     * @returns {DedicatedHostsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListDedicatedHostsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listDedicatedHosts().
     * @returns {Promise<VpcV1.DedicatedHost[]>}
     */
    public async getNext(): Promise<VpcV1.DedicatedHost[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listDedicatedHosts(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.dedicated_hosts;
    }

    /**
     * Returns all results by invoking listDedicatedHosts() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.DedicatedHost[]>}
     */
    public async getAll(): Promise<VpcV1.DedicatedHost[]> {
      const results: DedicatedHost[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * PlacementGroupsPager can be used to simplify the use of listPlacementGroups().
   */
  export class PlacementGroupsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListPlacementGroupsParams;

    /**
     * Construct a PlacementGroupsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listPlacementGroups()
     * @param {Object} [params] - The parameters to be passed to listPlacementGroups()
     * @constructor
     * @returns {PlacementGroupsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListPlacementGroupsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listPlacementGroups().
     * @returns {Promise<VpcV1.PlacementGroup[]>}
     */
    public async getNext(): Promise<VpcV1.PlacementGroup[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listPlacementGroups(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.placement_groups;
    }

    /**
     * Returns all results by invoking listPlacementGroups() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.PlacementGroup[]>}
     */
    public async getAll(): Promise<VpcV1.PlacementGroup[]> {
      const results: PlacementGroup[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * BareMetalServerProfilesPager can be used to simplify the use of listBareMetalServerProfiles().
   */
  export class BareMetalServerProfilesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListBareMetalServerProfilesParams;

    /**
     * Construct a BareMetalServerProfilesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listBareMetalServerProfiles()
     * @param {Object} [params] - The parameters to be passed to listBareMetalServerProfiles()
     * @constructor
     * @returns {BareMetalServerProfilesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListBareMetalServerProfilesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listBareMetalServerProfiles().
     * @returns {Promise<VpcV1.BareMetalServerProfile[]>}
     */
    public async getNext(): Promise<VpcV1.BareMetalServerProfile[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listBareMetalServerProfiles(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.profiles;
    }

    /**
     * Returns all results by invoking listBareMetalServerProfiles() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.BareMetalServerProfile[]>}
     */
    public async getAll(): Promise<VpcV1.BareMetalServerProfile[]> {
      const results: BareMetalServerProfile[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * BareMetalServersPager can be used to simplify the use of listBareMetalServers().
   */
  export class BareMetalServersPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListBareMetalServersParams;

    /**
     * Construct a BareMetalServersPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listBareMetalServers()
     * @param {Object} [params] - The parameters to be passed to listBareMetalServers()
     * @constructor
     * @returns {BareMetalServersPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListBareMetalServersParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listBareMetalServers().
     * @returns {Promise<VpcV1.BareMetalServer[]>}
     */
    public async getNext(): Promise<VpcV1.BareMetalServer[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listBareMetalServers(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.bare_metal_servers;
    }

    /**
     * Returns all results by invoking listBareMetalServers() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.BareMetalServer[]>}
     */
    public async getAll(): Promise<VpcV1.BareMetalServer[]> {
      const results: BareMetalServer[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * BareMetalServerNetworkAttachmentsPager can be used to simplify the use of listBareMetalServerNetworkAttachments().
   */
  export class BareMetalServerNetworkAttachmentsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListBareMetalServerNetworkAttachmentsParams;

    /**
     * Construct a BareMetalServerNetworkAttachmentsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listBareMetalServerNetworkAttachments()
     * @param {Object} params - The parameters to be passed to listBareMetalServerNetworkAttachments()
     * @constructor
     * @returns {BareMetalServerNetworkAttachmentsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListBareMetalServerNetworkAttachmentsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listBareMetalServerNetworkAttachments().
     * @returns {Promise<VpcV1.BareMetalServerNetworkAttachment[]>}
     */
    public async getNext(): Promise<VpcV1.BareMetalServerNetworkAttachment[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listBareMetalServerNetworkAttachments(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.network_attachments;
    }

    /**
     * Returns all results by invoking listBareMetalServerNetworkAttachments() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.BareMetalServerNetworkAttachment[]>}
     */
    public async getAll(): Promise<VpcV1.BareMetalServerNetworkAttachment[]> {
      const results: BareMetalServerNetworkAttachment[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * BareMetalServerNetworkInterfacesPager can be used to simplify the use of listBareMetalServerNetworkInterfaces().
   */
  export class BareMetalServerNetworkInterfacesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListBareMetalServerNetworkInterfacesParams;

    /**
     * Construct a BareMetalServerNetworkInterfacesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listBareMetalServerNetworkInterfaces()
     * @param {Object} params - The parameters to be passed to listBareMetalServerNetworkInterfaces()
     * @constructor
     * @returns {BareMetalServerNetworkInterfacesPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListBareMetalServerNetworkInterfacesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listBareMetalServerNetworkInterfaces().
     * @returns {Promise<VpcV1.BareMetalServerNetworkInterface[]>}
     */
    public async getNext(): Promise<VpcV1.BareMetalServerNetworkInterface[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listBareMetalServerNetworkInterfaces(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.network_interfaces;
    }

    /**
     * Returns all results by invoking listBareMetalServerNetworkInterfaces() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.BareMetalServerNetworkInterface[]>}
     */
    public async getAll(): Promise<VpcV1.BareMetalServerNetworkInterface[]> {
      const results: BareMetalServerNetworkInterface[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VolumeProfilesPager can be used to simplify the use of listVolumeProfiles().
   */
  export class VolumeProfilesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVolumeProfilesParams;

    /**
     * Construct a VolumeProfilesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVolumeProfiles()
     * @param {Object} [params] - The parameters to be passed to listVolumeProfiles()
     * @constructor
     * @returns {VolumeProfilesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListVolumeProfilesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVolumeProfiles().
     * @returns {Promise<VpcV1.VolumeProfile[]>}
     */
    public async getNext(): Promise<VpcV1.VolumeProfile[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVolumeProfiles(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.profiles;
    }

    /**
     * Returns all results by invoking listVolumeProfiles() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VolumeProfile[]>}
     */
    public async getAll(): Promise<VpcV1.VolumeProfile[]> {
      const results: VolumeProfile[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VolumesPager can be used to simplify the use of listVolumes().
   */
  export class VolumesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVolumesParams;

    /**
     * Construct a VolumesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVolumes()
     * @param {Object} [params] - The parameters to be passed to listVolumes()
     * @constructor
     * @returns {VolumesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListVolumesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVolumes().
     * @returns {Promise<VpcV1.Volume[]>}
     */
    public async getNext(): Promise<VpcV1.Volume[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVolumes(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.volumes;
    }

    /**
     * Returns all results by invoking listVolumes() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Volume[]>}
     */
    public async getAll(): Promise<VpcV1.Volume[]> {
      const results: Volume[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SnapshotConsistencyGroupsPager can be used to simplify the use of listSnapshotConsistencyGroups().
   */
  export class SnapshotConsistencyGroupsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSnapshotConsistencyGroupsParams;

    /**
     * Construct a SnapshotConsistencyGroupsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listSnapshotConsistencyGroups()
     * @param {Object} [params] - The parameters to be passed to listSnapshotConsistencyGroups()
     * @constructor
     * @returns {SnapshotConsistencyGroupsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListSnapshotConsistencyGroupsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSnapshotConsistencyGroups().
     * @returns {Promise<VpcV1.SnapshotConsistencyGroup[]>}
     */
    public async getNext(): Promise<VpcV1.SnapshotConsistencyGroup[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listSnapshotConsistencyGroups(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.snapshot_consistency_groups;
    }

    /**
     * Returns all results by invoking listSnapshotConsistencyGroups() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.SnapshotConsistencyGroup[]>}
     */
    public async getAll(): Promise<VpcV1.SnapshotConsistencyGroup[]> {
      const results: SnapshotConsistencyGroup[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SnapshotsPager can be used to simplify the use of listSnapshots().
   */
  export class SnapshotsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSnapshotsParams;

    /**
     * Construct a SnapshotsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listSnapshots()
     * @param {Object} [params] - The parameters to be passed to listSnapshots()
     * @constructor
     * @returns {SnapshotsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListSnapshotsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSnapshots().
     * @returns {Promise<VpcV1.Snapshot[]>}
     */
    public async getNext(): Promise<VpcV1.Snapshot[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listSnapshots(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.snapshots;
    }

    /**
     * Returns all results by invoking listSnapshots() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Snapshot[]>}
     */
    public async getAll(): Promise<VpcV1.Snapshot[]> {
      const results: Snapshot[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ShareProfilesPager can be used to simplify the use of listShareProfiles().
   */
  export class ShareProfilesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListShareProfilesParams;

    /**
     * Construct a ShareProfilesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listShareProfiles()
     * @param {Object} [params] - The parameters to be passed to listShareProfiles()
     * @constructor
     * @returns {ShareProfilesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListShareProfilesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listShareProfiles().
     * @returns {Promise<VpcV1.ShareProfile[]>}
     */
    public async getNext(): Promise<VpcV1.ShareProfile[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listShareProfiles(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.profiles;
    }

    /**
     * Returns all results by invoking listShareProfiles() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ShareProfile[]>}
     */
    public async getAll(): Promise<VpcV1.ShareProfile[]> {
      const results: ShareProfile[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SharesPager can be used to simplify the use of listShares().
   */
  export class SharesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSharesParams;

    /**
     * Construct a SharesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listShares()
     * @param {Object} [params] - The parameters to be passed to listShares()
     * @constructor
     * @returns {SharesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListSharesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listShares().
     * @returns {Promise<VpcV1.Share[]>}
     */
    public async getNext(): Promise<VpcV1.Share[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listShares(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.shares;
    }

    /**
     * Returns all results by invoking listShares() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.Share[]>}
     */
    public async getAll(): Promise<VpcV1.Share[]> {
      const results: Share[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ShareAccessorBindingsPager can be used to simplify the use of listShareAccessorBindings().
   */
  export class ShareAccessorBindingsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListShareAccessorBindingsParams;

    /**
     * Construct a ShareAccessorBindingsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listShareAccessorBindings()
     * @param {Object} params - The parameters to be passed to listShareAccessorBindings()
     * @constructor
     * @returns {ShareAccessorBindingsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListShareAccessorBindingsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listShareAccessorBindings().
     * @returns {Promise<VpcV1.ShareAccessorBinding[]>}
     */
    public async getNext(): Promise<VpcV1.ShareAccessorBinding[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listShareAccessorBindings(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.accessor_bindings;
    }

    /**
     * Returns all results by invoking listShareAccessorBindings() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ShareAccessorBinding[]>}
     */
    public async getAll(): Promise<VpcV1.ShareAccessorBinding[]> {
      const results: ShareAccessorBinding[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ShareMountTargetsPager can be used to simplify the use of listShareMountTargets().
   */
  export class ShareMountTargetsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListShareMountTargetsParams;

    /**
     * Construct a ShareMountTargetsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listShareMountTargets()
     * @param {Object} params - The parameters to be passed to listShareMountTargets()
     * @constructor
     * @returns {ShareMountTargetsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListShareMountTargetsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listShareMountTargets().
     * @returns {Promise<VpcV1.ShareMountTarget[]>}
     */
    public async getNext(): Promise<VpcV1.ShareMountTarget[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listShareMountTargets(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.mount_targets;
    }

    /**
     * Returns all results by invoking listShareMountTargets() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ShareMountTarget[]>}
     */
    public async getAll(): Promise<VpcV1.ShareMountTarget[]> {
      const results: ShareMountTarget[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ShareSnapshotsPager can be used to simplify the use of listShareSnapshots().
   */
  export class ShareSnapshotsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListShareSnapshotsParams;

    /**
     * Construct a ShareSnapshotsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listShareSnapshots()
     * @param {Object} params - The parameters to be passed to listShareSnapshots()
     * @constructor
     * @returns {ShareSnapshotsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListShareSnapshotsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listShareSnapshots().
     * @returns {Promise<VpcV1.ShareSnapshot[]>}
     */
    public async getNext(): Promise<VpcV1.ShareSnapshot[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listShareSnapshots(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.snapshots;
    }

    /**
     * Returns all results by invoking listShareSnapshots() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ShareSnapshot[]>}
     */
    public async getAll(): Promise<VpcV1.ShareSnapshot[]> {
      const results: ShareSnapshot[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * BackupPoliciesPager can be used to simplify the use of listBackupPolicies().
   */
  export class BackupPoliciesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListBackupPoliciesParams;

    /**
     * Construct a BackupPoliciesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listBackupPolicies()
     * @param {Object} [params] - The parameters to be passed to listBackupPolicies()
     * @constructor
     * @returns {BackupPoliciesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListBackupPoliciesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listBackupPolicies().
     * @returns {Promise<VpcV1.BackupPolicy[]>}
     */
    public async getNext(): Promise<VpcV1.BackupPolicy[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listBackupPolicies(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.backup_policies;
    }

    /**
     * Returns all results by invoking listBackupPolicies() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.BackupPolicy[]>}
     */
    public async getAll(): Promise<VpcV1.BackupPolicy[]> {
      const results: BackupPolicy[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * BackupPolicyJobsPager can be used to simplify the use of listBackupPolicyJobs().
   */
  export class BackupPolicyJobsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListBackupPolicyJobsParams;

    /**
     * Construct a BackupPolicyJobsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listBackupPolicyJobs()
     * @param {Object} params - The parameters to be passed to listBackupPolicyJobs()
     * @constructor
     * @returns {BackupPolicyJobsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListBackupPolicyJobsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listBackupPolicyJobs().
     * @returns {Promise<VpcV1.BackupPolicyJob[]>}
     */
    public async getNext(): Promise<VpcV1.BackupPolicyJob[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listBackupPolicyJobs(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.jobs;
    }

    /**
     * Returns all results by invoking listBackupPolicyJobs() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.BackupPolicyJob[]>}
     */
    public async getAll(): Promise<VpcV1.BackupPolicyJob[]> {
      const results: BackupPolicyJob[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VirtualNetworkInterfacesPager can be used to simplify the use of listVirtualNetworkInterfaces().
   */
  export class VirtualNetworkInterfacesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVirtualNetworkInterfacesParams;

    /**
     * Construct a VirtualNetworkInterfacesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVirtualNetworkInterfaces()
     * @param {Object} [params] - The parameters to be passed to listVirtualNetworkInterfaces()
     * @constructor
     * @returns {VirtualNetworkInterfacesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListVirtualNetworkInterfacesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVirtualNetworkInterfaces().
     * @returns {Promise<VpcV1.VirtualNetworkInterface[]>}
     */
    public async getNext(): Promise<VpcV1.VirtualNetworkInterface[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVirtualNetworkInterfaces(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.virtual_network_interfaces;
    }

    /**
     * Returns all results by invoking listVirtualNetworkInterfaces() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VirtualNetworkInterface[]>}
     */
    public async getAll(): Promise<VpcV1.VirtualNetworkInterface[]> {
      const results: VirtualNetworkInterface[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * NetworkInterfaceFloatingIpsPager can be used to simplify the use of listNetworkInterfaceFloatingIps().
   */
  export class NetworkInterfaceFloatingIpsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListNetworkInterfaceFloatingIpsParams;

    /**
     * Construct a NetworkInterfaceFloatingIpsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listNetworkInterfaceFloatingIps()
     * @param {Object} params - The parameters to be passed to listNetworkInterfaceFloatingIps()
     * @constructor
     * @returns {NetworkInterfaceFloatingIpsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListNetworkInterfaceFloatingIpsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listNetworkInterfaceFloatingIps().
     * @returns {Promise<VpcV1.FloatingIPReference[]>}
     */
    public async getNext(): Promise<VpcV1.FloatingIPReference[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listNetworkInterfaceFloatingIps(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.floating_ips;
    }

    /**
     * Returns all results by invoking listNetworkInterfaceFloatingIps() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.FloatingIPReference[]>}
     */
    public async getAll(): Promise<VpcV1.FloatingIPReference[]> {
      const results: FloatingIPReference[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VirtualNetworkInterfaceIpsPager can be used to simplify the use of listVirtualNetworkInterfaceIps().
   */
  export class VirtualNetworkInterfaceIpsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVirtualNetworkInterfaceIpsParams;

    /**
     * Construct a VirtualNetworkInterfaceIpsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVirtualNetworkInterfaceIps()
     * @param {Object} params - The parameters to be passed to listVirtualNetworkInterfaceIps()
     * @constructor
     * @returns {VirtualNetworkInterfaceIpsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListVirtualNetworkInterfaceIpsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVirtualNetworkInterfaceIps().
     * @returns {Promise<VpcV1.ReservedIPReference[]>}
     */
    public async getNext(): Promise<VpcV1.ReservedIPReference[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVirtualNetworkInterfaceIps(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.ips;
    }

    /**
     * Returns all results by invoking listVirtualNetworkInterfaceIps() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ReservedIPReference[]>}
     */
    public async getAll(): Promise<VpcV1.ReservedIPReference[]> {
      const results: ReservedIPReference[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ClusterNetworkProfilesPager can be used to simplify the use of listClusterNetworkProfiles().
   */
  export class ClusterNetworkProfilesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListClusterNetworkProfilesParams;

    /**
     * Construct a ClusterNetworkProfilesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listClusterNetworkProfiles()
     * @param {Object} [params] - The parameters to be passed to listClusterNetworkProfiles()
     * @constructor
     * @returns {ClusterNetworkProfilesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListClusterNetworkProfilesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listClusterNetworkProfiles().
     * @returns {Promise<VpcV1.ClusterNetworkProfile[]>}
     */
    public async getNext(): Promise<VpcV1.ClusterNetworkProfile[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listClusterNetworkProfiles(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.profiles;
    }

    /**
     * Returns all results by invoking listClusterNetworkProfiles() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ClusterNetworkProfile[]>}
     */
    public async getAll(): Promise<VpcV1.ClusterNetworkProfile[]> {
      const results: ClusterNetworkProfile[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ClusterNetworksPager can be used to simplify the use of listClusterNetworks().
   */
  export class ClusterNetworksPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListClusterNetworksParams;

    /**
     * Construct a ClusterNetworksPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listClusterNetworks()
     * @param {Object} [params] - The parameters to be passed to listClusterNetworks()
     * @constructor
     * @returns {ClusterNetworksPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListClusterNetworksParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listClusterNetworks().
     * @returns {Promise<VpcV1.ClusterNetwork[]>}
     */
    public async getNext(): Promise<VpcV1.ClusterNetwork[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listClusterNetworks(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.cluster_networks;
    }

    /**
     * Returns all results by invoking listClusterNetworks() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ClusterNetwork[]>}
     */
    public async getAll(): Promise<VpcV1.ClusterNetwork[]> {
      const results: ClusterNetwork[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ClusterNetworkInterfacesPager can be used to simplify the use of listClusterNetworkInterfaces().
   */
  export class ClusterNetworkInterfacesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListClusterNetworkInterfacesParams;

    /**
     * Construct a ClusterNetworkInterfacesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listClusterNetworkInterfaces()
     * @param {Object} params - The parameters to be passed to listClusterNetworkInterfaces()
     * @constructor
     * @returns {ClusterNetworkInterfacesPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListClusterNetworkInterfacesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listClusterNetworkInterfaces().
     * @returns {Promise<VpcV1.ClusterNetworkInterface[]>}
     */
    public async getNext(): Promise<VpcV1.ClusterNetworkInterface[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listClusterNetworkInterfaces(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.interfaces;
    }

    /**
     * Returns all results by invoking listClusterNetworkInterfaces() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ClusterNetworkInterface[]>}
     */
    public async getAll(): Promise<VpcV1.ClusterNetworkInterface[]> {
      const results: ClusterNetworkInterface[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ClusterNetworkSubnetsPager can be used to simplify the use of listClusterNetworkSubnets().
   */
  export class ClusterNetworkSubnetsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListClusterNetworkSubnetsParams;

    /**
     * Construct a ClusterNetworkSubnetsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listClusterNetworkSubnets()
     * @param {Object} params - The parameters to be passed to listClusterNetworkSubnets()
     * @constructor
     * @returns {ClusterNetworkSubnetsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListClusterNetworkSubnetsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listClusterNetworkSubnets().
     * @returns {Promise<VpcV1.ClusterNetworkSubnet[]>}
     */
    public async getNext(): Promise<VpcV1.ClusterNetworkSubnet[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listClusterNetworkSubnets(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.subnets;
    }

    /**
     * Returns all results by invoking listClusterNetworkSubnets() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ClusterNetworkSubnet[]>}
     */
    public async getAll(): Promise<VpcV1.ClusterNetworkSubnet[]> {
      const results: ClusterNetworkSubnet[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * ClusterNetworkSubnetReservedIpsPager can be used to simplify the use of listClusterNetworkSubnetReservedIps().
   */
  export class ClusterNetworkSubnetReservedIpsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListClusterNetworkSubnetReservedIpsParams;

    /**
     * Construct a ClusterNetworkSubnetReservedIpsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listClusterNetworkSubnetReservedIps()
     * @param {Object} params - The parameters to be passed to listClusterNetworkSubnetReservedIps()
     * @constructor
     * @returns {ClusterNetworkSubnetReservedIpsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListClusterNetworkSubnetReservedIpsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listClusterNetworkSubnetReservedIps().
     * @returns {Promise<VpcV1.ClusterNetworkSubnetReservedIP[]>}
     */
    public async getNext(): Promise<VpcV1.ClusterNetworkSubnetReservedIP[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listClusterNetworkSubnetReservedIps(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.reserved_ips;
    }

    /**
     * Returns all results by invoking listClusterNetworkSubnetReservedIps() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ClusterNetworkSubnetReservedIP[]>}
     */
    public async getAll(): Promise<VpcV1.ClusterNetworkSubnetReservedIP[]> {
      const results: ClusterNetworkSubnetReservedIP[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * PublicGatewaysPager can be used to simplify the use of listPublicGateways().
   */
  export class PublicGatewaysPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListPublicGatewaysParams;

    /**
     * Construct a PublicGatewaysPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listPublicGateways()
     * @param {Object} [params] - The parameters to be passed to listPublicGateways()
     * @constructor
     * @returns {PublicGatewaysPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListPublicGatewaysParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listPublicGateways().
     * @returns {Promise<VpcV1.PublicGateway[]>}
     */
    public async getNext(): Promise<VpcV1.PublicGateway[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listPublicGateways(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.public_gateways;
    }

    /**
     * Returns all results by invoking listPublicGateways() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.PublicGateway[]>}
     */
    public async getAll(): Promise<VpcV1.PublicGateway[]> {
      const results: PublicGateway[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * FloatingIpsPager can be used to simplify the use of listFloatingIps().
   */
  export class FloatingIpsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListFloatingIpsParams;

    /**
     * Construct a FloatingIpsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listFloatingIps()
     * @param {Object} [params] - The parameters to be passed to listFloatingIps()
     * @constructor
     * @returns {FloatingIpsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListFloatingIpsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listFloatingIps().
     * @returns {Promise<VpcV1.FloatingIP[]>}
     */
    public async getNext(): Promise<VpcV1.FloatingIP[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listFloatingIps(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.floating_ips;
    }

    /**
     * Returns all results by invoking listFloatingIps() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.FloatingIP[]>}
     */
    public async getAll(): Promise<VpcV1.FloatingIP[]> {
      const results: FloatingIP[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * NetworkAclsPager can be used to simplify the use of listNetworkAcls().
   */
  export class NetworkAclsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListNetworkAclsParams;

    /**
     * Construct a NetworkAclsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listNetworkAcls()
     * @param {Object} [params] - The parameters to be passed to listNetworkAcls()
     * @constructor
     * @returns {NetworkAclsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListNetworkAclsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listNetworkAcls().
     * @returns {Promise<VpcV1.NetworkACL[]>}
     */
    public async getNext(): Promise<VpcV1.NetworkACL[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listNetworkAcls(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.network_acls;
    }

    /**
     * Returns all results by invoking listNetworkAcls() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.NetworkACL[]>}
     */
    public async getAll(): Promise<VpcV1.NetworkACL[]> {
      const results: NetworkACL[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * NetworkAclRulesPager can be used to simplify the use of listNetworkAclRules().
   */
  export class NetworkAclRulesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListNetworkAclRulesParams;

    /**
     * Construct a NetworkAclRulesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listNetworkAclRules()
     * @param {Object} params - The parameters to be passed to listNetworkAclRules()
     * @constructor
     * @returns {NetworkAclRulesPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListNetworkAclRulesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listNetworkAclRules().
     * @returns {Promise<VpcV1.NetworkACLRuleItem[]>}
     */
    public async getNext(): Promise<VpcV1.NetworkACLRuleItem[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listNetworkAclRules(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.rules;
    }

    /**
     * Returns all results by invoking listNetworkAclRules() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.NetworkACLRuleItem[]>}
     */
    public async getAll(): Promise<VpcV1.NetworkACLRuleItem[]> {
      const results: NetworkACLRuleItem[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SecurityGroupsPager can be used to simplify the use of listSecurityGroups().
   */
  export class SecurityGroupsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSecurityGroupsParams;

    /**
     * Construct a SecurityGroupsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listSecurityGroups()
     * @param {Object} [params] - The parameters to be passed to listSecurityGroups()
     * @constructor
     * @returns {SecurityGroupsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListSecurityGroupsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSecurityGroups().
     * @returns {Promise<VpcV1.SecurityGroup[]>}
     */
    public async getNext(): Promise<VpcV1.SecurityGroup[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listSecurityGroups(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.security_groups;
    }

    /**
     * Returns all results by invoking listSecurityGroups() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.SecurityGroup[]>}
     */
    public async getAll(): Promise<VpcV1.SecurityGroup[]> {
      const results: SecurityGroup[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SecurityGroupTargetsPager can be used to simplify the use of listSecurityGroupTargets().
   */
  export class SecurityGroupTargetsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListSecurityGroupTargetsParams;

    /**
     * Construct a SecurityGroupTargetsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listSecurityGroupTargets()
     * @param {Object} params - The parameters to be passed to listSecurityGroupTargets()
     * @constructor
     * @returns {SecurityGroupTargetsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListSecurityGroupTargetsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSecurityGroupTargets().
     * @returns {Promise<VpcV1.SecurityGroupTargetReference[]>}
     */
    public async getNext(): Promise<VpcV1.SecurityGroupTargetReference[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listSecurityGroupTargets(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.targets;
    }

    /**
     * Returns all results by invoking listSecurityGroupTargets() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.SecurityGroupTargetReference[]>}
     */
    public async getAll(): Promise<VpcV1.SecurityGroupTargetReference[]> {
      const results: SecurityGroupTargetReference[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * IkePoliciesPager can be used to simplify the use of listIkePolicies().
   */
  export class IkePoliciesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListIkePoliciesParams;

    /**
     * Construct a IkePoliciesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listIkePolicies()
     * @param {Object} [params] - The parameters to be passed to listIkePolicies()
     * @constructor
     * @returns {IkePoliciesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListIkePoliciesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listIkePolicies().
     * @returns {Promise<VpcV1.IKEPolicy[]>}
     */
    public async getNext(): Promise<VpcV1.IKEPolicy[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listIkePolicies(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.ike_policies;
    }

    /**
     * Returns all results by invoking listIkePolicies() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.IKEPolicy[]>}
     */
    public async getAll(): Promise<VpcV1.IKEPolicy[]> {
      const results: IKEPolicy[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * IkePolicyConnectionsPager can be used to simplify the use of listIkePolicyConnections().
   */
  export class IkePolicyConnectionsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListIkePolicyConnectionsParams;

    /**
     * Construct a IkePolicyConnectionsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listIkePolicyConnections()
     * @param {Object} params - The parameters to be passed to listIkePolicyConnections()
     * @constructor
     * @returns {IkePolicyConnectionsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListIkePolicyConnectionsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listIkePolicyConnections().
     * @returns {Promise<VpcV1.VPNGatewayConnection[]>}
     */
    public async getNext(): Promise<VpcV1.VPNGatewayConnection[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listIkePolicyConnections(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.connections;
    }

    /**
     * Returns all results by invoking listIkePolicyConnections() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPNGatewayConnection[]>}
     */
    public async getAll(): Promise<VpcV1.VPNGatewayConnection[]> {
      const results: VPNGatewayConnection[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * IpsecPoliciesPager can be used to simplify the use of listIpsecPolicies().
   */
  export class IpsecPoliciesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListIpsecPoliciesParams;

    /**
     * Construct a IpsecPoliciesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listIpsecPolicies()
     * @param {Object} [params] - The parameters to be passed to listIpsecPolicies()
     * @constructor
     * @returns {IpsecPoliciesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListIpsecPoliciesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listIpsecPolicies().
     * @returns {Promise<VpcV1.IPsecPolicy[]>}
     */
    public async getNext(): Promise<VpcV1.IPsecPolicy[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listIpsecPolicies(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.ipsec_policies;
    }

    /**
     * Returns all results by invoking listIpsecPolicies() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.IPsecPolicy[]>}
     */
    public async getAll(): Promise<VpcV1.IPsecPolicy[]> {
      const results: IPsecPolicy[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * IpsecPolicyConnectionsPager can be used to simplify the use of listIpsecPolicyConnections().
   */
  export class IpsecPolicyConnectionsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListIpsecPolicyConnectionsParams;

    /**
     * Construct a IpsecPolicyConnectionsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listIpsecPolicyConnections()
     * @param {Object} params - The parameters to be passed to listIpsecPolicyConnections()
     * @constructor
     * @returns {IpsecPolicyConnectionsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListIpsecPolicyConnectionsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listIpsecPolicyConnections().
     * @returns {Promise<VpcV1.VPNGatewayConnection[]>}
     */
    public async getNext(): Promise<VpcV1.VPNGatewayConnection[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listIpsecPolicyConnections(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.connections;
    }

    /**
     * Returns all results by invoking listIpsecPolicyConnections() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPNGatewayConnection[]>}
     */
    public async getAll(): Promise<VpcV1.VPNGatewayConnection[]> {
      const results: VPNGatewayConnection[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpnGatewaysPager can be used to simplify the use of listVpnGateways().
   */
  export class VpnGatewaysPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpnGatewaysParams;

    /**
     * Construct a VpnGatewaysPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpnGateways()
     * @param {Object} [params] - The parameters to be passed to listVpnGateways()
     * @constructor
     * @returns {VpnGatewaysPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListVpnGatewaysParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpnGateways().
     * @returns {Promise<VpcV1.VPNGateway[]>}
     */
    public async getNext(): Promise<VpcV1.VPNGateway[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpnGateways(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.vpn_gateways;
    }

    /**
     * Returns all results by invoking listVpnGateways() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPNGateway[]>}
     */
    public async getAll(): Promise<VpcV1.VPNGateway[]> {
      const results: VPNGateway[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpnGatewayConnectionsPager can be used to simplify the use of listVpnGatewayConnections().
   */
  export class VpnGatewayConnectionsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpnGatewayConnectionsParams;

    /**
     * Construct a VpnGatewayConnectionsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpnGatewayConnections()
     * @param {Object} params - The parameters to be passed to listVpnGatewayConnections()
     * @constructor
     * @returns {VpnGatewayConnectionsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListVpnGatewayConnectionsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpnGatewayConnections().
     * @returns {Promise<VpcV1.VPNGatewayConnection[]>}
     */
    public async getNext(): Promise<VpcV1.VPNGatewayConnection[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpnGatewayConnections(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.connections;
    }

    /**
     * Returns all results by invoking listVpnGatewayConnections() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPNGatewayConnection[]>}
     */
    public async getAll(): Promise<VpcV1.VPNGatewayConnection[]> {
      const results: VPNGatewayConnection[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpnServersPager can be used to simplify the use of listVpnServers().
   */
  export class VpnServersPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpnServersParams;

    /**
     * Construct a VpnServersPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpnServers()
     * @param {Object} [params] - The parameters to be passed to listVpnServers()
     * @constructor
     * @returns {VpnServersPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListVpnServersParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpnServers().
     * @returns {Promise<VpcV1.VPNServer[]>}
     */
    public async getNext(): Promise<VpcV1.VPNServer[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpnServers(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.vpn_servers;
    }

    /**
     * Returns all results by invoking listVpnServers() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPNServer[]>}
     */
    public async getAll(): Promise<VpcV1.VPNServer[]> {
      const results: VPNServer[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpnServerClientsPager can be used to simplify the use of listVpnServerClients().
   */
  export class VpnServerClientsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpnServerClientsParams;

    /**
     * Construct a VpnServerClientsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpnServerClients()
     * @param {Object} params - The parameters to be passed to listVpnServerClients()
     * @constructor
     * @returns {VpnServerClientsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListVpnServerClientsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpnServerClients().
     * @returns {Promise<VpcV1.VPNServerClient[]>}
     */
    public async getNext(): Promise<VpcV1.VPNServerClient[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpnServerClients(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.clients;
    }

    /**
     * Returns all results by invoking listVpnServerClients() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPNServerClient[]>}
     */
    public async getAll(): Promise<VpcV1.VPNServerClient[]> {
      const results: VPNServerClient[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * VpnServerRoutesPager can be used to simplify the use of listVpnServerRoutes().
   */
  export class VpnServerRoutesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListVpnServerRoutesParams;

    /**
     * Construct a VpnServerRoutesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listVpnServerRoutes()
     * @param {Object} params - The parameters to be passed to listVpnServerRoutes()
     * @constructor
     * @returns {VpnServerRoutesPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListVpnServerRoutesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listVpnServerRoutes().
     * @returns {Promise<VpcV1.VPNServerRoute[]>}
     */
    public async getNext(): Promise<VpcV1.VPNServerRoute[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listVpnServerRoutes(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.routes;
    }

    /**
     * Returns all results by invoking listVpnServerRoutes() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.VPNServerRoute[]>}
     */
    public async getAll(): Promise<VpcV1.VPNServerRoute[]> {
      const results: VPNServerRoute[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * LoadBalancerProfilesPager can be used to simplify the use of listLoadBalancerProfiles().
   */
  export class LoadBalancerProfilesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListLoadBalancerProfilesParams;

    /**
     * Construct a LoadBalancerProfilesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listLoadBalancerProfiles()
     * @param {Object} [params] - The parameters to be passed to listLoadBalancerProfiles()
     * @constructor
     * @returns {LoadBalancerProfilesPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListLoadBalancerProfilesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listLoadBalancerProfiles().
     * @returns {Promise<VpcV1.LoadBalancerProfile[]>}
     */
    public async getNext(): Promise<VpcV1.LoadBalancerProfile[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listLoadBalancerProfiles(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.profiles;
    }

    /**
     * Returns all results by invoking listLoadBalancerProfiles() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.LoadBalancerProfile[]>}
     */
    public async getAll(): Promise<VpcV1.LoadBalancerProfile[]> {
      const results: LoadBalancerProfile[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * LoadBalancersPager can be used to simplify the use of listLoadBalancers().
   */
  export class LoadBalancersPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListLoadBalancersParams;

    /**
     * Construct a LoadBalancersPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listLoadBalancers()
     * @param {Object} [params] - The parameters to be passed to listLoadBalancers()
     * @constructor
     * @returns {LoadBalancersPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListLoadBalancersParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listLoadBalancers().
     * @returns {Promise<VpcV1.LoadBalancer[]>}
     */
    public async getNext(): Promise<VpcV1.LoadBalancer[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listLoadBalancers(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.load_balancers;
    }

    /**
     * Returns all results by invoking listLoadBalancers() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.LoadBalancer[]>}
     */
    public async getAll(): Promise<VpcV1.LoadBalancer[]> {
      const results: LoadBalancer[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * EndpointGatewaysPager can be used to simplify the use of listEndpointGateways().
   */
  export class EndpointGatewaysPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListEndpointGatewaysParams;

    /**
     * Construct a EndpointGatewaysPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listEndpointGateways()
     * @param {Object} [params] - The parameters to be passed to listEndpointGateways()
     * @constructor
     * @returns {EndpointGatewaysPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListEndpointGatewaysParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listEndpointGateways().
     * @returns {Promise<VpcV1.EndpointGateway[]>}
     */
    public async getNext(): Promise<VpcV1.EndpointGateway[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listEndpointGateways(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.endpoint_gateways;
    }

    /**
     * Returns all results by invoking listEndpointGateways() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.EndpointGateway[]>}
     */
    public async getAll(): Promise<VpcV1.EndpointGateway[]> {
      const results: EndpointGateway[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * EndpointGatewayIpsPager can be used to simplify the use of listEndpointGatewayIps().
   */
  export class EndpointGatewayIpsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListEndpointGatewayIpsParams;

    /**
     * Construct a EndpointGatewayIpsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listEndpointGatewayIps()
     * @param {Object} params - The parameters to be passed to listEndpointGatewayIps()
     * @constructor
     * @returns {EndpointGatewayIpsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListEndpointGatewayIpsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listEndpointGatewayIps().
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getNext(): Promise<VpcV1.ReservedIP[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listEndpointGatewayIps(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.ips;
    }

    /**
     * Returns all results by invoking listEndpointGatewayIps() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.ReservedIP[]>}
     */
    public async getAll(): Promise<VpcV1.ReservedIP[]> {
      const results: ReservedIP[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * FlowLogCollectorsPager can be used to simplify the use of listFlowLogCollectors().
   */
  export class FlowLogCollectorsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListFlowLogCollectorsParams;

    /**
     * Construct a FlowLogCollectorsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listFlowLogCollectors()
     * @param {Object} [params] - The parameters to be passed to listFlowLogCollectors()
     * @constructor
     * @returns {FlowLogCollectorsPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListFlowLogCollectorsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listFlowLogCollectors().
     * @returns {Promise<VpcV1.FlowLogCollector[]>}
     */
    public async getNext(): Promise<VpcV1.FlowLogCollector[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listFlowLogCollectors(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.flow_log_collectors;
    }

    /**
     * Returns all results by invoking listFlowLogCollectors() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.FlowLogCollector[]>}
     */
    public async getAll(): Promise<VpcV1.FlowLogCollector[]> {
      const results: FlowLogCollector[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * PrivatePathServiceGatewaysPager can be used to simplify the use of listPrivatePathServiceGateways().
   */
  export class PrivatePathServiceGatewaysPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListPrivatePathServiceGatewaysParams;

    /**
     * Construct a PrivatePathServiceGatewaysPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listPrivatePathServiceGateways()
     * @param {Object} [params] - The parameters to be passed to listPrivatePathServiceGateways()
     * @constructor
     * @returns {PrivatePathServiceGatewaysPager}
     */
    constructor(client: VpcV1, params?: VpcV1.ListPrivatePathServiceGatewaysParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listPrivatePathServiceGateways().
     * @returns {Promise<VpcV1.PrivatePathServiceGateway[]>}
     */
    public async getNext(): Promise<VpcV1.PrivatePathServiceGateway[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listPrivatePathServiceGateways(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.private_path_service_gateways;
    }

    /**
     * Returns all results by invoking listPrivatePathServiceGateways() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.PrivatePathServiceGateway[]>}
     */
    public async getAll(): Promise<VpcV1.PrivatePathServiceGateway[]> {
      const results: PrivatePathServiceGateway[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * PrivatePathServiceGatewayAccountPoliciesPager can be used to simplify the use of listPrivatePathServiceGatewayAccountPolicies().
   */
  export class PrivatePathServiceGatewayAccountPoliciesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListPrivatePathServiceGatewayAccountPoliciesParams;

    /**
     * Construct a PrivatePathServiceGatewayAccountPoliciesPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listPrivatePathServiceGatewayAccountPolicies()
     * @param {Object} params - The parameters to be passed to listPrivatePathServiceGatewayAccountPolicies()
     * @constructor
     * @returns {PrivatePathServiceGatewayAccountPoliciesPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListPrivatePathServiceGatewayAccountPoliciesParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listPrivatePathServiceGatewayAccountPolicies().
     * @returns {Promise<VpcV1.PrivatePathServiceGatewayAccountPolicy[]>}
     */
    public async getNext(): Promise<VpcV1.PrivatePathServiceGatewayAccountPolicy[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listPrivatePathServiceGatewayAccountPolicies(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.account_policies;
    }

    /**
     * Returns all results by invoking listPrivatePathServiceGatewayAccountPolicies() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.PrivatePathServiceGatewayAccountPolicy[]>}
     */
    public async getAll(): Promise<VpcV1.PrivatePathServiceGatewayAccountPolicy[]> {
      const results: PrivatePathServiceGatewayAccountPolicy[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * PrivatePathServiceGatewayEndpointGatewayBindingsPager can be used to simplify the use of listPrivatePathServiceGatewayEndpointGatewayBindings().
   */
  export class PrivatePathServiceGatewayEndpointGatewayBindingsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: VpcV1;

    protected params: VpcV1.ListPrivatePathServiceGatewayEndpointGatewayBindingsParams;

    /**
     * Construct a PrivatePathServiceGatewayEndpointGatewayBindingsPager object.
     *
     * @param {VpcV1}  client - The service client instance used to invoke listPrivatePathServiceGatewayEndpointGatewayBindings()
     * @param {Object} params - The parameters to be passed to listPrivatePathServiceGatewayEndpointGatewayBindings()
     * @constructor
     * @returns {PrivatePathServiceGatewayEndpointGatewayBindingsPager}
     */
    constructor(client: VpcV1, params: VpcV1.ListPrivatePathServiceGatewayEndpointGatewayBindingsParams) {
      if (params && params.start) {
        throw new Error(`the params.start field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listPrivatePathServiceGatewayEndpointGatewayBindings().
     * @returns {Promise<VpcV1.PrivatePathServiceGatewayEndpointGatewayBinding[]>}
     */
    public async getNext(): Promise<VpcV1.PrivatePathServiceGatewayEndpointGatewayBinding[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.start = this.pageContext.next;
      }
      const response = await this.client.listPrivatePathServiceGatewayEndpointGatewayBindings(this.params);
      const { result } = response;

      let next;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'start');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.endpoint_gateway_bindings;
    }

    /**
     * Returns all results by invoking listPrivatePathServiceGatewayEndpointGatewayBindings() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<VpcV1.PrivatePathServiceGatewayEndpointGatewayBinding[]>}
     */
    public async getAll(): Promise<VpcV1.PrivatePathServiceGatewayEndpointGatewayBinding[]> {
      const results: PrivatePathServiceGatewayEndpointGatewayBinding[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }
}

export = VpcV1;
